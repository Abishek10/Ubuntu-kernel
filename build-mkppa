#!/bin/bash
#==============================================================================
# The intention was to have a script that could automatically add some out-
# standing patches, apply them and create sources ready to be uploaded into
# a ppa.
# 
# == WARNING == (local commits will be discarded)
# The git tree will be forced to the last HEAD from the origin, then the
# patches will be applied and commited and a ppa version (with a changelog
# that contains all changes) will be created. From this the source package
# will be made with dpkg-buildpackage.
#
# Used files/directories/variables:
#
# PPADIR: The location of the other stuff. If unset it will default to the
#         <current dirname>-ppa in the directory above.
#
# PPADIR/patches: There are the patches (in git-format-patch format) to be
#                 applied and a "series" file (like quilt) which defines the
#                 patch order. A patch can include a line "BumpABI: yes".
#                 This will automatically bump the ABI (if applied).
#
# PPADIR/ppa-version: Contains the version number of the last ppa package.
#
# PPADIR/abi-version: Contains the version number of the package that will
#                     ultimately define the ABI number (this can be a link
#                     to the ppa-version of the kernel ppa ;-)).
#
# DEBNAME:
# DEBEMAIL: Those two environment variables (exported) are used by dch to
#           set the email address and the name of the maintainer.
#==============================================================================
DIST=hardy
PPAEXT=smb
if [ "$PPADIR" = "" ]; then
	PPADIR="../$(basename $(pwd))-ppa"
fi
PATCHDIR="$PPADIR/patches"

#
# Check some required tools
#
for i in git dch sed awk sort tail; do
	if [ "$(type -p $i)" = "" ]; then
		echo "$i is required for this script to work!" >&2
		exit 1
	fi
done

#
# Evaluate some arguments
#
NOINC=false
BUILDPKG=true
PPABUILD=false
FORCEDERASE=false
while [ $# -gt 0 ]; do
	case "$1" in
		#
		# Create a new branch (ppabuild) based on this given tag.
		#
		--base)
			if [ "$(git-tag -l $2|head -1)" != "$2" ]; then
				echo "Basetag not found or not unique!" >&2
				exit 1
			fi
			PPABASE="$2"
			PATCHDIR="$PPADIR/patches-$PPABASE"
			shift
			;;
		#
		# Delete all files (except the .git directory) so there are
		# really, really not bad files around.
		#
		--erase)
			FORCEDERASE=true
			;;
		#
		# Prevent the package building step.
		#
		--nopkg)
			BUILDPKG=false
			;;
		#
		# PPA builds do not build all flavours.
		#
		--ppabuild|--make-it-fast)
			PPABUILD=true
			;;
		#
		# Do not increment the ppa release number (this is useful
		# for test runs.
		#
		--noinc)
			NOINC=true
			;;
		-*|--*)
			echo "Unknown option <$1>!" >&2
			exit 1
			;;
		*)
			echo "Unknown argument <$1>!" >&2
			exit 1
			;;
	esac
	shift
done

function GetVersion()
{
	head -1 debian/changelog| sed 's/.*(\(.*\)).*/\1/'
}

function GetPatchTag()
{
	local TAG="$1"
	local FILE="$2"

	awk '
		/^[\t ]*'$TAG':/ {
			print $2
		}
	' "$FILE"
}

#
# Force a sane state of the git tree. If requested, delete everything but
# the .git directory. Then create a new master branch that throws away any
# local checkins.
#
if [ ! -d .git ]; then
	echo "Cannot find .git!" >&2
	exit 1
fi
git-checkout -q -f origin
if $FORCEDERASE; then
	echo "Removing all but .git..."
	find . -mindepth 1 -maxdepth 1 -type d ! -name .git -exec rm -rf {} \;
	find . -mindepth 1 -maxdepth 1 -type f -exec rm {} \;
fi
if [ "$PPABASE" != "" ]; then
	echo "Creating branch based on $PPABASE..."
	git-branch --no-track -f ppabuild $PPABASE
	git-checkout -q -f ppabuild
else
	echo "(Re-)Creating master branch..."
	git checkout -q -f master
fi

#
# If this is missing, there is really something odd.
#
if [ ! -f debian/changelog ]; then
	echo "debian/changlog not found!" >&2
	exit 1
fi

#
# If not all flavours should be build, then create a special PPA file,
# which is honoured by the build process.
#
PPAFILE="$(
	make --no-print-directory -f debian/rules print-ppa-file-name \
		2>/dev/null
)"
if [ "$PPAFILE" != "" ]; then
	if $PPABUILD; then
		git log|head -1|sed 's/commit //' >"$PPAFILE"
	else
		rm -f "$PPAFILE"
	fi
fi

#
# Get the revision number of the last release (the latest tag).
#
LASTRELEASE=$(git tag -l|grep Ubuntu|sort -t- -k2n -k3n|tail -1|cut -d- -f3)

#
# Apply all patches in the series file (patches are in git-format-patch style).
# If one of the patches is marked "BumpABI: yes", then bump the ABI later.
#
BUMPABI=false
if [ -r "$PATCHDIR/series" ]; then
	for i in $(cat $PATCHDIR/series); do
		git-am $PATCHDIR/$i
		if [ "$(GetPatchTag BumpABI "$PATCHDIR/$i")" = "yes" ]; then
			BUMPABI=true
		fi
	done
fi

#
# This are the version numers of the first entry in the changelog. This is
# used as a base to calculate the new numbers.
#
VER="$(GetVersion|cut -d- -f1)"
ABI="$(GetVersion|cut -d- -f2|cut -d. -f1)"
REL="$(GetVersion|cut -d- -f2|cut -d. -f2)"

#
# If there has been a patch that bumps the ABI, do it now once. Otherwise we
# stay with the current ABI version.
# Note: this only is necessary if it hasn't been bumped since the last
#       release.
#
KABI="$ABI"
if $BUMPABI; then
	if [ $(echo $LASTRELEASE|cut -d. -f1) -eq $KABI ]; then
		let "KABI++"
	fi
fi

#
# The whole stuff is ultimately overruled by a file/link that contains the
# ABI version to use.
#
if [ -r "$PPADIR/abi-version" ]; then
	KABI="$(cat "$PPADIR/abi-version"|cut -d- -f2|cut -d. -f1)"
fi

if [ -f $PPADIR/ppa-version ]; then
	PPAVER="$(cat $PPADIR/ppa-version)"
	if [ "$(echo $PPAVER|sed 's/'$PPAEXT'.*//')" = "$VER-$KABI.$REL" ]; then
		PPA=$(echo $PPAVER|sed 's/.*'$PPAEXT'//')
		if ! $NOINC; then
			let "PPA++"
		fi
	else
		PPA=1
	fi
else
	PPA="1"
fi
PPAVER="$VER-$KABI.${REL}${PPAEXT}$PPA"
echo "$PPAVER" >$PPADIR/ppa-version

#
# Create the changelog entries for the ppa upload. This also starts a new
# section with the calculated version number and (through debchange) sets
# the email address and committer name.
#
echo "Creating changelog for $PPAVER..."
CHANGES=$(cat <<EOD
  PPA build is based on release $LASTRELEASE

$(debian/rules prev_revision=$LASTRELEASE printchanges)
EOD)

dch -v"$PPAVER" -D"$DIST" "!!!PLACEHOLDER!!!"
awk -vTEXT="$CHANGES" '/!!!PLACEHOLDER!!!/{print TEXT; next} {print}' \
	debian/changelog >debian/changelog.$$ && \
	mv debian/changelog.$$ debian/changelog

#
# Update the debian control file
#
debian/rules debian/control.stub >/dev/null

#
# Stupid ABI check possibly wants stuff
#
if [ -d debian/abi ]; then
	if [ ! -d debian/abi/$VER-$ABI.$REL ]; then
		#
		# There is no ABI directory for the last release? Argh! Ok,
		# just take the latest and pray!
		#
		if [ ! -d debian/abi/$VER-$LASTRELEASE ]; then
			echo "WARNING: No kABI for $LASTRELEASE!!!"
			LASTRELEASE=$(ls -1 debian/abi|tail -1|cut -d- -f2)
			echo "Using $LASTRELEASE instead. Hope this works..."
		fi
		echo "Generate ABI modules files..."
		cp -r debian/abi/$VER-$LASTRELEASE debian/abi/$VER-$ABI.$REL
		find debian/abi/$VER-$ABI.$REL -type f ! -name '*.modules' \
			-exec rm {} \;
		echo $ABI >debian/abi/$VER-$ABI.$REL/abiname
	fi
fi

#
# Commit the changes that resulted from the new version.
#
echo "Creating release commit..."
cat <<EOD | git commit -q -F- -a -s
UBUNTU: PPA Version $PPAVER
Ignore: yes
EOD

if $BUILDPKG; then
	dpkg-buildpackage -S -sa -I.git -I.gitignore -i'\.git.*'
fi

exit 0
