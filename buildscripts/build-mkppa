#!/bin/bash
#==============================================================================
# The intention was to have a script that could automatically add some out-
# standing patches, apply them and create sources ready to be uploaded into
# a ppa.
# 
# == WARNING == (local commits will be discarded)
# The git tree will be forced to the last HEAD from the origin, then the
# patches will be applied and commited and a ppa version (with a changelog
# that contains all changes) will be created. From this the source package
# will be made with dpkg-buildpackage.
#
# Used files/directories/variables:
#
# PPADIR: The location of the other stuff. If unset it will default to the
#         <current dirname>-ppa in the directory above.
#
# PPADIR/patches: There are the patches (in git format-patch format) to be
#                 applied and a "series" file (like quilt) which defines the
#                 patch order. A patch can include a line "BumpABI: yes".
#                 This will automatically bump the ABI (if applied).
#
# PPADIR/ppa-version: Contains the version number of the last ppa package.
#
# PPADIR/abi-version: Contains the version number of the package that will
#                     ultimately define the ABI number (this can be a link
#                     to the ppa-version of the kernel ppa ;-)).
#
# DEBNAME:
# DEBEMAIL: Those two environment variables (exported) are used by dch to
#           set the email address and the name of the maintainer.
#==============================================================================
PPAEXT=smb
if [ "$PPADIR" = "" ]; then
	PPADIR="../$(basename $(pwd))-ppa"
fi
PATCHDIR="$PPADIR/patches"

#
# Check some required tools
#
for i in git dch sed awk sort tail; do
	if [ "$(type -p $i)" = "" ]; then
		echo "$i is required for this script to work!" >&2
		exit 1
	fi
done

#
# Evaluate some arguments
#
NOINC=false
BUILDPKG=true
PPABUILD=false
FORCEDERASE=false
while [ $# -gt 0 ]; do
	case "$1" in
		#
		# Create a new branch (ppabuild) based on this given tag.
		#
		--base)
			if [ "$(git tag -l $2|head -1)" != "$2" ]; then
				echo "Basetag not found or not unique!" >&2
				exit 1
			fi
			PPABASE="$2"
			PPADIR="$PPADIR/$PPABASE"
			PATCHDIR="$PPADIR/patches"
			echo "Using $PPADIR as base"
			shift
			;;
		#
		# Delete all files (except the .git directory) so there are
		# really, really not bad files around.
		#
		--erase)
			FORCEDERASE=true
			;;
		#
		# Prevent the package building step.
		#
		--nopkg)
			BUILDPKG=false
			;;
		#
		# PPA builds do not build all flavours.
		#
		--ppabuild|--make-it-fast)
			PPABUILD=true
			;;
		#
		# Do not increment the ppa release number (this is useful
		# for test runs.
		#
		--noinc)
			NOINC=true
			;;
		-*|--*)
			echo "Unknown option <$1>!" >&2
			exit 1
			;;
		*)
			echo "Unknown argument <$1>!" >&2
			exit 1
			;;
	esac
	shift
done

#
# If this is missing, there is really something odd.
#
if [ ! -f debian/changelog ]; then
	echo "debian/changlog not found!" >&2
	exit 1
fi
DIST=$(awk '
	$4 ~ /^urgency=/{
		D = $3
		sub(/;.*|-.*/, "", D)
		if (D != "UNRELEASED") {
			print D
			exit
		}
	}
' debian/changelog)

case $DIST in
	dapper|feisty|gutsy|hardy|intrepid|jaunty)
		;;
	*)
		echo "Unknown release name ($DIST)!" >&2
		exit 1
		;;
esac

function GetVersion()
{
	#
	# A PPA build should be based on a released version to be superseeded
	# by the next official build.
	#
	if [ "$PPABASE" = "" ]; then
		git tag -l | grep Ubuntu | sort -t- -k2n | sort -t- -k3n | \
		tail -1 | cut -d- -f2-
	else
		echo $PPABASE | cut -d- -f2-
	fi
}

function GetPatchTag()
{
	local TAG="$1"
	local FILE="$2"

	awk '
		/^[\t ]*'$TAG':/ {
			print $2
		}
	' "$FILE"
}

#
# Force a sane state of the git tree. If requested, delete everything but
# the .git directory. Then create a new master branch that throws away any
# local checkins.
#
if [ ! -d .git ]; then
	echo "Cannot find .git!" >&2
	exit 1
fi
git checkout -q -f origin
if $FORCEDERASE; then
	echo "Removing all but .git..."
	find . -mindepth 1 -maxdepth 1 -type d ! -name .git -exec rm -rf {} \;
	find . -mindepth 1 -maxdepth 1 -type f -exec rm {} \;
fi
if [ "$PPABASE" != "" ]; then
	echo "Creating branch based on $PPABASE..."
	git branch --no-track -f ppabuild $PPABASE
	git checkout -q -f ppabuild
else
	echo "(Re-)Creating master branch..."
	git checkout -q -f origin
	git branch -f master origin
	git checkout -q -f master
fi

#
# If not all flavours should be build, then create a special PPA file,
# which is honoured by the build process.
#
PPAFILE="$(
	make --no-print-directory -f debian/rules print-ppa-file-name \
		2>/dev/null
)"
if [ "$PPAFILE" != "" ]; then
	if $PPABUILD; then
		git log|head -1|sed 's/commit //' >"$PPAFILE"
	else
		rm -f "$PPAFILE"
	fi
fi

#
# Get the revision number of the last release (the latest tag).
#
if [ "$PPABASE" = "" ]; then
	LASTRELEASE=$(GetVersion|cut -d- -f2)
else
	LASTRELEASE=$(echo $PPABASE|cut -d- -f3)
fi

#
# Apply all patches in the series file (patches are in git format-patch style).
# If one of the patches is marked "BumpABI: yes", then bump the ABI later.
#
BUMPABI=false
if [ -r "$PATCHDIR/series" ]; then
	for i in $(cat $PATCHDIR/series); do
		git am $PATCHDIR/$i
		if [ "$(GetPatchTag BumpABI "$PATCHDIR/$i")" = "yes" ]; then
			BUMPABI=true
		fi
	done
fi

#
# This is the version number of the version that we are based on. It is
# used as a base to calculate the new numbers.
#
FULLVER=$(GetVersion)
VER="$(echo $FULLVER|cut -d- -f1)"
ABI="$(echo $FULLVER|cut -d- -f2|cut -d. -f1)"
REL="$(echo $FULLVER|cut -d- -f2|cut -d. -f2)"

#
# Possibly there were kABI bumpers in the time between the last relase and the
# current HEAD...
#
if [ "$(git log Ubuntu-$FULLVER..HEAD 2>/dev/null|grep BumpABI)" != "" ]; then
	BUMPABI=true
fi

#
# If there has been a patch that bumps the ABI, do it now once. Otherwise we
# stay with the current ABI version.
# Note: this only is necessary if it hasn't been bumped since the last
#       release.
#
KABI="$ABI"
if $BUMPABI; then
	if [ $(echo $LASTRELEASE|cut -d. -f1) -eq $KABI ]; then
		let "KABI++"
	fi
fi

#
# The whole stuff is ultimately overruled by a file/link that contains the
# ABI version to use.
#
if [ -r "$PPADIR/abi-version" ]; then
	KABI="$(cat "$PPADIR/abi-version"|cut -d- -f2|cut -d. -f1)"
fi

if [ -f $PPADIR/ppa-version ]; then
	PPAVER="$(cat $PPADIR/ppa-version)"
	if [ "$(echo $PPAVER|sed 's/'$PPAEXT'.*//')" = "$VER-$KABI.$REL" ]; then
		PPA=$(echo $PPAVER|sed 's/.*'$PPAEXT'//')
		if ! $NOINC; then
			let "PPA++"
		fi
	else
		PPA=1
	fi
else
	PPA="1"
fi
PPAVER="$VER-$KABI.${REL}${PPAEXT}$PPA"
echo "$PPAVER" >$PPADIR/ppa-version

#
# Create the changelog entries for the ppa upload. This also starts a new
# section with the calculated version number and (through debchange) sets
# the email address and committer name.
#
echo "Creating changelog for $PPAVER..."
CHANGES=$(cat <<EOD
  PPA build is based on release $LASTRELEASE

$(debian/rules prev_revision=$LASTRELEASE printchanges 2>/dev/null)
EOD)

#
# Eradicate all entries in the changelog after the last release.
#
echo "Erase to $FULLVER"
awk '
	BEGIN{
		silent=1
	}
	$2 == "('$FULLVER')" && $4 ~ /^urgency=/{
		silent=0
	}
	!silent{
		print
	}
' debian/changelog >debian/changelog.$$ && \
	mv debian/changelog.$$ debian/changelog

dch -b -v"$PPAVER" -D"$DIST" "!!!PLACEHOLDER!!!"
awk -vTEXT="$CHANGES" '/!!!PLACEHOLDER!!!/{print TEXT; next} {print}' \
	debian/changelog >debian/changelog.$$ && \
	mv debian/changelog.$$ debian/changelog

#
# Update the debian control file
#
debian/rules debian/control.stub >/dev/null

#
# Stupid ABI check possibly wants stuff
#
LASTFULLVER=$VER-$LASTRELEASE
if [ -d debian/abi ]; then
	#
	# No kABI files for the last release. If there is a tarball
	# that provides those relative to the kernel top level dir,
	# then use that.
	#
	if [ -f $PPADIR/abi-$LASTFULLVER.tar.gz ]; then
		echo "Found and use $FULLVER tarball."
		tar -xzf $PPADIR/abi-$LASTFULLVER.tar.gz
		git add debian/abi/$LASTFULLVER
	fi
	if [ ! -d debian/abi/$LASTFULLVER ]; then
		#
		# If the directory is still missing, there was no tarbal.
		# Maybe the files from an older release are there.
		#
		if [ ! -d debian/abi/$LASTFULLVER ]; then
			echo "WARNING: No kABI files for $LASTRELEASE!!!"
			LASTRELEASE=$(ls -1 debian/abi|tail -1|cut -d- -f2)
			if [ "$LASTRELEASE" = "" ]; then
				echo "Unable to continue!" >&2
				exit 1
			fi
			echo "Using $LASTRELEASE instead. Hope this works..."
			echo "Generate ABI modules files..."
			cp -r debian/abi/$VER-$LASTRELEASE \
				debian/abi/$LASTFULLVER
			echo $ABI >debian/abi/$LASTFULLVER/abiname
		fi
		git add debian/abi/$LASTFULLVER
	fi
fi

#
# Commit the changes that resulted from the new version.
#
echo "Creating release commit..."
cat <<EOD | git commit -q -F- -a -s
UBUNTU: PPA Version $PPAVER
Ignore: yes
EOD

if $BUILDPKG; then
	dpkg-buildpackage -S -sa -I.git -I.gitignore -i'\.git.*'
fi

exit 0
