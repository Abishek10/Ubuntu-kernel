diff -Nurp ../tmp1/./common/lib/modules/fglrx/build_mod/2.6.x/Makefile ./common/lib/modules/fglrx/build_mod/2.6.x/Makefile
--- ../tmp1/./common/lib/modules/fglrx/build_mod/2.6.x/Makefile	2010-09-21 15:00:54.420550561 +0200
+++ ./common/lib/modules/fglrx/build_mod/2.6.x/Makefile	2010-09-21 15:03:41.467568973 +0200
@@ -21,6 +21,10 @@ EXTRA_CFLAGS    += \
                 -DFGL_LINUX253P1_VMA_API \
                 -DPAGE_ATTR_FIX=$(PAGE_ATTR_FIX) \
 
+ifneq ($(shell grep compat_alloc_user_space $(srctree)/include/linux/compat.h),)
+	EXTRA_CFLAGS += -DARCH_COMPAT_ALLOC_USER_SPACE
+endif
+
 ifeq ($(KERNELRELEASE),)
 # on first call from remote location we get into this path
 # whilst on second call all is managed by the embedding kernel makefile
diff -Nurp ../tmp1/./common/lib/modules/fglrx/build_mod/firegl_public.c ./common/lib/modules/fglrx/build_mod/firegl_public.c
--- ../tmp1/./common/lib/modules/fglrx/build_mod/firegl_public.c	2010-09-21 15:00:54.424568033 +0200
+++ ./common/lib/modules/fglrx/build_mod/firegl_public.c	2010-09-21 15:02:03.088546971 +0200
@@ -1919,7 +1919,22 @@ unsigned long ATI_API_CALL KCL_GetAvaila
 #ifdef __x86_64__
 void* ATI_API_CALL __ke_compat_alloc_user_space(long size)
 {
-    return compat_alloc_user_space(size);
+    void __user *ptr;
+
+    /* If len would occupy more than half of the entire compat space... */
+    if (unlikely((unsigned long) size) > (((compat_uptr_t)~0) >> 1))
+        return NULL;
+
+#ifdef ARCH_COMPAT_ALLOC_USER_SPACE
+    ptr = arch_compat_alloc_user_space(size);
+#else
+    ptr = compat_alloc_user_space(size);
+#endif
+
+    if (unlikely(!access_ok(VERIFY_WRITE, ptr, size)))
+        return NULL;
+
+    return ptr;
 }
 #endif
 
