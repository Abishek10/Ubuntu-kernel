#!/usr/bin/env python
#

from os                                 import getenv, path, makedirs
from sys                                import stdout, argv
from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import warning, error, info, debug, basicConfig, INFO, DEBUG, getLogger
from lib.shell                          import ShellError, ShellTimeoutError, sh, ssh
from tempfile                           import mkdtemp
from time                               import sleep
import re
from datetime                           import date

import json

# test_runner_progress
#
def test_runner_progress(out, queue, quiet=True, silent=False):
    pkg_installation_started = False
    tests_started = False
    test_start_rc = re.compile('\d+:\d+:\d+ INFO \|\s+START\s+(\S+)\s+\S+\s+timestamp=.*$')
    previous_test = ''
    errors = 0

    for line in iter(out.readline, b''):
        queue.put(line)

        if silent:
            continue

        if quiet:
            l = line.rstrip()
            if 'DEBUG - Installing:' in l:
                if not pkg_installation_started:
                    stdout.write('    Installing pkgs:\n       ')
                    pkg_installation_started = True
                stdout.write(l.replace('DEBUG - Installing:', '').replace('\'', '') + ' ')
                stdout.flush()

            if tests_started:
                if 'INFO | \tSTART' in l:
                    m = test_start_rc.search(l)
                    if m:
                        try:
                            test, _ = m.group(1).split('.', 1)
                        except ValueError as e:
                            test = m.group(1)
                        if test != previous_test:
                            stdout.write('        ' + test)
                            previous_test = test
                            errors = 0

                elif 'END ERROR' in l:
                    errors += 1

                elif 'END FAIL' in l:
                    errors += 1

                elif 'INFO | END GOOD' in l:
                    if errors > 0:
                        stdout.write(' ... failed\n')
                    else:
                        stdout.write(' ... passed\n')

            elif 'INFO | START' in l:
                tests_started = True
                stdout.write('\n    Executing tests:\n')
                stdout.flush()
        else:
            stdout.write(line)
            stdout.flush()

    stdout.write('\n')
    stdout.flush()
    out.close()

# phablet_flash_progress
#
def phablet_flash_progress(out, queue, quiet=False):
    fid = ''
    previous_fid = ''
    downloading_md5sum = False
    for line in iter(out.readline, b''):
        queue.put(line)

        line = line.rstrip()
        if '%s: OK' % previous_fid == line:
            stdout.write('\rDownloading: ' + previous_fid + ' .. completed and verified.              \n')
            stdout.flush()
            downloading_md5sum = False

        if not downloading_md5sum:
            if '..........' in line:
                try:
                    d = line.split()
                    if len(d) > 8:
                        stdout.write('\rDownloading: ' + previous_fid + ' .. %s completed, %s until finished.     ' % (d[6], d[8]))
                except IndexError:
                    error('IndexError. len(d) = %d' % len(d))

        if line.startswith('Downloading '):
            fid = line.replace('Downloading ', '')
            fid = fid[fid.rfind('/')+1:]
            if fid != previous_fid + '.md5sum':
                previous_fid = fid
                stdout.write('Downloading: ' + previous_fid + ' .. ')
                stdout.flush()

            if 'md5sum' in fid:
                downloading_md5sum = True

        if line.startswith('Pushing '):
            stdout.write(line + '\n')
            stdout.flush()

        if 'Once completed the device should reboot into Ubuntu' in line:
            stdout.write('\n')
            stdout.write('The device should be reflashing. Once completed the device\n')
            stdout.write('should reboot into Ubuntu.\n')
            stdout.flush()

    stdout.write('\n')
    stdout.flush()
    out.close()

# ErrorExit
#
class ErrorExit(Exception):
    """
    Print out the message and exit.
    """
    def __init__(s, emsg):
        s.__message = emsg

    @property
    def message(s):
        return s.__message

# Error
#
class Error(ErrorExit):
    """
    """
    def __init__(s, emsg):
        ErrorExit.__init__(s, emsg)

# NoSuchFile
#
class NoSuchFile(ErrorExit):
    """
    """
    def __init__(s, emsg):
        ErrorExit.__init__(s, emsg)

# BadJson
#
class BadJson(ErrorExit):
    """
    """
    def __init__(s, emsg):
        ErrorExit.__init__(s, emsg)

# UMTConfiguration
#
class UMTConfiguration():
    '''
    Configuration file search path:
        1. User's home directory
        2. Current directory
    If it is specified on the command line, that is the only one to use.
    '''

    # __init__
    #
    def __init__(s, args):
        s.args = args
        s.config_file_name = 'umt.cfg'

        # If the user specified a configuration file on the command line then
        # that file must exist and will be used.
        #
        if args.config:
            try:
                d = s.__load_json(args.config)
            except NoSuchFile as e:
                raise ErrorExit('The specified configuration file (%s) does not exist.' % args.config)
            except BadJson as e:
                raise ErrorExit(['The specified configuration file (%s) is not correctly formatted JSON.' % (args.config), e.message])

        # Otherwise, we will search for a configuration file.
        #
        else:
            search_path = []
            search_path.append(s.config_file_name)                                            # Current directory
            search_path.append(path.join(path.expanduser('~'), s.config_file_name))           # User's home directory
            search_path.append(path.join(argv[0][:argv[0].rfind('/')], s.config_file_name))   # Where the application is located
            for p in search_path:
                if path.exists(p):
                    try:
                        d = s.__load_json(p)
                        for k in d:
                            setattr(s, k, d[k])
                    except BadJson as e:
                        raise ErrorExit(['The specified configuration (%s) is not correctly formatted JSON.' % (p), e.message])
                    break # First one wins

        # Command line parameters overwride those specified in
        # the configuration file.
        #
        for a in args.__dict__:
            setattr(s, a, args.__dict__[a])

    # __load_json
    #
    def __load_json(s, fp):
        '''
        Load the specified json formatted file and returns the associated object.
        '''
        retval = None
        if path.exists(fp):
            try:
                with open(fp, 'r') as f:
                    try:
                        retval = json.loads(f.read())
                    except ValueError as e:
                        raise BadJson(e.message)
            except:
                raise
        else:
            raise NoSuchFile(fp)

        return retval

# UbuntuMobileTester
#
class UbuntuMobileTester():
    '''
    '''

    # __init__
    #
    def __init__(s, config):
        s.config = config

# TheApp
#
class TheApp():
    '''
    '''

    # __init__
    #
    def __init__(s):
        if getenv('DEBUG'):
            LOGLEVEL = DEBUG
        else:
            LOGLEVEL = INFO
        LOGLEVEL = DEBUG
        basicConfig(level=LOGLEVEL, format="%(levelname)s - %(message)s")

    # __load_file
    #
    def __load_file(s, fp):
        '''
        Open a specific file and return it's contents.
        '''
        retval = None
        if path.exists(fp):
            with open(fp, 'r') as f:
                retval = f.read()
        else:
            raise NoSuchFile(fp)

        return retval

    # device_attached
    #
    def device_attached(s):
        (results, output) = sh('adb devices', quiet=True)
        found = 0
        devices = False
        for line in output:
            if devices:
                if 'device' in line:
                    found += 1

            elif 'List of devices attached' in line:
                devices = True

        if found > 1:
            raise ErrorExit('adb found more than one device attached. Only one device is permitted.')

        return found > 0

    # device_reflash
    #
    def device_reflash(s):
        sh('phablet-flash -l', output_enqueue_fn=phablet_flash_progress, quiet=True)

    # device_configure_for_ssh
    #
    def device_configure_for_ssh(s):
        # Restart the adb daemon with root permissions
        #
        sh('adb root', quiet=True)

    # fetch_public_key
    #
    def fetch_public_key(s):
        key = None
        try:
            p = path.join(path.expanduser('~'), '.ssh', 'id_rsa.pub')
            with open(p, 'r') as f:
                key = f.read()
        except IOError as e:
            warning('Unable to find a public ssh key (%s) to use for the authorized_keys file on the SUT' % p)
        return key

    # configure
    #
    def configure(s, umt):
        if not s.device_attached():
            raise ErrorExit('No devices were found attached to this system.')

        sh('adb root', quiet=True)

        import pexpect

        stdout.write('.'), stdout.flush()

        ## Before we start interactively working with adb, push over the
        ## wifi configuration script that we will need later.
        ##
        #try:
        #    sh('adb push %s/kernel-testing/wifi-config /data/ubuntu/tmp/' % (s.config.testing_root))
        #except ShellError:
        #    # Try one more time
        #    #
        #    sleep(2)
        #    try:
        #        sh('adb push %s/kernel-testing/wifi-config /data/ubuntu/tmp/' % (s.config.testing_root))
        #    except ShellError as e:
        #        emsg = []
        #        emsg.append('Failed to push wifi-config to the SUT.')
        #        emsg.append('')
        #        emsg.append('    cmd: %s' % e.cmd)
        #        emsg.append('')
        #        for l in e.output:
        #            emsg.append(l)
        #        raise ErrorExit(emsg)

        try:
            ch = pexpect.spawn('adb shell', timeout=300)
            ch.expect('root@android:/ # ')
        except pexpect.EOF:
            # If at first you don't succeed, try, try again
            #
            try:
                sleep(2)
                ch = pexpect.spawn('adb shell', timeout=300)
                ch.expect('root@android:/ # ')
            except pexpect.EOF:
                raise ErrorExit('Please try again, the device couldn\'t be found.')

        stdout.write('.'), stdout.flush()
        ch.sendline('ubuntu_chroot shell')
        ch.expect('root@localhost:/# ')

        stdout.write('.'), stdout.flush()
        ch.sendline('echo phablet ALL=\(ALL:ALL\) NOPASSWD: ALL >> /etc/sudoers')
        ch.expect('root@localhost:/# ')

        stdout.write('.'), stdout.flush()
        ch.sendline('cat /etc/sudoers')
        ch.expect('root@localhost:/# ')

        stdout.write('.'), stdout.flush()
        ch.sendline('apt-get update')
        ch.expect('root@localhost:/# ')

        stdout.write('.'), stdout.flush()
        ch.sendline('apt-get install -y openssh-server rsync')
        ch.expect('root@localhost:/# ')

        if s.config.ssh_key:
            ch.sendline('mkdir ~phablet/.ssh')
            ch.expect('root@localhost:/# ')

            ch.sendline('chown phablet.phablet ~phablet/.ssh')
            ch.expect('root@localhost:/# ')

            ch.sendline('chmod 0700 ~phablet/.ssh')
            ch.expect('root@localhost:/# ')

            ch.sendline('echo %s > ~phablet/.ssh/authorized_keys' % s.config.ssh_key)
            ch.expect('root@localhost:/# ')

            ch.sendline('chown phablet.phablet ~phablet/.ssh/authorized_keys')
            ch.expect('root@localhost:/# ')

        ## Not sure this is the right place to do this but ...
        ##
        #if s.config.wifi:
        #    ssid = s.config.wifi['ssid']
        #    key  = s.config.wifi['wpa2psk']

        #    ch.sendline('sudo ./tmp/wifi-config %s %s' % (ssid, key))
        #    ch.expect('root@localhost:/# ')

        stdout.write('. complete\n'), stdout.flush()
        ch.sendline('ip addr show wlan0')
        ch.expect('root@localhost:/# ')
        output = ch.before
        ip_found = False
        print('')
        print('Next step(s):')
        for l in output.split('\n'):
            if 'inet ' in l:
                x = l.split()
                ip = x[1][:x[1].rfind('/')]
                ip_found = True
                print('    %s test phablet@%s' % (argv[0], ip))
        if not ip_found:
            print('    ** Manually configure your wireless networking on the device. **')
            print('    %s configure' % argv[0])
        print('')

        ch = None

    # results
    #
    def results(s, umt):
        target = s.config.target[0]
        raw_results = s.config.raw_results_root
        if not raw_results:
            raw_results = path.join(s.config.testing_root, 'raw-results')

        # Pull all the results off of the SUT and onto the local system.
        #
        if not path.exists(raw_results):
            makedirs(raw_results)
        raw_results = mkdtemp(dir=raw_results)
        sh('mkdir -p %s' % raw_results, quiet=True)
        sh('rsync -e "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" -ar %s:kernel-test-results/ %s/' % (target, raw_results))

        # Each test set produces it's own set of results. We want to put them
        # together into one set of results.
        #
        krp = path.join(raw_results, 'kernel_results.xml')
        sh('%s/autotest/client/tools/glue_testsuites %s/autotest-results.*.xml > %s' % (s.config.testing_root, raw_results, krp), quiet=False)

        # Produce all the web pages for this new set of results.
        #
        results = s.config.raw_results_root
        if not results:
            results = path.join(s.config.testing_root, 'results')
        sh('mkdir -p %s' % results, quiet=True)
        sh('%s/kernel-testing/tr/ingest %s %s' % (s.config.testing_root, raw_results, s.config.results_root), quiet=False)

        sh('%s/kernel-testing/tr/digest %s' % (s.config.testing_root, s.config.results_root), quiet=False)


    # provision
    #
    def provision(s, umt):
        if not s.device_attached():
            raise ErrorExit('No devices were found attached to this system.')

        s.device_reflash()
        print('')
        print('Next step(s):')
        print('    Manually configure your wireless networking on the device.')
        print('    %s configure' % argv[0])
        print('')

    # test
    #
    def test(s, umt):
        target = s.config.target[0]

        try:
            if not s.config.no_at:
                if not path.exists(s.config.testing_root):
                    raise ErrorExit('%s: Path specified in umt.cfg does not exist.' % s.config.testing_root)

                p = path.join(s.config.testing_root, 'autotest')
                if not path.exists(p):
                    raise ErrorExit('%s: Path does not exist.' % p)

                p = path.join(s.config.testing_root, 'autotest-client-tests')
                if not path.exists(p):
                    raise ErrorExit('%s: Path does not exist.' % p)

                p = path.join(s.config.testing_root, 'kernel-testing')
                if not path.exists(p):
                    raise ErrorExit('%s: Path does not exist.' % p)

                ssh(target, 'sudo rm -rf autotest', quiet=True)

                print('    Copying autotest core to SUT')
                cmd = 'rsync -e "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" -arv --exclude=.git %s/autotest/ %s:autotest/' % (s.config.testing_root, target)
                sh(cmd, quiet=True)

                print('    Copying autotest-client-tests to SUT')
                sh('rsync -e "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" -arv --exclude=.git %s/autotest-client-tests/* %s:autotest/client/tests/' % (s.config.testing_root, target), quiet=True)

            if not s.config.no_kt:
                ssh(target, 'sudo rm -rf kernel-testing', quiet=True)

                print('    Copying kernel testing core to SUT')
                sh('rsync -e "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" -arv --exclude=.git %s/kernel-testing/ %s:kernel-testing/' % (s.config.testing_root, target), quiet=True)

            if not s.config.no_test:
                ssh(target, 'sudo rm -rf kernel-test-results', quiet=True)
                ssh(target, 'python kernel-testing/runner %s 2>&1 | tee kernel-test-results/log' % s.config.tests, quiet=not s.config.loud, output_enqueue_fn=test_runner_progress)
                print('    Tests completed')

            print('')
            print('Next step:')
            print('    %s results %s' % (argv[0], target))
            print('')

        except ShellError as e:
            emsg = []
            emsg.append('Remote command failed.')
            emsg.append('')
            emsg.append('    cmd: %s' % e.cmd)
            emsg.append('')
            for l in e.output:
                emsg.append(l)
            raise ErrorExit(emsg)

    # main
    #
    def main(s):
        retval = 1
        try:
            retval = 0

            app_description = '''
            '''
            app_epilog = '''
            '''
            parent_parser = ArgumentParser(prog='kb')

            subparsers = parent_parser.add_subparsers(title="actions", help="sub-commands help")

            p = subparsers.add_parser("provision", help="Install a new instance of the image onto the SUT and prepare it for testing.")
            p.set_defaults(func=s.provision)
            p.add_argument('-c', '--config', required=False,   type=str,                               help='The configuration file that is to be used.')

            p = subparsers.add_parser("configure", help="Install a new instance of the image onto the SUT and prepare it for testing.")
            p.set_defaults(func=s.configure)
            p.add_argument('-c', '--config', required=False,   type=str,                               help='The configuration file that is to be used.')

            p = subparsers.add_parser("results", help="Fetch the results from the SUT.")
            p.set_defaults(func=s.results)
            p.add_argument('-c', '--config', required=False,   type=str,                               help='The configuration file that is to be used.')
            p.add_argument('target',         metavar='target', type=str, nargs=1,                      help='The name or IP address of the SUT.')

            p  = subparsers.add_parser("test", help="Push the tests onto the SUT and then run them..")
            p.set_defaults(func=s.test)
            p.add_argument('-t', '--tests',  required=False,   type=str,            default='default', help='A list of the tests to be performed.')
            p.add_argument('--no-at',        required=False,   action='store_true', default=False,     help='Do not update the autotest tree on the SUT.')
            p.add_argument('--no-kt',        required=False,   action='store_true', default=False,     help='Do not update the kernel testing tree on the SUT.')
            p.add_argument('--no-test',      required=False,   action='store_true', default=False,     help='Do not run any of the tests.')
            p.add_argument('--loud',         required=False,   action='store_true', default=False,     help='Print out all the output from running the tests.')
            p.add_argument('-c', '--config', required=False,   type=str,                               help='The configuration file that is to be used.')
            p.add_argument('target',         metavar='target', type=str, nargs=1,                      help='The name or IP address of the SUT.')

            args = parent_parser.parse_args()

            s.config = UMTConfiguration(args)
            umt = UbuntuMobileTester(s.config)
            retval = args.func(umt)

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            print("Aborting ...")

        except ErrorExit as e:
            msg = e.message
            if type(msg) is list:
                for m in msg:
                    error(m)
            else:
                error(msg)

        return retval

if __name__ == '__main__':
    exit(TheApp().main())

# vi:set ts=4 sw=4 expandtab syntax=python:
