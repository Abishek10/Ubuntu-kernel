#!/usr/bin/env python
#

from os                                 import getenv, path, makedirs
from sys                                import stdout, argv
from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import warning, error, info, debug, basicConfig, INFO, DEBUG, getLogger
from lib.shell                          import ShellError, ShellTimeoutError, sh, ssh
from tempfile                           import mkdtemp
from time                               import sleep
import re
from datetime                           import date
import pexpect


import json

# test_runner_progress
#
def test_runner_progress(out, queue, quiet=True, silent=False):
    pkg_installation_started = False
    tests_started = False
    test_start_rc = re.compile('\d+:\d+:\d+ INFO \|\s+START\s+(\S+)\s+\S+\s+timestamp=.*$')
    previous_test = ''
    errors = 0

    for line in iter(out.readline, b''):
        queue.put(line)

        if silent:
            continue

        if quiet:
            l = line.rstrip()
            if 'DEBUG - Installing:' in l:
                if not pkg_installation_started:
                    stdout.write('    Installing pkgs:\n       ')
                    pkg_installation_started = True
                stdout.write(l.replace('DEBUG - Installing:', '').replace('\'', '') + ' ')
                stdout.flush()

            if tests_started:
                if 'INFO | \tSTART' in l:
                    m = test_start_rc.search(l)
                    if m:
                        try:
                            test, _ = m.group(1).split('.', 1)
                        except ValueError as e:
                            test = m.group(1)
                        if test != previous_test:
                            stdout.write('        ' + test)
                            previous_test = test
                            errors = 0

                elif 'END ERROR' in l:
                    errors += 1

                elif 'END FAIL' in l:
                    errors += 1

                elif 'INFO | END GOOD' in l:
                    if errors > 0:
                        stdout.write(' ... failed\n')
                    else:
                        stdout.write(' ... passed\n')

            elif 'INFO | START' in l:
                tests_started = True
                stdout.write('\n    Executing tests:\n')
                stdout.flush()
        else:
            stdout.write(line)
            stdout.flush()

    stdout.write('\n')
    stdout.flush()
    out.close()

# phablet_flash_progress
#
def phablet_flash_progress(out, queue, quiet=False):
    fid = ''
    previous_fid = ''
    downloading_md5sum = False
    for line in iter(out.readline, b''):
        queue.put(line)

        line = line.rstrip()
        if 'Validatind download for %s' % previous_fid == line:
            stdout.write('\rDownloading: ' + previous_fid + ' .. completed and verified.              \n')
            stdout.flush()
            downloading_md5sum = False

        if not downloading_md5sum:
            if '..........' in line:
                try:
                    d = line.split()
                    if len(d) > 8:
                        stdout.write('\rDownloading: ' + previous_fid + ' .. %s completed, %s until finished.     ' % (d[6], d[8]))
                except IndexError:
                    error('IndexError. len(d) = %d' % len(d))

        if line.startswith('Downloading '):
            fid = line.replace('Downloading ', '')
            fid = fid[fid.rfind('/')+1:]
            if fid != previous_fid + '.md5sum':
                previous_fid = fid
                stdout.write('Downloading: ' + previous_fid + ' .. ')
                stdout.flush()

            if 'md5sum' in fid:
                downloading_md5sum = True

        if line.startswith('Pushing '):
            stdout.write('\rUpdating device ...')
            stdout.flush()

    #stdout.write(' complete\n')
    #stdout.flush()
    out.close()

# ErrorExit
#
class ErrorExit(Exception):
    """
    Print out the message and exit.
    """
    def __init__(s, emsg):
        s.__message = emsg

    @property
    def message(s):
        return s.__message

# Error
#
class Error(ErrorExit):
    """
    """
    def __init__(s, emsg):
        ErrorExit.__init__(s, emsg)

# NoSuchFile
#
class NoSuchFile(ErrorExit):
    """
    """
    def __init__(s, emsg):
        ErrorExit.__init__(s, emsg)

# BadJson
#
class BadJson(ErrorExit):
    """
    """
    def __init__(s, emsg):
        ErrorExit.__init__(s, emsg)

# UMTConfiguration
#
class UMTConfiguration():
    '''
    Configuration file search path:
        1. User's home directory
        2. Current directory
    If it is specified on the command line, that is the only one to use.
    '''

    # __init__
    #
    def __init__(s, args):
        s.args = args
        s.config_file_name = 'umt.cfg'

        # If the user specified a configuration file on the command line then
        # that file must exist and will be used.
        #
        if args.config:
            try:
                d = s.__load_json(args.config)
            except NoSuchFile as e:
                raise ErrorExit('The specified configuration file (%s) does not exist.' % args.config)
            except BadJson as e:
                raise ErrorExit(['The specified configuration file (%s) is not correctly formatted JSON.' % (args.config), e.message])

        # Otherwise, we will search for a configuration file.
        #
        else:
            search_path = []
            search_path.append(s.config_file_name)                                            # Current directory
            search_path.append(path.join(path.expanduser('~'), s.config_file_name))           # User's home directory
            search_path.append(path.join(argv[0][:argv[0].rfind('/')], s.config_file_name))   # Where the application is located
            for p in search_path:
                if path.exists(p):
                    try:
                        d = s.__load_json(p)
                        for k in d:
                            setattr(s, k, d[k])
                    except BadJson as e:
                        raise ErrorExit(['The specified configuration (%s) is not correctly formatted JSON.' % (p), e.message])
                    break # First one wins

        # Command line parameters overwride those specified in
        # the configuration file.
        #
        for a in args.__dict__:
            setattr(s, a, args.__dict__[a])

    # __load_json
    #
    def __load_json(s, fp):
        '''
        Load the specified json formatted file and returns the associated object.
        '''
        retval = None
        if path.exists(fp):
            try:
                with open(fp, 'r') as f:
                    try:
                        retval = json.loads(f.read())
                    except ValueError as e:
                        raise BadJson(e.message)
            except:
                raise
        else:
            raise NoSuchFile(fp)

        return retval

# UbuntuMobileTester
#
class UbuntuMobileTester():
    '''
    '''

    # __init__
    #
    def __init__(s, config):
        s.config = config

# TheApp
#
class TheApp():
    '''
    '''

    # __init__
    #
    def __init__(s):
        if getenv('DEBUG'):
            LOGLEVEL = DEBUG
        else:
            LOGLEVEL = INFO
        #LOGLEVEL = DEBUG
        basicConfig(level=LOGLEVEL, format="%(levelname)s - %(message)s")

    # __load_file
    #
    def __load_file(s, fp):
        '''
        Open a specific file and return it's contents.
        '''
        retval = None
        if path.exists(fp):
            with open(fp, 'r') as f:
                retval = f.read()
        else:
            raise NoSuchFile(fp)

        return retval

    # device_attached
    #
    def device_attached(s):
        (results, output) = sh('adb devices', quiet=True)
        found = 0
        devices = False
        for line in output:
            if devices:
                if 'device' in line:
                    found += 1

            elif 'List of devices attached' in line:
                devices = True

        if found > 1:
            raise ErrorExit('adb found more than one device attached. Only one device is permitted.')

        return found > 0

    # device_reflash
    #
    def device_reflash(s):
        sh('phablet-flash', output_enqueue_fn=phablet_flash_progress, quiet=True)

    # device_configure_for_ssh
    #
    def device_configure_for_ssh(s):
        # Restart the adb daemon with root permissions
        #
        sh('adb root', quiet=True)

    # fetch_public_key
    #
    def fetch_public_key(s):
        key = None
        try:
            p = path.join(path.expanduser('~'), '.ssh', 'id_rsa.pub')
            with open(p, 'r') as f:
                key = f.read()
        except IOError as e:
            warning('Unable to find a public ssh key (%s) to use for the authorized_keys file on the SUT' % p)
        return key

    # wait_for_reboot
    #
    def wait_for_reboot(s):
        up = False
        tries = 0
        while not up:
            try:
                sh('adb root', quiet=True)
            except ShellError:
                # This is probably going to bit me in the ass...
                sleep(10)
                continue

            try:
                ch = pexpect.spawn('adb shell', timeout=600)
                ch.expect('root@android:/ # ')
                up = True
            except pexpect.EOF:
                # If at first you don't succeed, try, try again
                #
                tries += 1
                if tries >= 100:
                    raise ErrorExit('Please try again, the device couldn\'t be found.')
                    break
                sleep(10)

    # wait_for_ip
    #
    def wait_for_ip(s):
        ip = None
        ip_found = False
        tries = 0

        chx = pexpect.spawn('adb shell', timeout=600)
        chx.expect('root@android:/ # ')

        chx.sendline('ubuntu_chroot shell')
        chx.expect('root@localhost:/# ')

        cmd = 'ip addr show wlan0'
        while not ip_found:
            debug(cmd)
            stdout.write('.'), stdout.flush()
            chx.sendline(cmd)
            chx.expect('root@localhost:/# ')

            output = chx.before
            ip_found = False
            for l in output.split('\n'):
                if 'inet ' in l:
                    x = l.split()
                    ip = x[1][:x[1].rfind('/')]
                    ip_found = True
                    debug('ip address: %s' % ip)
                    break
            if not ip_found:
                tries += 1
                if tries >= 5:
                    break
                sleep(10)

        return ip_found, ip


    # chroot_shell_ex
    #
    def chroot_shell(s, cmd):
        completed = False
        tries = 0
        debug(cmd)
        stdout.write('.'), stdout.flush()
        chx = pexpect.spawn('adb shell', timeout=600)
        chx.expect('root@android:/ # ')

        chx.sendline('ubuntu_chroot shell')
        chx.expect('root@localhost:/# ')

        chx.sendline(cmd)
        while not completed:
            try:
                chx.expect('root@localhost:/# ')
                completed = True
            except pexpect.EOF:
                tries += 1
                debug('retry:')
                debug(chx.before)
                if tries >= 50:
                    completed = True
                    error('%s : failed to find the expected prompt' % cmd)
                    error(chx.before)
                sleep(10)
                chx = pexpect.spawn('adb shell', timeout=600)
                chx.expect('root@android:/ # ')

                chx.sendline('ubuntu_chroot shell')
                chx.expect('root@localhost:/# ')

                chx.sendline('echo boo')

    # configure
    #
    def __configure(s, umt):
        sh('adb root', quiet=True)

        stdout.write('.'), stdout.flush()

        # Before we start interactively working with adb, push over the
        # wifi configuration script that we will need later.
        #
        try:
            sh('adb push %s/kernel-testing/wifi-config /data/ubuntu/tmp/' % (s.config.testing_root), quiet=True)
        except ShellError:
            # Try one more time
            #
            sleep(2)
            try:
                sh('adb push %s/kernel-testing/wifi-config /data/ubuntu/tmp/' % (s.config.testing_root), quiet=True)
            except ShellError as e:
                emsg = []
                emsg.append('Failed to push wifi-config to the SUT.')
                emsg.append('')
                emsg.append('    cmd: %s' % e.cmd)
                emsg.append('')
                for l in e.output:
                    emsg.append(l)
                raise ErrorExit(emsg)

        debug('configuring wifi')
        # Not sure this is the right place to do this but ...
        #
        if s.config.wifi:
            ssid = s.config.wifi['ssid']
            key  = s.config.wifi['wpa2psk']

            s.chroot_shell('sudo ./tmp/wifi-config %s %s' % (ssid, key))

        ip_found, ip = s.wait_for_ip()

        s.chroot_shell('echo phablet ALL=\(ALL:ALL\) NOPASSWD: ALL >> /etc/sudoers')
        s.chroot_shell('apt-get update')
        s.chroot_shell('apt-get install -y rsync')
        s.chroot_shell('apt-get install -y openssh-server')

        debug('setup .ssh stuff')
        if s.config.ssh_key:
            s.chroot_shell('mkdir ~phablet/.ssh')
            s.chroot_shell('chown phablet.phablet ~phablet/.ssh')
            s.chroot_shell('chmod 0700 ~phablet/.ssh')
            s.chroot_shell('echo %s > ~phablet/.ssh/authorized_keys' % s.config.ssh_key)
            s.chroot_shell('chown phablet.phablet ~phablet/.ssh/authorized_keys')

        stdout.write('. complete\n'), stdout.flush()
        return ip_found, ip

    def configure(s, umt):
        if not s.device_attached():
            raise ErrorExit('No devices were found attached to this system.')

        ip_found, ip = s.__configure(umt)

        print('')
        print('Next step(s):')
        if ip_found:
            print('    %s test phablet@%s' % (argv[0], ip))
        else:
            print('    ** Manually configure your wireless networking on the device. **')
            print('    %s configure' % argv[0])
        print('')

        ch = None

        return 'phablet@%s' % ip

    # results
    #
    def results(s, umt):
        target = s.config.target[0]
        raw_results = s.config.raw_results_root
        if not raw_results:
            raw_results = path.join(s.config.testing_root, 'raw-results')

        # Pull all the results off of the SUT and onto the local system.
        #
        if not path.exists(raw_results):
            makedirs(raw_results)
        raw_results = mkdtemp(dir=raw_results)
        sh('mkdir -p %s' % raw_results, quiet=True)
        sh('rsync -e "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" -ar %s:kernel-test-results/ %s/' % (target, raw_results), quiet=True)

        # Each test set produces it's own set of results. We want to put them
        # together into one set of results.
        #
        krp = path.join(raw_results, 'kernel_results.xml')
        sh('%s/autotest/client/tools/glue_testsuites %s/autotest-results.*.xml > %s' % (s.config.testing_root, raw_results, krp), quiet=False)

        # Produce all the web pages for this new set of results.
        #
        results = s.config.raw_results_root
        if not results:
            results = path.join(s.config.testing_root, 'results')
        sh('mkdir -p %s' % results, quiet=True)
        sh('%s/kernel-testing/tr/ingest %s %s' % (s.config.testing_root, raw_results, s.config.results_root), quiet=False)

        sh('%s/kernel-testing/tr/digest %s' % (s.config.testing_root, s.config.results_root), quiet=False)


    # provision
    #
    def provision(s, umt):
        if not s.device_attached():
            raise ErrorExit('No devices were found attached to this system.')

        s.device_reflash()

        stdout.write('\n')
        stdout.write('The device should be reflashing. Once completed the device\n')
        stdout.write('should reboot into Ubuntu.\n')
        stdout.flush()

        print('')
        print('Next step(s):')
        print('    Manually configure your wireless networking on the device.')
        print('    %s configure' % argv[0])
        print('')

    # full
    #
    def full(s, umt):
        setattr(s.config, 'no_at', False)
        setattr(s.config, 'no_kt', False)
        setattr(s.config, 'no_test', False)
        setattr(s.config, 'tests', 'default')
        setattr(s.config, 'loud', False)

        if not s.device_attached():
            raise ErrorExit('No devices were found attached to this system.')

        s.device_reflash()
        stdout.write('\r                                      \rReflashing and Rebooting')
        s.wait_for_reboot()
        stdout.write('\r                                      \rConfiguring ')

        ip_found, ip = s.__configure(umt)
        s.config.target = ['phablet@%s' % ip]
        stdout.write('Testing:            \n')
        s.__test(umt)

        stdout.write('Retrieving results')
        s.results(umt)


    # test
    #
    def __test(s, umt):
        target = s.config.target[0]
        if not s.config.no_at:
            if not path.exists(s.config.testing_root):
                raise ErrorExit('%s: Path specified in umt.cfg does not exist.' % s.config.testing_root)

            p = path.join(s.config.testing_root, 'autotest')
            if not path.exists(p):
                raise ErrorExit('%s: Path does not exist.' % p)

            p = path.join(s.config.testing_root, 'autotest-client-tests')
            if not path.exists(p):
                raise ErrorExit('%s: Path does not exist.' % p)

            p = path.join(s.config.testing_root, 'kernel-testing')
            if not path.exists(p):
                raise ErrorExit('%s: Path does not exist.' % p)

            ssh(target, 'sudo rm -rf autotest', quiet=True)

            print('    Copying autotest core to SUT')
            cmd = 'rsync -e "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" -arv --exclude=.git %s/autotest/ %s:autotest/' % (s.config.testing_root, target)
            sh(cmd, quiet=True)

            print('    Copying autotest-client-tests to SUT')
            sh('rsync -e "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" -arv --exclude=.git %s/autotest-client-tests/* %s:autotest/client/tests/' % (s.config.testing_root, target), quiet=True)

        if not s.config.no_kt:
            ssh(target, 'sudo rm -rf kernel-testing', quiet=True)

            print('    Copying kernel testing core to SUT')
            sh('rsync -e "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" -arv --exclude=.git %s/kernel-testing/ %s:kernel-testing/' % (s.config.testing_root, target), quiet=True)

        if not s.config.no_test:
            ssh(target, 'sudo rm -rf kernel-test-results', quiet=True)
            ssh(target, 'python kernel-testing/runner %s 2>&1 | tee kernel-test-results/log' % s.config.tests, quiet=not s.config.loud, output_enqueue_fn=test_runner_progress)
            print('    Tests completed')

    def test(s, umt):
        try:
            target = s.config.target[0]
            s.__test(umt)

            print('')
            print('Next step:')
            print('    %s results %s' % (argv[0], target))
            print('')

        except ShellError as e:
            emsg = []
            emsg.append('Remote command failed.')
            emsg.append('')
            emsg.append('    cmd: %s' % e.cmd)
            emsg.append('')
            for l in e.output:
                emsg.append(l)
            raise ErrorExit(emsg)

    # main
    #
    def main(s):
        retval = 1
        try:
            retval = 0

            app_description = '''
            '''
            app_epilog = '''
            '''
            parent_parser = ArgumentParser(prog='kb')

            subparsers = parent_parser.add_subparsers(title="actions", help="sub-commands help")

            p = subparsers.add_parser("full", help="Install a new instance of the image, configure and then run the tests.")
            p.set_defaults(func=s.full)
            p.add_argument('-c', '--config', required=False,   type=str,                               help='The configuration file that is to be used.')

            p = subparsers.add_parser("provision", help="Install a new instance of the image onto the SUT and prepare it for testing.")
            p.set_defaults(func=s.provision)
            p.add_argument('-c', '--config', required=False,   type=str,                               help='The configuration file that is to be used.')

            p = subparsers.add_parser("configure", help="Install a new instance of the image onto the SUT and prepare it for testing.")
            p.set_defaults(func=s.configure)
            p.add_argument('-c', '--config', required=False,   type=str,                               help='The configuration file that is to be used.')

            p = subparsers.add_parser("results", help="Fetch the results from the SUT.")
            p.set_defaults(func=s.results)
            p.add_argument('-c', '--config', required=False,   type=str,                               help='The configuration file that is to be used.')
            p.add_argument('target',         metavar='target', type=str, nargs=1,                      help='The name or IP address of the SUT.')

            p  = subparsers.add_parser("test", help="Push the tests onto the SUT and then run them..")
            p.set_defaults(func=s.test)
            p.add_argument('-t', '--tests',  required=False,   type=str,            default='default', help='A list of the tests to be performed.')
            p.add_argument('--no-at',        required=False,   action='store_true', default=False,     help='Do not update the autotest tree on the SUT.')
            p.add_argument('--no-kt',        required=False,   action='store_true', default=False,     help='Do not update the kernel testing tree on the SUT.')
            p.add_argument('--no-test',      required=False,   action='store_true', default=False,     help='Do not run any of the tests.')
            p.add_argument('--loud',         required=False,   action='store_true', default=False,     help='Print out all the output from running the tests.')
            p.add_argument('-c', '--config', required=False,   type=str,                               help='The configuration file that is to be used.')
            p.add_argument('target',         metavar='target', type=str, nargs=1,                      help='The name or IP address of the SUT.')

            args = parent_parser.parse_args()

            s.config = UMTConfiguration(args)

            umt = UbuntuMobileTester(s.config)
            retval = args.func(umt)

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            print("Aborting ...")

        # In case this wasn't handled earlier
        #
        except ShellError as e:
            emsg = []
            emsg.append('Command failed.')
            emsg.append('')
            emsg.append('    cmd: %s' % e.cmd)
            emsg.append('')
            for l in e.output:
                emsg.append(l)
            raise ErrorExit(emsg)

        except ErrorExit as e:
            msg = e.message
            if type(msg) is list:
                for m in msg:
                    error(m)
            else:
                error(msg)

        return retval

if __name__ == '__main__':
    exit(TheApp().main())

# vi:set ts=4 sw=4 expandtab syntax=python:
