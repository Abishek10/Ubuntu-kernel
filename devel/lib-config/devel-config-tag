#!/usr/bin/perl 
use strict;

if ($#ARGV != 1) {
	die "Usage: $0 <dump> <overrides>\n";
}

my ($dump, $overrides) = @ARGV;
my %options;
my %modenote;
my %desc;

my ($option, $maybe, $default, %flags, $prompt);
sub emit()
{
	return if (!$option || !$prompt);

	if ($prompt =~ s/\(DEPRECATED\)//) {
		$flags{'DEPRECATED'} = 1;
	}
	if ($prompt =~ s/\(DANGEROUS\)//) {
		$flags{'DANGEROUS'} = 1;
	}
	$prompt =~ s/\s*$//;

	if ($flags{'EXPERIMENTAL'}) {
		# We default EXPERIMENTAL options off by default.
		my ($mode, $note) = ('n', '');

		if ($option =~ /^CONFIG_SENSORS_/ && $default eq 'm') {
			($mode, $note) = ('m', "sensors are opt-in");

		} elsif ($option =~ /^CONFIG_[^_]*_?FS$/ && $default eq 'm') {
			($mode, $note) = ('m', "filesystems are opt-in");

		} elsif ($option =~ /^CONFIG_[SP]ATA_/ && $default eq 'm') {
			($mode, $note) = ('m', "ATA drivers are opt-in");

		} elsif ($option =~ /^CONFIG_INPUT_/ && $default eq 'm') {
			($mode, $note) = ('m', "input drivers are opt-in");

		} elsif ($option =~ /^CONFIG_NETFILTER_XT_/ && $default eq 'm') {
			($mode, $note) = ('m', "netfilter targets are opt-in");

		} elsif ($option =~ /^CONFIG_HID_/ && $default eq 'm') {
			($mode, $note) = ('m', "HID drivers are opt-in");

		} elsif ($option =~ /^CONFIG_CRYPTO_/ && $default eq 'm') {
			($mode, $note) = ('m', "CRYPTO drivers are opt-in");
		}
		$note = "note<$note>" if ($note);
		$modenote{$option} = [$mode, $note] if ($mode ne 'n');
		$default = 'n';
	}

	$options{$option} = join(' ', ($maybe, $default, $default));
	for my $flag (sort keys %flags) {
		$options{$option} .= " flag<$flag>";
	}
	$desc{$option} = $prompt;

	# Reset for the next option ...
	($maybe, $default, $prompt) = ('', '', '');
	undef %flags;
}
my ($note, $mode);
open(DUMP, "<$dump") || die "$0: $dump: open failed - $!\n";
while (<DUMP>) {
	chomp;

	# New record markers ...
	if (/^config\s(\S*)\s*$/) {
		emit();
		$option = "CONFIG_$1";

	} elsif (/^choice\s*$/) {
		emit();
		$option = '';

	} elsif (/^menu\s*$/) {
		emit();
		$option = '';

	# Type specifiers ...
	} elsif (/^\s\sboolean\s*$/) {
		$maybe = "y/n";
		$default = 'y';

	} elsif (/^\s\stristate\s*$/) {
		$maybe = "y/m/n";
		$default = 'm';

	} elsif (/^\s\sstring\s*$/) {
		$maybe = '-';
		$default = '-';

	} elsif (/^\s\sinteger\s*$/) {
		$maybe = '-';
		$default = '-';

	# Description ...
	} elsif (/^\s\s(?:prompt|menu)\s"([^"]*)"\s*(.*)/) {
		my ($cond) = ($2);
		$prompt = $1;
		if ($cond =~ /\bSTAGING\b/) {
			$flags{'STAGING'} = 1;
		}
		if ($cond =~ /\bEXPERIMENTAL\b/) {
			$flags{'EXPERIMENTAL'} = 1;
		}

	# Dependancies ...           Defaults ...
	} elsif (/^\s\sdepends\s/ || /^\s\sdefault\s/) {
		if (/\bSTAGING\b/) {
			$flags{'STAGING'} = 1;
		}
		if (/\bEXPERIMENTAL\b/) {
			$flags{'EXPERIMENTAL'} = 1;
		}
	}

}
close(DUMP);

my @oa;
my ($mode, $note);
foreach my $key (sort keys %options) {
	($mode, $note) = ('', undef);

	@oa = split(' ', $options{$key});

	# We default DEBUG options off.
	if ($key =~ /_DEBUG(_FS$|_|$)/) {
		($mode, $note) = ('n', undef);
		$oa[2] = 'n';

	# NET_VENDOR_* represents vendor specific groupings, alway enable.
	} elsif ($oa[2] ne 'y' && $key =~ /^CONFIG_NET_VENDOR_/) {
		($mode, $note) = ('y', "VENDOR driver group always enabled");
	
	# *_PHY represent network PHY devices, always enable.
	#   http://marc.info/?l=linux-netdev&m=125700321922154&w=2
	} elsif ($_ =~ /^CONFIG_.*_PHY/ && $oa[2] eq 'm') {
		($mode, $note) = ('y', "PHY drivers are not autoloadable");
	}

	$options{$key} = join(' ', @oa);
	if ($mode) {
		$note = "note<$note>" if ($note);
		$modenote{$key} = [$mode, $note];
	}
}

my @ea;
open(OVERRIDES, "<$overrides") ||
	die "$0: $overrides: open failed - $!\n";
while (<OVERRIDES>) {
	chomp;

	next if ($_ =~ /^$/ || $_ =~ /^#/);

	@ea = split(' ');

	@oa = split(' ', $options{$ea[0]});
	$oa[0] = '-' if ($oa[0] eq '');
	$oa[1] = '-' if ($oa[1] eq '');
	$oa[2] = '-' if ($oa[2] eq '');

	# Set the option to the specified value and add any other options
	$modenote{$ea[0]} = [$ea[1], join(' ', @ea[2..$#ea])];

	$options{$ea[0]} = join(' ', @oa);
}
close(OVERRIDES);

foreach my $key (sort keys %options) {
	if ($modenote{$key}) {
		($mode, $note) = @{$modenote{$key}};

		@oa = split(' ', $options{$key});
		if ($mode && $mode ne '-') {
			if ($oa[2] ne $mode && $note) {
				push(@oa, "flag<policy=$mode>");
			}
			$oa[2] = $mode;
		}
		push(@oa, $note) if ($note);
		$options{$key} = join(' ', @oa);
	}
	print "$key $options{$key} desc<$desc{$key}>\n";
}
