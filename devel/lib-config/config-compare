#!/usr/bin/perl

use strict;

my $P = 'config-compare';

my %values;

# Predicate execution engine.
my %pred_attr;
sub pred_do {
	my ($pred) = @_;
	my (@a) = split(' ', $pred);
	my $possible;

	if ($a[0] eq 'arch') {
		die "$P: $pred: malformed -- $pred <arch>\n" if ($#a < 1);
		for $possible (@a[1..$#a]) {
			#print "    *** ARCH<$flavour ?? $possible>\n";
			return 1 if ($pred_attr{'arch'} eq $possible);
		}
		return 0;
	} elsif ($a[0] eq 'flavour') {
		die "$P: $pred: malformed -- $pred <flavour>\n" if ($#a < 1);
		for $possible (@a[1..$#a]) {
			#print "    *** FLAVOUR<$flavour ?? $a[1]>\n";
			return 1 if ($pred_attr{'flavour'} eq $possible);
		}
		return 0;
	} elsif ($a[0] eq 'value') {
		@a = ($a[0], $pred_attr{'option'}, @a[1..$#a]) if ($#a == 1);
		die "$P: $pred: malformed -- $pred <name> <val>\n" if ($#a != 2);
		#warn "    *** CHECK<$a[1] $a[2] ?? " . $values{$pred_attr{'column'}, $a[1]} . ">\n";
		return ($values{$pred_attr{'column'}, $a[1]} eq $a[2]);
	} elsif ($a[0] eq 'exists') {
		@a = ($a[0], $pred_attr{'option'}, @a[1..$#a]) if ($#a == 1);
		die "$P: $pred: malformed -- $pred <name>\n" if ($#a != 1);
		return (defined $values{$pred_attr{'column'}, $a[1]});
	} else {
		die "$P: $pred: unknown predicate\n";
	}
	return 1;
}
sub pred_first {
	my ($rest) = @_;
	my $depth = 0;
	my $off;
	my $char;
	my $pred;
	
	for ($off = 0; $off <= length($rest); $off++) {
		$char = substr($rest, $off, 1);
		if ($char eq '(') {
			$depth++;
		} elsif ($char eq ')') {
			$depth--;
		} elsif ($depth == 0 && $char eq '&') {
			last;
		} elsif ($depth == 0 && $char eq '|') {
			last;
		}
	}
	if ($depth > 0) {
		die "$P: $rest: missing close parenthesis ')'\n";
	} elsif ($depth < 0) {
		die "$P: $rest: missing open parenthesis '('\n";
	}

	($pred, $rest) = (substr($rest, 0, $off), substr($rest, $off + 1));

	$pred =~ s/^\s*//;
	$pred =~ s/\s*$//;

	#print "pred<$pred> rest<$rest> char<$char>\n";
	($pred, $rest, $char);
}
sub pred_exec {
	my ($rest) = @_;
	my $pred;
	my $cut = 0;
	my $res;
	my $sep;

	#print "pred_exec<$rest>\n";

	($pred, $rest, $sep) = pred_first($rest);

	# Leading ! implies inversion.
	if ($pred =~ /^\s*!\s*(.*)$/) {
		#print " invert<$1>\n";
		($cut, $res) = pred_exec($1);
		$res = !$res;

	# Leading / implies a CUT operation.
	} elsif ($pred =~ /^\s*\/\s*(.*)$/) {
		#print " cut<$1>\n";
		($cut, $res) = pred_exec($1);
		$cut = 1;

	# Recurse left for complex expressions.
	} elsif ($pred =~ /^\s*\((.*)\)\s*$/) {
		#print " left<$1>\n";
		($cut, $res) = pred_exec($1);

	# Check for common syntax issues.
	} elsif ($pred eq '') {
		if ($sep eq '&' || $sep eq '|') {
			die "$P: $pred$rest: malformed binary operator\n";
		} else {
			die "$P: $pred$rest: syntax error\n";
		}
		
	# A predicate, execute it.
	} else {
		#print " DO<$pred> sep<$sep>\n";
		$res = pred_do($pred);
	}

	#print " pre-return res<$res> sep<$sep>\n";
	if ($sep eq '') {
		#
		
	# Recurse right for binary operators -- note these are lazy.
	} elsif ($sep eq '&' || $sep eq '|') {
		#print " right<$rest> ? sep<$sep> res<$res>\n";
		if ($rest =~ /^\s*($|\||\&)/) {
			die "$P: $pred$rest: malformed binary operator\n";
		}
		if ($cut == 0 && (($res && $sep eq '&') || (!$res && $sep eq '|'))) {
			#print " right<$rest>\n";
			($cut, $res) = pred_exec($rest);
		}

	} else {
		die "$P: $pred$rest: malformed predicate\n";
	}
	#warn " return cut<$cut> res<$res> sep<$sep>\n";
	return ($cut, $res);
}
sub policy_check {
	my ($column, $option, $policy) = @_;

	# Pull out the arch and flavour from the column name.
	($pred_attr{'arch'}, $pred_attr{'flavour'}) = split(/-/, $column, 2);

	$pred_attr{'column'} = $column;
	$pred_attr{'option'} = $option;

	my ($cut, $res) = pred_exec($policy);
	#print "CUT<$cut> RES<$res>\n";
	return $res;
}

my %options;
my @options;

my $policy = 1;

my $info;
my %flags;
my %expected;
my %policy;

my $sort = 0;

my $colour = 0;

my $format = 'wiki';

while (1) {
	if ($ARGV[0] eq '--required') {
		open(RQRD, "<$ARGV[1]") || die "$0: $ARGV[1]: open failed - $!\n";
		while (<RQRD>) {
			chomp;

			if (!defined $options{$_}) {
				$options{$_} = 1;
				push(@options, $_);
			}
		}
		close(RQRD);
		shift @ARGV;
		shift @ARGV;

	}  elsif ($ARGV[0] eq '--no-policy') {
		$policy = 0;
		shift @ARGV;

	} elsif ($ARGV[0] eq '--info') {
		$info = $ARGV[1];
		shift @ARGV;
		shift @ARGV;

	} elsif ($ARGV[0] eq '--sort') {
		$sort = 1;
		shift @ARGV;

	} elsif ($ARGV[0] eq '--colour') {
		$colour = 1;
		shift @ARGV;

	} elsif ($ARGV[0] eq '--format') {
		$format = $ARGV[1];
		shift @ARGV;
		shift @ARGV;

	} else {
		last;
	}
}

if ($format eq 'wiki') {
	my $f__row_colour;
	sub wiki_em {
		"'''" . $_[0] . "'''";
	}
	sub wiki_table_row_colour {
		if ($_[0]) {
			$f__row_colour = "<#" . $_[0] . ">";
		} else {
			$f__row_colour = '';
		}
	}
	sub wiki_table_row_start {
		"||";
	}
	sub wiki_table_cell {
		$f__row_colour . " " . $_[0] . " ||";
	}
	sub wiki_table_row_end {
		"\n";
	}

	no strict;

	*f_em			= \&wiki_em;
	*f_table_row_colour	= \&wiki_table_row_colour;
	*f_table_row_start	= \&wiki_table_row_start;
	*f_table_cell		= \&wiki_table_cell;
	*f_table_row_end	= \&wiki_table_row_end;

} else {
	die "$P: $format: invalid output format\n";
}

if ($info) {
	my ($config, $maybe, $default, $expected, $options, $option, $value);
	open(INFO, "<$info") || die "$0: $info: open failed - $!\n";
	while (<INFO>) {
		chomp;
		($config, $maybe, $default, $expected, $options) = split(' ', $_, 5);
		while ($options =~ /\s*(\S+)<(.*?)?>/g) {
			($option, $value) = ($1, $2);
			if ($option eq 'flag') {
				$flags{$config} .= " " . f_em($value);
			} elsif ($option eq 'note') {
				$flags{$config} .= " $2";
			} elsif ($option eq 'choice') {
				$flags{$config} .= " " . f_em('CHOICE');
			} elsif ($option eq 'policy') {
				$policy{$config} = $value;
				#$flags{$config} .= " " . f_em("policy=$value");
				$expected = $value;
			}
		}
		$values{'Policy', $config} = $expected;
		if (!defined $policy{$config} &&
		    $expected ne 'c' && $expected ne '-') {
			$policy{$config} = "value $expected";
		}
	}
	close(INFO);
}

# No info, no policy checks...
if (!$info) {
	$policy = 0;
}

my @columns = @ARGV;

my $opt;
my $is;
for my $column (@columns) {
	open(CONFIG, "<$column") || die "$0: $column: open failed - $!\n";
	while (<CONFIG>) {
		chomp;

		if ($_ =~ /^# (\S+) is not set/) {
			$opt = $1;
			$is = 'n';
		} elsif ($_ =~ /(\S+)=(\S+)/) {
			$opt = $1;
			$is = $2;
		} else {
			next;
		}

		$values{$column, $opt} = $is;

		if (!defined $options{$opt}) {
			$options{$opt} = 1;
			push(@options, $opt);
		}
	}
	close(CONFIG);
}

@options = sort(@options) if ($sort);

push(@columns, "Policy") if ($policy);

print f_table_row_start();
print f_table_cell(f_em('Option'));
for my $column (@columns) {
	print f_table_cell(f_em($column));
}
print f_table_cell(f_em('Comments'));
print f_table_row_end();
my $val;
my $cmt;
my $seen;

my $ok;
my %ok;

if (!$policy) {
	%policy = ();
}
for my $option (@options) {
	$seen = '';
	$cmt = '';
	$ok = 1;
	%ok = ();
	for my $column (@columns) {
		$is = (defined $values{$column, $option})?
				$values{$column, $option} : '-';
		# If we have no policy at all then pick the first valid entry.
		if (!defined $policy{$option} && $is ne '-') {
			$policy{$option} = "value $is";
		}
		if ($policy{$option} && $column ne 'Policy' &&
		    defined $values{$column, $option} &&
		    !policy_check($column, $option, $policy{$option})) {
			$ok = 0;
			$ok{$column} = 0;
		} else {
			$ok{$column} = 1;
		}
		$seen++ if ($is ne '-' && $column ne 'Policy');
	}

	if ($colour) {
		if ($flags{$option} =~ /BUILD FAILURE/) {
			f_table_row_colour('baffc8');

		} elsif (!$ok) {
			f_table_row_colour('ffbac8');

		} else {
			f_table_row_colour(undef);
		}
	}
	print f_table_row_start();
	print f_table_cell($option);
	for my $column (@columns) {
		$is = (defined $values{$column, $option})?
				$values{$column, $option} : '-';
		if ($ok{$column}) {
			print f_table_cell($is);
		} else {
			print f_table_cell(f_em($is));
		}
	}
	if ($seen == 0) {
		$cmt .= " ". f_em('GONE');
	}
	if (!$ok) {
		$cmt .= " " . f_em('Inconsistent');
	}
	if ($flags{$option}) {
		$cmt .= $flags{$option};
	}
	print f_table_cell($cmt);
	print f_table_row_end();
}
