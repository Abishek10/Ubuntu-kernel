#! /usr/bin/python

# Copyright 2013 Canonical Ltd.
# Author: Andy Whitcroft <apw@canonical.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Allow editing of bugs ..."""

from __future__ import print_function

#from collections import OrderedDict
from optparse import OptionParser

from launchpadlib.launchpad import Launchpad
#from ubuntutools.question import YesNoQuestion

#import lputils

def usage(throw, msg):
    if throw:
        raise BaseException(msg)


def main():
    options = {}
    parser = OptionParser(
        usage="usage: %prog -s suite [options] package [...]")
    parser.add_option(
        "-l", "--launchpad", dest="launchpad_instance", default="production")
#    parser.add_option(
#        "-n", "--dry-run", default=False, action="store_true",
#        help="only show removals that would be performed")
#    parser.add_option(
#        "-d", "--distribution", default="ubuntu",
#        metavar="DISTRIBUTION", help="override in DISTRIBUTION")
#    parser.add_option(
#        "-s", "--suite", metavar="SUITE", help="override in SUITE")
#    parser.add_option(
#        "-e", "--version",
#        metavar="VERSION", help="package version (default: current version)")
#    parser.add_option(
#        "-c", "--command", default='unblock',
#        help="migration hint command (default: unlock)")
#
    options, args = parser.parse_args()

    options.launchpad = Launchpad.login_with(
        "bug-command", options.launchpad_instance, version="devel")

#    # We care about the development series by defaults.
#    if hasattr(options, 'suite'):
#        ubuntu = options.launchpad.distributions['ubuntu']
#        options.suite = ubuntu.current_series.name + '-proposed'

    ubuntu = options.launchpad.distributions['ubuntu']
    devel = ubuntu.current_series

    bug = None
    task = None
    while len(args) > 0:
        cmd = args.pop(0)

        if cmd == 'bug':
            usage(len(cmd) < 1, "bug <bug number>")
            bnum = args.pop(0)
            bug = options.launchpad.bugs[bnum]
            #print("BUG: " + str(bug))
        
            task = None

#        elif cmd == 'package':
#            usage(len(cmd) < 1, "package <source package>")
#            usage(bug != None, "task: bug required")
#
#            source_name = args.pop(0)
#
#            source = ubuntu.getSourcePackage(name=source_name)
#            print("PACKAGE: " + str(source)

        elif cmd == 'task':
            usage(len(cmd) < 2, "task <series> <source package>")
            usage(bug == None, "task: bug required")

            (series_name, source_name) = (args.pop(0), args.pop(0))

            series = ubuntu.getSeries(name_or_version=series_name)
            series_source = series.getSourcePackage(name=source_name)
            for tsk in bug.bug_tasks:
                if tsk.target_link != series_source.self_link:
                    continue
                task = tsk
                break

            # If there is no specific task there may be a source package task
            # but only if we are talking about the development release.
            if not task and devel.self_link == series.self_link:
                series_source = ubuntu.getSourcePackage(name=source_name)
                for tsk in bug.bug_tasks:
                    if tsk.target_link != series_source.self_link:
                        continue
                    task = tsk
                    break
                
            #print("TASK: " + str(task))

        elif cmd == 'zap-all-but':
            name = task.target.name

            for tsk in bug.bug_tasks:
                if tsk == task:
                    pass # print("immune")
                elif tsk.target.name != name:
                    pass # print("uninteresting")
                else:
                    #print("ZAP")
                    tsk.status = 'Invalid'
                    tsk.lp_save()

        elif cmd == 'status':
            usage(len(cmd) < 1, "status <new status>")
            usage(task == None, "task: bug required")

            new_status = args.pop(0)
            
            task.status = new_status
            task.lp_save()

if __name__ == '__main__':
    main()
