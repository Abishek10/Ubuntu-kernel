#!/usr/bin/python


from __future__ import print_function

import sys
import re
import sqlite3
from subprocess     import Popen, PIPE


class IdStore:
    def __init__(this, db):
        this.__con = sqlite3.connect(db)

        try:
            result = this.__con.execute('select Version from Version;')
        except:
            this.__con.execute('create table Version(Version INT);')
            this.__con.execute('create table TagDetail(Series TEXT, Source TEXT, Version TEXT, Tag TEXT, Id TEXT, TidLink TEXT);')
            this.__con.execute('create table IdDetail(Id TEXT, Tid INTEGER, Frevert BOOLEAN DEFAULT 0, Foverlay DEFAULT 0);')
            this.__con.execute('create table TitleId(Title TEXT, Tid INTEGER, Id TEXT);')
            this.__con.execute('insert into Version(Version) values (1);')
            this.__con.execute('create index IdDetailIdxId on IdDetail(Id)')
            this.__con.commit()

        this.recalc_rids()


    def recalc_rids(this):
        this.__tag_rids = {}

        tags = []
        commit_link = {}

        cur = this.__con.execute('select ROWID,Series,Source,Version,Id,TidLink from TagDetail;')
        for row in cur:
            (r_rowid, r_series, r_source, r_version, r_id, r_tidprev) = row

            if r_rowid == r_tidprev:
                continue
            if r_tidprev:
                commit_link[int(r_rowid)] = int(r_tidprev);

        cur = this.__con.execute('select ROWID,Series,Source,Version,Id,TidLink from TagDetail;')
        for row in cur:
            (r_rowid, r_series, r_source, r_version, r_id, r_tidprev) = row

            rids = []
            while r_rowid != None:
                ##print(r_rowid, commit_link.get(int(r_rowid), None))
                rids.append(str(r_rowid))
                r_rowid = commit_link.get(int(r_rowid), None)

            this.__tag_rids[(r_series, r_source, r_version)] = rids
        
        ##print(this.__tag_rids)
        ##print(this.__tag_rids[('lucid', 'linux', 'pending')])


    def commit(this):
        this.__con.commit();


    # Look through the output of git log for commit references, recording the
    # local sha representing those passed in wanted.
    log_commit = re.compile(r'^commit\s([0-9a-f]{40})')
    # commit SHA1 upstream
    log_shaA = re.compile(r'commit\s+([0-9a-f]{40})\s+upstream')
    # cherry picked from commit SHA1
    # backported from commit SHA1
    log_shaB = re.compile(r'(?i)(?:(?:cherry(?:-|\s+)picked|back(?:-|\s*)port(?:ed)?)\s+from\s+(?:commit\s+)?|upstream(?:-|\s+)commit[:\s]\s*|commit\s+upstream\s+)([0-9a-f]{40})\b')
    # Change-Id: ID
    log_shaC = re.compile(r'Change-Id: (I[0-9a-f]+)')
    log_title = re.compile(r'^\s\s\s\s(\S.*)$')

    def log_shas(this, tid, commits):
        ##print('log_shas', commits)
        cmd = [ 'git', 'log', commits ]
        p = Popen(cmd, stdout=PIPE)

        found = {}
        sha_current = None
        title_seen = True
        for line in p.stdout:
            ##print(line, end='')
            # commit <sha>
            match = this.log_commit.search(line)
            if match:
                sha_current = match.group(1)
                # Note we want to find the title...
                title_seen = False
                ## sha_current is in commits
                #if sha_current in this.__commit_tag:
                #    print('log_shas: stop at tag ' + this.__commit_tag[sha_current])
                #    break
                this.__con.execute('insert into IdDetail(Id, Tid) values (?, ?);',
                    (sha_current, tid))
                continue
            if not sha_current:
                continue
            # '    <title>'
            if not title_seen:
                match = this.log_title.search(line)
                if match:
                    title = match.group(1).strip()
                    title_seen = True
                    # sha_current has title title
                    title_safe = None
                    try:
                        title_safe = unicode(title, 'utf-8')
                    except:
                        pass
                    if title_safe:
                        this.__con.execute('insert into TitleId(Title, Tid, Id) values (?, ?, ?);',
                            (title_safe, tid, sha_current))
            if not sha_current:
                continue
            # <sha1>
            match = this.log_shaA.search(line)
            if not match:
                match = this.log_shaB.search(line)
            if not match:
                match = this.log_shaC.search(line)
            if match:
                sha = match.group(1)
                # sha_current mentions and likely is sha
                ##print("IS", sha_current, sha)
                this.__con.execute('insert into IdDetail(Id, Tid) values (?, ?);',
                    (sha, tid))
                continue
        return found


    def log_base(this, commits):
        ##print('log_base', commits)
        cmd = [ 'git', 'log', '--pretty=format:%H', commits ]
        p = Popen(cmd, stdout=PIPE)

        for line in p.stdout:
            cur = this.__con.execute('select ROWID,Id from TagDetail where Id=?', (line.strip(),))
            row = cur.fetchone()
            cur.close()
            if row:
                break
        if row:
            return row
        else:
            return (None, None)


    def git_tag_detail(this, tag):
        cmd = [ 'git', 'log', '-1', '--format=%H', tag ]
        p = Popen(cmd, stdout=PIPE)
        commit = None
        for line in p.stdout:
            commit = line.strip()
        p.terminate()

        ##print('git_tag_detail', tag, commit)

        return commit


    def tag_seen(this, tag):
        ##print(tag)
        cur = this.__con.execute('select Id from TagDetail where Tag=?;', (tag,))
        result = cur.fetchone()
        cur.close()
        ##print("tag_seen", result)
        return result


    def tag_detail_check(this, series, source, version, tag):
        ##print('tag_detail_check', series, source, version, tag)

        commit_tag = this.git_tag_detail(tag)

        cur = this.__con.execute('select Id,ROWID from TagDetail where Series=? and Source=? and Tag=?;', (series, source, tag))
        result = cur.fetchone()
        cur.close()

        if not result:
            ##print('tag_detail_check no entry')
            return False

        if result[0] != commit_tag:
            ##print('tag_detail_check missmatch', result[0], commit_tag)
            # XXX: need to delete dependent tags here
            this.__con.execute('delete from IdDetail where Tid=?;', (result[1],))
            this.__con.execute('delete from TagDetail where ROWID=?;', (result[1],))
            return False

        return True


    def tag_detail_add(this, series, source, version, tag, p_tid):
        ##print('tag_detail_add', series, source, version, tag, p_tid)

        commit_tag = this.git_tag_detail(tag)

        ##print('tag_detail_add APW', series, source, version, tag, prev, commit_tag, commit_prev)

        cur = this.__con.cursor()
        cur.execute('insert into TagDetail(Series, Source, Version, Tag, Id, TidLink) values (?, ?, ?, ?, ?, ?);',
            (series, source, version, tag, commit_tag, p_tid))
        tid = cur.lastrowid;
        cur.close()

        this.recalc_rids()

        return tid


    def package_update(this, series, package, version, tag):
        if store.tag_detail_check(series, package, version, tag):
            return False
        
        print(tag, "scanning", tag, file=sys.stderr)
        (p_tid, prev) = store.log_base(tag)
        print(tag, "scanning", ((prev + '..') if prev else '') + tag, file=sys.stderr)
        tid = store.tag_detail_add(series, package, version, tag, p_tid)
        store.log_shas(tid, ((prev + '..') if prev else '') + tag)

        store.commit()

        return True


    def package_has(this, series, package, version, commit):
        rids = this.__tag_rids[(series, package, version)]

        cur = this.__con.cursor()
        cur.execute('select Id from IdDetail where Id=? and Tid in (' + ','.join(rids) + ');',
            (commit,))
        row = cur.fetchone()
        cur.close()

        ##if series == 'lucid' and package == 'linux':
        ##    print('package_has', series, package, version, commit, row)
        return row


    def __overlay_add(this, tid, sha):
        this.__con.execute('insert into IdDetail(Id, Tid, Foverlay) values (?, ?, ?);',
                (sha, tid, 1))


    def overlay_cmd_title(this, title, shas):
        ##print("overlay_cmd_title", title, shas)
        cur = this.__con.cursor()
        cur.execute('select Tid,Id from TitleId where Title=?;', (title,))
        for row in cur:
            (tid, commit) = row
            for sha in shas:
                ##print("overlay_cmd_title", tid, sha)
                this.__overlay_add(tid, sha)
        cur.close()

    def overlay_cmd_unpublished_version(this, version):
        pass


    def overlay_update(this, overlays):
        # Read in the any corrective overlays.
        this.__con.execute('delete from IdDetail where Foverlay=?', (1,))
        with file(overlays) as fh:
            for line in fh:
                if line[0] == ':':
                    exec("this.overlay_cmd_" + line[1:])
                    continue
                shas = line.split()
                if len(shas) == 0 or shas[0] == '#':
                    continue
                fix = shas.pop(0)
                cur = this.__con.execute('select Tid from IdDetail where Id=?;', (fix,))
                for row in cur:
                    tid = row[0]
                    for sha in shas:
                        ##print("basic overlay", tid, sha)
                        this.__overlay_add(tid, sha)
                cur.close()
                #if not row:
                #    print("OVERLAY IGNORED: " + line, end='', file=sys.stderr)
                #    continue

        this.__con.commit()


#                                "$here/cves-applied2" <"$cve_list" "$overlay" \
#                                        "$series" "$cvebranch" \
#                                        $bases $tag_list "$branch" "pending" | \
#                                        tee "$state+cache"
#store = IdStore("/home/apw/test.db")
##store.overlay_update('/home/apw/bzr/cve-tracker/kernel-cve-tracker/active/10autotriage.linux')
#raise "DEBUG"

(store_db, overlay, series, package) = sys.argv[1:5]
tagvers = sys.argv[5:]

store = IdStore(store_db)

print("Opened store " + store_db + " successfully", file=sys.stderr)

update_overlay = False
for tag, version in zip(tagvers[::2], tagvers[1::2]):
    if store.package_update(series, package, version, tag):
        update_overlay = True

# XXX: make sure we do this at least once ... a better trigger is required
if series == 'upstream' and package == 'linux':
    update_overlay = True

if overlay != '-' and update_overlay:
    store.overlay_update(overlay)

# Read in all of the CVEs and their associated upstream commits.
cves = []

for line in sys.stdin:
    shas = line.split()
    cve_num = shas.pop(0)

    # Work out which package fixes to apply, if there are specific
    # fixes listed use those else use the linux ones.
    pkg_needed = 'linux'
    for sha in shas:
        # <package>:[pre>]need[|need]...
        (pkg, sha) = sha.split(':', 1)

        if pkg == package:
            pkg_needed = package

    needs = []
    for sha in shas:
        # <package>:[pre>]need[|need]...
        (pkg, sha) = sha.split(':', 1)
        if '>' in sha:
            (psha, sha) = sha.split('>')
        else:
            psha = '-'
        shal = sha.split('|')

        # Only the fixes listed for this package are interesting.
        if pkg != pkg_needed:
            continue

        # Drop illegal values.
        valid = True
        if psha != '-' and len(psha) != 40 and not psha.startswith('I'):
            valid = False
        for isha in shal:
            if len(isha) != 40 and not isha.startswith('local-') and not isha.startswith('I'):
                value = False
                break
        if not valid:
            continue

        needs.append((psha, shal))

    ##print(cve_num, needs)
    (ptag, pversion) = tagvers[-2:]

    ##print("CHECKING PREREQ VERSION:", tag, version)
    # Do we have the dependancies
    all_shal = []
    for (psha, shal) in needs:
        ##if cve_num == 'active/CVE-2014-3940':
        ##    print("LOOKING FOR", series, package, pversion, psha)
        if psha != '-' and not store.package_has(series, package, pversion, psha):
            continue
        ##if cve_num == 'active/CVE-2014-3940':
        ##    print("FOUND", series, package, pversion, psha)
        all_shal += shal
    
    found = True
    if len(all_shal) > 0:
        for tag, version in zip(tagvers[::2], tagvers[1::2]):
            found = True
            for sha in all_shal:
                if not store.package_has(series, package, version, sha):
                    found = False
                    break
            if found:
                break

        ##print(psha, shal)
    if len(all_shal) == 0:
        print(cve_num, series, package, '-', 'not-affected')
    elif not found:
        print(cve_num, series, package, ','.join(all_shal), 'needed')
    else:
        print(cve_num, series, package, ','.join(all_shal), version)
