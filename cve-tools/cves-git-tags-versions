#!/usr/bin/python
#
# cves-git-tags
#

from __future__ import print_function

import sys
import os
import re

from subprocess     import Popen, PIPE

mode = sys.argv[1]
cache = sys.argv[2]
versions = sys.argv[3:]

# Find the debian version of the release pointed to by this tag
commit_changelog = re.compile(r'^:.*\s(\S*/changelog)')
commit_version = re.compile(r'\((.*)\)')
def tag_version_payload(tag):
    # Find the filename of the changelog
    cmd = [ 'git', 'show', '--raw', tag ]
    p = Popen(cmd, stdout=PIPE)

    changelog = None
    for line in p.stdout:
        line = line.decode('utf-8')
        match = commit_changelog.search(line)
        if match:
            changelog = match.group(1)
            break

    if not changelog:
        return tag

    # Grab the first line and pull the version string out of it
    cmd = [ 'git', 'cat-file', '-p', "%s:%s" % (tag, changelog) ]
    p = Popen(cmd, stdout=PIPE)
    line = p.stdout.readline()
    line = line.decode('utf-8')
    p.terminate()
    match = commit_version.search(line)
    if match:
        return match.group(1)

    return tag


def tag_version_cache(tag, sha1):
    # Use the sha1 of the tag as a cache key.
    vcache = os.path.join(cache, sha1 + ".v")
    try:
        with open(vcache, 'r') as f:
            line = f.readline()
            return line.strip()
    except:
        version = tag_version_payload(tag)

        with open(vcache, 'w') as f:
            f.write(version + "\n")
    
        return version


kernelver_version       = re.compile(r'^VERSION\s*=\s*([^\s]+)')
kernelver_patchlevel    = re.compile(r'^PATCHLEVEL\s*=\s*([^\s]+)')
kernelver_sublevel      = re.compile(r'^SUBLEVEL\s*=\s*([^\s]+)')
kernelver_extraversion  = re.compile(r'^EXTRAVERSION\s*=\s*([^\s]+)')
def tag_kernelver_payload(tag):
    # Grab the kernel makefile and determine the version.
    # VERSION = 3
    # PATCHLEVEL = 13
    # SUBLEVEL = 11
    # EXTRAVERSION = .2
    V = None
    P = None
    S = None
    E = ''
    cmd = [ 'git', 'cat-file', '-p', "%s:Makefile" % (tag) ]
    p = Popen(cmd, stdout=PIPE)
    for line in p.stdout:
        line = line.decode('utf-8')
        match = kernelver_version.search(line)
        if match:
            V = match.group(1)
        match = kernelver_patchlevel.search(line)
        if match:
            P = match.group(1)
        match = kernelver_sublevel.search(line)
        if match:
            S = match.group(1)
        match = kernelver_extraversion.search(line)
        if match:
            E = match.group(1)
    p.terminate()

    return "{0}.{1}.{2}{3}".format(V, P, S, E)


def tag_thing_cache(tag, sha1, ext, thing):
    # Use the sha1 of the tag as a cache key.
    vcache = os.path.join(cache, sha1 + ext)
    try:
        with open(vcache, 'r') as f:
            line = f.readline()
            return line.strip()
    except:
        result = thing(tag)

        with open(vcache, 'w') as f:
            f.write(result + "\n")
    
        return result


def tag_kernelver_cache(tag, sha1):
    return tag_thing_cache(tag, sha1, 'kv', tag_kernelver_payload)


# Get a list of tags by their debian version number
def git_taglist():
    tags = {}
    # Grab the first line and pull the version string out of it
    cmd = [ 'git', 'for-each-ref', 'refs/tags/Ubuntu-*' ]
    p = Popen(cmd, stdout=PIPE)
    for line in p.stdout:
        line = line.decode('utf-8')
        (sha1, what, tag) = line.strip().split()
        tag_name = tag.split('/')[2]

        tag_vers = tag_version_cache(tag_name, sha1)
        tag_kver = tag_kernelver_cache(tag_name, sha1)

        tags[tag_vers] = (tag_name, tag_kver)
        #print(sha1, what, tag_name)
    p.terminate()
    return tags


tag_version_map = git_taglist()
for version in versions:
    if version not in tag_version_map:
        sys.stderr.write("cves-git-tags-versions: {0} has no tag\n".format(version))
        continue

    (tag, kver) = tag_version_map[version]

    if mode == 'tags':
        print(tag, version)
    elif mode == 'versions':
        print(version, tag, kver)
