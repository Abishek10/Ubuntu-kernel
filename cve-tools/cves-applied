#!/usr/bin/python
#
# cves-applied -- 
#
import sys
import re
import os

from subprocess     import Popen, PIPE

overlays = sys.argv[1]
branch = sys.argv[2]
tagvers = sys.argv[3:]

# cves[cve] = [ sha1 ... ]
cves = {}
# prereq_map[sha] = sha1
prereq_map = {}
# prereq_wanted[sha] = True/False
prereq_wanted = {}
# wanted[sha] = True/False
wanted = {}
# overlay[sha] = [ sha1 ... ]
overlay = {}

# Read in all of the CVEs and their associated upstream commits.
for line in sys.stdin:
    shas = line.split()
    cve_num = shas.pop(0)

    cves[cve_num] = list()

    for sha in shas:
        pre = sha.split('>')
        if len(pre) == 2:
            (psha, sha) = pre
            if psha != '-':
                if len(psha) != 40:
                    continue
                prereq_map[sha] = psha
                prereq_wanted[psha] = True
        else:
            psha = '-'
        if len(sha) != 40 and not sha.startswith('local-'):
            continue
        wanted[sha] = True
        cves[cve_num].append((psha, sha))

def overlay_title(title, shas):
    overlay[title] = shas

# Read in the any corrective overlays.
if overlays != '-':
    with file(overlays) as fh:
        for line in fh:
            if line[0] == ':':
                exec("overlay_" + line[1:])
                continue
            shas = line.split()
            if len(shas) == 0 or shas[0] == '#':
                continue
            fix = shas.pop(0)
            overlay[fix] = shas


# Take the list of tags and record their version
tags = []
tags_ver = {}
for tag, version in zip(tagvers[::2], tagvers[1::2]):
    tags.append(tag)
    if version:
        tags_ver[tag] = version
    else:
        tags_ver[tag] = tag


# Look through the output of git log for commit references, recording the
# local sha representing those passed in wanted.
log_commit = re.compile(r'^commit\s([0-9a-f]{40})')
# commit SHA1 upstream
log_shaA = re.compile(r'commit\s+([0-9a-f]{40})\s+upstream')
# cherry picked from commit SHA1
# backported from commit SHA1
log_shaB = re.compile(r'(?i)(?:(?:cherry(?:-|\s+)picked|back(?:-|\s*)port(?:ed)?)\s+from\s+(?:commit\s+)?|upstream(?:-|\s+)commit[:\s]\s*|commit\s+upstream\s+)([0-9a-f]{40})\b')
log_title = re.compile(r'^\s\s\s\s(\S.*)$')

def log_shas(commits, wanted, overlay):
    cmd = [ 'git', 'log', commits ]
    p = Popen(cmd, stdout=PIPE)

    found = {}
    sha_current = None
    title_seen = True
    for line in p.stdout:
        # commit <sha>
        match = log_commit.search(line)
        if match:
            sha_current = match.group(1)
            if sha_current in wanted:
                del wanted[sha_current]
                found[sha_current] = sha_current
            # If we have an overlay inject that here and ignore the real entry.
            if sha_current in overlay:
                for sha in overlay[sha_current]:
                    if sha in wanted:
                        del wanted[sha]
                        found[sha] = sha_current
                    # Prefix match, cve specific backport fix...
                    if sha[0:40] in wanted:
                        found[sha] = sha_current
                sha_current = None
            # Note we want to find the title...
            title_seen = False
            continue
        if not sha_current:
            continue
        # '    <title>'
        if not title_seen:
            match = log_title.search(line)
            if match:
                title = match.group(1).strip()
                # If we have a title based overlay inject that here.
                if title in overlay:
                    for sha in overlay[title]:
                        if sha in wanted:
                            del wanted[sha]
                            found[sha] = sha_current
                        # Prefix match, cve specific backport fix...
                        if sha[0:40] in wanted:
                            found[sha] = sha_current
                    sha_current = None
                title_seen = True
        if not sha_current:
            continue
        # <sha1>
        match = log_shaA.search(line)
        if not match:
            match = log_shaB.search(line)
        if match:
            sha = match.group(1)
            if sha in wanted:
                del wanted[sha]
                found[sha] = sha_current
            continue
    return found


# Run through the tags looking for any sha1 conversions we can find.
prev = ''
found = {}
for tag in tags:
    # Run the log for this tag looking for commit ids mentioned in the
    # body text.
    found[tag] = log_shas(prev + tag, wanted, overlay)

    prev = tag + ".."

# Run through all the prerequisite shas and see if they are in the latest
# tag, if so we assume we need that part of the fix for this branch
prereq_found = log_shas(tag, prereq_wanted, overlay)

# Run through all of the cves and see if we found all of the shas
# it consists of.
tag_found = None
for cve_num in cves:
    wanted_sha = cves[cve_num]
    commits = []
    for tag in tags:
        for (psha, sha) in list(wanted_sha):
            for sha_found in [sha, sha + '-' + os.path.basename(cve_num), None]:
                if sha_found in found[tag]:
                    break
            if sha_found:
                wanted_sha.remove((psha, sha))
                commits.append(found[tag][sha_found])
                tag_found = tag
            elif psha != '-' and psha not in prereq_found:
                wanted_sha.remove((psha, sha))
    wanted = [y for (x,y) in wanted_sha]
    if len(wanted):
        print cve_num + " " + branch + " " + ",".join(wanted) + " needed"
    elif len(commits):
        print cve_num + " " + branch + " " + ",".join(commits) + " " + \
            tags_ver[tag_found]
    else:
        print cve_num + " " + branch + " - not-affected"
