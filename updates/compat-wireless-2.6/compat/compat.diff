--- a/drivers/misc/eeprom/Makefile
+++ b/drivers/misc/eeprom/Makefile
@@ -1,5 +1 @@
-obj-$(CONFIG_EEPROM_AT24)	+= at24.o
-obj-$(CONFIG_EEPROM_AT25)	+= at25.o
-obj-$(CONFIG_EEPROM_LEGACY)	+= eeprom.o
-obj-$(CONFIG_EEPROM_MAX6875)	+= max6875.o
 obj-$(CONFIG_EEPROM_93CX6)	+= eeprom_93cx6.o
--- a/drivers/net/b44.c
+++ b/drivers/net/b44.c
@@ -2112,6 +2112,7 @@ static int __devinit b44_get_invariants(struct b44 *bp)
 	return err;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops b44_netdev_ops = {
 	.ndo_open		= b44_open,
 	.ndo_stop		= b44_close,
@@ -2127,6 +2128,7 @@ static const struct net_device_ops b44_netdev_ops = {
 	.ndo_poll_controller	= b44_poll_controller,
 #endif
 };
+#endif
 
 static int __devinit b44_init_one(struct ssb_device *sdev,
 				  const struct ssb_device_id *ent)
@@ -2166,9 +2168,26 @@ static int __devinit b44_init_one(struct ssb_device *sdev,
 	bp->rx_pending = B44_DEF_RX_RING_PENDING;
 	bp->tx_pending = B44_DEF_TX_RING_PENDING;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+	dev->open = b44_open;
+	dev->stop = b44_close;
+	dev->hard_start_xmit = b44_start_xmit;
+	dev->get_stats = b44_get_stats;
+	dev->set_multicast_list = b44_set_rx_mode;
+	dev->set_mac_address = b44_set_mac_addr;
+	dev->do_ioctl = b44_ioctl;
+	dev->tx_timeout = b44_tx_timeout;
+	netif_napi_add(dev, &bp->napi, b44_poll, 64);
+	dev->watchdog_timeo = B44_TX_TIMEOUT;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	dev->poll_controller = b44_poll_controller;
+#endif
+	dev->change_mtu = b44_change_mtu;
+#else
 	dev->netdev_ops = &b44_netdev_ops;
 	netif_napi_add(dev, &bp->napi, b44_poll, 64);
 	dev->watchdog_timeo = B44_TX_TIMEOUT;
+#endif
 	dev->irq = sdev->irq;
 	SET_ETHTOOL_OPS(dev, &b44_ethtool_ops);
 
--- a/drivers/net/usb/Makefile
+++ b/drivers/net/usb/Makefile
@@ -2,23 +2,7 @@
 # Makefile for USB Network drivers
 #
 
-obj-$(CONFIG_USB_CATC)		+= catc.o
-obj-$(CONFIG_USB_KAWETH)	+= kaweth.o
-obj-$(CONFIG_USB_PEGASUS)	+= pegasus.o
-obj-$(CONFIG_USB_RTL8150)	+= rtl8150.o
-obj-$(CONFIG_USB_HSO)		+= hso.o
-obj-$(CONFIG_USB_NET_AX8817X)	+= asix.o
 obj-$(CONFIG_USB_NET_CDCETHER)	+= cdc_ether.o
-obj-$(CONFIG_USB_NET_CDC_EEM)	+= cdc_eem.o
-obj-$(CONFIG_USB_NET_DM9601)	+= dm9601.o
-obj-$(CONFIG_USB_NET_SMSC95XX)	+= smsc95xx.o
-obj-$(CONFIG_USB_NET_GL620A)	+= gl620a.o
-obj-$(CONFIG_USB_NET_NET1080)	+= net1080.o
-obj-$(CONFIG_USB_NET_PLUSB)	+= plusb.o
 obj-$(CONFIG_USB_NET_RNDIS_HOST)	+= rndis_host.o
-obj-$(CONFIG_USB_NET_CDC_SUBSET)	+= cdc_subset.o
-obj-$(CONFIG_USB_NET_ZAURUS)	+= zaurus.o
-obj-$(CONFIG_USB_NET_MCS7830)	+= mcs7830.o
 obj-$(CONFIG_USB_USBNET)	+= usbnet.o
-obj-$(CONFIG_USB_NET_INT51X1)	+= int51x1.o
 
--- a/drivers/net/usb/rndis_host.c
+++ b/drivers/net/usb/rndis_host.c
@@ -266,6 +266,7 @@ response_error:
 	return -EDOM;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 /* same as usbnet_netdev_ops but MTU change not allowed */
 static const struct net_device_ops rndis_netdev_ops = {
 	.ndo_open		= usbnet_open,
@@ -275,6 +276,7 @@ static const struct net_device_ops rndis_netdev_ops = {
 	.ndo_set_mac_address 	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 int
 generic_rndis_bind(struct usbnet *dev, struct usb_interface *intf, int flags)
@@ -337,7 +339,11 @@ generic_rndis_bind(struct usbnet *dev, struct usb_interface *intf, int flags)
 	dev->rx_urb_size &= ~(dev->maxpacket - 1);
 	u.init->max_transfer_size = cpu_to_le32(dev->rx_urb_size);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	net->netdev_ops = &rndis_netdev_ops;
+#else
+	net->change_mtu = NULL;
+#endif
 
 	retval = rndis_command(dev, u.header, CONTROL_BUFFER_SIZE);
 	if (unlikely(retval < 0)) {
--- a/drivers/net/usb/usbnet.c	2009-07-02 00:16:46.300294574 -0700
+++ b/drivers/net/usb/usbnet.c	2009-07-02 00:20:34.717101235 -0700
@@ -1151,6 +1151,7 @@
 }
 EXPORT_SYMBOL_GPL(usbnet_disconnect);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops usbnet_netdev_ops = {
 	.ndo_open		= usbnet_open,
 	.ndo_stop		= usbnet_stop,
@@ -1160,6 +1161,7 @@
 	.ndo_set_mac_address 	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 /*-------------------------------------------------------------------------*/
 
@@ -1229,7 +1231,15 @@
 		net->features |= NETIF_F_HIGHDMA;
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	net->netdev_ops = &usbnet_netdev_ops;
+#else
+	net->change_mtu = usbnet_change_mtu;
+	net->hard_start_xmit = usbnet_start_xmit;
+	net->open = usbnet_open;
+	net->stop = usbnet_stop;
+	net->tx_timeout = usbnet_tx_timeout;
+#endif
 	net->watchdog_timeo = TX_TIMEOUT_JIFFIES;
 	net->ethtool_ops = &usbnet_ethtool_ops;
 
--- a/net/wireless/Makefile
+++ b/net/wireless/Makefile
@@ -10,3 +10,11 @@ cfg80211-$(CONFIG_CFG80211_DEBUGFS) += debugfs.o
 cfg80211-$(CONFIG_WIRELESS_EXT) += wext-compat.o wext-sme.o
 
 ccflags-y += -D__CHECK_ENDIAN__
+# Compat-wireless kernel compatibility code
+cfg80211-y += compat-2.6.27.o
+cfg80211-y += compat-2.6.28.o
+cfg80211-y += compat-2.6.29.o
+cfg80211-y += compat-2.6.30.o
+cfg80211-y += compat-2.6.31.o
+cfg80211-y += compat-2.6.32.o
+
--- a/drivers/net/wireless/ath/ath5k/base.h
+++ b/drivers/net/wireless/ath/ath5k/base.h
@@ -46,7 +46,11 @@
 #include <linux/wireless.h>
 #include <linux/if_ether.h>
 #include <linux/leds.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 #include <linux/rfkill.h>
+#else
+#include <linux/rfkill_backport.h>
+#endif
 
 #include "ath5k.h"
 #include "debug.h"
--- a/drivers/net/wireless/ath/ath9k/hw.c	2009-07-21 13:18:14.945936434 -0700
+++ b/drivers/net/wireless/ath/ath9k/hw.c	2009-07-21 13:18:15.389946641 -0700
@@ -3434,7 +3434,7 @@
 
 	pCap->hw_caps |= ATH9K_HW_CAP_ENHANCEDPM;
 
-#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
+#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)) || ((LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL_BACKPORT) || defined(CONFIG_RFKILL_BACKPORT_MODULE))
 	ah->rfsilent = ah->eep_ops->get_eeprom(ah, EEP_RF_SILENT);
 	if (ah->rfsilent & EEP_RFSILENT_ENABLED) {
 		ah->rfkill_gpio =
--- a/drivers/net/wireless/b43/pcmcia.c	2009-07-08 23:31:13.028453519 -0700
+++ b/drivers/net/wireless/b43/pcmcia.c	2009-07-08 23:31:15.213207643 -0700
@@ -88,7 +88,11 @@ static int __devinit b43_pcmcia_probe(st
 	res = pcmcia_get_tuple_data(dev, &tuple);
 	if (res != 0)
 		goto err_kfree_ssb;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28))
+	res = pcmcia_parse_tuple(NULL,&tuple, &parse);
+#else
 	res = pcmcia_parse_tuple(&tuple, &parse);
+#endif
 	if (res != 0)
 		goto err_kfree_ssb;
 
--- a/drivers/net/wireless/b43/phy_common.h
+++ b/drivers/net/wireless/b43/phy_common.h
@@ -2,6 +2,9 @@
 #define LINUX_B43_PHY_COMMON_H_
 
 #include <linux/types.h>
+#if (LINUX_VERSION_CODE == KERNEL_VERSION(2,6,28))
+#include <asm/atomic.h>
+#endif
 
 struct b43_wldev;
 
--- a/drivers/net/wireless/ipw2x00/ipw2100.c
+++ b/drivers/net/wireless/ipw2x00/ipw2100.c
@@ -6008,6 +6008,7 @@ static void ipw2100_rf_kill(struct work_struct *work)
 
 static void ipw2100_irq_tasklet(struct ipw2100_priv *priv);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops ipw2100_netdev_ops = {
 	.ndo_open		= ipw2100_open,
 	.ndo_stop		= ipw2100_close,
@@ -6018,6 +6019,7 @@ static const struct net_device_ops ipw2100_netdev_ops = {
 	.ndo_set_mac_address	= ipw2100_set_address,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 /* Look into using netdev destructor to shutdown ieee80211? */
 
@@ -6043,7 +6045,16 @@ static struct net_device *ipw2100_alloc_device(struct pci_dev *pci_dev,
 	priv->ieee->perfect_rssi = -20;
 	priv->ieee->worst_rssi = -85;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	dev->netdev_ops = &ipw2100_netdev_ops;
+#else
+	dev->open = ipw2100_open;
+	dev->stop = ipw2100_close;
+	dev->init = ipw2100_net_init;
+	dev->tx_timeout = ipw2100_tx_timeout;
+	dev->set_mac_address = ipw2100_set_address;
+#endif
+
 	dev->ethtool_ops = &ipw2100_ethtool_ops;
 	dev->wireless_handlers = &ipw2100_wx_handler_def;
 	priv->wireless_data.ieee80211 = priv->ieee;
--- a/drivers/net/wireless/ipw2x00/ipw2200.c	2009-07-21 13:18:54.353940665 -0700
+++ b/drivers/net/wireless/ipw2x00/ipw2200.c	2009-07-21 13:18:54.537944910 -0700
@@ -11525,6 +11525,7 @@
 	return NETDEV_TX_OK;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops ipw_prom_netdev_ops = {
 	.ndo_open 		= ipw_prom_open,
 	.ndo_stop		= ipw_prom_stop,
@@ -11533,6 +11534,7 @@
 	.ndo_set_mac_address 	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 static int ipw_prom_alloc(struct ipw_priv *priv)
 {
@@ -11553,7 +11555,13 @@
 	memcpy(priv->prom_net_dev->dev_addr, priv->mac_addr, ETH_ALEN);
 
 	priv->prom_net_dev->type = ARPHRD_IEEE80211_RADIOTAP;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	priv->prom_net_dev->netdev_ops = &ipw_prom_netdev_ops;
+#else
+	priv->prom_net_dev->open = ipw_prom_open;
+	priv->prom_net_dev->stop = ipw_prom_stop;
+	priv->prom_net_dev->hard_start_xmit = ipw_prom_hard_start_xmit;
+#endif
 
 	priv->prom_priv->ieee->iw_mode = IW_MODE_MONITOR;
 	SET_NETDEV_DEV(priv->prom_net_dev, &priv->pci_dev->dev);
@@ -11581,6 +11589,7 @@
 
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops ipw_netdev_ops = {
 	.ndo_init		= ipw_net_init,
 	.ndo_open		= ipw_net_open,
@@ -11591,6 +11600,7 @@
 	.ndo_change_mtu		= ieee80211_change_mtu,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 static int __devinit ipw_pci_probe(struct pci_dev *pdev,
 				   const struct pci_device_id *ent)
@@ -11692,7 +11702,15 @@
 	priv->ieee->perfect_rssi = -20;
 	priv->ieee->worst_rssi = -85;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	net_dev->netdev_ops = &ipw_netdev_ops;
+#else
+	net_dev->open = ipw_net_open;
+	net_dev->stop = ipw_net_stop;
+	net_dev->init = ipw_net_init;
+	net_dev->set_multicast_list = ipw_net_set_multicast_list;
+	net_dev->set_mac_address = ipw_net_set_mac_address;
+#endif
 	priv->wireless_data.spy_data = &priv->ieee->spy_data;
 	net_dev->wireless_data = &priv->wireless_data;
 	net_dev->wireless_handlers = &ipw_wx_handler_def;
--- a/drivers/net/wireless/libertas/if_cs.c
+++ b/drivers/net/wireless/libertas/if_cs.c
@@ -813,7 +813,11 @@ static int if_cs_probe(struct pcmcia_device *p_dev)
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
 	if ((ret = pcmcia_get_first_tuple(p_dev, &tuple)) != 0 ||
 	    (ret = pcmcia_get_tuple_data(p_dev, &tuple)) != 0 ||
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28))
+	    (ret = pcmcia_parse_tuple(NULL,&tuple, &parse)) != 0)
+#else
 	    (ret = pcmcia_parse_tuple(&tuple, &parse)) != 0)
+#endif
 	{
 		lbs_pr_err("error in pcmcia_get_first_tuple etc\n");
 		goto out1;
--- a/drivers/net/wireless/libertas/main.c
+++ b/drivers/net/wireless/libertas/main.c
@@ -1148,6 +1148,7 @@ static void lbs_free_adapter(struct lbs_private *priv)
 	lbs_deb_leave(LBS_DEB_MAIN);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops lbs_netdev_ops = {
 	.ndo_open 		= lbs_dev_open,
 	.ndo_stop		= lbs_eth_stop,
@@ -1158,6 +1159,7 @@ static const struct net_device_ops lbs_netdev_ops = {
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 /**
  * @brief This function adds the card. it will probe the
@@ -1193,7 +1195,16 @@ struct lbs_private *lbs_add_card(void *card, struct device *dmdev)
 	priv->infra_open = 0;
 
 	/* Setup the OS Interface to our functions */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
  	dev->netdev_ops = &lbs_netdev_ops;
+#else
+	dev->open = lbs_dev_open;
+	dev->hard_start_xmit = lbs_hard_start_xmit;
+	dev->stop = lbs_eth_stop;
+	dev->set_mac_address = lbs_set_mac_address;
+	dev->tx_timeout = lbs_tx_timeout;
+	dev->set_multicast_list = lbs_set_multicast_list;
+#endif
 	dev->watchdog_timeo = 5 * HZ;
 	dev->ethtool_ops = &lbs_ethtool_ops;
 #ifdef	WIRELESS_EXT
@@ -1419,6 +1430,7 @@ out:
 EXPORT_SYMBOL_GPL(lbs_stop_card);
 
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops mesh_netdev_ops = {
 	.ndo_open		= lbs_dev_open,
 	.ndo_stop 		= lbs_mesh_stop,
@@ -1426,6 +1438,7 @@ static const struct net_device_ops mesh_netdev_ops = {
 	.ndo_set_mac_address	= lbs_set_mac_address,
 	.ndo_set_multicast_list = lbs_set_multicast_list,
 };
+#endif
 
 /**
  * @brief This function adds mshX interface
@@ -1449,7 +1462,15 @@ static int lbs_add_mesh(struct lbs_private *priv)
 	mesh_dev->ml_priv = priv;
 	priv->mesh_dev = mesh_dev;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	mesh_dev->netdev_ops = &mesh_netdev_ops;
+#else
+	mesh_dev->open = lbs_dev_open;
+	mesh_dev->hard_start_xmit = lbs_hard_start_xmit;
+	mesh_dev->stop = lbs_mesh_stop;
+	mesh_dev->set_mac_address = lbs_set_mac_address;
+	mesh_dev->set_multicast_list = lbs_set_multicast_list;
+#endif
 	mesh_dev->ethtool_ops = &lbs_ethtool_ops;
 	memcpy(mesh_dev->dev_addr, priv->dev->dev_addr,
 			sizeof(priv->dev->dev_addr));
@@ -1664,11 +1685,13 @@ out:
 	lbs_deb_leave(LBS_DEB_MAIN);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops rtap_netdev_ops = {
 	.ndo_open = lbs_rtap_open,
 	.ndo_stop = lbs_rtap_stop,
 	.ndo_start_xmit = lbs_rtap_hard_start_xmit,
 };
+#endif
 
 static int lbs_add_rtap(struct lbs_private *priv)
 {
@@ -1689,7 +1712,13 @@ static int lbs_add_rtap(struct lbs_private *priv)
 
 	memcpy(rtap_dev->dev_addr, priv->current_addr, ETH_ALEN);
 	rtap_dev->type = ARPHRD_IEEE80211_RADIOTAP;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	rtap_dev->netdev_ops = &rtap_netdev_ops;
+#else
+	rtap_dev->open = lbs_rtap_open;
+	rtap_dev->stop = lbs_rtap_stop;
+	rtap_dev->hard_start_xmit = lbs_rtap_hard_start_xmit;
+#endif
 	rtap_dev->ml_priv = priv;
 	SET_NETDEV_DEV(rtap_dev, priv->dev->dev.parent);
 
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@ -814,16 +814,22 @@ static struct device_driver mac80211_hwsim_driver = {
 	.name = "mac80211_hwsim"
 };
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops hwsim_netdev_ops = {
 	.ndo_start_xmit 	= hwsim_mon_xmit,
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_set_mac_address 	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 static void hwsim_mon_setup(struct net_device *dev)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	dev->netdev_ops = &hwsim_netdev_ops;
+#else
+	dev->hard_start_xmit = hwsim_mon_xmit;
+#endif
 	dev->destructor = free_netdev;
 	ether_setup(dev);
 	dev->tx_queue_len = 0;
--- a/drivers/net/wireless/rndis_wlan.c
+++ b/drivers/net/wireless/rndis_wlan.c
@@ -2335,6 +2335,7 @@ static int bcm4320b_early_init(struct usbnet *usbdev)
 	return 0;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 /* same as rndis_netdev_ops but with local multicast handler */
 static const struct net_device_ops rndis_wlan_netdev_ops = {
 	.ndo_open		= usbnet_open,
@@ -2345,6 +2346,7 @@ static const struct net_device_ops rndis_wlan_netdev_ops = {
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_set_multicast_list	= rndis_wlan_set_multicast_list,
 };
+#endif
 
 
 static int rndis_wlan_bind(struct usbnet *usbdev, struct usb_interface *intf)
@@ -2395,7 +2397,11 @@ static int rndis_wlan_bind(struct usbnet *usbdev, struct usb_interface *intf)
 	 * rndis_host wants to avoid all OID as much as possible
 	 * so do promisc/multicast handling in rndis_wlan.
 	 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	usbdev->net->netdev_ops = &rndis_wlan_netdev_ops;
+#else
+	usbdev->net->set_multicast_list = rndis_wlan_set_multicast_list;
+#endif
 
 	tmp = RNDIS_PACKET_TYPE_DIRECTED | RNDIS_PACKET_TYPE_BROADCAST;
 	retval = rndis_set_oid(usbdev, OID_GEN_CURRENT_PACKET_FILTER, &tmp,
--- a/drivers/net/wireless/wl12xx/wl1251_main.c
+++ b/drivers/net/wireless/wl12xx/wl1251_main.c
@@ -26,6 +26,9 @@
 #include <linux/firmware.h>
 #include <linux/delay.h>
 #include <linux/irq.h>
+#if (LINUX_VERSION_CODE == KERNEL_VERSION(2,6,28))
+#include <linux/device.h>
+#endif
 #include <linux/spi/spi.h>
 #include <linux/crc32.h>
 #include <linux/etherdevice.h>
--- a/drivers/net/wireless/wl12xx/wl1251_spi.c
+++ b/drivers/net/wireless/wl12xx/wl1251_spi.c
@@ -23,6 +23,9 @@
 
 #include <linux/module.h>
 #include <linux/crc7.h>
+#if (LINUX_VERSION_CODE == KERNEL_VERSION(2,6,28))
+#include <linux/device.h>
+#endif
 #include <linux/spi/spi.h>
 
 #include "wl1251.h"
--- a/include/linux/rfkill_backport.h	2009-07-08 19:34:26.145290692 -0700
+++ b/include/linux/rfkill_backport.h	2009-07-08 23:33:04.501218904 -0700
@@ -23,6 +23,7 @@
  */
 
 #include <linux/types.h>
+#include <net/compat.h>
 
 /* define userspace visible states */
 #define RFKILL_STATE_SOFT_BLOCKED	0
@@ -147,7 +148,7 @@ struct rfkill_ops {
 	int	(*set_block)(void *data, bool blocked);
 };
 
-#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
+#if defined(CONFIG_RFKILL_BACKPORT) || defined(CONFIG_RFKILL_MODULE_BACKPORT)
 /**
  * rfkill_alloc - allocate rfkill structure
  * @name: name of the struct -- the string is not copied internally
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -23,6 +23,7 @@
 /* remove once we remove the wext stuff */
 #include <net/iw_handler.h>
 #include <linux/wireless.h>
+#include <net/compat.h>
 
 
 /*
--- a/net/mac80211/driver-trace.h
+++ b/net/mac80211/driver-trace.h
@@ -1,7 +1,9 @@
 #if !defined(__MAC80211_DRIVER_TRACE) || defined(TRACE_HEADER_MULTI_READ)
 #define __MAC80211_DRIVER_TRACE
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
 #include <linux/tracepoint.h>
+#endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27)) */
 #include <net/mac80211.h>
 #include "ieee80211_i.h"
 
@@ -645,4 +647,6 @@ TRACE_EVENT(drv_ampdu_action,
 #define TRACE_INCLUDE_PATH .
 #undef TRACE_INCLUDE_FILE
 #define TRACE_INCLUDE_FILE driver-trace
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30))
 #include <trace/define_trace.h>
+#endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)) */
--- a/net/mac80211/iface.c	2009-07-21 13:19:35.836937034 -0700
+++ b/net/mac80211/iface.c	2009-07-21 13:19:36.396937822 -0700
@@ -645,6 +645,7 @@
 	WARN_ON(flushed);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops ieee80211_dataif_ops = {
 	.ndo_open		= ieee80211_open,
 	.ndo_stop		= ieee80211_stop,
@@ -664,11 +665,22 @@
 	.ndo_change_mtu 	= ieee80211_change_mtu,
 	.ndo_set_mac_address 	= eth_mac_addr,
 };
+#endif
 
 static void ieee80211_if_setup(struct net_device *dev)
 {
 	ether_setup(dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	dev->netdev_ops = &ieee80211_dataif_ops;
+#else
+	dev->hard_start_xmit = ieee80211_subif_start_xmit;
+	dev->set_multicast_list = ieee80211_set_multicast_list;
+	dev->change_mtu = ieee80211_change_mtu;
+	dev->open = ieee80211_open;
+	dev->stop = ieee80211_stop;
+	/* we will validate the address ourselves in ->open */
+	dev->validate_addr = NULL;
+#endif
 	dev->wireless_handlers = &ieee80211_iw_handler_def;
 	dev->destructor = free_netdev;
 }
@@ -684,7 +696,11 @@
 
 	/* and set some type-dependent values */
 	sdata->vif.type = type;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	sdata->dev->netdev_ops = &ieee80211_dataif_ops;
+#else
+	sdata->dev->hard_start_xmit = ieee80211_subif_start_xmit;
+#endif
 	sdata->wdev.iftype = type;
 
 	/* only monitor differs */
@@ -707,7 +723,11 @@
 		break;
 	case NL80211_IFTYPE_MONITOR:
 		sdata->dev->type = ARPHRD_IEEE80211_RADIOTAP;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 		sdata->dev->netdev_ops = &ieee80211_monitorif_ops;
+#else
+		sdata->dev->hard_start_xmit = ieee80211_monitor_start_xmit;
+#endif
 		sdata->u.mntr_flags = MONITOR_FLAG_CONTROL |
 				      MONITOR_FLAG_OTHER_BSS;
 		break;
@@ -773,6 +793,8 @@
 	if (!ndev)
 		return -ENOMEM;
 
+/* This is an optimization, just ignore for older kernels */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
 	ndev->needed_headroom = local->tx_headroom +
 				4*6 /* four MAC addresses */
 				+ 2 + 2 + 2 + 2 /* ctl, dur, seq, qos */
@@ -781,6 +803,7 @@
 				- ETH_HLEN /* ethernet hard_header_len */
 				+ IEEE80211_ENCRYPT_HEADROOM;
 	ndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;
+#endif
 
 	ret = dev_alloc_name(ndev, ndev->name);
 	if (ret < 0)
@@ -814,6 +837,10 @@
 	if (ret)
 		goto fail;
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,28))
+	ndev->uninit = ieee80211_teardown_sdata;
+#endif
+
 	if (ieee80211_vif_is_mesh(&sdata->vif) &&
 	    params && params->mesh_id_len)
 		ieee80211_sdata_set_mesh_id(sdata,
--- a/net/mac80211/key.c
+++ b/net/mac80211/key.c
@@ -21,6 +21,9 @@
 #include "aes_ccm.h"
 #include "aes_cmac.h"
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+#include <asm/unaligned.h>
+#endif
 
 /**
  * DOC: Key handling basics
--- a/net/mac80211/rate.c
+++ b/net/mac80211/rate.c
@@ -22,7 +22,7 @@ struct rate_control_alg {
 static LIST_HEAD(rate_ctrl_algs);
 static DEFINE_MUTEX(rate_ctrl_mutex);
 
-static char *ieee80211_default_rc_algo = CONFIG_MAC80211_RC_DEFAULT;
+static char *ieee80211_default_rc_algo = CONFIG_COMPAT_MAC80211_RC_DEFAULT;
 module_param(ieee80211_default_rc_algo, charp, 0644);
 MODULE_PARM_DESC(ieee80211_default_rc_algo,
 		 "Default rate control algorithm for mac80211 to use");
@@ -117,8 +117,8 @@ ieee80211_rate_control_ops_get(const char *name)
 		ops = ieee80211_try_rate_control_ops_get(ieee80211_default_rc_algo);
 
 	/* try built-in one if specific alg requested but not found */
-	if (!ops && strlen(CONFIG_MAC80211_RC_DEFAULT))
-		ops = ieee80211_try_rate_control_ops_get(CONFIG_MAC80211_RC_DEFAULT);
+	if (!ops && strlen(CONFIG_COMPAT_MAC80211_RC_DEFAULT))
+		ops = ieee80211_try_rate_control_ops_get(CONFIG_COMPAT_MAC80211_RC_DEFAULT);
 
 	return ops;
 }
--- a/net/rfkill/Makefile
+++ b/net/rfkill/Makefile
@@ -2,6 +2,6 @@
 # Makefile for the RF switch subsystem.
 #
 
-rfkill-y			+= core.o
-rfkill-$(CONFIG_RFKILL_INPUT)	+= input.o
-obj-$(CONFIG_RFKILL)		+= rfkill.o
+rfkill_backport-y			+= core.o
+rfkill_backport-$(CONFIG_RFKILL_BACKPORT_INPUT)	+= input.o
+obj-$(CONFIG_RFKILL_BACKPORT)		+= rfkill_backport.o
--- a/net/rfkill/core.c	2009-07-21 13:20:20.385938726 -0700
+++ b/net/rfkill/core.c	2009-07-21 13:20:20.869936904 -0700
@@ -26,7 +26,7 @@
 #include <linux/capability.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
-#include <linux/rfkill.h>
+#include <linux/rfkill_backport.h>
 #include <linux/spinlock.h>
 #include <linux/miscdevice.h>
 #include <linux/wait.h>
@@ -61,7 +61,7 @@
 	const struct rfkill_ops	*ops;
 	void			*data;
 
-#ifdef CONFIG_RFKILL_LEDS
+#ifdef CONFIG_RFKILL_BACKPORT_LEDS
 	struct led_trigger	led_trigger;
 	const char		*ledtrigname;
 #endif
@@ -122,7 +122,7 @@
 static bool rfkill_epo_lock_active;
 
 
-#ifdef CONFIG_RFKILL_LEDS
+#ifdef CONFIG_RFKILL_BACKPORT_LEDS
 static void rfkill_led_trigger_event(struct rfkill *rfkill)
 {
 	struct led_trigger *trigger;
@@ -316,7 +316,7 @@
 	rfkill_event(rfkill);
 }
 
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 static atomic_t rfkill_input_disabled = ATOMIC_INIT(0);
 
 /**
@@ -774,7 +774,7 @@
 }
 
 static struct class rfkill_class = {
-	.name		= "rfkill",
+	.name		= "rfkill_backport",
 	.dev_release	= rfkill_release,
 	.dev_attrs	= rfkill_dev_attrs,
 	.dev_uevent	= rfkill_dev_uevent,
@@ -920,7 +920,7 @@
 	if (!rfkill->persistent || rfkill_epo_lock_active) {
 		schedule_work(&rfkill->sync_work);
 	} else {
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 		bool soft_blocked = !!(rfkill->state & RFKILL_BLOCK_SW);
 
 		if (!atomic_read(&rfkill_input_disabled))
@@ -1148,7 +1148,7 @@
 	list_for_each_entry_safe(ev, tmp, &data->events, list)
 		kfree(ev);
 
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 	if (data->input_handler)
 		if (atomic_dec_return(&rfkill_input_disabled) == 0)
 			printk(KERN_DEBUG "rfkill: input handler enabled\n");
@@ -1159,7 +1159,7 @@
 	return 0;
 }
 
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 static long rfkill_fop_ioctl(struct file *file, unsigned int cmd,
 			     unsigned long arg)
 {
@@ -1191,14 +1191,14 @@
 	.write		= rfkill_fop_write,
 	.poll		= rfkill_fop_poll,
 	.release	= rfkill_fop_release,
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 	.unlocked_ioctl	= rfkill_fop_ioctl,
 	.compat_ioctl	= rfkill_fop_ioctl,
 #endif
 };
 
 static struct miscdevice rfkill_miscdev = {
-	.name	= "rfkill",
+	.name	= "rfkill_backport",
 	.fops	= &rfkill_fops,
 	.minor	= MISC_DYNAMIC_MINOR,
 };
@@ -1221,7 +1221,7 @@
 		goto out;
 	}
 
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 	error = rfkill_handler_init();
 	if (error) {
 		misc_deregister(&rfkill_miscdev);
@@ -1237,7 +1237,7 @@
 
 static void __exit rfkill_exit(void)
 {
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 	rfkill_handler_exit();
 #endif
 	misc_deregister(&rfkill_miscdev);
--- a/net/rfkill/input.c	2009-07-07 17:27:09.290706860 -0700
+++ b/net/rfkill/input.c	2009-07-07 17:26:57.195684653 -0700
@@ -17,7 +17,11 @@
 #include <linux/slab.h>
 #include <linux/workqueue.h>
 #include <linux/init.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 #include <linux/rfkill.h>
+#else
+#include <linux/rfkill_backport.h>
+#endif
 #include <linux/sched.h>
 
 #include "rfkill.h"
@@ -229,7 +233,7 @@ static int rfkill_connect(struct input_h
 
 	handle->dev = dev;
 	handle->handler = handler;
-	handle->name = "rfkill";
+	handle->name = "rfkill_backport";
 
 	/* causes rfkill_start() to be called */
 	error = input_register_handle(handle);
--- a/net/wireless/core.h	2009-07-07 13:32:53.367707921 -0700
+++ b/net/wireless/core.h	2009-07-07 13:32:53.943703622 -0700
@@ -11,7 +11,11 @@
 #include <linux/kref.h>
 #include <linux/rbtree.h>
 #include <linux/debugfs.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 #include <linux/rfkill.h>
+#else
+#include <linux/rfkill_backport.h>
+#endif
 #include <linux/workqueue.h>
 #include <net/genetlink.h>
 #include <net/cfg80211.h>
--- a/net/wireless/scan.c	2009-07-21 13:21:01.952935088 -0700
+++ b/net/wireless/scan.c	2009-07-21 13:21:02.468936915 -0700
@@ -408,7 +408,11 @@
 			size_t used = dev->wiphy.bss_priv_size + sizeof(*res);
 			size_t ielen = res->pub.len_information_elements;
 
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,28)
+			if (0) {
+#else
 			if (!found->ies_allocated && ksize(found) >= used + ielen) {
+#endif
 				memcpy(found->pub.information_elements,
 				       res->pub.information_elements, ielen);
 				found->pub.len_information_elements = ielen;
--- a/drivers/net/wireless/Makefile	2009-07-06 12:53:07.479194884 -0700
+++ b/drivers/net/wireless/Makefile	2009-07-06 12:54:42.026195576 -0700
@@ -5,43 +5,16 @@
 obj-$(CONFIG_IPW2100) += ipw2x00/
 obj-$(CONFIG_IPW2200) += ipw2x00/
 
-obj-$(CONFIG_STRIP) += strip.o
-obj-$(CONFIG_ARLAN) += arlan.o 
-
-arlan-objs := arlan-main.o arlan-proc.o
-
-# Obsolete cards
-obj-$(CONFIG_WAVELAN)		+= wavelan.o
-obj-$(CONFIG_PCMCIA_NETWAVE)	+= netwave_cs.o
-obj-$(CONFIG_PCMCIA_WAVELAN)	+= wavelan_cs.o
-
-obj-$(CONFIG_HERMES)		+= orinoco/
-
-obj-$(CONFIG_AIRO)		+= airo.o
-obj-$(CONFIG_AIRO_CS)		+= airo_cs.o airo.o
-
-obj-$(CONFIG_ATMEL)             += atmel.o
-obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o 
-obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
-
 obj-$(CONFIG_AT76C50X_USB)      += at76c50x-usb.o
 
-obj-$(CONFIG_PRISM54)		+= prism54/
-
-obj-$(CONFIG_HOSTAP)		+= hostap/
 obj-$(CONFIG_B43)		+= b43/
 obj-$(CONFIG_B43LEGACY)		+= b43legacy/
 obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
 obj-$(CONFIG_RTL8180)		+= rtl818x/
 obj-$(CONFIG_RTL8187)		+= rtl818x/
 
-# 16-bit wireless PCMCIA client drivers
-obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
-obj-$(CONFIG_PCMCIA_WL3501)	+= wl3501_cs.o
-
 obj-$(CONFIG_USB_NET_RNDIS_WLAN)	+= rndis_wlan.o
 
-obj-$(CONFIG_USB_ZD1201)	+= zd1201.o
 obj-$(CONFIG_LIBERTAS)		+= libertas/
 
 obj-$(CONFIG_LIBERTAS_THINFIRM)	+= libertas_tf/
--- a/drivers/net/wireless/p54/p54usb.c	2009-07-07 13:36:49.523678591 -0700
+++ b/drivers/net/wireless/p54/p54usb.c	2009-07-07 13:36:49.831718432 -0700
@@ -1047,7 +1047,9 @@
 	.resume = p54u_resume,
 	.reset_resume = p54u_resume,
 #endif /* CONFIG_PM */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
 	.soft_unbind = 1,
+#endif
 };
 
 static int __init p54u_init(void)
--- a/drivers/net/wireless/zd1211rw/zd_chip.h	2009-07-06 16:09:14.934197004 -0700
+++ b/drivers/net/wireless/zd1211rw/zd_chip.h	2009-07-06 16:10:01.570226234 -0700
@@ -897,9 +897,9 @@
 int zd_chip_unlock_phy_regs(struct zd_chip *chip);
 
 enum led_status {
-	LED_OFF = 0,
-	LED_SCANNING = 1,
-	LED_ASSOCIATED = 2,
+	ZD_LED_OFF = 0,
+	ZD_LED_SCANNING = 1,
+	ZD_LED_ASSOCIATED = 2,
 };
 
 int zd_chip_control_leds(struct zd_chip *chip, enum led_status status);
--- a/drivers/net/wireless/zd1211rw/zd_chip.c	2009-07-06 16:09:24.986198445 -0700
+++ b/drivers/net/wireless/zd1211rw/zd_chip.c	2009-07-06 16:10:19.898624742 -0700
@@ -1278,11 +1278,11 @@
 	other_led = chip->link_led == LED1 ? LED2 : LED1;
 
 	switch (status) {
-	case LED_OFF:
+	case ZD_LED_OFF:
 		ioreqs[0].value = FW_LINK_OFF;
 		ioreqs[1].value = v[1] & ~(LED1|LED2);
 		break;
-	case LED_SCANNING:
+	case ZD_LED_SCANNING:
 		ioreqs[0].value = FW_LINK_OFF;
 		ioreqs[1].value = v[1] & ~other_led;
 		if (get_seconds() % 3 == 0) {
@@ -1291,7 +1291,7 @@
 			ioreqs[1].value |= chip->link_led;
 		}
 		break;
-	case LED_ASSOCIATED:
+	case ZD_LED_ASSOCIATED:
 		ioreqs[0].value = FW_LINK_TX;
 		ioreqs[1].value = v[1] & ~other_led;
 		ioreqs[1].value |= chip->link_led;
--- a/drivers/net/wireless/zd1211rw/zd_mac.c	2009-07-06 16:09:30.382198435 -0700
+++ b/drivers/net/wireless/zd1211rw/zd_mac.c	2009-07-06 16:11:36.778629948 -0700
@@ -1013,7 +1013,7 @@
 	spin_unlock_irq(&mac->lock);
 
 	r = zd_chip_control_leds(chip,
-		                 is_associated ? LED_ASSOCIATED : LED_SCANNING);
+		                 is_associated ? ZD_LED_ASSOCIATED : ZD_LED_SCANNING);
 	if (r)
 		dev_dbg_f(zd_mac_dev(mac), "zd_chip_control_leds error %d\n", r);
 
@@ -1038,5 +1038,5 @@
 	dev_dbg_f(zd_mac_dev(mac), "\n");
 	cancel_rearming_delayed_workqueue(zd_workqueue,
 		&mac->housekeeping.link_led_work);
-	zd_chip_control_leds(&mac->chip, LED_OFF);
+	zd_chip_control_leds(&mac->chip, ZD_LED_OFF);
 }
--- a/net/wireless/wext.c	2009-07-07 15:03:28.803678550 -0700
+++ b/net/wireless/wext.c	2009-07-07 15:03:11.011682437 -0700
@@ -1103,8 +1103,13 @@
 			return private(dev, iwr, cmd, info, handler);
 	}
 	/* Old driver API : call driver ioctl handler */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	if (dev->netdev_ops->ndo_do_ioctl)
 		return dev->netdev_ops->ndo_do_ioctl(dev, ifr, cmd);
+#else
+	if (dev->do_ioctl)
+		return dev->do_ioctl(dev, ifr, cmd);
+#endif
 	return -EOPNOTSUPP;
 }
 
--- a/drivers/net/wireless/libertas/defs.h	2009-07-08 14:04:29.692256519 -0700
+++ b/drivers/net/wireless/libertas/defs.h	2009-07-08 14:03:26.712279246 -0700
@@ -16,6 +16,14 @@
 #define DRV_NAME "libertas"
 #endif
 
+/*
+ * Really nasty hack to avoid stuffing compat.diff with tons of ifdefs,
+ * we could add this to a compat header file but too lazy to check ml_priv
+ * is not used anywhere else
+ */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#define ml_priv priv
+#endif
 
 #define LBS_DEB_ENTER	0x00000001
 #define LBS_DEB_LEAVE	0x00000002
