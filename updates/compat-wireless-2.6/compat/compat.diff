--- a/include/net/cfg80211.h	2009-02-13 14:28:03.000000000 -0800
+++ b/include/net/cfg80211.h	2009-02-13 14:28:04.000000000 -0800
@@ -11,6 +11,7 @@
 #include <net/genetlink.h>
 /* remove once we remove the wext stuff */
 #include <net/iw_handler.h>
+#include <net/compat.h>
 
 /*
  * 802.11 configuration in-kernel interface
--- a/net/wireless/Makefile	2008-10-27 19:54:52.000000000 +0100
+++ b/net/wireless/Makefile	2008-10-27 19:54:53.000000000 +0100
@@ -1,10 +1,9 @@
-obj-$(CONFIG_WIRELESS_EXT) += wext.o
 obj-$(CONFIG_CFG80211) += cfg80211.o
 obj-$(CONFIG_LIB80211) += lib80211.o
 obj-$(CONFIG_LIB80211_CRYPT_WEP) += lib80211_crypt_wep.o
 obj-$(CONFIG_LIB80211_CRYPT_CCMP) += lib80211_crypt_ccmp.o
 obj-$(CONFIG_LIB80211_CRYPT_TKIP) += lib80211_crypt_tkip.o
 
-cfg80211-y += core.o sysfs.o radiotap.o util.o reg.o scan.o
+cfg80211-y += core.o sysfs.o radiotap.o util.o reg.o scan.o compat.o
 cfg80211-$(CONFIG_WIRELESS_EXT) += wext-compat.o
 cfg80211-$(CONFIG_NL80211) += nl80211.o
--- a/drivers/net/wireless/zd1211rw/zd_chip.h	2008-03-07 20:02:06.000000000 -0500
+++ b/drivers/net/wireless/zd1211rw/zd_chip.h	2008-03-07 20:02:07.000000000 -0500
@@ -897,7 +897,7 @@
 int zd_chip_unlock_phy_regs(struct zd_chip *chip);
 
 enum led_status {
-	LED_OFF = 0,
+	LED_OFF_ZD = 0,
 	LED_SCANNING = 1,
 	LED_ASSOCIATED = 2,
 };
--- a/drivers/net/usb/Makefile	2008-10-27 09:41:27.000000000 -0700
+++ b/drivers/net/usb/Makefile	2008-10-27 09:43:01.000000000 -0700
@@ -2,21 +2,7 @@
 # Makefile for USB Network drivers
 #
 
-obj-$(CONFIG_USB_CATC)		+= catc.o
-obj-$(CONFIG_USB_KAWETH)	+= kaweth.o
-obj-$(CONFIG_USB_PEGASUS)	+= pegasus.o
-obj-$(CONFIG_USB_RTL8150)	+= rtl8150.o
-obj-$(CONFIG_USB_HSO)		+= hso.o
-obj-$(CONFIG_USB_NET_AX8817X)	+= asix.o
 obj-$(CONFIG_USB_NET_CDCETHER)	+= cdc_ether.o
-obj-$(CONFIG_USB_NET_DM9601)	+= dm9601.o
-obj-$(CONFIG_USB_NET_SMSC95XX)	+= smsc95xx.o
-obj-$(CONFIG_USB_NET_GL620A)	+= gl620a.o
-obj-$(CONFIG_USB_NET_NET1080)	+= net1080.o
-obj-$(CONFIG_USB_NET_PLUSB)	+= plusb.o
 obj-$(CONFIG_USB_NET_RNDIS_HOST)	+= rndis_host.o
-obj-$(CONFIG_USB_NET_CDC_SUBSET)	+= cdc_subset.o
-obj-$(CONFIG_USB_NET_ZAURUS)	+= zaurus.o
-obj-$(CONFIG_USB_NET_MCS7830)	+= mcs7830.o
 obj-$(CONFIG_USB_USBNET)	+= usbnet.o
 
diff --git a/drivers/net/wireless/b43/pcmcia.c b/drivers/net/wireless/b43/pcmcia.c
index 3cfc303..33c76b0 100644
--- a/drivers/net/wireless/b43/pcmcia.c
+++ b/drivers/net/wireless/b43/pcmcia.c
@@ -87,7 +87,11 @@ static int __devinit b43_pcmcia_probe(struct pcmcia_device *dev)
 	res = pcmcia_get_tuple_data(dev, &tuple);
 	if (res != 0)
 		goto err_kfree_ssb;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28))
+	res = pcmcia_parse_tuple(NULL,&tuple, &parse);
+#else
 	res = pcmcia_parse_tuple(&tuple, &parse);
+#endif
 	if (res != 0)
 		goto err_kfree_ssb;
 
diff --git a/drivers/net/wireless/libertas/if_cs.c b/drivers/net/wireless/libertas/if_cs.c
index 842a08d..079c1fd 100644
--- a/drivers/net/wireless/libertas/if_cs.c
+++ b/drivers/net/wireless/libertas/if_cs.c
@@ -791,7 +791,11 @@ static int if_cs_probe(struct pcmcia_device *p_dev)
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
 	if ((ret = pcmcia_get_first_tuple(p_dev, &tuple)) != 0 ||
 	    (ret = pcmcia_get_tuple_data(p_dev, &tuple)) != 0 ||
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28))
+	    (ret = pcmcia_parse_tuple(NULL,&tuple, &parse)) != 0)
+#else
 	    (ret = pcmcia_parse_tuple(&tuple, &parse)) != 0)
+#endif
 	{
 		lbs_pr_err("error in pcmcia_get_first_tuple etc\n");
 		goto out1;
diff --git a/net/mac80211/wme.c b/net/mac80211/wme.c
index a0c860f..9c6f214 100644
--- a/net/mac80211/wme.c
+++ b/net/mac80211/wme.c
@@ -122,6 +122,7 @@ u16 ieee80211_select_queue(struct net_device *dev, struct sk_buff *skb)
 	if (unlikely(queue >= local->hw.queues))
 		queue = local->hw.queues - 1;
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
 	/*
 	 * Now we know the 1d priority, fill in the QoS header if
 	 * there is one (and we haven't done this before).
@@ -137,6 +138,7 @@ u16 ieee80211_select_queue(struct net_device *dev, struct sk_buff *skb)
 		*p++ = ack_policy | tid;
 		*p = 0;
 	}
+#endif
 
 	return queue;
 }
--- a/drivers/net/wireless/Makefile	2008-11-10 12:55:55.000000000 -0800
+++ b/drivers/net/wireless/Makefile	2008-11-10 12:57:30.000000000 -0800
@@ -5,43 +5,17 @@
 obj-$(CONFIG_IPW2100) += ipw2x00/
 obj-$(CONFIG_IPW2200) += ipw2x00/
 
-obj-$(CONFIG_STRIP) += strip.o
-obj-$(CONFIG_ARLAN) += arlan.o 
-
-arlan-objs := arlan-main.o arlan-proc.o
-
-# Obsolete cards
-obj-$(CONFIG_WAVELAN)		+= wavelan.o
-obj-$(CONFIG_PCMCIA_NETWAVE)	+= netwave_cs.o
-obj-$(CONFIG_PCMCIA_WAVELAN)	+= wavelan_cs.o
-
-obj-$(CONFIG_HERMES)		+= orinoco/
-
-obj-$(CONFIG_AIRO)		+= airo.o
-obj-$(CONFIG_AIRO_CS)		+= airo_cs.o airo.o
-
-obj-$(CONFIG_ATMEL)             += atmel.o
-obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o 
-obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
-
 obj-$(CONFIG_AT76C50X_USB)      += at76c50x-usb.o
 
-obj-$(CONFIG_PRISM54)		+= prism54/
-
-obj-$(CONFIG_HOSTAP)		+= hostap/
 obj-$(CONFIG_B43)		+= b43/
 obj-$(CONFIG_B43LEGACY)		+= b43legacy/
 obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
 obj-$(CONFIG_RTL8180)		+= rtl818x/
 obj-$(CONFIG_RTL8187)		+= rtl818x/
 
-# 16-bit wireless PCMCIA client drivers
-obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
-obj-$(CONFIG_PCMCIA_WL3501)	+= wl3501_cs.o
 
 obj-$(CONFIG_USB_NET_RNDIS_WLAN)	+= rndis_wlan.o
 
-obj-$(CONFIG_USB_ZD1201)	+= zd1201.o
 obj-$(CONFIG_LIBERTAS)		+= libertas/
 
 obj-$(CONFIG_LIBERTAS_THINFIRM)	+= libertas_tf/
--- a/drivers/misc/eeprom/Makefile	2009-01-22 07:51:17.000000000 -0800
+++ b/drivers/misc/eeprom/Makefile	2009-01-22 07:51:26.000000000 -0800
@@ -1,4 +1 @@
-obj-$(CONFIG_EEPROM_AT24)	+= at24.o
-obj-$(CONFIG_EEPROM_AT25)	+= at25.o
-obj-$(CONFIG_EEPROM_LEGACY)	+= eeprom.o
 obj-$(CONFIG_EEPROM_93CX6)	+= eeprom_93cx6.o
--- a/drivers/net/wireless/zd1211rw/zd_chip.c	2009-01-15 16:35:33.000000000 -0800
+++ b/drivers/net/wireless/zd1211rw/zd_chip.c	2009-01-15 16:35:33.000000000 -0800
@@ -1278,7 +1278,7 @@
 	other_led = chip->link_led == LED1 ? LED2 : LED1;
 
 	switch (status) {
-	case LED_OFF:
+	case LED_OFF_ZD:
 		ioreqs[0].value = FW_LINK_OFF;
 		ioreqs[1].value = v[1] & ~(LED1|LED2);
 		break;
--- a/drivers/net/wireless/zd1211rw/zd_mac.c	2009-03-02 12:40:07.000000000 -0800
+++ b/drivers/net/wireless/zd1211rw/zd_mac.c	2009-03-02 12:40:09.000000000 -0800
@@ -1047,5 +1047,5 @@
 	dev_dbg_f(zd_mac_dev(mac), "\n");
 	cancel_rearming_delayed_workqueue(zd_workqueue,
 		&mac->housekeeping.link_led_work);
-	zd_chip_control_leds(&mac->chip, LED_OFF);
+	zd_chip_control_leds(&mac->chip, LED_OFF_ZD);
 }
--- a/net/mac80211/rx.c	2009-02-10 23:51:58.000000000 -0800
+++ b/net/mac80211/rx.c	2009-02-10 23:52:04.000000000 -0800
@@ -804,12 +804,17 @@
 
 	/* Send all buffered frames to the station */
 	while ((skb = skb_dequeue(&sta->tx_filtered)) != NULL) {
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,28))
+		dev_kfree_skb(skb);
+#else
 		sent++;
 		skb->requeue = 1;
 		dev_queue_xmit(skb);
+#endif
 	}
 	while ((skb = skb_dequeue(&sta->ps_tx_buf)) != NULL) {
 		local->total_ps_buffered--;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
 		sent++;
 #ifdef CONFIG_MAC80211_VERBOSE_PS_DEBUG
 		printk(KERN_DEBUG "%s: STA %pM aid %d send PS frame "
@@ -818,6 +823,9 @@
 #endif /* CONFIG_MAC80211_VERBOSE_PS_DEBUG */
 		skb->requeue = 1;
 		dev_queue_xmit(skb);
+#else
+		dev_kfree_skb(skb);
+#endif
 	}
 
 	return sent;
--- a/drivers/net/b44.c	2009-01-22 07:52:14.000000000 -0800
+++ b/drivers/net/b44.c	2009-01-22 07:52:14.000000000 -0800
@@ -846,6 +846,9 @@
 static int b44_poll(struct napi_struct *napi, int budget)
 {
 	struct b44 *bp = container_of(napi, struct b44, napi);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+	struct net_device *netdev = bp->dev;
+#endif
 	int work_done;
 
 	spin_lock_irq(&bp->lock);
@@ -874,7 +877,11 @@
 	}
 
 	if (work_done < budget) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+		netif_rx_complete(netdev, napi);
+#else
 		netif_rx_complete(napi);
+#endif
 		b44_enable_ints(bp);
 	}
 
@@ -906,13 +913,21 @@
 			goto irq_ack;
 		}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+		if (netif_rx_schedule_prep(dev, &bp->napi)) {
+#else
 		if (netif_rx_schedule_prep(&bp->napi)) {
+#endif
 			/* NOTE: These writes are posted by the readback of
 			 *       the ISTAT register below.
 			 */
 			bp->istat = istat;
 			__b44_disable_ints(bp);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+			__netif_rx_schedule(dev, &bp->napi);
+#else
 			__netif_rx_schedule(&bp->napi);
+#endif
 		} else {
 			printk(KERN_ERR PFX "%s: Error, poll already scheduled\n",
 			       dev->name);
@@ -2108,6 +2123,7 @@
 	return err;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops b44_netdev_ops = {
 	.ndo_open		= b44_open,
 	.ndo_stop		= b44_close,
@@ -2123,6 +2139,7 @@
 	.ndo_poll_controller	= b44_poll_controller,
 #endif
 };
+#endif
 
 static int __devinit b44_init_one(struct ssb_device *sdev,
 				  const struct ssb_device_id *ent)
@@ -2162,9 +2179,26 @@
 	bp->rx_pending = B44_DEF_RX_RING_PENDING;
 	bp->tx_pending = B44_DEF_TX_RING_PENDING;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+	dev->open = b44_open;
+	dev->stop = b44_close;
+	dev->hard_start_xmit = b44_start_xmit;
+	dev->get_stats = b44_get_stats;
+	dev->set_multicast_list = b44_set_rx_mode;
+	dev->set_mac_address = b44_set_mac_addr;
+	dev->do_ioctl = b44_ioctl;
+	dev->tx_timeout = b44_tx_timeout;
+	netif_napi_add(dev, &bp->napi, b44_poll, 64);
+	dev->watchdog_timeo = B44_TX_TIMEOUT;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	dev->poll_controller = b44_poll_controller;
+#endif
+	dev->change_mtu = b44_change_mtu;
+#else
 	dev->netdev_ops = &b44_netdev_ops;
 	netif_napi_add(dev, &bp->napi, b44_poll, 64);
 	dev->watchdog_timeo = B44_TX_TIMEOUT;
+#endif
 	dev->irq = sdev->irq;
 	SET_ETHTOOL_OPS(dev, &b44_ethtool_ops);
 
--- a/net/mac80211/iface.c	2009-02-13 14:25:06.000000000 -0800
+++ b/net/mac80211/iface.c	2009-02-13 14:25:08.000000000 -0800
@@ -667,6 +667,7 @@
 	WARN_ON(flushed);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops ieee80211_dataif_ops = {
 	.ndo_open		= ieee80211_open,
 	.ndo_stop		= ieee80211_stop,
@@ -686,11 +687,22 @@
 	.ndo_change_mtu 	= ieee80211_change_mtu,
 	.ndo_set_mac_address 	= eth_mac_addr,
 };
+#endif
 
 static void ieee80211_if_setup(struct net_device *dev)
 {
 	ether_setup(dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	dev->netdev_ops = &ieee80211_dataif_ops;
+#else
+	dev->hard_start_xmit = ieee80211_subif_start_xmit;
+	dev->set_multicast_list = ieee80211_set_multicast_list;
+	dev->change_mtu = ieee80211_change_mtu;
+	dev->open = ieee80211_open;
+	dev->stop = ieee80211_stop;
+	/* we will validate the address ourselves in ->open */
+	dev->validate_addr = NULL;
+#endif
 	dev->wireless_handlers = &ieee80211_iw_handler_def;
 	dev->destructor = free_netdev;
 }
@@ -706,7 +718,11 @@
 
 	/* and set some type-dependent values */
 	sdata->vif.type = type;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	sdata->dev->netdev_ops = &ieee80211_dataif_ops;
+#else
+	sdata->dev->hard_start_xmit = ieee80211_subif_start_xmit;
+#endif
 	sdata->wdev.iftype = type;
 
 	/* only monitor differs */
@@ -729,7 +745,11 @@
 		break;
 	case NL80211_IFTYPE_MONITOR:
 		sdata->dev->type = ARPHRD_IEEE80211_RADIOTAP;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 		sdata->dev->netdev_ops = &ieee80211_monitorif_ops;
+#else
+		sdata->dev->hard_start_xmit = ieee80211_monitor_start_xmit;
+#endif
 		sdata->u.mntr_flags = MONITOR_FLAG_CONTROL |
 				      MONITOR_FLAG_OTHER_BSS;
 		break;
@@ -836,6 +856,10 @@
 	if (ret)
 		goto fail;
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,28))
+	ndev->uninit = ieee80211_teardown_sdata;
+#endif
+
 	if (ieee80211_vif_is_mesh(&sdata->vif) &&
 	    params && params->mesh_id_len)
 		ieee80211_sdata_set_mesh_id(sdata,
--- a/net/mac80211/main.c	2009-02-13 14:25:06.000000000 -0800
+++ b/net/mac80211/main.c	2009-02-13 14:25:08.000000000 -0800
@@ -488,6 +488,7 @@
 		return;
 	}
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
 	if (!test_sta_flags(sta, WLAN_STA_PS) && !skb->requeue) {
 		/* Software retry the packet once */
 		skb->requeue = 1;
@@ -495,6 +496,7 @@
 		dev_queue_xmit(skb);
 		return;
 	}
+#endif
 
 #ifdef CONFIG_MAC80211_VERBOSE_DEBUG
 	if (net_ratelimit())
@@ -803,6 +805,7 @@
 }
 EXPORT_SYMBOL(ieee80211_alloc_hw);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops ieee80211_master_ops = {
 	.ndo_start_xmit = ieee80211_master_start_xmit,
 	.ndo_open = ieee80211_master_open,
@@ -810,12 +813,22 @@
 	.ndo_set_multicast_list = ieee80211_master_set_multicast_list,
 	.ndo_select_queue = ieee80211_select_queue,
 };
+#endif
 
 static void ieee80211_master_setup(struct net_device *mdev)
 {
 	mdev->type = ARPHRD_IEEE80211;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	mdev->netdev_ops = &ieee80211_master_ops;
 	mdev->header_ops = &ieee80211_header_ops;
+#else
+	mdev->hard_start_xmit = ieee80211_master_start_xmit;
+	mdev->open = ieee80211_master_open;
+	mdev->stop = ieee80211_master_stop;
+	mdev->header_ops = &ieee80211_header_ops;
+	mdev->set_multicast_list = ieee80211_master_set_multicast_list;
+	mdev->select_queue = ieee80211_select_queue;
+#endif
 	mdev->tx_queue_len = 1000;
 	mdev->addr_len = ETH_ALEN;
 }
--- a/net/mac80211/rate.c	2009-02-06 17:12:28.000000000 -0800
+++ b/net/mac80211/rate.c	2009-02-06 17:12:51.000000000 -0800
@@ -22,7 +22,7 @@
 static LIST_HEAD(rate_ctrl_algs);
 static DEFINE_MUTEX(rate_ctrl_mutex);
 
-static char *ieee80211_default_rc_algo = CONFIG_MAC80211_RC_DEFAULT;
+static char *ieee80211_default_rc_algo = CONFIG_COMPAT_MAC80211_RC_DEFAULT;
 module_param(ieee80211_default_rc_algo, charp, 0644);
 MODULE_PARM_DESC(ieee80211_default_rc_algo,
 		 "Default rate control algorithm for mac80211 to use");
@@ -117,8 +117,8 @@
 		ops = ieee80211_try_rate_control_ops_get(ieee80211_default_rc_algo);
 
 	/* try built-in one if specific alg requested but not found */
-	if (!ops && strlen(CONFIG_MAC80211_RC_DEFAULT))
-		ops = ieee80211_try_rate_control_ops_get(CONFIG_MAC80211_RC_DEFAULT);
+	if (!ops && strlen(CONFIG_COMPAT_MAC80211_RC_DEFAULT))
+		ops = ieee80211_try_rate_control_ops_get(CONFIG_COMPAT_MAC80211_RC_DEFAULT);
 
 	return ops;
 }
--- wireless-testing/net/wireless/nl80211.c	2009-02-27 18:27:32.000000000 -0500
+++ compat-wireless-2.6/net/wireless/nl80211.c	2009-02-27 19:51:08.000000000 -0500
@@ -614,15 +614,17 @@
 		if (!err)
 			flags = &_flags;
 	}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
+#endif
 	err = drv->ops->change_virtual_intf(&drv->wiphy, ifindex,
 					    type, flags, &params);
 
 	dev = __dev_get_by_index(&init_net, ifindex);
 	WARN_ON(!dev || (!err && dev->ieee80211_ptr->iftype != type));
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_unlock();
-
+#endif
  unlock:
 	cfg80211_put_dev(drv);
 	return err;
@@ -662,16 +664,18 @@
 		params.mesh_id = nla_data(info->attrs[NL80211_ATTR_MESH_ID]);
 		params.mesh_id_len = nla_len(info->attrs[NL80211_ATTR_MESH_ID]);
 	}
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
+#endif
 	err = parse_monitor_flags(type == NL80211_IFTYPE_MONITOR ?
 				  info->attrs[NL80211_ATTR_MNTR_FLAGS] : NULL,
 				  &flags);
 	err = drv->ops->add_virtual_intf(&drv->wiphy,
 		nla_data(info->attrs[NL80211_ATTR_IFNAME]),
 		type, err ? NULL : &flags, &params);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_unlock();
-
+#endif
 
  unlock:
 	cfg80211_put_dev(drv);
@@ -694,11 +698,13 @@
 		err = -EOPNOTSUPP;
 		goto out;
 	}
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->del_virtual_intf(&drv->wiphy, ifindex);
 	rtnl_unlock();
-
+#else
+	err = drv->ops->del_virtual_intf(&drv->wiphy, ifindex);
+#endif
  out:
 	cfg80211_put_dev(drv);
 	return err;
@@ -782,11 +788,15 @@
 	if (mac_addr)
 		NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->get_key(&drv->wiphy, dev, key_idx, mac_addr,
 				&cookie, get_key_callback);
 	rtnl_unlock();
-
+#else
+	err = drv->ops->get_key(&drv->wiphy, dev, key_idx, mac_addr,
+                                &cookie, get_key_callback);
+#endif
 	if (err)
 		goto out;
 
@@ -844,11 +854,13 @@
 		err = -EOPNOTSUPP;
 		goto out;
 	}
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = func(&drv->wiphy, dev, key_idx);
 	rtnl_unlock();
-
+#else
+	err = func(&drv->wiphy, dev, key_idx);
+#endif
  out:
 	cfg80211_put_dev(drv);
 	dev_put(dev);
@@ -929,10 +941,13 @@
 		err = -EOPNOTSUPP;
 		goto out;
 	}
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->add_key(&drv->wiphy, dev, key_idx, mac_addr, &params);
 	rtnl_unlock();
+#else
+	err = drv->ops->add_key(&drv->wiphy, dev, key_idx, mac_addr, &params);
+#endif
 
  out:
 	cfg80211_put_dev(drv);
@@ -965,10 +980,13 @@
 		err = -EOPNOTSUPP;
 		goto out;
 	}
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->del_key(&drv->wiphy, dev, key_idx, mac_addr);
 	rtnl_unlock();
+#else
+	err = drv->ops->del_key(&drv->wiphy, dev, key_idx, mac_addr);
+#endif
 
  out:
 	cfg80211_put_dev(drv);
@@ -1048,11 +1066,13 @@
 		err = -EINVAL;
 		goto out;
 	}
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = call(&drv->wiphy, dev, &params);
 	rtnl_unlock();
-
+#else
+	err = call(&drv->wiphy, dev, &params);
+#endif
  out:
 	cfg80211_put_dev(drv);
 	dev_put(dev);
@@ -1073,11 +1093,13 @@
 		err = -EOPNOTSUPP;
 		goto out;
 	}
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->del_beacon(&drv->wiphy, dev);
 	rtnl_unlock();
-
+#else
+	err = drv->ops->del_beacon(&drv->wiphy, dev);
+#endif
  out:
 	cfg80211_put_dev(drv);
 	dev_put(dev);
@@ -1260,16 +1282,20 @@
 		err = -ENOSYS;
 		goto out_err;
 	}
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
-
+#endif
 	while (1) {
 		err = dev->ops->dump_station(&dev->wiphy, netdev, sta_idx,
 					     mac_addr, &sinfo);
 		if (err == -ENOENT)
 			break;
 		if (err)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 			goto out_err_rtnl;
+#else
+			goto out_err;
+#endif
 
 		if (nl80211_send_station(skb,
 				NETLINK_CB(cb->skb).pid,
@@ -1285,8 +1311,10 @@
  out:
 	cb->args[1] = sta_idx;
 	err = skb->len;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
  out_err_rtnl:
 	rtnl_unlock();
+#endif
  out_err:
 	cfg80211_put_dev(dev);
  out_put_netdev:
@@ -1320,9 +1348,13 @@
 		goto out;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->get_station(&drv->wiphy, dev, mac_addr, &sinfo);
 	rtnl_unlock();
+#else
+	err = drv->ops->get_station(&drv->wiphy, dev, mac_addr, &sinfo);
+#endif
 
 	if (err)
 		goto out;
@@ -1424,9 +1456,13 @@
 		goto out;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->change_station(&drv->wiphy, dev, mac_addr, &params);
 	rtnl_unlock();
+#else
+	err = drv->ops->change_station(&drv->wiphy, dev, mac_addr, &params);
+#endif
 
  out:
 	if (params.vlan)
@@ -1487,9 +1523,13 @@
 		goto out;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->add_station(&drv->wiphy, dev, mac_addr, &params);
 	rtnl_unlock();
+#else
+	err = drv->ops->add_station(&drv->wiphy, dev, mac_addr, &params);
+#endif
 
  out:
 	if (params.vlan)
@@ -1518,9 +1558,13 @@
 		goto out;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->del_station(&drv->wiphy, dev, mac_addr);
 	rtnl_unlock();
+#else
+	err = drv->ops->del_station(&drv->wiphy, dev, mac_addr);	
+#endif
 
  out:
 	cfg80211_put_dev(drv);
@@ -1620,7 +1664,9 @@
 		goto out_err;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
+#endif
 
 	while (1) {
 		err = dev->ops->dump_mpath(&dev->wiphy, netdev, path_idx,
@@ -1628,7 +1674,11 @@
 		if (err == -ENOENT)
 			break;
 		if (err)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 			goto out_err_rtnl;
+#else
+			goto out_err;
+#endif
 
 		if (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).pid,
 				       cb->nlh->nlmsg_seq, NLM_F_MULTI,
@@ -1643,8 +1693,10 @@
  out:
 	cb->args[1] = path_idx;
 	err = skb->len;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
  out_err_rtnl:
 	rtnl_unlock();
+#endif
  out_err:
 	cfg80211_put_dev(dev);
  out_put_netdev:
@@ -1679,9 +1731,13 @@
 		goto out;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->get_mpath(&drv->wiphy, dev, dst, next_hop, &pinfo);
 	rtnl_unlock();
+#else
+	err = drv->ops->get_mpath(&drv->wiphy, dev, dst, next_hop, &pinfo);
+#endif
 
 	if (err)
 		goto out;
@@ -1732,9 +1788,13 @@
 		goto out;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->change_mpath(&drv->wiphy, dev, dst, next_hop);
 	rtnl_unlock();
+#else
+	err = drv->ops->change_mpath(&drv->wiphy, dev, dst, next_hop);
+#endif
 
  out:
 	cfg80211_put_dev(drv);
@@ -1767,9 +1827,13 @@
 		goto out;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->add_mpath(&drv->wiphy, dev, dst, next_hop);
 	rtnl_unlock();
+#else
+	err = drv->ops->add_mpath(&drv->wiphy, dev, dst, next_hop);
+#endif
 
  out:
 	cfg80211_put_dev(drv);
@@ -1796,9 +1860,13 @@
 		goto out;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->del_mpath(&drv->wiphy, dev, dst);
 	rtnl_unlock();
+#else
+	err = drv->ops->del_mpath(&drv->wiphy, dev, dst);
+#endif
 
  out:
 	cfg80211_put_dev(drv);
@@ -1844,9 +1912,13 @@
 		goto out;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->change_bss(&drv->wiphy, dev, &params);
 	rtnl_unlock();
+#else
+	err = drv->ops->change_bss(&drv->wiphy, dev, &params);
+#endif
 
  out:
 	cfg80211_put_dev(drv);
@@ -1951,9 +2023,13 @@
 		return err;
 
 	/* Get the mesh params */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->get_mesh_params(&drv->wiphy, dev, &cur_params);
 	rtnl_unlock();
+#else
+	err = drv->ops->get_mesh_params(&drv->wiphy, dev, &cur_params);
+#endif
 	if (err)
 		goto out;
 
@@ -2099,9 +2175,13 @@
 			nla_get_u16);
 
 	/* Apply changes */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
 	err = drv->ops->set_mesh_params(&drv->wiphy, dev, &cfg, mask);
 	rtnl_unlock();
+#else
+	err = drv->ops->set_mesh_params(&drv->wiphy, dev, &cfg, mask);
+#endif
 
 	/* cleanup */
 	cfg80211_put_dev(drv);
@@ -2277,9 +2357,13 @@
 		return err;
 
 	if (drv->ops->set_mgmt_extra_ie) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 		rtnl_lock();
 		err = drv->ops->set_mgmt_extra_ie(&drv->wiphy, dev, &params);
 		rtnl_unlock();
+#else
+		err = drv->ops->set_mgmt_extra_ie(&drv->wiphy, dev, &params);
+#endif
 	} else
 		err = -EOPNOTSUPP;
 
@@ -2311,9 +2395,9 @@
 		err = -EOPNOTSUPP;
 		goto out;
 	}
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_lock();
-
+#endif
 	if (drv->scan_req) {
 		err = -EBUSY;
 		goto out_unlock;
@@ -2424,7 +2508,9 @@
 		kfree(request);
 	}
  out_unlock:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
 	rtnl_unlock();
+#endif
  out:
 	cfg80211_put_dev(drv);
 	dev_put(dev);
