--- a/drivers/misc/eeprom/Makefile
+++ b/drivers/misc/eeprom/Makefile
@@ -1,4 +1 @@
-obj-$(CONFIG_EEPROM_AT24)	+= at24.o
-obj-$(CONFIG_EEPROM_AT25)	+= at25.o
-obj-$(CONFIG_EEPROM_LEGACY)	+= eeprom.o
 obj-$(CONFIG_EEPROM_93CX6)	+= eeprom_93cx6.o
--- a/drivers/net/b44.c
+++ b/drivers/net/b44.c
@@ -2112,6 +2112,7 @@ static int __devinit b44_get_invariants(struct b44 *bp)
 	return err;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops b44_netdev_ops = {
 	.ndo_open		= b44_open,
 	.ndo_stop		= b44_close,
@@ -2127,6 +2128,7 @@ static const struct net_device_ops b44_netdev_ops = {
 	.ndo_poll_controller	= b44_poll_controller,
 #endif
 };
+#endif
 
 static int __devinit b44_init_one(struct ssb_device *sdev,
 				  const struct ssb_device_id *ent)
@@ -2166,9 +2168,26 @@ static int __devinit b44_init_one(struct ssb_device *sdev,
 	bp->rx_pending = B44_DEF_RX_RING_PENDING;
 	bp->tx_pending = B44_DEF_TX_RING_PENDING;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+	dev->open = b44_open;
+	dev->stop = b44_close;
+	dev->hard_start_xmit = b44_start_xmit;
+	dev->get_stats = b44_get_stats;
+	dev->set_multicast_list = b44_set_rx_mode;
+	dev->set_mac_address = b44_set_mac_addr;
+	dev->do_ioctl = b44_ioctl;
+	dev->tx_timeout = b44_tx_timeout;
+	netif_napi_add(dev, &bp->napi, b44_poll, 64);
+	dev->watchdog_timeo = B44_TX_TIMEOUT;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	dev->poll_controller = b44_poll_controller;
+#endif
+	dev->change_mtu = b44_change_mtu;
+#else
 	dev->netdev_ops = &b44_netdev_ops;
 	netif_napi_add(dev, &bp->napi, b44_poll, 64);
 	dev->watchdog_timeo = B44_TX_TIMEOUT;
+#endif
 	dev->irq = sdev->irq;
 	SET_ETHTOOL_OPS(dev, &b44_ethtool_ops);
 
--- a/drivers/net/usb/Makefile
+++ b/drivers/net/usb/Makefile
@@ -2,22 +2,7 @@
 # Makefile for USB Network drivers
 #
 
-obj-$(CONFIG_USB_CATC)		+= catc.o
-obj-$(CONFIG_USB_KAWETH)	+= kaweth.o
-obj-$(CONFIG_USB_PEGASUS)	+= pegasus.o
-obj-$(CONFIG_USB_RTL8150)	+= rtl8150.o
-obj-$(CONFIG_USB_HSO)		+= hso.o
-obj-$(CONFIG_USB_NET_AX8817X)	+= asix.o
 obj-$(CONFIG_USB_NET_CDCETHER)	+= cdc_ether.o
-obj-$(CONFIG_USB_NET_CDC_EEM)	+= cdc_eem.o
-obj-$(CONFIG_USB_NET_DM9601)	+= dm9601.o
-obj-$(CONFIG_USB_NET_SMSC95XX)	+= smsc95xx.o
-obj-$(CONFIG_USB_NET_GL620A)	+= gl620a.o
-obj-$(CONFIG_USB_NET_NET1080)	+= net1080.o
-obj-$(CONFIG_USB_NET_PLUSB)	+= plusb.o
 obj-$(CONFIG_USB_NET_RNDIS_HOST)	+= rndis_host.o
-obj-$(CONFIG_USB_NET_CDC_SUBSET)	+= cdc_subset.o
-obj-$(CONFIG_USB_NET_ZAURUS)	+= zaurus.o
-obj-$(CONFIG_USB_NET_MCS7830)	+= mcs7830.o
 obj-$(CONFIG_USB_USBNET)	+= usbnet.o
 
--- a/drivers/net/usb/rndis_host.c
+++ b/drivers/net/usb/rndis_host.c
@@ -266,6 +266,7 @@ response_error:
 	return -EDOM;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 /* same as usbnet_netdev_ops but MTU change not allowed */
 static const struct net_device_ops rndis_netdev_ops = {
 	.ndo_open		= usbnet_open,
@@ -275,6 +276,7 @@ static const struct net_device_ops rndis_netdev_ops = {
 	.ndo_set_mac_address 	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 int
 generic_rndis_bind(struct usbnet *dev, struct usb_interface *intf, int flags)
@@ -337,7 +339,11 @@ generic_rndis_bind(struct usbnet *dev, struct usb_interface *intf, int flags)
 	dev->rx_urb_size &= ~(dev->maxpacket - 1);
 	u.init->max_transfer_size = cpu_to_le32(dev->rx_urb_size);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	net->netdev_ops = &rndis_netdev_ops;
+#else
+	net->change_mtu = NULL;
+#endif
 
 	retval = rndis_command(dev, u.header, CONTROL_BUFFER_SIZE);
 	if (unlikely(retval < 0)) {
--- a/drivers/net/usb/usbnet.c
+++ b/drivers/net/usb/usbnet.c
@@ -1106,6 +1106,7 @@ void usbnet_disconnect (struct usb_interface *intf)
 }
 EXPORT_SYMBOL_GPL(usbnet_disconnect);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops usbnet_netdev_ops = {
 	.ndo_open		= usbnet_open,
 	.ndo_stop		= usbnet_stop,
@@ -1115,6 +1116,7 @@ static const struct net_device_ops usbnet_netdev_ops = {
 	.ndo_set_mac_address 	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 /*-------------------------------------------------------------------------*/
 
@@ -1184,8 +1186,10 @@ usbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod)
 		net->features |= NETIF_F_HIGHDMA;
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	net->netdev_ops = &usbnet_netdev_ops;
-#ifdef CONFIG_COMPAT_NET_DEV_OPS
+#else
+	net->change_mtu = usbnet_change_mtu;
 	net->hard_start_xmit = usbnet_start_xmit;
 	net->open = usbnet_open;
 	net->stop = usbnet_stop;
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -5,43 +5,17 @@
 obj-$(CONFIG_IPW2100) += ipw2x00/
 obj-$(CONFIG_IPW2200) += ipw2x00/
 
-obj-$(CONFIG_STRIP) += strip.o
-obj-$(CONFIG_ARLAN) += arlan.o 
-
-arlan-objs := arlan-main.o arlan-proc.o
-
-# Obsolete cards
-obj-$(CONFIG_WAVELAN)		+= wavelan.o
-obj-$(CONFIG_PCMCIA_NETWAVE)	+= netwave_cs.o
-obj-$(CONFIG_PCMCIA_WAVELAN)	+= wavelan_cs.o
-
-obj-$(CONFIG_HERMES)		+= orinoco/
-
-obj-$(CONFIG_AIRO)		+= airo.o
-obj-$(CONFIG_AIRO_CS)		+= airo_cs.o airo.o
-
-obj-$(CONFIG_ATMEL)             += atmel.o
-obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o 
-obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
-
 obj-$(CONFIG_AT76C50X_USB)      += at76c50x-usb.o
 
-obj-$(CONFIG_PRISM54)		+= prism54/
-
-obj-$(CONFIG_HOSTAP)		+= hostap/
 obj-$(CONFIG_B43)		+= b43/
 obj-$(CONFIG_B43LEGACY)		+= b43legacy/
 obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
 obj-$(CONFIG_RTL8180)		+= rtl818x/
 obj-$(CONFIG_RTL8187)		+= rtl818x/
 
-# 16-bit wireless PCMCIA client drivers
-obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
-obj-$(CONFIG_PCMCIA_WL3501)	+= wl3501_cs.o
 
 obj-$(CONFIG_USB_NET_RNDIS_WLAN)	+= rndis_wlan.o
 
-obj-$(CONFIG_USB_ZD1201)	+= zd1201.o
 obj-$(CONFIG_LIBERTAS)		+= libertas/
 
 obj-$(CONFIG_LIBERTAS_THINFIRM)	+= libertas_tf/
--- a/drivers/net/wireless/ath/ath5k/base.h
+++ b/drivers/net/wireless/ath/ath5k/base.h
@@ -46,7 +46,11 @@
 #include <linux/wireless.h>
 #include <linux/if_ether.h>
 #include <linux/leds.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 #include <linux/rfkill.h>
+#else
+#include <linux/rfkill_backport.h>
+#endif
 
 #include "ath5k.h"
 #include "debug.h"
--- a/drivers/net/wireless/ath/ath9k/ath9k.h
+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
@@ -21,7 +21,11 @@
 #include <linux/device.h>
 #include <net/mac80211.h>
 #include <linux/leds.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 #include <linux/rfkill.h>
+#else
+#include <linux/rfkill_backport.h>
+#endif
 
 #include "hw.h"
 #include "rc.h"
--- a/drivers/net/wireless/ath/ath9k/main.c
+++ b/drivers/net/wireless/ath/ath9k/main.c
@@ -1178,7 +1178,7 @@ void ath_radio_disable(struct ath_softc *sc)
 	ath9k_ps_restore(sc);
 }
 
-#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
+#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)) || ((LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL_BACKPORT) || defined(CONFIG_RFKILL_BACKPORT_MODULE))
 
 /*******************/
 /*	Rfkill	   */
@@ -1210,7 +1210,11 @@ static void ath_rfkill_poll_state(struct rfkill *rfkill, void *data)
 	struct ath_softc *sc = data;
 	bool blocked = !!ath_is_rfkill_set(sc);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 	if (rfkill_set_hw_state(rfkill, blocked))
+#else
+	if (backport_rfkill_set_hw_state(rfkill, blocked))
+#endif
 		ath_radio_disable(sc);
 	else
 		ath_radio_enable(sc);
@@ -1226,10 +1230,17 @@ static int ath_init_sw_rfkill(struct ath_softc *sc)
 	snprintf(sc->rf_kill.rfkill_name, sizeof(sc->rf_kill.rfkill_name),
 		"ath9k-%s::rfkill", wiphy_name(sc->hw->wiphy));
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 	sc->rf_kill.rfkill = rfkill_alloc(sc->rf_kill.rfkill_name,
 					  wiphy_dev(sc->hw->wiphy),
 					  RFKILL_TYPE_WLAN,
 					  &sc->rf_kill.ops, sc);
+#else
+	sc->rf_kill.rfkill = backport_rfkill_alloc(sc->rf_kill.rfkill_name,
+					  wiphy_dev(sc->hw->wiphy),
+					  RFKILL_TYPE_WLAN,
+					  &sc->rf_kill.ops, sc);
+#endif
 	if (!sc->rf_kill.rfkill) {
 		DPRINTF(sc, ATH_DBG_FATAL, "Failed to allocate rfkill\n");
 		return -ENOMEM;
@@ -1242,8 +1253,13 @@ static int ath_init_sw_rfkill(struct ath_softc *sc)
 static void ath_deinit_rfkill(struct ath_softc *sc)
 {
 	if (sc->sc_flags & SC_OP_RFKILL_REGISTERED) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 		rfkill_unregister(sc->rf_kill.rfkill);
 		rfkill_destroy(sc->rf_kill.rfkill);
+#else
+		backport_rfkill_unregister(sc->rf_kill.rfkill);
+		backport_rfkill_destroy(sc->rf_kill.rfkill);
+#endif
 		sc->sc_flags &= ~SC_OP_RFKILL_REGISTERED;
 	}
 }
@@ -1251,10 +1267,18 @@ static void ath_deinit_rfkill(struct ath_softc *sc)
 static int ath_start_rfkill_poll(struct ath_softc *sc)
 {
 	if (!(sc->sc_flags & SC_OP_RFKILL_REGISTERED)) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 		if (rfkill_register(sc->rf_kill.rfkill)) {
+#else
+		if (backport_rfkill_register(sc->rf_kill.rfkill)) {
+#endif
 			DPRINTF(sc, ATH_DBG_FATAL,
 				"Unable to register rfkill\n");
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 			rfkill_destroy(sc->rf_kill.rfkill);
+#else
+			backport_rfkill_destroy(sc->rf_kill.rfkill);
+#endif
 
 			/* Deinitialize the device */
 			ath_cleanup(sc);
@@ -1286,7 +1310,7 @@ void ath_detach(struct ath_softc *sc)
 
 	DPRINTF(sc, ATH_DBG_CONFIG, "Detach ATH hw\n");
 
-#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
+#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)) || ((LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL_BACKPORT) || defined(CONFIG_RFKILL_BACKPORT_MODULE))
 	ath_deinit_rfkill(sc);
 #endif
 	ath_deinit_leds(sc);
@@ -1626,7 +1650,7 @@ int ath_attach(u16 devid, struct ath_softc *sc)
 	if (error != 0)
 		goto error_attach;
 
-#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
+#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)) || ((LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL_BACKPORT) || defined(CONFIG_RFKILL_BACKPORT_MODULE))
 	/* Initialize s/w rfkill */
 	error = ath_init_sw_rfkill(sc);
 	if (error)
@@ -2018,7 +2042,7 @@ static int ath9k_start(struct ieee80211_hw *hw)
 
 	ieee80211_wake_queues(hw);
 
-#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
+#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)) || ((LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)) && defined(CONFIG_RFKILL_BACKPORT) || defined(CONFIG_RFKILL_BACKPORT_MODULE))
 	r = ath_start_rfkill_poll(sc);
 #endif
 
@@ -2159,7 +2183,11 @@ static void ath9k_stop(struct ieee80211_hw *hw)
 	} else
 		sc->rx.rxlink = NULL;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 	rfkill_pause_polling(sc->rf_kill.rfkill);
+#else
+	backport_rfkill_pause_polling(sc->rf_kill.rfkill);
+#endif
 
 	/* disable HAL and put h/w to sleep */
 	ath9k_hw_disable(sc->sc_ah);
--- a/drivers/net/wireless/b43/pcmcia.c
+++ b/drivers/net/wireless/b43/pcmcia.c
@@ -87,7 +87,11 @@ static int __devinit b43_pcmcia_probe(struct pcmcia_device *dev)
 	res = pcmcia_get_tuple_data(dev, &tuple);
 	if (res != 0)
 		goto err_kfree_ssb;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28))
+	res = pcmcia_parse_tuple(NULL,&tuple, &parse);
+#else
 	res = pcmcia_parse_tuple(&tuple, &parse);
+#endif
 	if (res != 0)
 		goto err_kfree_ssb;
 
--- a/drivers/net/wireless/b43/phy_common.h
+++ b/drivers/net/wireless/b43/phy_common.h
@@ -2,6 +2,9 @@
 #define LINUX_B43_PHY_COMMON_H_
 
 #include <linux/types.h>
+#if (LINUX_VERSION_CODE == KERNEL_VERSION(2,6,28))
+#include <asm/atomic.h>
+#endif
 
 struct b43_wldev;
 
--- a/drivers/net/wireless/ipw2x00/ipw2100.c
+++ b/drivers/net/wireless/ipw2x00/ipw2100.c
@@ -6008,6 +6008,7 @@ static void ipw2100_rf_kill(struct work_struct *work)
 
 static void ipw2100_irq_tasklet(struct ipw2100_priv *priv);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops ipw2100_netdev_ops = {
 	.ndo_open		= ipw2100_open,
 	.ndo_stop		= ipw2100_close,
@@ -6018,6 +6019,7 @@ static const struct net_device_ops ipw2100_netdev_ops = {
 	.ndo_set_mac_address	= ipw2100_set_address,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 /* Look into using netdev destructor to shutdown ieee80211? */
 
@@ -6043,7 +6045,16 @@ static struct net_device *ipw2100_alloc_device(struct pci_dev *pci_dev,
 	priv->ieee->perfect_rssi = -20;
 	priv->ieee->worst_rssi = -85;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	dev->netdev_ops = &ipw2100_netdev_ops;
+#else
+	dev->open = ipw2100_open;
+	dev->stop = ipw2100_close;
+	dev->init = ipw2100_net_init;
+	dev->tx_timeout = ipw2100_tx_timeout;
+	dev->set_mac_address = ipw2100_set_address;
+#endif
+
 	dev->ethtool_ops = &ipw2100_ethtool_ops;
 	dev->wireless_handlers = &ipw2100_wx_handler_def;
 	priv->wireless_data.ieee80211 = priv->ieee;
--- a/drivers/net/wireless/ipw2x00/ipw2200.c
+++ b/drivers/net/wireless/ipw2x00/ipw2200.c
@@ -11530,6 +11530,7 @@ static int ipw_prom_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	return -EOPNOTSUPP;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops ipw_prom_netdev_ops = {
 	.ndo_open 		= ipw_prom_open,
 	.ndo_stop		= ipw_prom_stop,
@@ -11538,6 +11539,7 @@ static const struct net_device_ops ipw_prom_netdev_ops = {
 	.ndo_set_mac_address 	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 static int ipw_prom_alloc(struct ipw_priv *priv)
 {
@@ -11558,7 +11560,13 @@ static int ipw_prom_alloc(struct ipw_priv *priv)
 	memcpy(priv->prom_net_dev->dev_addr, priv->mac_addr, ETH_ALEN);
 
 	priv->prom_net_dev->type = ARPHRD_IEEE80211_RADIOTAP;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	priv->prom_net_dev->netdev_ops = &ipw_prom_netdev_ops;
+#else
+	priv->prom_net_dev->open = ipw_prom_open;
+	priv->prom_net_dev->stop = ipw_prom_stop;
+	priv->prom_net_dev->hard_start_xmit = ipw_prom_hard_start_xmit;
+#endif
 
 	priv->prom_priv->ieee->iw_mode = IW_MODE_MONITOR;
 	SET_NETDEV_DEV(priv->prom_net_dev, &priv->pci_dev->dev);
@@ -11586,6 +11594,7 @@ static void ipw_prom_free(struct ipw_priv *priv)
 
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops ipw_netdev_ops = {
 	.ndo_init		= ipw_net_init,
 	.ndo_open		= ipw_net_open,
@@ -11596,6 +11605,7 @@ static const struct net_device_ops ipw_netdev_ops = {
 	.ndo_change_mtu		= ieee80211_change_mtu,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 static int __devinit ipw_pci_probe(struct pci_dev *pdev,
 				   const struct pci_device_id *ent)
@@ -11697,7 +11707,15 @@ static int __devinit ipw_pci_probe(struct pci_dev *pdev,
 	priv->ieee->perfect_rssi = -20;
 	priv->ieee->worst_rssi = -85;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	net_dev->netdev_ops = &ipw_netdev_ops;
+#else
+	net_dev->open = ipw_net_open;
+	net_dev->stop = ipw_net_stop;
+	net_dev->init = ipw_net_init;
+	net_dev->set_multicast_list = ipw_net_set_multicast_list;
+	net_dev->set_mac_address = ipw_net_set_mac_address;
+#endif
 	priv->wireless_data.spy_data = &priv->ieee->spy_data;
 	net_dev->wireless_data = &priv->wireless_data;
 	net_dev->wireless_handlers = &ipw_wx_handler_def;
--- a/drivers/net/wireless/libertas/if_cs.c
+++ b/drivers/net/wireless/libertas/if_cs.c
@@ -813,7 +813,11 @@ static int if_cs_probe(struct pcmcia_device *p_dev)
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
 	if ((ret = pcmcia_get_first_tuple(p_dev, &tuple)) != 0 ||
 	    (ret = pcmcia_get_tuple_data(p_dev, &tuple)) != 0 ||
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28))
+	    (ret = pcmcia_parse_tuple(NULL,&tuple, &parse)) != 0)
+#else
 	    (ret = pcmcia_parse_tuple(&tuple, &parse)) != 0)
+#endif
 	{
 		lbs_pr_err("error in pcmcia_get_first_tuple etc\n");
 		goto out1;
--- a/drivers/net/wireless/libertas/main.c
+++ b/drivers/net/wireless/libertas/main.c
@@ -1148,6 +1148,7 @@ static void lbs_free_adapter(struct lbs_private *priv)
 	lbs_deb_leave(LBS_DEB_MAIN);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops lbs_netdev_ops = {
 	.ndo_open 		= lbs_dev_open,
 	.ndo_stop		= lbs_eth_stop,
@@ -1158,6 +1159,7 @@ static const struct net_device_ops lbs_netdev_ops = {
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 /**
  * @brief This function adds the card. it will probe the
@@ -1193,7 +1195,16 @@ struct lbs_private *lbs_add_card(void *card, struct device *dmdev)
 	priv->infra_open = 0;
 
 	/* Setup the OS Interface to our functions */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
  	dev->netdev_ops = &lbs_netdev_ops;
+#else
+	dev->open = lbs_dev_open;
+	dev->hard_start_xmit = lbs_hard_start_xmit;
+	dev->stop = lbs_eth_stop;
+	dev->set_mac_address = lbs_set_mac_address;
+	dev->tx_timeout = lbs_tx_timeout;
+	dev->set_multicast_list = lbs_set_multicast_list;
+#endif
 	dev->watchdog_timeo = 5 * HZ;
 	dev->ethtool_ops = &lbs_ethtool_ops;
 #ifdef	WIRELESS_EXT
@@ -1419,6 +1430,7 @@ out:
 EXPORT_SYMBOL_GPL(lbs_stop_card);
 
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops mesh_netdev_ops = {
 	.ndo_open		= lbs_dev_open,
 	.ndo_stop 		= lbs_mesh_stop,
@@ -1426,6 +1438,7 @@ static const struct net_device_ops mesh_netdev_ops = {
 	.ndo_set_mac_address	= lbs_set_mac_address,
 	.ndo_set_multicast_list = lbs_set_multicast_list,
 };
+#endif
 
 /**
  * @brief This function adds mshX interface
@@ -1449,7 +1462,15 @@ static int lbs_add_mesh(struct lbs_private *priv)
 	mesh_dev->ml_priv = priv;
 	priv->mesh_dev = mesh_dev;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	mesh_dev->netdev_ops = &mesh_netdev_ops;
+#else
+	mesh_dev->open = lbs_dev_open;
+	mesh_dev->hard_start_xmit = lbs_hard_start_xmit;
+	mesh_dev->stop = lbs_mesh_stop;
+	mesh_dev->set_mac_address = lbs_set_mac_address;
+	mesh_dev->set_multicast_list = lbs_set_multicast_list;
+#endif
 	mesh_dev->ethtool_ops = &lbs_ethtool_ops;
 	memcpy(mesh_dev->dev_addr, priv->dev->dev_addr,
 			sizeof(priv->dev->dev_addr));
@@ -1664,11 +1685,13 @@ out:
 	lbs_deb_leave(LBS_DEB_MAIN);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops rtap_netdev_ops = {
 	.ndo_open = lbs_rtap_open,
 	.ndo_stop = lbs_rtap_stop,
 	.ndo_start_xmit = lbs_rtap_hard_start_xmit,
 };
+#endif
 
 static int lbs_add_rtap(struct lbs_private *priv)
 {
@@ -1689,7 +1712,13 @@ static int lbs_add_rtap(struct lbs_private *priv)
 
 	memcpy(rtap_dev->dev_addr, priv->current_addr, ETH_ALEN);
 	rtap_dev->type = ARPHRD_IEEE80211_RADIOTAP;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	rtap_dev->netdev_ops = &rtap_netdev_ops;
+#else
+	rtap_dev->open = lbs_rtap_open;
+	rtap_dev->stop = lbs_rtap_stop;
+	rtap_dev->hard_start_xmit = lbs_rtap_hard_start_xmit;
+#endif
 	rtap_dev->ml_priv = priv;
 	SET_NETDEV_DEV(rtap_dev, priv->dev->dev.parent);
 
--- a/drivers/net/wireless/mac80211_hwsim.c	2009-05-18 14:35:29.000000000 -0700
+++ b/drivers/net/wireless/mac80211_hwsim.c	2009-05-18 14:35:29.000000000 -0700
@@ -733,16 +733,22 @@
 	.name = "mac80211_hwsim"
 };
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops hwsim_netdev_ops = {
 	.ndo_start_xmit 	= hwsim_mon_xmit,
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_set_mac_address 	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 };
+#endif
 
 static void hwsim_mon_setup(struct net_device *dev)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	dev->netdev_ops = &hwsim_netdev_ops;
+#else
+	dev->hard_start_xmit = hwsim_mon_xmit;
+#endif
 	dev->destructor = free_netdev;
 	ether_setup(dev);
 	dev->tx_queue_len = 0;
--- a/drivers/net/wireless/rndis_wlan.c	2009-04-28 15:35:05.000000000 -0700
+++ b/drivers/net/wireless/rndis_wlan.c	2009-04-28 15:35:06.000000000 -0700
@@ -2362,6 +2362,7 @@
 	return 0;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 /* same as rndis_netdev_ops but with local multicast handler */
 static const struct net_device_ops rndis_wlan_netdev_ops = {
 	.ndo_open		= usbnet_open,
@@ -2372,6 +2373,7 @@
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_set_multicast_list	= rndis_wlan_set_multicast_list,
 };
+#endif
 
 
 static int rndis_wlan_bind(struct usbnet *usbdev, struct usb_interface *intf)
@@ -2422,7 +2424,11 @@
 	 * rndis_host wants to avoid all OID as much as possible
 	 * so do promisc/multicast handling in rndis_wlan.
 	 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	usbdev->net->netdev_ops = &rndis_wlan_netdev_ops;
+#else
+	usbdev->net->set_multicast_list = rndis_wlan_set_multicast_list;
+#endif
 
 	tmp = RNDIS_PACKET_TYPE_DIRECTED | RNDIS_PACKET_TYPE_BROADCAST;
 	retval = rndis_set_oid(usbdev, OID_GEN_CURRENT_PACKET_FILTER, &tmp,
--- a/drivers/net/wireless/wl12xx/main.c
+++ b/drivers/net/wireless/wl12xx/main.c
@@ -26,6 +26,9 @@
 #include <linux/firmware.h>
 #include <linux/delay.h>
 #include <linux/irq.h>
+#if (LINUX_VERSION_CODE == KERNEL_VERSION(2,6,28))
+#include <linux/device.h>
+#endif
 #include <linux/spi/spi.h>
 #include <linux/crc32.h>
 #include <linux/etherdevice.h>
--- a/drivers/net/wireless/wl12xx/spi.c
+++ b/drivers/net/wireless/wl12xx/spi.c
@@ -23,6 +23,9 @@
 
 #include <linux/module.h>
 #include <linux/crc7.h>
+#if (LINUX_VERSION_CODE == KERNEL_VERSION(2,6,28))
+#include <linux/device.h>
+#endif
 #include <linux/spi/spi.h>
 
 #include "wl12xx.h"
--- a/include/linux/rfkill_backport.h
+++ b/include/linux/rfkill_backport.h
@@ -134,7 +134,7 @@ struct rfkill_ops {
 	int	(*set_block)(void *data, bool blocked);
 };
 
-#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
+#if defined(CONFIG_RFKILL_BACKPORT) || defined(CONFIG_RFKILL_MODULE_BACKPORT)
 /**
  * rfkill_alloc - allocate rfkill structure
  * @name: name of the struct -- the string is not copied internally
@@ -146,7 +146,7 @@ struct rfkill_ops {
  * This function should be called by the transmitter driver to allocate an
  * rfkill structure. Returns %NULL on failure.
  */
-struct rfkill * __must_check rfkill_alloc(const char *name,
+struct rfkill * __must_check backport_rfkill_alloc(const char *name,
 					  struct device *parent,
 					  const enum rfkill_type type,
 					  const struct rfkill_ops *ops,
@@ -166,7 +166,7 @@ struct rfkill * __must_check rfkill_alloc(const char *name,
  * If the hardware blocked state is not set before registration,
  * it is assumed to be unblocked.
  */
-int __must_check rfkill_register(struct rfkill *rfkill);
+int __must_check backport_rfkill_register(struct rfkill *rfkill);
 
 /**
  * rfkill_pause_polling(struct rfkill *rfkill)
@@ -175,7 +175,7 @@ int __must_check rfkill_register(struct rfkill *rfkill);
  * NOTE: not necessary for suspend/resume -- in that case the
  * core stops polling anyway
  */
-void rfkill_pause_polling(struct rfkill *rfkill);
+void backport_rfkill_pause_polling(struct rfkill *rfkill);
 
 /**
  * rfkill_resume_polling(struct rfkill *rfkill)
@@ -184,7 +184,7 @@ void rfkill_pause_polling(struct rfkill *rfkill);
  * NOTE: not necessary for suspend/resume -- in that case the
  * core stops polling anyway
  */
-void rfkill_resume_polling(struct rfkill *rfkill);
+void backport_rfkill_resume_polling(struct rfkill *rfkill);
 
 
 /**
@@ -195,7 +195,7 @@ void rfkill_resume_polling(struct rfkill *rfkill);
  * teardown to destroy rfkill structure. Until it returns, the driver
  * needs to be able to service method calls.
  */
-void rfkill_unregister(struct rfkill *rfkill);
+void backport_rfkill_unregister(struct rfkill *rfkill);
 
 /**
  * rfkill_destroy - free rfkill structure
@@ -203,7 +203,7 @@ void rfkill_unregister(struct rfkill *rfkill);
  *
  * Destroys the rfkill structure.
  */
-void rfkill_destroy(struct rfkill *rfkill);
+void backport_rfkill_destroy(struct rfkill *rfkill);
 
 /**
  * rfkill_set_hw_state - Set the internal rfkill hardware block state
@@ -224,7 +224,7 @@ void rfkill_destroy(struct rfkill *rfkill);
  * should be blocked) so that drivers need not keep track of the soft
  * block state -- which they might not be able to.
  */
-bool __must_check rfkill_set_hw_state(struct rfkill *rfkill, bool blocked);
+bool __must_check backport_rfkill_set_hw_state(struct rfkill *rfkill, bool blocked);
 
 /**
  * rfkill_set_sw_state - Set the internal rfkill software block state
@@ -244,7 +244,7 @@ bool __must_check rfkill_set_hw_state(struct rfkill *rfkill, bool blocked);
  * The function returns the combined block state (true if transmitter
  * should be blocked).
  */
-bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked);
+bool backport_rfkill_set_sw_state(struct rfkill *rfkill, bool blocked);
 
 /**
  * rfkill_set_states - Set the internal rfkill block states
@@ -255,17 +255,17 @@ bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked);
  * This function can be called in any context, even from within rfkill
  * callbacks.
  */
-void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw);
+void backport_rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw);
 
 /**
  * rfkill_blocked - query rfkill block
  *
  * @rfkill: rfkill struct to query
  */
-bool rfkill_blocked(struct rfkill *rfkill);
-#else /* !RFKILL */
+bool backport_rfkill_blocked(struct rfkill *rfkill);
+#else /* !RFKILL_BACKPORT */
 static inline struct rfkill * __must_check
-rfkill_alloc(const char *name,
+backport_rfkill_alloc(const char *name,
 	     struct device *parent,
 	     const enum rfkill_type type,
 	     const struct rfkill_ops *ops,
@@ -274,57 +274,57 @@ rfkill_alloc(const char *name,
 	return ERR_PTR(-ENODEV);
 }
 
-static inline int __must_check rfkill_register(struct rfkill *rfkill)
+static inline int __must_check backport_rfkill_register(struct rfkill *rfkill)
 {
 	if (rfkill == ERR_PTR(-ENODEV))
 		return 0;
 	return -EINVAL;
 }
 
-static inline void rfkill_pause_polling(struct rfkill *rfkill)
+static inline void backport_rfkill_pause_polling(struct rfkill *rfkill)
 {
 }
 
-static inline void rfkill_resume_polling(struct rfkill *rfkill)
+static inline void backport_rfkill_resume_polling(struct rfkill *rfkill)
 {
 }
 
-static inline void rfkill_unregister(struct rfkill *rfkill)
+static inline void backport_rfkill_unregister(struct rfkill *rfkill)
 {
 }
 
-static inline void rfkill_destroy(struct rfkill *rfkill)
+static inline void backport_rfkill_destroy(struct rfkill *rfkill)
 {
 }
 
-static inline bool rfkill_set_hw_state(struct rfkill *rfkill, bool blocked)
+static inline bool backport_rfkill_set_hw_state(struct rfkill *rfkill, bool blocked)
 {
 	return blocked;
 }
 
-static inline bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked)
+static inline bool backport_rfkill_set_sw_state(struct rfkill *rfkill, bool blocked)
 {
 	return blocked;
 }
 
-static inline void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw)
+static inline void backport_rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw)
 {
 }
 
-static inline bool rfkill_blocked(struct rfkill *rfkill)
+static inline bool backport_rfkill_blocked(struct rfkill *rfkill)
 {
 	return false;
 }
-#endif /* RFKILL || RFKILL_MODULE */
+#endif /* RFKILL_BACKPORT || RFKILL_BACKPORT_MODULE */
 
 
-#ifdef CONFIG_RFKILL_LEDS
+#ifdef CONFIG_RFKILL_BACKPORT_LEDS
 /**
  * rfkill_get_led_trigger_name - Get the LED trigger name for the button's LED.
  * This function might return a NULL pointer if registering of the
  * LED trigger failed. Use this as "default_trigger" for the LED.
  */
-const char *rfkill_get_led_trigger_name(struct rfkill *rfkill);
+const char *backport_rfkill_get_led_trigger_name(struct rfkill *rfkill);
 
 /**
  * rfkill_set_led_trigger_name -- set the LED trigger name
@@ -335,15 +335,15 @@ const char *rfkill_get_led_trigger_name(struct rfkill *rfkill);
  * trigger that rfkill creates. It is optional, but if called
  * must be called before rfkill_register() to be effective.
  */
-void rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name);
+void backport_rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name);
 #else
-static inline const char *rfkill_get_led_trigger_name(struct rfkill *rfkill)
+static inline const char *backport_rfkill_get_led_trigger_name(struct rfkill *rfkill)
 {
 	return NULL;
 }
 
 static inline void
-rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name)
+backport_rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name)
 {
 }
 #endif
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -23,6 +23,7 @@
 /* remove once we remove the wext stuff */
 #include <net/iw_handler.h>
 #include <linux/wireless.h>
+#include <net/compat.h>
 
 
 /*
--- a/net/mac80211/iface.c	2009-04-28 15:34:50.000000000 -0700
+++ b/net/mac80211/iface.c	2009-04-28 15:35:06.000000000 -0700
@@ -671,6 +671,7 @@
 	WARN_ON(flushed);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops ieee80211_dataif_ops = {
 	.ndo_open		= ieee80211_open,
 	.ndo_stop		= ieee80211_stop,
@@ -690,11 +691,22 @@
 	.ndo_change_mtu 	= ieee80211_change_mtu,
 	.ndo_set_mac_address 	= eth_mac_addr,
 };
+#endif
 
 static void ieee80211_if_setup(struct net_device *dev)
 {
 	ether_setup(dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	dev->netdev_ops = &ieee80211_dataif_ops;
+#else
+	dev->hard_start_xmit = ieee80211_subif_start_xmit;
+	dev->set_multicast_list = ieee80211_set_multicast_list;
+	dev->change_mtu = ieee80211_change_mtu;
+	dev->open = ieee80211_open;
+	dev->stop = ieee80211_stop;
+	/* we will validate the address ourselves in ->open */
+	dev->validate_addr = NULL;
+#endif
 	dev->wireless_handlers = &ieee80211_iw_handler_def;
 	dev->destructor = free_netdev;
 }
@@ -710,7 +722,11 @@
 
 	/* and set some type-dependent values */
 	sdata->vif.type = type;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	sdata->dev->netdev_ops = &ieee80211_dataif_ops;
+#else
+	sdata->dev->hard_start_xmit = ieee80211_subif_start_xmit;
+#endif
 	sdata->wdev.iftype = type;
 
 	/* only monitor differs */
@@ -733,7 +749,11 @@
 		break;
 	case NL80211_IFTYPE_MONITOR:
 		sdata->dev->type = ARPHRD_IEEE80211_RADIOTAP;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 		sdata->dev->netdev_ops = &ieee80211_monitorif_ops;
+#else
+		sdata->dev->hard_start_xmit = ieee80211_monitor_start_xmit;
+#endif
 		sdata->u.mntr_flags = MONITOR_FLAG_CONTROL |
 				      MONITOR_FLAG_OTHER_BSS;
 		break;
@@ -840,6 +860,10 @@
 	if (ret)
 		goto fail;
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,28))
+	ndev->uninit = ieee80211_teardown_sdata;
+#endif
+
 	if (ieee80211_vif_is_mesh(&sdata->vif) &&
 	    params && params->mesh_id_len)
 		ieee80211_sdata_set_mesh_id(sdata,
--- a/net/mac80211/key.c
+++ b/net/mac80211/key.c
@@ -21,6 +21,9 @@
 #include "aes_ccm.h"
 #include "aes_cmac.h"
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+#include <asm/unaligned.h>
+#endif
 
 /**
  * DOC: Key handling basics
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -759,6 +759,7 @@ struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len,
 }
 EXPORT_SYMBOL(ieee80211_alloc_hw);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static const struct net_device_ops ieee80211_master_ops = {
 	.ndo_start_xmit = ieee80211_master_start_xmit,
 	.ndo_open = ieee80211_master_open,
@@ -766,12 +767,22 @@ static const struct net_device_ops ieee80211_master_ops = {
 	.ndo_set_multicast_list = ieee80211_master_set_multicast_list,
 	.ndo_select_queue = ieee80211_select_queue,
 };
+#endif
 
 static void ieee80211_master_setup(struct net_device *mdev)
 {
 	mdev->type = ARPHRD_IEEE80211;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	mdev->netdev_ops = &ieee80211_master_ops;
 	mdev->header_ops = &ieee80211_header_ops;
+#else
+	mdev->hard_start_xmit = ieee80211_master_start_xmit;
+	mdev->open = ieee80211_master_open;
+	mdev->stop = ieee80211_master_stop;
+	mdev->header_ops = &ieee80211_header_ops;
+	mdev->set_multicast_list = ieee80211_master_set_multicast_list;
+	mdev->select_queue = ieee80211_select_queue;
+#endif
 	mdev->tx_queue_len = 1000;
 	mdev->addr_len = ETH_ALEN;
 }
--- a/net/mac80211/rate.c
+++ b/net/mac80211/rate.c
@@ -22,7 +22,7 @@ struct rate_control_alg {
 static LIST_HEAD(rate_ctrl_algs);
 static DEFINE_MUTEX(rate_ctrl_mutex);
 
-static char *ieee80211_default_rc_algo = CONFIG_MAC80211_RC_DEFAULT;
+static char *ieee80211_default_rc_algo = CONFIG_COMPAT_MAC80211_RC_DEFAULT;
 module_param(ieee80211_default_rc_algo, charp, 0644);
 MODULE_PARM_DESC(ieee80211_default_rc_algo,
 		 "Default rate control algorithm for mac80211 to use");
@@ -117,8 +117,8 @@ ieee80211_rate_control_ops_get(const char *name)
 		ops = ieee80211_try_rate_control_ops_get(ieee80211_default_rc_algo);
 
 	/* try built-in one if specific alg requested but not found */
-	if (!ops && strlen(CONFIG_MAC80211_RC_DEFAULT))
-		ops = ieee80211_try_rate_control_ops_get(CONFIG_MAC80211_RC_DEFAULT);
+	if (!ops && strlen(CONFIG_COMPAT_MAC80211_RC_DEFAULT))
+		ops = ieee80211_try_rate_control_ops_get(CONFIG_COMPAT_MAC80211_RC_DEFAULT);
 
 	return ops;
 }
--- a/net/mac80211/wme.c
+++ b/net/mac80211/wme.c
@@ -97,6 +97,7 @@ u16 ieee80211_select_queue(struct net_device *dev, struct sk_buff *skb)
 	if (unlikely(queue >= local->hw.queues))
 		queue = local->hw.queues - 1;
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
 	/*
 	 * Now we know the 1d priority, fill in the QoS header if
 	 * there is one (and we haven't done this before).
@@ -112,6 +113,7 @@ u16 ieee80211_select_queue(struct net_device *dev, struct sk_buff *skb)
 		*p++ = ack_policy | tid;
 		*p = 0;
 	}
+#endif
 
 	return queue;
 }
--- a/net/rfkill/Makefile
+++ b/net/rfkill/Makefile
@@ -2,6 +2,6 @@
 # Makefile for the RF switch subsystem.
 #
 
-rfkill-y			+= core.o
-rfkill-$(CONFIG_RFKILL_INPUT)	+= input.o
-obj-$(CONFIG_RFKILL)		+= rfkill.o
+rfkill_backport-y			+= core.o
+rfkill_backport-$(CONFIG_RFKILL_BACKPORT_INPUT)	+= input.o
+obj-$(CONFIG_RFKILL_BACKPORT)		+= rfkill_backport.o
--- a/net/rfkill/core.c
+++ b/net/rfkill/core.c
@@ -26,7 +26,7 @@
 #include <linux/capability.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
-#include <linux/rfkill.h>
+#include <linux/rfkill_backport.h>
 #include <linux/spinlock.h>
 #include <linux/miscdevice.h>
 #include <linux/wait.h>
@@ -62,7 +62,7 @@ struct rfkill {
 	const struct rfkill_ops	*ops;
 	void			*data;
 
-#ifdef CONFIG_RFKILL_LEDS
+#ifdef CONFIG_RFKILL_BACKPORT_LEDS
 	struct led_trigger	led_trigger;
 	const char		*ledtrigname;
 #endif
@@ -123,7 +123,7 @@ static struct {
 static bool rfkill_epo_lock_active;
 
 
-#ifdef CONFIG_RFKILL_LEDS
+#ifdef CONFIG_RFKILL_BACKPORT_LEDS
 static void rfkill_led_trigger_event(struct rfkill *rfkill)
 {
 	struct led_trigger *trigger;
@@ -148,19 +148,19 @@ static void rfkill_led_trigger_activate(struct led_classdev *led)
 	rfkill_led_trigger_event(rfkill);
 }
 
-const char *rfkill_get_led_trigger_name(struct rfkill *rfkill)
+const char *backport_rfkill_get_led_trigger_name(struct rfkill *rfkill)
 {
 	return rfkill->led_trigger.name;
 }
-EXPORT_SYMBOL(rfkill_get_led_trigger_name);
+EXPORT_SYMBOL(backport_rfkill_get_led_trigger_name);
 
-void rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name)
+void backport_rfkill_set_led_trigger_name(struct rfkill *rfkill, const char *name)
 {
 	BUG_ON(!rfkill);
 
 	rfkill->ledtrigname = name;
 }
-EXPORT_SYMBOL(rfkill_set_led_trigger_name);
+EXPORT_SYMBOL(backport_rfkill_set_led_trigger_name);
 
 static int rfkill_led_trigger_register(struct rfkill *rfkill)
 {
@@ -187,7 +187,7 @@ static inline int rfkill_led_trigger_register(struct rfkill *rfkill)
 static inline void rfkill_led_trigger_unregister(struct rfkill *rfkill)
 {
 }
-#endif /* CONFIG_RFKILL_LEDS */
+#endif /* CONFIG_RFKILL_BACKPORT_LEDS */
 
 static void rfkill_fill_event(struct rfkill_event *ev, struct rfkill *rfkill,
 			      enum rfkill_operation op)
@@ -317,7 +317,7 @@ static void rfkill_set_block(struct rfkill *rfkill, bool blocked)
 	rfkill_event(rfkill);
 }
 
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 static atomic_t rfkill_input_disabled = ATOMIC_INIT(0);
 
 /**
@@ -464,7 +464,7 @@ bool rfkill_get_global_sw_state(const enum rfkill_type type)
 #endif
 
 
-bool rfkill_set_hw_state(struct rfkill *rfkill, bool blocked)
+bool backport_rfkill_set_hw_state(struct rfkill *rfkill, bool blocked)
 {
 	bool ret, change;
 
@@ -478,7 +478,7 @@ bool rfkill_set_hw_state(struct rfkill *rfkill, bool blocked)
 
 	return ret;
 }
-EXPORT_SYMBOL(rfkill_set_hw_state);
+EXPORT_SYMBOL(backport_rfkill_set_hw_state);
 
 static void __rfkill_set_sw_state(struct rfkill *rfkill, bool blocked)
 {
@@ -494,7 +494,7 @@ static void __rfkill_set_sw_state(struct rfkill *rfkill, bool blocked)
 		rfkill->state &= ~bit;
 }
 
-bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked)
+bool backport_rfkill_set_sw_state(struct rfkill *rfkill, bool blocked)
 {
 	unsigned long flags;
 	bool prev, hwblock;
@@ -519,9 +519,9 @@ bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked)
 
 	return blocked;
 }
-EXPORT_SYMBOL(rfkill_set_sw_state);
+EXPORT_SYMBOL(backport_rfkill_set_sw_state);
 
-void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw)
+void backport_rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw)
 {
 	unsigned long flags;
 	bool swprev, hwprev;
@@ -549,7 +549,7 @@ void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw)
 		rfkill_led_trigger_event(rfkill);
 	}
 }
-EXPORT_SYMBOL(rfkill_set_states);
+EXPORT_SYMBOL(backport_rfkill_set_states);
 
 static ssize_t rfkill_name_show(struct device *dev,
 				struct device_attribute *attr,
@@ -690,7 +690,7 @@ static int rfkill_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return error;
 }
 
-void rfkill_pause_polling(struct rfkill *rfkill)
+void backport_rfkill_pause_polling(struct rfkill *rfkill)
 {
 	BUG_ON(!rfkill);
 
@@ -699,9 +699,9 @@ void rfkill_pause_polling(struct rfkill *rfkill)
 
 	cancel_delayed_work_sync(&rfkill->poll_work);
 }
-EXPORT_SYMBOL(rfkill_pause_polling);
+EXPORT_SYMBOL(backport_rfkill_pause_polling);
 
-void rfkill_resume_polling(struct rfkill *rfkill)
+void backport_rfkill_resume_polling(struct rfkill *rfkill)
 {
 	BUG_ON(!rfkill);
 
@@ -710,13 +710,13 @@ void rfkill_resume_polling(struct rfkill *rfkill)
 
 	schedule_work(&rfkill->poll_work.work);
 }
-EXPORT_SYMBOL(rfkill_resume_polling);
+EXPORT_SYMBOL(backport_rfkill_resume_polling);
 
 static int rfkill_suspend(struct device *dev, pm_message_t state)
 {
 	struct rfkill *rfkill = to_rfkill(dev);
 
-	rfkill_pause_polling(rfkill);
+	backport_rfkill_pause_polling(rfkill);
 
 	rfkill->suspended = true;
 
@@ -733,13 +733,13 @@ static int rfkill_resume(struct device *dev)
 
 	rfkill->suspended = false;
 
-	rfkill_resume_polling(rfkill);
+	backport_rfkill_resume_polling(rfkill);
 
 	return 0;
 }
 
 static struct class rfkill_class = {
-	.name		= "rfkill",
+	.name		= "rfkill_backport",
 	.dev_release	= rfkill_release,
 	.dev_attrs	= rfkill_dev_attrs,
 	.dev_uevent	= rfkill_dev_uevent,
@@ -747,7 +747,7 @@ static struct class rfkill_class = {
 	.resume		= rfkill_resume,
 };
 
-bool rfkill_blocked(struct rfkill *rfkill)
+bool backport_rfkill_blocked(struct rfkill *rfkill)
 {
 	unsigned long flags;
 	u32 state;
@@ -758,10 +758,10 @@ bool rfkill_blocked(struct rfkill *rfkill)
 
 	return !!(state & RFKILL_BLOCK_ANY);
 }
-EXPORT_SYMBOL(rfkill_blocked);
+EXPORT_SYMBOL(backport_rfkill_blocked);
 
 
-struct rfkill * __must_check rfkill_alloc(const char *name,
+struct rfkill * __must_check backport_rfkill_alloc(const char *name,
 					  struct device *parent,
 					  const enum rfkill_type type,
 					  const struct rfkill_ops *ops,
@@ -800,7 +800,7 @@ struct rfkill * __must_check rfkill_alloc(const char *name,
 
 	return rfkill;
 }
-EXPORT_SYMBOL(rfkill_alloc);
+EXPORT_SYMBOL(backport_rfkill_alloc);
 
 static void rfkill_poll(struct work_struct *work)
 {
@@ -843,7 +843,7 @@ static void rfkill_sync_work(struct work_struct *work)
 	mutex_unlock(&rfkill_global_mutex);
 }
 
-int __must_check rfkill_register(struct rfkill *rfkill)
+int __must_check backport_rfkill_register(struct rfkill *rfkill)
 {
 	static unsigned long rfkill_no;
 	struct device *dev = &rfkill->dev;
@@ -885,7 +885,7 @@ int __must_check rfkill_register(struct rfkill *rfkill)
 	if (!rfkill->persistent || rfkill_epo_lock_active) {
 		schedule_work(&rfkill->sync_work);
 	} else {
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 		bool soft_blocked = !!(rfkill->state & RFKILL_BLOCK_SW);
 
 		if (!atomic_read(&rfkill_input_disabled))
@@ -906,9 +906,9 @@ int __must_check rfkill_register(struct rfkill *rfkill)
 	mutex_unlock(&rfkill_global_mutex);
 	return error;
 }
-EXPORT_SYMBOL(rfkill_register);
+EXPORT_SYMBOL(backport_rfkill_register);
 
-void rfkill_unregister(struct rfkill *rfkill)
+void backport_rfkill_unregister(struct rfkill *rfkill)
 {
 	BUG_ON(!rfkill);
 
@@ -929,14 +929,14 @@ void rfkill_unregister(struct rfkill *rfkill)
 
 	rfkill_led_trigger_unregister(rfkill);
 }
-EXPORT_SYMBOL(rfkill_unregister);
+EXPORT_SYMBOL(backport_rfkill_unregister);
 
-void rfkill_destroy(struct rfkill *rfkill)
+void backport_rfkill_destroy(struct rfkill *rfkill)
 {
 	if (rfkill)
 		put_device(&rfkill->dev);
 }
-EXPORT_SYMBOL(rfkill_destroy);
+EXPORT_SYMBOL(backport_rfkill_destroy);
 
 static int rfkill_fop_open(struct inode *inode, struct file *file)
 {
@@ -1107,7 +1107,7 @@ static int rfkill_fop_release(struct inode *inode, struct file *file)
 	list_for_each_entry_safe(ev, tmp, &data->events, list)
 		kfree(ev);
 
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 	if (data->input_handler)
 		if (atomic_dec_return(&rfkill_input_disabled) == 0)
 			printk(KERN_DEBUG "rfkill: input handler enabled\n");
@@ -1118,7 +1118,7 @@ static int rfkill_fop_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 static long rfkill_fop_ioctl(struct file *file, unsigned int cmd,
 			     unsigned long arg)
 {
@@ -1150,14 +1150,14 @@ static const struct file_operations rfkill_fops = {
 	.write		= rfkill_fop_write,
 	.poll		= rfkill_fop_poll,
 	.release	= rfkill_fop_release,
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 	.unlocked_ioctl	= rfkill_fop_ioctl,
 	.compat_ioctl	= rfkill_fop_ioctl,
 #endif
 };
 
 static struct miscdevice rfkill_miscdev = {
-	.name	= "rfkill",
+	.name	= "rfkill_backport",
 	.fops	= &rfkill_fops,
 	.minor	= MISC_DYNAMIC_MINOR,
 };
@@ -1180,7 +1180,7 @@ static int __init rfkill_init(void)
 		goto out;
 	}
 
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 	error = rfkill_handler_init();
 	if (error) {
 		misc_deregister(&rfkill_miscdev);
@@ -1196,7 +1196,7 @@ subsys_initcall(rfkill_init);
 
 static void __exit rfkill_exit(void)
 {
-#ifdef CONFIG_RFKILL_INPUT
+#ifdef CONFIG_RFKILL_BACKPORT_INPUT
 	rfkill_handler_exit();
 #endif
 	misc_deregister(&rfkill_miscdev);
--- a/net/rfkill/input.c
+++ b/net/rfkill/input.c
@@ -17,7 +17,7 @@
 #include <linux/slab.h>
 #include <linux/workqueue.h>
 #include <linux/init.h>
-#include <linux/rfkill.h>
+#include <linux/rfkill_backport.h>
 #include <linux/sched.h>
 
 #include "rfkill.h"
@@ -229,7 +229,7 @@ static int rfkill_connect(struct input_handler *handler, struct input_dev *dev,
 
 	handle->dev = dev;
 	handle->handler = handler;
-	handle->name = "rfkill";
+	handle->name = "rfkill_backport";
 
 	/* causes rfkill_start() to be called */
 	error = input_register_handle(handle);
--- a/net/wireless/Makefile
+++ b/net/wireless/Makefile
@@ -1,11 +1,10 @@
-obj-$(CONFIG_WIRELESS_EXT) += wext.o
 obj-$(CONFIG_CFG80211) += cfg80211.o
 obj-$(CONFIG_LIB80211) += lib80211.o
 obj-$(CONFIG_LIB80211_CRYPT_WEP) += lib80211_crypt_wep.o
 obj-$(CONFIG_LIB80211_CRYPT_CCMP) += lib80211_crypt_ccmp.o
 obj-$(CONFIG_LIB80211_CRYPT_TKIP) += lib80211_crypt_tkip.o
 
-cfg80211-y += core.o sysfs.o radiotap.o util.o reg.o scan.o nl80211.o mlme.o ibss.o
+cfg80211-y += core.o sysfs.o radiotap.o util.o reg.o scan.o nl80211.o mlme.o ibss.o compat.o
 cfg80211-$(CONFIG_CFG80211_DEBUGFS) += debugfs.o
 cfg80211-$(CONFIG_WIRELESS_EXT) += wext-compat.o
 
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -260,7 +260,11 @@ static void cfg80211_rfkill_sync_work(struct work_struct *work)
 	struct cfg80211_registered_device *drv;
 
 	drv = container_of(work, struct cfg80211_registered_device, rfkill_sync);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 	cfg80211_rfkill_set_block(drv, rfkill_blocked(drv->rfkill));
+#else
+	cfg80211_rfkill_set_block(drv, backport_rfkill_blocked(drv->rfkill));
+#endif
 }
 
 /* exported functions */
@@ -311,9 +315,15 @@ struct wiphy *wiphy_new(const struct cfg80211_ops *ops, int sizeof_priv)
 	drv->wiphy.dev.platform_data = drv;
 
 	drv->rfkill_ops.set_block = cfg80211_rfkill_set_block;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 	drv->rfkill = rfkill_alloc(dev_name(&drv->wiphy.dev),
 				   &drv->wiphy.dev, RFKILL_TYPE_WLAN,
 				   &drv->rfkill_ops, drv);
+#else
+	drv->rfkill = backport_rfkill_alloc(dev_name(&drv->wiphy.dev),
+				   &drv->wiphy.dev, RFKILL_TYPE_WLAN,
+				   &drv->rfkill_ops, drv);
+#endif
 
 	if (!drv->rfkill) {
 		kfree(drv);
@@ -399,7 +409,11 @@ int wiphy_register(struct wiphy *wiphy)
 	if (res)
 		return res;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 	res = rfkill_register(drv->rfkill);
+#else
+	res = backport_rfkill_register(drv->rfkill);
+#endif
 	if (res)
 		goto out_rm_dev;
 
@@ -447,7 +461,11 @@ void wiphy_rfkill_start_polling(struct wiphy *wiphy)
 	if (!drv->ops->rfkill_poll)
 		return;
 	drv->rfkill_ops.poll = cfg80211_rfkill_poll;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 	rfkill_resume_polling(drv->rfkill);
+#else
+	backport_rfkill_resume_polling(drv->rfkill);
+#endif
 }
 EXPORT_SYMBOL(wiphy_rfkill_start_polling);
 
@@ -455,7 +473,11 @@ void wiphy_rfkill_stop_polling(struct wiphy *wiphy)
 {
 	struct cfg80211_registered_device *drv = wiphy_to_dev(wiphy);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 	rfkill_pause_polling(drv->rfkill);
+#else
+	backport_rfkill_pause_polling(drv->rfkill);
+#endif
 }
 EXPORT_SYMBOL(wiphy_rfkill_stop_polling);
 
@@ -463,7 +485,11 @@ void wiphy_unregister(struct wiphy *wiphy)
 {
 	struct cfg80211_registered_device *drv = wiphy_to_dev(wiphy);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 	rfkill_unregister(drv->rfkill);
+#else
+	backport_rfkill_unregister(drv->rfkill);
+#endif
 
 	/* protect the device list */
 	mutex_lock(&cfg80211_mutex);
@@ -501,7 +527,11 @@ EXPORT_SYMBOL(wiphy_unregister);
 void cfg80211_dev_free(struct cfg80211_registered_device *drv)
 {
 	struct cfg80211_internal_bss *scan, *tmp;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 	rfkill_destroy(drv->rfkill);
+#else
+	backport_rfkill_destroy(drv->rfkill);
+#endif
 	mutex_destroy(&drv->mtx);
 	mutex_destroy(&drv->devlist_mtx);
 	list_for_each_entry_safe(scan, tmp, &drv->bss_list, list)
@@ -519,7 +549,11 @@ void wiphy_rfkill_set_hw_state(struct wiphy *wiphy, bool blocked)
 {
 	struct cfg80211_registered_device *drv = wiphy_to_dev(wiphy);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 	if (rfkill_set_hw_state(drv->rfkill, blocked))
+#else
+	if (backport_rfkill_set_hw_state(drv->rfkill, blocked))
+#endif
 		schedule_work(&drv->rfkill_sync);
 }
 EXPORT_SYMBOL(wiphy_rfkill_set_hw_state);
@@ -579,7 +613,11 @@ static int cfg80211_netdev_notifier_call(struct notifier_block * nb,
 		mutex_unlock(&rdev->devlist_mtx);
 		break;
 	case NETDEV_PRE_UP:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 		if (rfkill_blocked(rdev->rfkill))
+#else
+		if (backport_rfkill_blocked(rdev->rfkill))
+#endif
 			return notifier_from_errno(-ERFKILL);
 		break;
 	}
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -11,7 +11,11 @@
 #include <linux/kref.h>
 #include <linux/rbtree.h>
 #include <linux/debugfs.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 #include <linux/rfkill.h>
+#else
+#include <linux/rfkill_backport.h>
+#endif
 #include <linux/workqueue.h>
 #include <net/genetlink.h>
 #include <net/cfg80211.h>
@@ -104,7 +108,11 @@ struct cfg80211_internal_bss {
 	struct rb_node rbn;
 	unsigned long ts;
 	struct kref ref;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	bool hold, ies_allocated;
+#else
+	bool hold;
+#endif
 
 	/* must be last because of priv member */
 	struct cfg80211_bss pub;
--- a/net/wireless/scan.c	2009-04-28 15:34:48.000000000 -0700
+++ b/net/wireless/scan.c	2009-04-28 15:35:06.000000000 -0700
@@ -59,10 +59,12 @@
 	bss = container_of(ref, struct cfg80211_internal_bss, ref);
 	if (bss->pub.free_priv)
 		bss->pub.free_priv(&bss->pub);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 
 	if (bss->ies_allocated)
 		kfree(bss->pub.information_elements);
 
+#endif
 	kfree(bss);
 }
 
@@ -365,13 +367,26 @@
 
 	found = rb_find_bss(dev, res);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 	if (found) {
+#else
+	if (found && overwrite) {
+		list_replace(&found->list, &res->list);
+		rb_replace_node(&found->rbn, &res->rbn,
+				&dev->bss_tree);
+		/* XXX: workaround */
+		res->hold = found->hold;
+		kref_put(&found->ref, bss_release);
+		found = res;
+	} else if (found) {
+#endif
 		kref_get(&found->ref);
 		found->pub.beacon_interval = res->pub.beacon_interval;
 		found->pub.tsf = res->pub.tsf;
 		found->pub.signal = res->pub.signal;
 		found->pub.capability = res->pub.capability;
 		found->ts = res->ts;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 
 		/* overwrite IEs */
 		if (overwrite) {
@@ -399,6 +414,7 @@
 			}
 		}
 
+#endif
 		kref_put(&res->ref, bss_release);
 	} else {
 		/* this "consumes" the reference */
--- a/net/wireless/wext-compat.c
+++ b/net/wireless/wext-compat.c
@@ -764,7 +764,11 @@ int cfg80211_wext_siwtxpower(struct net_device *dev,
 
 	/* only change when not disabling */
 	if (!data->txpower.disabled) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 		rfkill_set_sw_state(rdev->rfkill, false);
+#else
+		backport_rfkill_set_sw_state(rdev->rfkill, false);
+#endif
 
 		if (data->txpower.fixed) {
 			/*
@@ -789,7 +793,11 @@ int cfg80211_wext_siwtxpower(struct net_device *dev,
 			}
 		}
 	} else {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 		rfkill_set_sw_state(rdev->rfkill, true);
+#else
+		backport_rfkill_set_sw_state(rdev->rfkill, true);
+#endif
 		schedule_work(&rdev->rfkill_sync);
 		return 0;
 	}
@@ -820,7 +828,11 @@ int cfg80211_wext_giwtxpower(struct net_device *dev,
 
 	/* well... oh well */
 	data->txpower.fixed = 1;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31))
 	data->txpower.disabled = rfkill_blocked(rdev->rfkill);
+#else
+	data->txpower.disabled = backport_rfkill_blocked(rdev->rfkill);
+#endif
 	data->txpower.value = val;
 	data->txpower.flags = IW_TXPOW_DBM;
 
