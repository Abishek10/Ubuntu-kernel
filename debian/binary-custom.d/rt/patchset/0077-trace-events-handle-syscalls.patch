Add syscall tracing in event trace.

Signed-off-by: Steven Rostedt <srostedt@redhat.com>
---
 kernel/trace/trace.c        |  106 ++++++++++++++++++++++++++++++++++++++++++++
 kernel/trace/trace.h        |   28 +++++++++++
 kernel/trace/trace_events.c |   92 ++++++++++++++++++++++++++++++++++++++
 3 files changed, 226 insertions(+)

Index: linux-2.6.24.2-rt2/kernel/trace/trace_events.c
===================================================================
--- linux-2.6.24.2-rt2.orig/kernel/trace/trace_events.c	2008-02-21 13:11:17.000000000 -0500
+++ linux-2.6.24.2-rt2/kernel/trace/trace_events.c	2008-02-21 13:11:18.000000000 -0500
@@ -101,6 +101,98 @@ notrace void trace_event_wakeup(struct t
 
 #define getarg(arg, ap) arg = va_arg(ap, typeof(arg));
 
+/* HACK */
+void notrace
+sys_call(unsigned long nr, unsigned long p1, unsigned long p2, unsigned long p3)
+{
+	struct trace_array *tr;
+	struct trace_array_cpu *data;
+	unsigned long flags;
+	unsigned long ip;
+	int cpu;
+
+	if (!ftrace_events_enabled || !events_trace)
+		return;
+
+	tr = events_trace;
+	local_irq_save(flags);
+	cpu = raw_smp_processor_id();
+	data = tr->data[cpu];
+
+	atomic_inc(&data->disabled);
+	if (atomic_read(&data->disabled) != 1)
+		goto out;
+
+	ip = CALLER_ADDR0;
+
+	tracing_event_syscall(tr, data, flags, ip, nr, p1, p2, p3);
+
+ out:
+	atomic_dec(&data->disabled);
+	local_irq_restore(flags);
+}
+
+#if defined(CONFIG_COMPAT) && defined(CONFIG_X86)
+void notrace
+sys_ia32_call(unsigned long nr, unsigned long p1, unsigned long p2,
+	      unsigned long p3)
+{
+	struct trace_array *tr;
+	struct trace_array_cpu *data;
+	unsigned long flags;
+	unsigned long ip;
+	int cpu;
+
+	if (!ftrace_events_enabled || !events_trace)
+		return;
+
+	tr = events_trace;
+	local_irq_save(flags);
+	cpu = raw_smp_processor_id();
+	data = tr->data[cpu];
+
+	atomic_inc(&data->disabled);
+	if (atomic_read(&data->disabled) != 1)
+		goto out;
+
+	ip = CALLER_ADDR0;
+	tracing_event_syscall(tr, data, flags, ip, nr | 0x80000000, p1, p2, p3);
+
+ out:
+	atomic_dec(&data->disabled);
+	local_irq_restore(flags);
+}
+#endif
+
+void notrace
+sys_ret(unsigned long ret)
+{
+	struct trace_array *tr;
+	struct trace_array_cpu *data;
+	unsigned long flags;
+	unsigned long ip;
+	int cpu;
+
+	if (!ftrace_events_enabled || !events_trace)
+		return;
+
+	tr = events_trace;
+	local_irq_save(flags);
+	cpu = raw_smp_processor_id();
+	data = tr->data[cpu];
+
+	atomic_inc(&data->disabled);
+	if (atomic_read(&data->disabled) != 1)
+		goto out;
+
+	ip = CALLER_ADDR0;
+	tracing_event_sysret(tr, data, flags, ip, ret);
+
+ out:
+	atomic_dec(&data->disabled);
+	local_irq_restore(flags);
+}
+
 notrace void ftrace_record_event(enum ftrace_event_enum event, ...)
 {
 	struct trace_array *tr = events_trace;
Index: linux-2.6.24.2-rt2/kernel/trace/trace.c
===================================================================
--- linux-2.6.24.2-rt2.orig/kernel/trace/trace.c	2008-02-21 13:11:17.000000000 -0500
+++ linux-2.6.24.2-rt2/kernel/trace/trace.c	2008-02-21 13:11:18.000000000 -0500
@@ -27,6 +27,9 @@
 #include <linux/gfp.h>
 #include <linux/fs.h>
 
+#include <asm/asm-offsets.h>
+#include <asm/unistd.h>
+
 #include "trace.h"
 
 unsigned long __read_mostly	tracing_max_latency = (cycle_t)ULONG_MAX;
@@ -85,6 +88,8 @@ enum trace_type {
 	TRACE_TIMESTAMP,
 	TRACE_TASK,
 	TRACE_WAKEUP,
+	TRACE_SYSCALL,
+	TRACE_SYSRET,
 
 	__TRACE_LAST_TYPE
 };
@@ -577,6 +582,42 @@ void tracing_event_wakeup(struct trace_a
 	entry->wakeup.curr_prio	= curr_prio;
 }
 
+void tracing_event_syscall(struct trace_array *tr,
+			   struct trace_array_cpu *data,
+			   unsigned long flags,
+			   unsigned long ip,
+			   unsigned long nr,
+			   unsigned long p1,
+			   unsigned long p2,
+			   unsigned long p3)
+{
+	struct trace_entry *entry;
+
+	entry = tracing_get_trace_entry(tr, data);
+	tracing_generic_entry_update(entry, flags);
+	entry->type			= TRACE_SYSCALL;
+	entry->syscall.ip		= ip;
+	entry->syscall.nr		= nr;
+	entry->syscall.p1		= p1;
+	entry->syscall.p2		= p2;
+	entry->syscall.p3		= p3;
+}
+
+void tracing_event_sysret(struct trace_array *tr,
+			  struct trace_array_cpu *data,
+			  unsigned long flags,
+			  unsigned long ip,
+			  unsigned long ret)
+{
+	struct trace_entry *entry;
+
+	entry = tracing_get_trace_entry(tr, data);
+	tracing_generic_entry_update(entry, flags);
+	entry->type			= TRACE_SYSRET;
+	entry->sysret.ip		= ip;
+	entry->sysret.ret		= ret;
+}
+
 enum trace_file_type {
 	TRACE_FILE_LAT_FMT	= 1,
 };
@@ -938,6 +979,13 @@ lat_print_timestamp(struct seq_file *m, 
 
 static const char state_to_char[] = TASK_STATE_TO_CHAR_STR;
 
+extern unsigned long sys_call_table[NR_syscalls];
+
+#if defined(CONFIG_COMPAT) && defined(CONFIG_X86)
+extern unsigned long ia32_sys_call_table[], ia32_syscall_end[];
+# define IA32_NR_syscalls (ia32_syscall_end - ia32_sys_call_table)
+#endif
+
 static void notrace
 print_lat_fmt(struct seq_file *m, struct trace_iterator *iter,
 	      unsigned int trace_idx, int cpu)
@@ -949,6 +997,7 @@ print_lat_fmt(struct seq_file *m, struct
 	unsigned long abs_usecs;
 	unsigned long rel_usecs;
 	char *comm;
+	unsigned long nr;
 	int S;
 
 	if (!next_entry)
@@ -1033,6 +1082,34 @@ print_lat_fmt(struct seq_file *m, struct
 			   comm, entry->wakeup.pid,
 			   entry->wakeup.prio, entry->wakeup.curr_prio);
 		break;
+	case TRACE_SYSCALL:
+		seq_print_ip_sym(m, entry->syscall.ip, sym_flags);
+		nr = entry->syscall.nr;
+		seq_putc(m, ' ');
+#if defined(CONFIG_COMPAT) && defined(CONFIG_X86)
+		if (nr & 0x80000000) {
+			nr &= ~0x80000000;
+			if (nr < IA32_NR_syscalls)
+				seq_print_ip_sym(m, ia32_sys_call_table[nr], 0);
+			else
+				seq_printf(m, "<badsys(%lu)>", nr);
+		} else
+#endif
+			if (nr < NR_syscalls)
+				seq_print_ip_sym(m, sys_call_table[nr], 0);
+			else
+				seq_printf(m, "<badsys(%lu)>", nr);
+
+		seq_printf(m, " (%lx %lx %lx)\n",
+			   entry->syscall.p1,
+			   entry->syscall.p2,
+			   entry->syscall.p3);
+		break;
+	case TRACE_SYSRET:
+		seq_print_ip_sym(m, entry->sysret.ip, sym_flags);
+		seq_printf(m, " < (%ld)\n",
+			   entry->sysret.ret);
+		break;
 	default:
 		seq_printf(m, "Unknown type %d\n", entry->type);
 	}
@@ -1048,6 +1125,7 @@ print_trace_fmt(struct seq_file *m, stru
 	unsigned long secs;
 	char *comm;
 	int S;
+	long nr;
 
 	comm = trace_find_cmdline(iter->ent->pid);
 
@@ -1121,6 +1199,34 @@ print_trace_fmt(struct seq_file *m, stru
 			   comm, entry->wakeup.pid,
 			   entry->wakeup.prio, entry->wakeup.curr_prio);
 		break;
+	case TRACE_SYSCALL:
+		seq_print_ip_sym(m, entry->syscall.ip, sym_flags);
+		nr = entry->syscall.nr;
+		seq_putc(m, ' ');
+#if defined(CONFIG_COMPAT) && defined(CONFIG_X86)
+		if (nr & 0x80000000) {
+			nr &= ~0x80000000;
+			if (nr < IA32_NR_syscalls)
+				seq_print_ip_sym(m, ia32_sys_call_table[nr], 0);
+			else
+				seq_printf(m, "<badsys(%lu)>", nr);
+		} else
+#endif
+			if (nr < NR_syscalls)
+				seq_print_ip_sym(m, sys_call_table[nr], 0);
+			else
+				seq_printf(m, "<badsys(%lu)>", nr);
+
+		seq_printf(m, " (%lx %lx %lx)\n",
+			   entry->syscall.p1,
+			   entry->syscall.p2,
+			   entry->syscall.p3);
+		break;
+	case TRACE_SYSRET:
+		seq_print_ip_sym(m, entry->sysret.ip, sym_flags);
+		seq_printf(m, "< (%ld)\n",
+			   entry->sysret.ret);
+		break;
 	}
 	seq_printf(m, "\n");
 }
Index: linux-2.6.24.2-rt2/kernel/trace/trace.h
===================================================================
--- linux-2.6.24.2-rt2.orig/kernel/trace/trace.h	2008-02-21 13:11:17.000000000 -0500
+++ linux-2.6.24.2-rt2/kernel/trace/trace.h	2008-02-21 13:11:18.000000000 -0500
@@ -64,6 +64,19 @@ struct wakeup_entry {
 	unsigned		curr_prio;
 };
 
+struct syscall_entry {
+	unsigned long		ip;
+	unsigned long		nr;
+	unsigned long		p1;
+	unsigned long		p2;
+	unsigned long		p3;
+};
+
+struct sysret_entry {
+	unsigned long		ip;
+	unsigned long		ret;
+};
+
 /*
  * The trace entry - the most basic unit of tracing. This is what
  * is printed in the end as a single line in the trace output, such as:
@@ -87,6 +100,8 @@ struct trace_entry {
 		struct timestamp_entry		timestamp;
 		struct task_entry		task;
 		struct wakeup_entry		wakeup;
+		struct syscall_entry		syscall;
+		struct sysret_entry		sysret;
 	};
 };
 
@@ -214,6 +229,19 @@ void tracing_event_wakeup(struct trace_a
 			  unsigned long ip,
 			  pid_t pid, int prio,
 			  int curr_prio);
+void tracing_event_syscall(struct trace_array *tr,
+			   struct trace_array_cpu *data,
+			   unsigned long flags,
+			   unsigned long ip,
+			   unsigned long nr,
+			   unsigned long p1,
+			   unsigned long p2,
+			   unsigned long p3);
+void tracing_event_sysret(struct trace_array *tr,
+			  struct trace_array_cpu *data,
+			  unsigned long flags,
+			  unsigned long ip,
+			  unsigned long ret);
 
 void tracing_start_function_trace(void);
 void tracing_stop_function_trace(void);
