From: Sebastian Siewior <bigeasy@linutronix.de>
Date: Sun, 27 Apr 2008 14:28:21 +0200
Subject: m68knommu: upstream pending patches

That's a conglomerate of Greg Ungerers and Sebastian Siewiors
m68knommu patches which are not in .24 but on the way upstream
(partly included in .25/.26)

Compressed-into-one-patch-by: tglx
---
 arch/m68knommu/Kconfig                       |   24 
 arch/m68knommu/Makefile                      |   31 
 arch/m68knommu/kernel/asm-offsets.c          |    1 
 arch/m68knommu/kernel/irq.c                  |   11 
 arch/m68knommu/kernel/setup.c                |    2 
 arch/m68knommu/kernel/time.c                 |  109 -
 arch/m68knommu/kernel/traps.c                |  112 +
 arch/m68knommu/kernel/vmlinux.lds.S          |   90 -
 arch/m68knommu/platform/5206/config.c        |   76 -
 arch/m68knommu/platform/5206e/config.c       |   80 -
 arch/m68knommu/platform/520x/config.c        |  101 +
 arch/m68knommu/platform/523x/config.c        |  138 +-
 arch/m68knommu/platform/5249/config.c        |   77 -
 arch/m68knommu/platform/5272/config.c        |   89 -
 arch/m68knommu/platform/527x/config.c        |   87 +
 arch/m68knommu/platform/528x/config.c        |  355 +++++
 arch/m68knommu/platform/5307/Makefile        |   14 
 arch/m68knommu/platform/5307/config.c        |   88 -
 arch/m68knommu/platform/5307/entry.S         |  235 ---
 arch/m68knommu/platform/5307/head.S          |  222 ---
 arch/m68knommu/platform/5307/pit.c           |   97 -
 arch/m68knommu/platform/5307/timers.c        |  155 --
 arch/m68knommu/platform/5307/vectors.c       |  105 -
 arch/m68knommu/platform/532x/config.c        |  179 +-
 arch/m68knommu/platform/532x/spi-mcf532x.c   |  176 ++
 arch/m68knommu/platform/532x/usb-mcf532x.c   |  171 ++
 arch/m68knommu/platform/5407/config.c        |   83 -
 arch/m68knommu/platform/68328/ints.c         |    2 
 arch/m68knommu/platform/68328/timers.c       |   56 
 arch/m68knommu/platform/68360/config.c       |    5 
 arch/m68knommu/platform/coldfire/Makefile    |   32 
 arch/m68knommu/platform/coldfire/dma.c       |   39 
 arch/m68knommu/platform/coldfire/dma_timer.c |   84 +
 arch/m68knommu/platform/coldfire/entry.S     |  241 +++
 arch/m68knommu/platform/coldfire/head.S      |  222 +++
 arch/m68knommu/platform/coldfire/irq_chip.c  |  110 +
 arch/m68knommu/platform/coldfire/pit.c       |  180 ++
 arch/m68knommu/platform/coldfire/timers.c    |  182 ++
 arch/m68knommu/platform/coldfire/vectors.c   |  105 +
 drivers/net/fec.c                            | 1812 +++++++++++++--------------
 drivers/serial/68328serial.c                 |    2 
 drivers/serial/mcf.c                         |   22 
 drivers/serial/mcfserial.c                   |  121 -
 fs/nfs/file.c                                |    4 
 include/asm-generic/vmlinux.lds.h            |   40 
 include/asm-m68knommu/bitops.h               |   30 
 include/asm-m68knommu/byteorder.h            |   16 
 include/asm-m68knommu/cacheflush.h           |    2 
 include/asm-m68knommu/commproc.h             |   19 
 include/asm-m68knommu/dma.h                  |    3 
 include/asm-m68knommu/m523xsim.h             |  147 ++
 include/asm-m68knommu/m528xsim.h             |   63 
 include/asm-m68knommu/m532xsim.h             |   86 -
 include/asm-m68knommu/mcfcache.h             |    2 
 include/asm-m68knommu/mcfuart.h              |    3 
 mm/nommu.c                                   |   10 
 mm/page_alloc.c                              |    8 
 57 files changed, 4172 insertions(+), 2384 deletions(-)

Index: linux-2.6.24.7-rt27/arch/m68knommu/Kconfig
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/Kconfig	2009-02-08 00:00:32.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/Kconfig	2009-02-08 00:00:48.000000000 -0500
@@ -53,10 +53,22 @@ config GENERIC_CALIBRATE_DELAY
 	bool
 	default y
 
+config GENERIC_TIME
+	bool
+	default y
+
+config GENERIC_CMOS_UPDATE
+	bool
+	default y
+
 config TIME_LOW_RES
 	bool
 	default y
 
+config GENERIC_CLOCKEVENTS
+	bool
+	default n
+
 config NO_IOPORT
 	def_bool y
 
@@ -100,11 +112,14 @@ config M5206e
 
 config M520x
 	bool "MCF520x"
+	select GENERIC_CLOCKEVENTS
 	help
 	   Freescale Coldfire 5207/5208 processor support.
 
 config M523x
 	bool "MCF523x"
+	select GENERIC_CLOCKEVENTS
+	select GENERIC_HARDIRQS_NO__DO_IRQ
 	help
 	  Freescale Coldfire 5230/1/2/4/5 processor support
 
@@ -130,6 +145,7 @@ config M5275
 
 config M528x
 	bool "MCF528x"
+	select GENERIC_CLOCKEVENTS
 	help
 	  Motorola ColdFire 5280/5282 processor support.
 
@@ -153,6 +169,7 @@ endchoice
 config M527x
 	bool
 	depends on (M5271 || M5275)
+	select GENERIC_CLOCKEVENTS
 	default y
 
 config COLDFIRE
@@ -658,6 +675,13 @@ config ROMKERNEL
 
 endchoice
 
+config GENERIC_HARDIRQS_NO__DO_IRQ
+	bool "Force generic IRQ implementation"
+
+source "kernel/time/Kconfig"
+if COLDFIRE
+source "kernel/Kconfig.preempt"
+endif
 source "mm/Kconfig"
 
 endmenu
Index: linux-2.6.24.7-rt27/arch/m68knommu/Makefile
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/Makefile	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/Makefile	2009-02-08 00:00:48.000000000 -0500
@@ -61,17 +61,17 @@ MODEL := $(model-y)
 # for the selected cpu. ONLY need to define this for the non-base member
 # of the family.
 #
-cpuclass-$(CONFIG_M5206)	:= 5307
-cpuclass-$(CONFIG_M5206e)	:= 5307
-cpuclass-$(CONFIG_M520x)	:= 5307
-cpuclass-$(CONFIG_M523x)	:= 5307
-cpuclass-$(CONFIG_M5249)	:= 5307
-cpuclass-$(CONFIG_M527x)	:= 5307
-cpuclass-$(CONFIG_M5272)	:= 5307
-cpuclass-$(CONFIG_M528x)	:= 5307
-cpuclass-$(CONFIG_M5307)	:= 5307
-cpuclass-$(CONFIG_M532x)	:= 5307
-cpuclass-$(CONFIG_M5407)	:= 5307
+cpuclass-$(CONFIG_M5206)	:= coldfire
+cpuclass-$(CONFIG_M5206e)	:= coldfire
+cpuclass-$(CONFIG_M520x)	:= coldfire
+cpuclass-$(CONFIG_M523x)	:= coldfire
+cpuclass-$(CONFIG_M5249)	:= coldfire
+cpuclass-$(CONFIG_M527x)	:= coldfire
+cpuclass-$(CONFIG_M5272)	:= coldfire
+cpuclass-$(CONFIG_M528x)	:= coldfire
+cpuclass-$(CONFIG_M5307)	:= coldfire
+cpuclass-$(CONFIG_M532x)	:= coldfire
+cpuclass-$(CONFIG_M5407)	:= coldfire
 cpuclass-$(CONFIG_M68328)	:= 68328
 cpuclass-$(CONFIG_M68EZ328)	:= 68328
 cpuclass-$(CONFIG_M68VZ328)	:= 68328
@@ -90,13 +90,14 @@ export PLATFORM BOARD MODEL CPUCLASS
 cflags-$(CONFIG_M5206)		:= -m5200
 cflags-$(CONFIG_M5206e)		:= -m5200
 cflags-$(CONFIG_M520x)		:= -m5307
-cflags-$(CONFIG_M523x)		:= -m5307
+cflags-$(CONFIG_M523x)		:= $(call cc-option,-mcpu=523x,-m5307)
 cflags-$(CONFIG_M5249)		:= -m5200
-cflags-$(CONFIG_M527x)		:= -m5307
+cflags-$(CONFIG_M5271)		:= $(call cc-option,-mcpu=5271,-m5307)
 cflags-$(CONFIG_M5272)		:= -m5307
-cflags-$(CONFIG_M528x)		:= -m5307
+cflags-$(CONFIG_M5275)		:= $(call cc-option,-mcpu=5275,-m5307)
+cflags-$(CONFIG_M528x)		:= $(call cc-option,-m528x,-m5307)
 cflags-$(CONFIG_M5307)		:= -m5307
-cflags-$(CONFIG_M532x)		:= -m5307
+cflags-$(CONFIG_M532x)		:= $(call cc-option,-mcpu=532x,-m5307)
 cflags-$(CONFIG_M5407)		:= -m5200
 cflags-$(CONFIG_M68328)		:= -m68000
 cflags-$(CONFIG_M68EZ328)	:= -m68000
Index: linux-2.6.24.7-rt27/arch/m68knommu/kernel/asm-offsets.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/kernel/asm-offsets.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/kernel/asm-offsets.c	2009-02-08 00:00:48.000000000 -0500
@@ -91,6 +91,7 @@ int main(void)
 	DEFINE(TI_TASK, offsetof(struct thread_info, task));
 	DEFINE(TI_EXECDOMAIN, offsetof(struct thread_info, exec_domain));
 	DEFINE(TI_FLAGS, offsetof(struct thread_info, flags));
+	DEFINE(TI_PREEMPTCOUNT, offsetof(struct thread_info, preempt_count));
 	DEFINE(TI_CPU, offsetof(struct thread_info, cpu));
 
 	return 0;
Index: linux-2.6.24.7-rt27/arch/m68knommu/kernel/irq.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/kernel/irq.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/kernel/irq.c	2009-02-08 00:00:48.000000000 -0500
@@ -23,7 +23,7 @@ asmlinkage void do_IRQ(int irq, struct p
 	struct pt_regs *oldregs = set_irq_regs(regs);
 
 	irq_enter();
-	__do_IRQ(irq);
+	generic_handle_irq(irq);
 	irq_exit();
 
 	set_irq_regs(oldregs);
@@ -34,12 +34,16 @@ void ack_bad_irq(unsigned int irq)
 	printk(KERN_ERR "IRQ: unexpected irq=%d\n", irq);
 }
 
+#ifndef CONFIG_M523x
 static struct irq_chip m_irq_chip = {
 	.name		= "M68K-INTC",
 	.enable		= enable_vector,
 	.disable	= disable_vector,
 	.ack		= ack_vector,
 };
+#else
+void coldfire_init_irq_chip(void);
+#endif
 
 void __init init_IRQ(void)
 {
@@ -47,12 +51,16 @@ void __init init_IRQ(void)
 
 	init_vectors();
 
+#ifndef CONFIG_M523x
 	for (irq = 0; (irq < NR_IRQS); irq++) {
 		irq_desc[irq].status = IRQ_DISABLED;
 		irq_desc[irq].action = NULL;
 		irq_desc[irq].depth = 1;
 		irq_desc[irq].chip = &m_irq_chip;
 	}
+#else
+	coldfire_init_irq_chip();
+#endif
 }
 
 int show_interrupts(struct seq_file *p, void *v)
@@ -79,4 +87,3 @@ int show_interrupts(struct seq_file *p, 
 
 	return 0;
 }
-
Index: linux-2.6.24.7-rt27/arch/m68knommu/kernel/setup.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/kernel/setup.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/kernel/setup.c	2009-02-08 00:00:48.000000000 -0500
@@ -165,7 +165,7 @@ void __init setup_arch(char **cmdline_p)
 	printk(KERN_INFO "DragonEngine II board support by Georges Menie\n");
 #endif
 #ifdef CONFIG_M5235EVB
-	printk(KERN_INFO "Motorola M5235EVB support (C)2005 Syn-tech Systems, Inc. (Jate Sujjavanich)");
+	printk(KERN_INFO "Motorola M5235EVB support (C)2005 Syn-tech Systems, Inc. (Jate Sujjavanich)\n");
 #endif
 
 #ifdef DEBUG
Index: linux-2.6.24.7-rt27/arch/m68knommu/kernel/time.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/kernel/time.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/kernel/time.c	2009-02-08 00:00:48.000000000 -0500
@@ -22,7 +22,6 @@
 #include <linux/timex.h>
 
 #include <asm/machdep.h>
-#include <asm/io.h>
 #include <asm/irq_regs.h>
 
 #define	TICK_SIZE (tick_nsec / 1000)
@@ -34,14 +33,13 @@ static inline int set_rtc_mmss(unsigned 
 	return -1;
 }
 
+#ifndef CONFIG_GENERIC_CLOCKEVENTS
 /*
  * timer_interrupt() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
  */
 irqreturn_t arch_timer_interrupt(int irq, void *dummy)
 {
-	/* last time the cmos clock got updated */
-	static long last_rtc_update=0;
 
 	write_seqlock(&xtime_lock);
 
@@ -52,49 +50,12 @@ irqreturn_t arch_timer_interrupt(int irq
 	if (current->pid)
 		profile_tick(CPU_PROFILING);
 
-	/*
-	 * If we have an externally synchronized Linux clock, then update
-	 * CMOS clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
-	 * called as close as possible to 500 ms before the new second starts.
-	 */
-	if (ntp_synced() &&
-	    xtime.tv_sec > last_rtc_update + 660 &&
-	    (xtime.tv_nsec / 1000) >= 500000 - ((unsigned) TICK_SIZE) / 2 &&
-	    (xtime.tv_nsec  / 1000) <= 500000 + ((unsigned) TICK_SIZE) / 2) {
-	  if (set_rtc_mmss(xtime.tv_sec) == 0)
-	    last_rtc_update = xtime.tv_sec;
-	  else
-	    last_rtc_update = xtime.tv_sec - 600; /* do it again in 60 s */
-	}
-#ifdef CONFIG_HEARTBEAT
-	/* use power LED as a heartbeat instead -- much more useful
-	   for debugging -- based on the version for PReP by Cort */
-	/* acts like an actual heart beat -- ie thump-thump-pause... */
-	if (mach_heartbeat) {
-	    static unsigned cnt = 0, period = 0, dist = 0;
-
-	    if (cnt == 0 || cnt == dist)
-		mach_heartbeat( 1 );
-	    else if (cnt == 7 || cnt == dist+7)
-		mach_heartbeat( 0 );
-
-	    if (++cnt > period) {
-		cnt = 0;
-		/* The hyperbolic function below modifies the heartbeat period
-		 * length in dependency of the current (5min) load. It goes
-		 * through the points f(0)=126, f(1)=86, f(5)=51,
-		 * f(inf)->30. */
-		period = ((672<<FSHIFT)/(5*avenrun[0]+(7<<FSHIFT))) + 30;
-		dist = period / 4;
-	    }
-	}
-#endif /* CONFIG_HEARTBEAT */
-
 	write_sequnlock(&xtime_lock);
 	return(IRQ_HANDLED);
 }
+#endif
 
-void time_init(void)
+static unsigned long read_rtc_mmss(void)
 {
 	unsigned int year, mon, day, hour, min, sec;
 
@@ -105,67 +66,21 @@ void time_init(void)
 
 	if ((year += 1900) < 1970)
 		year += 100;
-	xtime.tv_sec = mktime(year, mon, day, hour, min, sec);
-	xtime.tv_nsec = 0;
-	wall_to_monotonic.tv_sec = -xtime.tv_sec;
 
-	hw_timer_init();
+	return  mktime(year, mon, day, hour, min, sec);;
 }
 
-/*
- * This version of gettimeofday has near microsecond resolution.
- */
-void do_gettimeofday(struct timeval *tv)
+unsigned long read_persistent_clock(void)
 {
-	unsigned long flags;
-	unsigned long seq;
-	unsigned long usec, sec;
-
-	do {
-		seq = read_seqbegin_irqsave(&xtime_lock, flags);
-		usec = hw_timer_offset();
-		sec = xtime.tv_sec;
-		usec += (xtime.tv_nsec / 1000);
-	} while (read_seqretry_irqrestore(&xtime_lock, seq, flags));
-
-	while (usec >= 1000000) {
-		usec -= 1000000;
-		sec++;
-	}
-
-	tv->tv_sec = sec;
-	tv->tv_usec = usec;
+	return read_rtc_mmss();
 }
 
-EXPORT_SYMBOL(do_gettimeofday);
-
-int do_settimeofday(struct timespec *tv)
+int update_persistent_clock(struct timespec now)
 {
-	time_t wtm_sec, sec = tv->tv_sec;
-	long wtm_nsec, nsec = tv->tv_nsec;
-
-	if ((unsigned long)tv->tv_nsec >= NSEC_PER_SEC)
-		return -EINVAL;
-
-	write_seqlock_irq(&xtime_lock);
-	/*
-	 * This is revolting. We need to set the xtime.tv_usec
-	 * correctly. However, the value in this location is
-	 * is value at the last tick.
-	 * Discover what correction gettimeofday
-	 * would have done, and then undo it!
-	 */
-	nsec -= (hw_timer_offset() * 1000);
-
-	wtm_sec  = wall_to_monotonic.tv_sec + (xtime.tv_sec - sec);
-	wtm_nsec = wall_to_monotonic.tv_nsec + (xtime.tv_nsec - nsec);
-
-	set_normalized_timespec(&xtime, sec, nsec);
-	set_normalized_timespec(&wall_to_monotonic, wtm_sec, wtm_nsec);
+	return set_rtc_mmss(now.tv_sec);
+}
 
-	ntp_clear();
-	write_sequnlock_irq(&xtime_lock);
-	clock_was_set();
-	return 0;
+void time_init(void)
+{
+	hw_timer_init();
 }
-EXPORT_SYMBOL(do_settimeofday);
Index: linux-2.6.24.7-rt27/arch/m68knommu/kernel/traps.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/kernel/traps.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/kernel/traps.c	2009-02-08 00:00:48.000000000 -0500
@@ -28,6 +28,7 @@
 #include <linux/linkage.h>
 #include <linux/init.h>
 #include <linux/ptrace.h>
+#include <linux/kallsyms.h>
 
 #include <asm/setup.h>
 #include <asm/fpu.h>
@@ -102,56 +103,79 @@ asmlinkage void buserr_c(struct frame *f
 	force_sig(SIGSEGV, current);
 }
 
+static void print_this_address(unsigned long addr, int i)
+{
+#ifdef CONFIG_KALLSYMS
+	printk(KERN_EMERG " [%08lx] ", addr);
+	print_symbol(KERN_CONT "%s\n", addr);
+#else
+	if (i % 5)
+		printk(KERN_CONT " [%08lx] ", addr);
+	else
+		printk(KERN_CONT "\n" KERN_EMERG " [%08lx] ", addr);
+	i++;
+#endif
+}
 
 int kstack_depth_to_print = 48;
 
-void show_stack(struct task_struct *task, unsigned long *stack)
+static void __show_stack(struct task_struct *task, unsigned long *stack)
 {
 	unsigned long *endstack, addr;
-	extern char _start, _etext;
+#ifdef CONFIG_FRAME_POINTER
+	unsigned long *last_stack;
+#endif
 	int i;
 
-	if (!stack) {
-		if (task)
-			stack = (unsigned long *)task->thread.ksp;
-		else
-			stack = (unsigned long *)&stack;
-	}
+	if (!stack)
+		stack = (unsigned long *)task->thread.ksp;
 
 	addr = (unsigned long) stack;
 	endstack = (unsigned long *) PAGE_ALIGN(addr);
 
 	printk(KERN_EMERG "Stack from %08lx:", (unsigned long)stack);
 	for (i = 0; i < kstack_depth_to_print; i++) {
-		if (stack + 1 > endstack)
+		if (stack + 1 + i > endstack)
 			break;
 		if (i % 8 == 0)
 			printk("\n" KERN_EMERG "       ");
-		printk(" %08lx", *stack++);
+		printk(" %08lx", *(stack + i));
 	}
 	printk("\n");
-
-	printk(KERN_EMERG "Call Trace:");
 	i = 0;
-	while (stack + 1 <= endstack) {
+
+#ifdef CONFIG_FRAME_POINTER
+	printk(KERN_EMERG "Call Trace:\n");
+
+	last_stack = stack - 1;
+	while (stack <= endstack && stack > last_stack) {
+
+		addr = *(stack + 1);
+		print_this_address(addr, i);
+		i++;
+
+		last_stack = stack;
+		stack = (unsigned long *)*stack;
+	}
+	printk("\n");
+#else
+	printk(KERN_EMERG "Call Trace with CONFIG_FRAME_POINTER disabled:\n");
+	while (stack <= endstack) {
 		addr = *stack++;
 		/*
-		 * If the address is either in the text segment of the
-		 * kernel, or in the region which contains vmalloc'ed
-		 * memory, it *may* be the address of a calling
-		 * routine; if so, print it so that someone tracing
-		 * down the cause of the crash will be able to figure
-		 * out the call path that was taken.
+		 * If the address is either in the text segment of the kernel,
+		 * or in a region which is occupied by a module then it *may*
+		 * be the address of a calling routine; if so, print it so that
+		 * someone tracing down the cause of the crash will be able to
+		 * figure out the call path that was taken.
 		 */
-		if (((addr >= (unsigned long) &_start) &&
-		     (addr <= (unsigned long) &_etext))) {
-			if (i % 4 == 0)
-				printk("\n" KERN_EMERG "       ");
-			printk(" [<%08lx>]", addr);
+		if (__kernel_text_address(addr)) {
+			print_this_address(addr, i);
 			i++;
 		}
 	}
-	printk("\n");
+	printk(KERN_CONT "\n");
+#endif
 }
 
 void bad_super_trap(struct frame *fp)
@@ -298,19 +322,47 @@ asmlinkage void set_esp0(unsigned long s
 	current->thread.esp0 = ssp;
 }
 
-
 /*
  * The architecture-independent backtrace generator
  */
 void dump_stack(void)
 {
-	unsigned long stack;
-
-	show_stack(current, &stack);
+	/*
+	 * We need frame pointers for this little trick, which works as follows:
+	 *
+	 * +------------+ 0x00
+	 * | Next SP	|	-> 0x0c
+	 * +------------+ 0x04
+	 * | Caller	|
+	 * +------------+ 0x08
+	 * | Local vars	|	-> our stack var
+	 * +------------+ 0x0c
+	 * | Next SP	|	-> 0x18, that is what we pass to show_stack()
+	 * +------------+ 0x10
+	 * | Caller	|
+	 * +------------+ 0x14
+	 * | Local vars	|
+	 * +------------+ 0x18
+	 * | ...	|
+	 * +------------+
+	 */
+
+	unsigned long *stack;
+
+	stack = (unsigned long *)&stack;
+	stack++;
+	__show_stack(current, stack);
 }
-
 EXPORT_SYMBOL(dump_stack);
 
+void show_stack(struct task_struct *task, unsigned long *stack)
+{
+	if (!stack && !task)
+		dump_stack();
+	else
+		__show_stack(task, stack);
+}
+
 #ifdef CONFIG_M68KFPU_EMU
 asmlinkage void fpemu_signal(int signal, int code, void *addr)
 {
Index: linux-2.6.24.7-rt27/arch/m68knommu/kernel/vmlinux.lds.S
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/kernel/vmlinux.lds.S	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/kernel/vmlinux.lds.S	2009-02-08 00:00:48.000000000 -0500
@@ -7,6 +7,8 @@
  *	run kernels.
  */
 
+#define	OUTPUT_DATA_SECTION > DATA
+
 #include <asm-generic/vmlinux.lds.h>
 
 #if defined(CONFIG_RAMKERNEL)
@@ -34,7 +36,6 @@
 #define	DATA_ADDR
 #endif
 
-
 OUTPUT_ARCH(m68k)
 ENTRY(_start)
 
@@ -64,81 +65,32 @@ SECTIONS {
 		_stext = . ;
 		TEXT_TEXT
 		SCHED_TEXT
+		LOCK_TEXT
         	*(.text.lock)
 
-		. = ALIGN(16);          /* Exception table              */
-		__start___ex_table = .;
-		*(__ex_table)
-		__stop___ex_table = .;
-
-		*(.rodata) *(.rodata.*)
-		*(__vermagic)		/* Kernel version magic */
-		*(.rodata1)
-		*(.rodata.str1.1)
-
-		/* Kernel symbol table: Normal symbols */
-		. = ALIGN(4);
-		__start___ksymtab = .;
-		*(__ksymtab)
-		__stop___ksymtab = .;
-
-		/* Kernel symbol table: GPL-only symbols */
-		__start___ksymtab_gpl = .;
-		*(__ksymtab_gpl)
-		__stop___ksymtab_gpl = .;
-
-		/* Kernel symbol table: Normal unused symbols */
-		__start___ksymtab_unused = .;
-		*(__ksymtab_unused)
-		__stop___ksymtab_unused = .;
-
-		/* Kernel symbol table: GPL-only unused symbols */
-		__start___ksymtab_unused_gpl = .;
-		*(__ksymtab_unused_gpl)
-		__stop___ksymtab_unused_gpl = .;
-
-		/* Kernel symbol table: GPL-future symbols */
-		__start___ksymtab_gpl_future = .;
-		*(__ksymtab_gpl_future)
-		__stop___ksymtab_gpl_future = .;
-
-		/* Kernel symbol table: Normal symbols */
-		__start___kcrctab = .;
-		*(__kcrctab)
-		__stop___kcrctab = .;
-
-		/* Kernel symbol table: GPL-only symbols */
-		__start___kcrctab_gpl = .;
-		*(__kcrctab_gpl)
-		__stop___kcrctab_gpl = .;
-
-		/* Kernel symbol table: GPL-future symbols */
-		__start___kcrctab_gpl_future = .;
-		*(__kcrctab_gpl_future)
-		__stop___kcrctab_gpl_future = .;
-
-		/* Kernel symbol table: strings */
-		*(__ksymtab_strings)
-
-		/* Built-in module parameters */
-		. = ALIGN(4) ;
-		__start___param = .;
-		*(__param)
-		__stop___param = .;
-
 		. = ALIGN(4) ;
-		_etext = . ;
 	} > TEXT
 
+	_etext = . ;
+
+	RODATA
+
 	.data DATA_ADDR : {
 		. = ALIGN(4);
 		_sdata = . ;
 		DATA_DATA
+		. = ALIGN(16);          /* Exception table              */
+		__start___ex_table = .;
+		*(__ex_table)
+		__stop___ex_table = .;
 		. = ALIGN(8192) ;
 		*(.data.init_task)
 		_edata = . ;
 	} > DATA
 
+	BUG_TABLE
+	PERCPU(4096)
+
 	.init : {
 		. = ALIGN(4096);
 		__init_begin = .;
@@ -169,12 +121,6 @@ SECTIONS {
 		__init_end = .;
 	} > INIT
 
-	/DISCARD/ : {
-		*(.exit.text)
-		*(.exit.data)
-		*(.exitcall.exit)
-	}
-
 	.bss : {
 		. = ALIGN(4);
 		_sbss = . ;
@@ -184,5 +130,11 @@ SECTIONS {
 		_ebss = . ;
 	} > BSS
 
-}
+	_end = . ;
 
+	/DISCARD/ : {
+		*(.exit.text)
+		*(.exit.data)
+		*(.exitcall.exit)
+	}
+}
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/5206/config.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/5206/config.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/5206/config.c	2009-02-08 00:00:48.000000000 -0500
@@ -13,12 +13,11 @@
 #include <linux/param.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>
+#include <linux/io.h>
 #include <asm/machdep.h>
 #include <asm/coldfire.h>
-#include <asm/mcftimer.h>
 #include <asm/mcfsim.h>
-#include <asm/mcfdma.h>
+#include <asm/mcfuart.h>
 
 /***************************************************************************/
 
@@ -26,15 +25,51 @@ void coldfire_reset(void);
 
 /***************************************************************************/
 
-/*
- *	DMA channel base address table.
- */
-unsigned int   dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
-        MCF_MBAR + MCFDMA_BASE0,
-        MCF_MBAR + MCFDMA_BASE1,
+static struct mcf_platform_uart m5206_uart_platform[] = {
+	{
+		.mapbase	= MCF_MBAR + MCFUART_BASE1,
+		.irq		= 73,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE2,
+		.irq		= 74,
+	},
+	{ },
 };
 
-unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+static struct platform_device m5206_uart = {
+	.name			= "mcfuart",
+	.id			= 0,
+	.dev.platform_data	= m5206_uart_platform,
+};
+
+static struct platform_device *m5206_devices[] __initdata = {
+	&m5206_uart,
+};
+
+/***************************************************************************/
+
+static void __init m5206_uart_init_line(int line, int irq)
+{
+	if (line == 0) {
+		writel(MCFSIM_ICR_LEVEL6 | MCFSIM_ICR_PRI1, MCF_MBAR + MCFSIM_UART1ICR);
+		writeb(irq, MCFUART_BASE1 + MCFUART_UIVR);
+		mcf_setimr(mcf_getimr() & ~MCFSIM_IMR_UART1);
+	} else if (line == 1) {
+		writel(MCFSIM_ICR_LEVEL6 | MCFSIM_ICR_PRI2, MCF_MBAR + MCFSIM_UART2ICR);
+		writeb(irq, MCFUART_BASE2 + MCFUART_UIVR);
+		mcf_setimr(mcf_getimr() & ~MCFSIM_IMR_UART2);
+	}
+}
+
+static void __init m5206_uarts_init(void)
+{
+	const int nrlines = ARRAY_SIZE(m5206_uart_platform);
+	int line;
+
+	for (line = 0; (line < nrlines); line++)
+		m5206_uart_init_line(line, m5206_uart_platform[line].irq);
+}
 
 /***************************************************************************/
 
@@ -74,24 +109,21 @@ void mcf_settimericr(unsigned int timer,
 
 /***************************************************************************/
 
-int mcf_timerirqpending(int timer)
+void __init config_BSP(char *commandp, int size)
 {
-	unsigned int imr = 0;
-
-	switch (timer) {
-	case 1:  imr = MCFSIM_IMR_TIMER1; break;
-	case 2:  imr = MCFSIM_IMR_TIMER2; break;
-	default: break;
-	}
-	return (mcf_getipr() & imr);
+	mcf_setimr(MCFSIM_IMR_MASKALL);
+	mach_reset = coldfire_reset;
 }
 
 /***************************************************************************/
 
-void config_BSP(char *commandp, int size)
+static int __init init_BSP(void)
 {
-	mcf_setimr(MCFSIM_IMR_MASKALL);
-	mach_reset = coldfire_reset;
+	m5206_uarts_init();
+	platform_add_devices(m5206_devices, ARRAY_SIZE(m5206_devices));
+	return 0;
 }
 
+arch_initcall(init_BSP);
+
 /***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/5206e/config.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/5206e/config.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/5206e/config.c	2009-02-08 00:00:48.000000000 -0500
@@ -10,8 +10,9 @@
 
 #include <linux/kernel.h>
 #include <linux/param.h>
+#include <linux/init.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>
+#include <linux/io.h>
 #include <asm/machdep.h>
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
@@ -23,15 +24,51 @@ void coldfire_reset(void);
 
 /***************************************************************************/
 
-/*
- *	DMA channel base address table.
- */
-unsigned int   dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
-        MCF_MBAR + MCFDMA_BASE0,
-        MCF_MBAR + MCFDMA_BASE1,
+static struct mcf_platform_uart m5206_uart_platform[] = {
+	{
+		.mapbase	= MCF_MBAR + MCFUART_BASE1,
+		.irq		= 73,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE2,
+		.irq		= 74,
+	},
+	{ },
 };
 
-unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+static struct platform_device m5206_uart = {
+	.name			= "mcfuart",
+	.id			= 0,
+	.dev.platform_data	= m5206_uart_platform,
+};
+
+static struct platform_device *m5206_devices[] __initdata = {
+	&m5206_uart,
+};
+
+/***************************************************************************/
+
+static void __init m5206_uart_init_line(int line, int irq)
+{
+	if (line == 0) {
+		writel(MCFSIM_ICR_LEVEL6 | MCFSIM_ICR_PRI1, MCF_MBAR + MCFSIM_UART1ICR);
+		writeb(irq, MCFUART_BASE1 + MCFUART_UIVR);
+		mcf_setimr(mcf_getimr() & ~MCFSIM_IMR_UART1);
+	} else if (line == 1) {
+		writel(MCFSIM_ICR_LEVEL6 | MCFSIM_ICR_PRI2, MCF_MBAR + MCFSIM_UART2ICR);
+		writeb(irq, MCFUART_BASE2 + MCFUART_UIVR);
+		mcf_setimr(mcf_getimr() & ~MCFSIM_IMR_UART2);
+	}
+}
+
+static void __init m5206_uarts_init(void)
+{
+	const int nrlines = ARRAY_SIZE(m5206_uart_platform);
+	int line;
+
+	for (line = 0; (line < nrlines); line++)
+		m5206_uart_init_line(line, m5206_uart_platform[line].irq);
+}
 
 /***************************************************************************/
 
@@ -71,21 +108,7 @@ void mcf_settimericr(unsigned int timer,
 
 /***************************************************************************/
 
-int mcf_timerirqpending(int timer)
-{
-	unsigned int imr = 0;
-
-	switch (timer) {
-	case 1:  imr = MCFSIM_IMR_TIMER1; break;
-	case 2:  imr = MCFSIM_IMR_TIMER2; break;
-	default: break;
-	}
-	return (mcf_getipr() & imr);
-}
-
-/***************************************************************************/
-
-void config_BSP(char *commandp, int size)
+void __init config_BSP(char *commandp, int size)
 {
 	mcf_setimr(MCFSIM_IMR_MASKALL);
 
@@ -99,3 +122,14 @@ void config_BSP(char *commandp, int size
 }
 
 /***************************************************************************/
+
+static int __init init_BSP(void)
+{
+	m5206_uarts_init();
+	platform_add_devices(m5206_devices, ARRAY_SIZE(m5206_devices));
+	return 0;
+}
+
+arch_initcall(init_BSP);
+
+/***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/520x/config.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/520x/config.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/520x/config.c	2009-02-08 00:00:48.000000000 -0500
@@ -5,7 +5,7 @@
  *
  *  Copyright (C) 2005,      Freescale (www.freescale.com)
  *  Copyright (C) 2005,      Intec Automation (mike@steroidmicros.com)
- *  Copyright (C) 1999-2003, Greg Ungerer (gerg@snapgear.com)
+ *  Copyright (C) 1999-2007, Greg Ungerer (gerg@snapgear.com)
  *  Copyright (C) 2001-2003, SnapGear Inc. (www.snapgear.com)
  */
 
@@ -13,21 +13,93 @@
 
 #include <linux/kernel.h>
 #include <linux/param.h>
+#include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/io.h>
 #include <asm/machdep.h>
-#include <asm/dma.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+#include <asm/mcfuart.h>
 
 /***************************************************************************/
 
-/*
- *	DMA channel base address table.
- */
-unsigned int dma_base_addr[MAX_M68K_DMA_CHANNELS];
-unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+void coldfire_reset(void);
 
 /***************************************************************************/
 
-void coldfire_reset(void);
+static struct mcf_platform_uart m520x_uart_platform[] = {
+	{
+		.mapbase	= MCF_MBAR + MCFUART_BASE1,
+		.irq		= MCFINT_VECBASE + MCFINT_UART0,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE2,
+		.irq		= MCFINT_VECBASE + MCFINT_UART1,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE3,
+		.irq		= MCFINT_VECBASE + MCFINT_UART2,
+	},
+	{ },
+};
+
+static struct platform_device m520x_uart = {
+	.name			= "mcfuart",
+	.id			= 0,
+	.dev.platform_data	= m520x_uart_platform,
+};
+
+static struct platform_device *m520x_devices[] __initdata = {
+	&m520x_uart,
+};
+
+/***************************************************************************/
+
+#define	INTC0	(MCF_MBAR + MCFICM_INTC0)
+
+static void __init m520x_uart_init_line(int line, int irq)
+{
+	u32 imr;
+	u16 par;
+	u8 par2;
+
+	writeb(0x03, INTC0 + MCFINTC_ICR0 + MCFINT_UART0 + line);
+
+	imr = readl(INTC0 + MCFINTC_IMRL);
+	imr &= ~((1 << (irq - MCFINT_VECBASE)) | 1);
+	writel(imr, INTC0 + MCFINTC_IMRL);
+
+	switch (line) {
+	case 0:
+		par = readw(MCF_IPSBAR + MCF_GPIO_PAR_UART);
+		par |= MCF_GPIO_PAR_UART_PAR_UTXD0 |
+		       MCF_GPIO_PAR_UART_PAR_URXD0;
+		writew(par, MCF_IPSBAR + MCF_GPIO_PAR_UART);
+		break;
+	case 1:
+		par = readw(MCF_IPSBAR + MCF_GPIO_PAR_UART);
+		par |= MCF_GPIO_PAR_UART_PAR_UTXD1 |
+		       MCF_GPIO_PAR_UART_PAR_URXD1;
+		writew(par, MCF_IPSBAR + MCF_GPIO_PAR_UART);
+		break;
+	case 2:
+		par2 = readb(MCF_IPSBAR + MCF_GPIO_PAR_FECI2C);
+		par2 &= ~0x0F;
+		par2 |= MCF_GPIO_PAR_FECI2C_PAR_SCL_UTXD2 |
+			MCF_GPIO_PAR_FECI2C_PAR_SDA_URXD2;
+		writeb(par2, MCF_IPSBAR + MCF_GPIO_PAR_FECI2C);
+		break;
+	}
+}
+
+static void __init m520x_uarts_init(void)
+{
+	const int nrlines = ARRAY_SIZE(m520x_uart_platform);
+	int line;
+
+	for (line = 0; (line < nrlines); line++)
+		m520x_uart_init_line(line, m520x_uart_platform[line].irq);
+}
 
 /***************************************************************************/
 
@@ -42,9 +114,20 @@ void mcf_autovector(unsigned int vec)
 
 /***************************************************************************/
 
-void config_BSP(char *commandp, int size)
+void __init config_BSP(char *commandp, int size)
 {
 	mach_reset = coldfire_reset;
+	m520x_uarts_init();
+}
+
+/***************************************************************************/
+
+static int __init init_BSP(void)
+{
+	platform_add_devices(m520x_devices, ARRAY_SIZE(m520x_devices));
+	return 0;
 }
 
+arch_initcall(init_BSP);
+
 /***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/523x/config.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/523x/config.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/523x/config.c	2009-02-08 00:00:48.000000000 -0500
@@ -16,11 +16,15 @@
 #include <linux/param.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>
+#include <linux/io.h>
 #include <asm/machdep.h>
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
-#include <asm/mcfdma.h>
+#include <asm/mcfuart.h>
+
+#ifdef CONFIG_MTD
+#include <linux/mtd/physmap.h>
+#endif
 
 /***************************************************************************/
 
@@ -28,14 +32,58 @@ void coldfire_reset(void);
 
 /***************************************************************************/
 
-/*
- *	DMA channel base address table.
- */
-unsigned int   dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
-        MCF_MBAR + MCFDMA_BASE0,
+static struct mcf_platform_uart m523x_uart_platform[] = {
+	{
+		.mapbase	= MCF_MBAR + MCFUART_BASE1,
+		.irq		= MCFINT_VECBASE + MCFINT_UART0,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE2,
+		.irq		= MCFINT_VECBASE + MCFINT_UART0 + 1,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE3,
+		.irq		= MCFINT_VECBASE + MCFINT_UART0 + 2,
+	},
+	{ },
+};
+
+static struct platform_device m523x_uart = {
+	.name			= "mcfuart",
+	.id			= 0,
+	.dev.platform_data	= m523x_uart_platform,
 };
 
-unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+static struct platform_device *m523x_devices[] __initdata = {
+	&m523x_uart,
+};
+
+/***************************************************************************/
+
+#define	INTC0	(MCF_MBAR + MCFICM_INTC0)
+
+static void __init m523x_uart_init_line(int line, int irq)
+{
+	u32 imr;
+
+	if ((line < 0) || (line > 2))
+		return;
+
+	writeb(0x30+line, (INTC0 + MCFINTC_ICR0 + MCFINT_UART0 + line));
+
+	imr = readl(INTC0 + MCFINTC_IMRL);
+	imr &= ~((1 << (irq - MCFINT_VECBASE)) | 1);
+	writel(imr, INTC0 + MCFINTC_IMRL);
+}
+
+static void __init m523x_uarts_init(void)
+{
+	const int nrlines = ARRAY_SIZE(m523x_uart_platform);
+	int line;
+
+	for (line = 0; (line < nrlines); line++)
+		m523x_uart_init_line(line, m523x_uart_platform[line].irq);
+}
 
 /***************************************************************************/
 
@@ -49,15 +97,85 @@ void mcf_disableall(void)
 
 void mcf_autovector(unsigned int vec)
 {
-	/* Everything is auto-vectored on the 5272 */
+	/* Everything is auto-vectored on the 523x */
 }
 
 /***************************************************************************/
 
-void config_BSP(char *commandp, int size)
+#if defined(CONFIG_SAVANT)
+
+/*
+ *	Do special config for SAVANT BSP
+ */
+static void __init config_savantBSP(char *commandP, int size)
+{
+	/* setup BOOTPARAM_STRING */
+	strncpy(commandP, "root=/dev/mtdblock1 ro rootfstype=romfs", size);
+	/* Look at Chatter DIP Switch, if CS3 is enabled */
+	{
+		uint32_t *csmr3 = (uint32_t *) (MCF_IPSBAR + MCF523x_CSMR3);
+		uint32_t *csar3 = (uint32_t *) (MCF_IPSBAR + MCF523x_CSAR3);
+		uint16_t *dipsP = (uint16_t *) *csar3;
+		uint16_t dipSetOff = *dipsP & 0x0100; // switch #1
+		uint16_t *btnPressP = (uint16_t *)(*csar3 + 0x10);
+		uint16_t shortButtonPress = *btnPressP & 0x8000;
+		if (*csmr3 & 1) {
+			/* CS3 enabled */
+			if (!dipSetOff && shortButtonPress) {
+				/* switch on, so be quiet */
+				strncat(commandP, " console=", size-strlen(commandP)-1);
+			}
+		}
+	}
+	commandP[size-1] = 0;
+
+	/* Set on-chip peripheral space to user mode */
+	{
+		uint8_t *gpacr = (uint8_t *) (MCF_IPSBAR + MCF523x_GPACR);
+		uint8_t *pacr1 = (uint8_t *) (MCF_IPSBAR + MCF523x_PACR1);
+		uint8_t *pacr4 = (uint8_t *) (MCF_IPSBAR + MCF523x_PACR4);
+		uint8_t *pacr7 = (uint8_t *) (MCF_IPSBAR + MCF523x_PACR7);
+		uint8_t *pacr8 = (uint8_t *) (MCF_IPSBAR + MCF523x_PACR8);
+		*gpacr = 0x04;
+		*pacr1 = 0x40; /* EIM required for Chip Select access */
+		*pacr4 = 0x40; /* I2C */
+		*pacr7 = 0x44; /* INTC0 & 1 handy for debug */
+		*pacr8 = 0x40; /* FEC MAC */
+	}
+
+#ifdef CONFIG_MTD
+	/* all board spins cannot access flash from linux unless we change the map here */
+	{
+		uint32_t *csar0 = (uint32_t *) (MCF_IPSBAR + MCF523x_CSAR0);
+		uint32_t start = *csar0;
+		uint32_t size = 0xffffFFFF - start + 1;
+		physmap_configure(start, size, CONFIG_MTD_PHYSMAP_BANKWIDTH, NULL);
+	}
+#endif
+}
+
+#endif /* CONFIG_SAVANT */
+
+/***************************************************************************/
+
+void __init config_BSP(char *commandp, int size)
 {
 	mcf_disableall();
+#if defined(CONFIG_SAVANT)
+	config_savantBSP(commandp, size);
+#endif /* CONFIG_SAVANT */
 	mach_reset = coldfire_reset;
+	m523x_uarts_init();
+}
+
+/***************************************************************************/
+
+static int __init init_BSP(void)
+{
+	platform_add_devices(m523x_devices, ARRAY_SIZE(m523x_devices));
+	return 0;
 }
 
+arch_initcall(init_BSP);
+
 /***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/5249/config.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/5249/config.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/5249/config.c	2009-02-08 00:00:48.000000000 -0500
@@ -12,11 +12,11 @@
 #include <linux/param.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>
+#include <linux/io.h>
 #include <asm/machdep.h>
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
-#include <asm/mcfdma.h>
+#include <asm/mcfuart.h>
 
 /***************************************************************************/
 
@@ -24,17 +24,51 @@ void coldfire_reset(void);
 
 /***************************************************************************/
 
-/*
- *	DMA channel base address table.
- */
-unsigned int   dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
-        MCF_MBAR + MCFDMA_BASE0,
-        MCF_MBAR + MCFDMA_BASE1,
-        MCF_MBAR + MCFDMA_BASE2,
-        MCF_MBAR + MCFDMA_BASE3,
+static struct mcf_platform_uart m5249_uart_platform[] = {
+	{
+		.mapbase	= MCF_MBAR + MCFUART_BASE1,
+		.irq		= 73,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE2,
+		.irq		= 74,
+	}
+};
+
+static struct platform_device m5249_uart = {
+	.name			= "mcfuart",
+	.id			= 0,
+	.dev.platform_data	= m5249_uart_platform,
 };
 
-unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+static struct platform_device *m5249_devices[] __initdata = {
+	&m5249_uart,
+};
+
+/***************************************************************************/
+
+static void __init m5249_uart_init_line(int line, int irq)
+{
+	if (line == 0) {
+		writel(MCFSIM_ICR_LEVEL6 | MCFSIM_ICR_PRI1, MCF_MBAR + MCFSIM_UART1ICR);
+		writeb(irq, MCFUART_BASE1 + MCFUART_UIVR);
+		mcf_setimr(mcf_getimr() & ~MCFSIM_IMR_UART1);
+	} else if (line == 1) {
+		writel(MCFSIM_ICR_LEVEL6 | MCFSIM_ICR_PRI2, MCF_MBAR + MCFSIM_UART2ICR);
+		writeb(irq, MCFUART_BASE2 + MCFUART_UIVR);
+		mcf_setimr(mcf_getimr() & ~MCFSIM_IMR_UART2);
+	}
+}
+
+static void __init m5249_uarts_init(void)
+{
+	const int nrlines = ARRAY_SIZE(m5249_uart_platform);
+	int line;
+
+	for (line = 0; (line < nrlines); line++)
+		m5249_uart_init_line(line, m5249_uart_platform[line].irq);
+}
+
 
 /***************************************************************************/
 
@@ -71,24 +105,21 @@ void mcf_settimericr(unsigned int timer,
 
 /***************************************************************************/
 
-int mcf_timerirqpending(int timer)
+void __init config_BSP(char *commandp, int size)
 {
-	unsigned int imr = 0;
-
-	switch (timer) {
-	case 1:  imr = MCFSIM_IMR_TIMER1; break;
-	case 2:  imr = MCFSIM_IMR_TIMER2; break;
-	default: break;
-	}
-	return (mcf_getipr() & imr);
+	mcf_setimr(MCFSIM_IMR_MASKALL);
+	mach_reset = coldfire_reset;
 }
 
 /***************************************************************************/
 
-void config_BSP(char *commandp, int size)
+static int __init init_BSP(void)
 {
-	mcf_setimr(MCFSIM_IMR_MASKALL);
-	mach_reset = coldfire_reset;
+	m5249_uarts_init();
+	platform_add_devices(m5249_devices, ARRAY_SIZE(m5249_devices));
+	return 0;
 }
 
+arch_initcall(init_BSP);
+
 /***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/5272/config.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/5272/config.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/5272/config.c	2009-02-08 00:00:48.000000000 -0500
@@ -13,11 +13,11 @@
 #include <linux/param.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>
+#include <linux/io.h>
 #include <asm/machdep.h>
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
-#include <asm/mcfdma.h>
+#include <asm/mcfuart.h>
 
 /***************************************************************************/
 
@@ -37,14 +37,57 @@ unsigned char ledbank = 0xff;
 
 /***************************************************************************/
 
-/*
- *	DMA channel base address table.
- */
-unsigned int   dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
-        MCF_MBAR + MCFDMA_BASE0,
+static struct mcf_platform_uart m5272_uart_platform[] = {
+	{
+		.mapbase	= MCF_MBAR + MCFUART_BASE1,
+		.irq		= 73,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE2,
+		.irq		= 74,
+	},
+	{ },
 };
 
-unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+static struct platform_device m5272_uart = {
+	.name			= "mcfuart",
+	.id			= 0,
+	.dev.platform_data	= m5272_uart_platform,
+};
+
+static struct platform_device *m5272_devices[] __initdata = {
+	&m5272_uart,
+};
+
+/***************************************************************************/
+
+static void __init m5272_uart_init_line(int line, int irq)
+{
+	u32 v;
+
+	if ((line >= 0) && (line < 2)) {
+		v = (line) ? 0x0e000000 : 0xe0000000;
+		writel(v, MCF_MBAR + MCFSIM_ICR2);
+
+		/* Enable the output lines for the serial ports */
+		v = readl(MCF_MBAR + MCFSIM_PBCNT);
+		v = (v & ~0x000000ff) | 0x00000055;
+		writel(v, MCF_MBAR + MCFSIM_PBCNT);
+
+		v = readl(MCF_MBAR + MCFSIM_PDCNT);
+		v = (v & ~0x000003fc) | 0x000002a8;
+		writel(v, MCF_MBAR + MCFSIM_PDCNT);
+	}
+}
+
+static void __init m5272_uarts_init(void)
+{
+	const int nrlines = ARRAY_SIZE(m5272_uart_platform);
+	int line;
+
+	for (line = 0; (line < nrlines); line++)
+		m5272_uart_init_line(line, m5272_uart_platform[line].irq);
+}
 
 /***************************************************************************/
 
@@ -80,20 +123,7 @@ void mcf_settimericr(int timer, int leve
 
 /***************************************************************************/
 
-int mcf_timerirqpending(int timer)
-{
-	volatile unsigned long *icrp;
-
-	if ((timer >= 1 ) && (timer <= 4)) {
-		icrp = (volatile unsigned long *) (MCF_MBAR + MCFSIM_ICR1);
-		return (*icrp & (0x8 << ((4 - timer) * 4)));
-	}
-	return 0;
-}
-
-/***************************************************************************/
-
-void config_BSP(char *commandp, int size)
+void __init config_BSP(char *commandp, int size)
 {
 #if defined (CONFIG_MOD5272)
 	volatile unsigned char	*pivrp;
@@ -109,10 +139,6 @@ void config_BSP(char *commandp, int size
 	/* Copy command line from FLASH to local buffer... */
 	memcpy(commandp, (char *) 0xf0004000, size);
 	commandp[size-1] = 0;
-#elif defined(CONFIG_MTD_KeyTechnology)
-	/* Copy command line from FLASH to local buffer... */
-	memcpy(commandp, (char *) 0xffe06000, size);
-	commandp[size-1] = 0;
 #elif defined(CONFIG_CANCam)
 	/* Copy command line from FLASH to local buffer... */
 	memcpy(commandp, (char *) 0xf0010000, size);
@@ -125,3 +151,14 @@ void config_BSP(char *commandp, int size
 }
 
 /***************************************************************************/
+
+static int __init init_BSP(void)
+{
+	m5272_uarts_init();
+	platform_add_devices(m5272_devices, ARRAY_SIZE(m5272_devices));
+	return 0;
+}
+
+arch_initcall(init_BSP);
+
+/***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/527x/config.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/527x/config.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/527x/config.c	2009-02-08 00:00:48.000000000 -0500
@@ -16,11 +16,11 @@
 #include <linux/param.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>
+#include <linux/io.h>
 #include <asm/machdep.h>
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
-#include <asm/mcfdma.h>
+#include <asm/mcfuart.h>
 
 /***************************************************************************/
 
@@ -28,14 +28,72 @@ void coldfire_reset(void);
 
 /***************************************************************************/
 
-/*
- *	DMA channel base address table.
- */
-unsigned int   dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
-        MCF_MBAR + MCFDMA_BASE0,
+static struct mcf_platform_uart m527x_uart_platform[] = {
+	{
+		.mapbase	= MCF_MBAR + MCFUART_BASE1,
+		.irq		= MCFINT_VECBASE + MCFINT_UART0,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE2,
+		.irq		= MCFINT_VECBASE + MCFINT_UART1,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE3,
+		.irq		= MCFINT_VECBASE + MCFINT_UART2,
+	},
+	{ },
 };
 
-unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+static struct platform_device m527x_uart = {
+	.name			= "mcfuart",
+	.id			= 0,
+	.dev.platform_data	= m527x_uart_platform,
+};
+
+static struct platform_device *m527x_devices[] __initdata = {
+	&m527x_uart,
+};
+
+/***************************************************************************/
+
+#define	INTC0	(MCF_MBAR + MCFICM_INTC0)
+
+static void __init m527x_uart_init_line(int line, int irq)
+{
+	u16 sepmask;
+	u32 imr;
+
+	if ((line < 0) || (line > 2))
+		return;
+
+	/* level 6, line based priority */
+	writeb(0x30+line, INTC0 + MCFINTC_ICR0 + MCFINT_UART0 + line);
+
+	imr = readl(INTC0 + MCFINTC_IMRL);
+	imr &= ~((1 << (irq - MCFINT_VECBASE)) | 1);
+	writel(imr, INTC0 + MCFINTC_IMRL);
+
+	/*
+	 * External Pin Mask Setting & Enable External Pin for Interface
+       	 */
+	sepmask = readw(MCF_IPSBAR + MCF_GPIO_PAR_UART);
+	if (line == 0)
+		sepmask |= UART0_ENABLE_MASK;
+	else if (line == 1)
+		sepmask |= UART1_ENABLE_MASK;
+	else if (line == 2)
+		sepmask |= UART2_ENABLE_MASK;
+	writew(sepmask, MCF_IPSBAR + MCF_GPIO_PAR_UART);
+}
+
+static void __init m527x_uarts_init(void)
+{
+	const int nrlines = ARRAY_SIZE(m527x_uart_platform);
+	int line;
+
+	for (line = 0; (line < nrlines); line++)
+		m527x_uart_init_line(line, m527x_uart_platform[line].irq);
+}
 
 /***************************************************************************/
 
@@ -54,10 +112,21 @@ void mcf_autovector(unsigned int vec)
 
 /***************************************************************************/
 
-void config_BSP(char *commandp, int size)
+void __init config_BSP(char *commandp, int size)
 {
 	mcf_disableall();
 	mach_reset = coldfire_reset;
 }
 
 /***************************************************************************/
+
+static int __init init_BSP(void)
+{
+	m527x_uarts_init();
+	platform_add_devices(m527x_devices, ARRAY_SIZE(m527x_devices));
+	return 0;
+}
+
+arch_initcall(init_BSP);
+
+/***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/528x/config.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/528x/config.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/528x/config.c	2009-02-08 00:00:48.000000000 -0500
@@ -16,26 +16,314 @@
 #include <linux/param.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/io.h>
 #include <asm/machdep.h>
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
-#include <asm/mcfdma.h>
+#include <asm/mcfuart.h>
+#include <asm/mcfqspi.h>
+
+#ifdef CONFIG_MTD_PARTITIONS
+#include <linux/mtd/partitions.h>
+#endif
 
 /***************************************************************************/
 
 void coldfire_reset(void);
+void coldfire_qspi_cs_control(u8 cs, u8 command);
+
+/***************************************************************************/
+
+#if defined(CONFIG_SPI)
+
+#if defined(CONFIG_WILDFIRE)
+#define SPI_NUM_CHIPSELECTS 	0x02
+#define SPI_PAR_VAL		0x07  // Enable DIN, DOUT, CLK
+#define SPI_CS_MASK		0x18
+
+#define FLASH_BLOCKSIZE		(1024*64)
+#define FLASH_NUMBLOCKS		16
+#define FLASH_TYPE		"m25p80"
+
+#define M25P80_CS		0
+#define MMC_CS			1
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition stm25p_partitions[] = {
+	/* sflash */
+	[0] = {
+		.name = "stm25p80",
+		.offset = 0x00000000,
+		.size = FLASH_BLOCKSIZE * FLASH_NUMBLOCKS,
+		.mask_flags = 0
+	}
+};
+
+#endif
+
+#elif defined(CONFIG_WILDFIREMOD)
+
+#define SPI_NUM_CHIPSELECTS	0x08
+#define SPI_PAR_VAL		0x07  // Enable DIN, DOUT, CLK
+#define SPI_CS_MASK		0x78
+
+#define FLASH_BLOCKSIZE		(1024*64)
+#define FLASH_NUMBLOCKS		64
+#define FLASH_TYPE		"m25p32"
+/* Reserve 1M for the kernel parition */
+#define FLASH_KERNEL_SIZE   (1024 * 1024)
+
+#define M25P80_CS		5
+#define MMC_CS			6
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition stm25p_partitions[] = {
+	/* sflash */
+	[0] = {
+		.name = "kernel",
+		.offset = FLASH_BLOCKSIZE * FLASH_NUMBLOCKS - FLASH_KERNEL_SIZE,
+		.size = FLASH_KERNEL_SIZE,
+		.mask_flags = 0
+	},
+	[1] = {
+		.name = "image",
+		.offset = 0x00000000,
+		.size = FLASH_BLOCKSIZE * FLASH_NUMBLOCKS - FLASH_KERNEL_SIZE,
+		.mask_flags = 0
+	},
+	[2] = {
+		.name = "all",
+		.offset = 0x00000000,
+		.size = FLASH_BLOCKSIZE * FLASH_NUMBLOCKS,
+		.mask_flags = 0
+	}
+};
+#endif
+
+#else
+#define SPI_NUM_CHIPSELECTS 	0x04
+#define SPI_PAR_VAL		0x7F  // Enable DIN, DOUT, CLK, CS0 - CS4
+#endif
+
+#ifdef MMC_CS
+static struct coldfire_spi_chip flash_chip_info = {
+	.mode = SPI_MODE_0,
+	.bits_per_word = 16,
+	.del_cs_to_clk = 17,
+	.del_after_trans = 1,
+	.void_write_data = 0
+};
+
+static struct coldfire_spi_chip mmc_chip_info = {
+	.mode = SPI_MODE_0,
+	.bits_per_word = 16,
+	.del_cs_to_clk = 17,
+	.del_after_trans = 1,
+	.void_write_data = 0xFFFF
+};
+#endif
+
+#ifdef M25P80_CS
+static struct flash_platform_data stm25p80_platform_data = {
+	.name = "ST M25P80 SPI Flash chip",
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts = stm25p_partitions,
+	.nr_parts = sizeof(stm25p_partitions) / sizeof(*stm25p_partitions),
+#endif
+	.type = FLASH_TYPE
+};
+#endif
+
+static struct spi_board_info spi_board_info[] __initdata = {
+#ifdef M25P80_CS
+	{
+		.modalias = "m25p80",
+		.max_speed_hz = 16000000,
+		.bus_num = 1,
+		.chip_select = M25P80_CS,
+		.platform_data = &stm25p80_platform_data,
+		.controller_data = &flash_chip_info
+	},
+#endif
+#ifdef MMC_CS
+	{
+		.modalias = "mmc_spi",
+		.max_speed_hz = 16000000,
+		.bus_num = 1,
+		.chip_select = MMC_CS,
+		.controller_data = &mmc_chip_info
+	}
+#endif
+};
+
+static struct coldfire_spi_master coldfire_master_info = {
+	.bus_num = 1,
+	.num_chipselect = SPI_NUM_CHIPSELECTS,
+	.irq_source = MCF5282_QSPI_IRQ_SOURCE,
+	.irq_vector = MCF5282_QSPI_IRQ_VECTOR,
+	.irq_mask = ((0x01 << MCF5282_QSPI_IRQ_SOURCE) | 0x01),
+	.irq_lp = 0x2B,  // Level 5 and Priority 3
+	.par_val = SPI_PAR_VAL,
+	.cs_control = coldfire_qspi_cs_control,
+};
+
+static struct resource coldfire_spi_resources[] = {
+	[0] = {
+		.name = "qspi-par",
+		.start = MCF5282_QSPI_PAR,
+		.end = MCF5282_QSPI_PAR,
+		.flags = IORESOURCE_MEM
+	},
+
+	[1] = {
+		.name = "qspi-module",
+		.start = MCF5282_QSPI_QMR,
+		.end = MCF5282_QSPI_QMR + 0x18,
+		.flags = IORESOURCE_MEM
+	},
+
+	[2] = {
+		.name = "qspi-int-level",
+		.start = MCF5282_INTC0 + MCFINTC_ICR0 + MCF5282_QSPI_IRQ_SOURCE,
+		.end = MCF5282_INTC0 + MCFINTC_ICR0 + MCF5282_QSPI_IRQ_SOURCE,
+		.flags = IORESOURCE_MEM
+	},
+
+	[3] = {
+		.name = "qspi-int-mask",
+		.start = MCF5282_INTC0 + MCFINTC_IMRL,
+		.end = MCF5282_INTC0 + MCFINTC_IMRL,
+		.flags = IORESOURCE_MEM
+	}
+};
+
+static struct platform_device coldfire_spi = {
+	.name = "spi_coldfire",
+	.id = -1,
+	.resource = coldfire_spi_resources,
+	.num_resources = ARRAY_SIZE(coldfire_spi_resources),
+	.dev = {
+		.platform_data = &coldfire_master_info,
+	}
+};
+
+void coldfire_qspi_cs_control(u8 cs, u8 command)
+{
+	u8 cs_bit = ((0x01 << cs) << 3) & SPI_CS_MASK;
+
+#if defined(CONFIG_WILDFIRE)
+	u8 cs_mask = ~(((0x01 << cs) << 3) & SPI_CS_MASK);
+#endif
+#if defined(CONFIG_WILDFIREMOD)
+	u8 cs_mask = (cs << 3) & SPI_CS_MASK;
+#endif
+
+	/*
+	 * Don't do anything if the chip select is not
+	 * one of the port qs pins.
+	 */
+	if (command & QSPI_CS_INIT) {
+#if defined(CONFIG_WILDFIRE)
+		MCF5282_GPIO_DDRQS  |= cs_bit;
+		MCF5282_GPIO_PQSPAR &= ~cs_bit;
+#endif
+
+#if defined(CONFIG_WILDFIREMOD)
+		MCF5282_GPIO_DDRQS  |= SPI_CS_MASK;
+		MCF5282_GPIO_PQSPAR &= ~SPI_CS_MASK;
+#endif
+	}
+
+	if (command & QSPI_CS_ASSERT) {
+		MCF5282_GPIO_PORTQS &= ~SPI_CS_MASK;
+		MCF5282_GPIO_PORTQS |= cs_mask;
+	} else if (command & QSPI_CS_DROP) {
+		MCF5282_GPIO_PORTQS |= SPI_CS_MASK;
+	}
+}
+
+static int __init spi_dev_init(void)
+{
+	int retval;
+
+	retval = platform_device_register(&coldfire_spi);
+	if (retval < 0)
+		return retval;
+
+	if (ARRAY_SIZE(spi_board_info))
+		retval = spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
+
+	return retval;
+}
+
+#endif /* CONFIG_SPI */
 
 /***************************************************************************/
 
-/*
- *	DMA channel base address table.
- */
-unsigned int   dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
-        MCF_MBAR + MCFDMA_BASE0,
+static struct mcf_platform_uart m528x_uart_platform[] = {
+	{
+		.mapbase	= MCF_MBAR + MCFUART_BASE1,
+		.irq		= MCFINT_VECBASE + MCFINT_UART0,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE2,
+		.irq		= MCFINT_VECBASE + MCFINT_UART0 + 1,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE3,
+		.irq		= MCFINT_VECBASE + MCFINT_UART0 + 2,
+	},
+	{ },
+};
+
+static struct platform_device m528x_uart = {
+	.name			= "mcfuart",
+	.id			= 0,
+	.dev.platform_data	= m528x_uart_platform,
+};
+
+static struct platform_device *m528x_devices[] __initdata = {
+	&m528x_uart,
 };
 
-unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+/***************************************************************************/
+
+#define	INTC0	(MCF_MBAR + MCFICM_INTC0)
+
+static void __init m528x_uart_init_line(int line, int irq)
+{
+	u8 port;
+	u32 imr;
+
+	if ((line < 0) || (line > 2))
+		return;
+
+	/* level 6, line based priority */
+	writeb(0x30+line, INTC0 + MCFINTC_ICR0 + MCFINT_UART0 + line);
+
+	imr = readl(INTC0 + MCFINTC_IMRL);
+	imr &= ~((1 << (irq - MCFINT_VECBASE)) | 1);
+	writel(imr, INTC0 + MCFINTC_IMRL);
+
+	/* make sure PUAPAR is set for UART0 and UART1 */
+	if (line < 2) {
+		port = readb(MCF_MBAR + MCF5282_GPIO_PUAPAR);
+		port |= (0x03 << (line * 2));
+		writeb(port, MCF_MBAR + MCF5282_GPIO_PUAPAR);
+	}
+}
+
+static void __init m528x_uarts_init(void)
+{
+	const int nrlines = ARRAY_SIZE(m528x_uart_platform);
+	int line;
+
+	for (line = 0; (line < nrlines); line++)
+		m528x_uart_init_line(line, m528x_uart_platform[line].irq);
+}
 
 /***************************************************************************/
 
@@ -54,10 +342,57 @@ void mcf_autovector(unsigned int vec)
 
 /***************************************************************************/
 
-void config_BSP(char *commandp, int size)
+#ifdef CONFIG_WILDFIRE
+void wildfire_halt (void)
+{
+	writeb(0, 0x30000007);
+	writeb(0x2, 0x30000007);
+}
+#endif
+
+#ifdef CONFIG_WILDFIREMOD
+void wildfiremod_halt (void)
+{
+	printk("WildFireMod hibernating...\n");
+
+	/* Set portE.5 to Digital IO */
+	MCF5282_GPIO_PEPAR &= ~(1 << (5 * 2));
+
+	/* Make portE.5 an output */
+	MCF5282_GPIO_DDRE |= (1 << 5);
+
+	/* Now toggle portE.5 from low to high */
+	MCF5282_GPIO_PORTE &= ~(1 << 5);
+	MCF5282_GPIO_PORTE |= (1 << 5);
+
+	printk("Failed to hibernate. Halting!\n");
+}
+#endif
+
+void __init config_BSP(char *commandp, int size)
 {
 	mcf_disableall();
-	mach_reset = coldfire_reset;
+
+#ifdef CONFIG_WILDFIRE
+	mach_halt = wildfire_halt;
+#endif
+#ifdef CONFIG_WILDFIREMOD
+	mach_halt = wildfiremod_halt;
+#endif
+}
+
+/***************************************************************************/
+
+static int __init init_BSP(void)
+{
+	m528x_uarts_init();
+#ifdef CONFIG_SPI
+	spi_dev_init();
+#endif
+	platform_add_devices(m528x_devices, ARRAY_SIZE(m528x_devices));
+	return 0;
 }
 
+arch_initcall(init_BSP);
+
 /***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/5307/Makefile
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/5307/Makefile	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/5307/Makefile	2009-02-08 00:00:48.000000000 -0500
@@ -16,17 +16,5 @@ ifdef CONFIG_FULLDEBUG
 EXTRA_AFLAGS += -DDEBUGGER_COMPATIBLE_CACHE=1
 endif
 
-obj-$(CONFIG_COLDFIRE)	+= entry.o vectors.o
-obj-$(CONFIG_M5206)	+= timers.o
-obj-$(CONFIG_M5206e)	+= timers.o
-obj-$(CONFIG_M520x)	+= pit.o
-obj-$(CONFIG_M523x)	+= pit.o
-obj-$(CONFIG_M5249)	+= timers.o
-obj-$(CONFIG_M527x)     += pit.o
-obj-$(CONFIG_M5272)	+= timers.o
-obj-$(CONFIG_M5307)	+= config.o timers.o
-obj-$(CONFIG_M532x)	+= timers.o
-obj-$(CONFIG_M528x)     += pit.o
-obj-$(CONFIG_M5407)	+= timers.o
+obj-y	+= config.o
 
-extra-y := head.o
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/5307/config.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/5307/config.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/5307/config.c	2009-02-08 00:00:48.000000000 -0500
@@ -13,11 +13,11 @@
 #include <linux/param.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>
+#include <linux/io.h>
 #include <asm/machdep.h>
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
-#include <asm/mcfdma.h>
+#include <asm/mcfuart.h>
 #include <asm/mcfwdebug.h>
 
 /***************************************************************************/
@@ -38,17 +38,51 @@ unsigned char ledbank = 0xff;
 
 /***************************************************************************/
 
-/*
- *	DMA channel base address table.
- */
-unsigned int   dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
-        MCF_MBAR + MCFDMA_BASE0,
-        MCF_MBAR + MCFDMA_BASE1,
-        MCF_MBAR + MCFDMA_BASE2,
-        MCF_MBAR + MCFDMA_BASE3,
+static struct mcf_platform_uart m5307_uart_platform[] = {
+	{
+		.mapbase	= MCF_MBAR + MCFUART_BASE1,
+		.irq		= 73,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE2,
+		.irq		= 74,
+	},
+	{ },
+};
+
+static struct platform_device m5307_uart = {
+	.name			= "mcfuart",
+	.id			= 0,
+	.dev.platform_data	= m5307_uart_platform,
 };
 
-unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+static struct platform_device *m5307_devices[] __initdata = {
+	&m5307_uart,
+};
+
+/***************************************************************************/
+
+static void __init m5307_uart_init_line(int line, int irq)
+{
+	if (line == 0) {
+		writel(MCFSIM_ICR_LEVEL6 | MCFSIM_ICR_PRI1, MCF_MBAR + MCFSIM_UART1ICR);
+		writeb(irq, MCFUART_BASE1 + MCFUART_UIVR);
+		mcf_setimr(mcf_getimr() & ~MCFSIM_IMR_UART1);
+	} else if (line == 1) {
+		writel(MCFSIM_ICR_LEVEL6 | MCFSIM_ICR_PRI2, MCF_MBAR + MCFSIM_UART2ICR);
+		writeb(irq, MCFUART_BASE2 + MCFUART_UIVR);
+		mcf_setimr(mcf_getimr() & ~MCFSIM_IMR_UART2);
+	}
+}
+
+static void __init m5307_uarts_init(void)
+{
+	const int nrlines = ARRAY_SIZE(m5307_uart_platform);
+	int line;
+
+	for (line = 0; (line < nrlines); line++)
+		m5307_uart_init_line(line, m5307_uart_platform[line].irq);
+}
 
 /***************************************************************************/
 
@@ -85,27 +119,12 @@ void mcf_settimericr(unsigned int timer,
 
 /***************************************************************************/
 
-int mcf_timerirqpending(int timer)
-{
-	unsigned int imr = 0;
-
-	switch (timer) {
-	case 1:  imr = MCFSIM_IMR_TIMER1; break;
-	case 2:  imr = MCFSIM_IMR_TIMER2; break;
-	default: break;
-	}
-	return (mcf_getipr() & imr);
-}
-
-/***************************************************************************/
-
-void config_BSP(char *commandp, int size)
+void __init config_BSP(char *commandp, int size)
 {
 	mcf_setimr(MCFSIM_IMR_MASKALL);
 
 #if defined(CONFIG_NETtel) || defined(CONFIG_eLIA) || \
-      defined(CONFIG_DISKtel) || defined(CONFIG_SECUREEDGEMP3) || \
-      defined(CONFIG_CLEOPATRA)
+    defined(CONFIG_SECUREEDGEMP3) || defined(CONFIG_CLEOPATRA)
 	/* Copy command line from FLASH to local buffer... */
 	memcpy(commandp, (char *) 0xf0004000, size);
 	commandp[size-1] = 0;
@@ -117,7 +136,7 @@ void config_BSP(char *commandp, int size
 
 	mach_reset = coldfire_reset;
 
-#ifdef MCF_BDM_DISABLE
+#ifdef CONFIG_BDM_DISABLE
 	/*
 	 * Disable the BDM clocking.  This also turns off most of the rest of
 	 * the BDM device.  This is good for EMC reasons. This option is not
@@ -128,3 +147,14 @@ void config_BSP(char *commandp, int size
 }
 
 /***************************************************************************/
+
+static int __init init_BSP(void)
+{
+	m5307_uarts_init();
+	platform_add_devices(m5307_devices, ARRAY_SIZE(m5307_devices));
+	return 0;
+}
+
+arch_initcall(init_BSP);
+
+/***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/5307/entry.S
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/5307/entry.S	2009-02-08 00:00:33.000000000 -0500
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,235 +0,0 @@
-/*
- *  linux/arch/m68knommu/platform/5307/entry.S
- *
- *  Copyright (C) 1999-2007, Greg Ungerer (gerg@snapgear.com)
- *  Copyright (C) 1998  D. Jeff Dionne <jeff@lineo.ca>,
- *                      Kenneth Albanowski <kjahds@kjahds.com>,
- *  Copyright (C) 2000  Lineo Inc. (www.lineo.com)
- *  Copyright (C) 2004-2006  Macq Electronique SA. (www.macqel.com)
- *
- * Based on:
- *
- *  linux/arch/m68k/kernel/entry.S
- *
- *  Copyright (C) 1991, 1992  Linus Torvalds
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file README.legal in the main directory of this archive
- * for more details.
- *
- * Linux/m68k support by Hamish Macdonald
- *
- * 68060 fixes by Jesper Skov
- * ColdFire support by Greg Ungerer (gerg@snapgear.com)
- * 5307 fixes by David W. Miller
- * linux 2.4 support David McCullough <davidm@snapgear.com>
- * Bug, speed and maintainability fixes by Philippe De Muyter <phdm@macqel.be>
- */
-
-#include <linux/sys.h>
-#include <linux/linkage.h>
-#include <asm/unistd.h>
-#include <asm/thread_info.h>
-#include <asm/errno.h>
-#include <asm/setup.h>
-#include <asm/segment.h>
-#include <asm/asm-offsets.h>
-#include <asm/entry.h>
-
-.bss
-
-sw_ksp:
-.long	0
-
-sw_usp:
-.long	0
-
-.text
-
-.globl system_call
-.globl resume
-.globl ret_from_exception
-.globl ret_from_signal
-.globl sys_call_table
-.globl ret_from_interrupt
-.globl inthandler
-.globl fasthandler
-
-enosys:
-	mov.l	#sys_ni_syscall,%d3
-	bra	1f
-
-ENTRY(system_call)
-	SAVE_ALL
-	move	#0x2000,%sr		/* enable intrs again */
-
-	cmpl	#NR_syscalls,%d0
-	jcc	enosys
-	lea	sys_call_table,%a0
-	lsll	#2,%d0			/* movel %a0@(%d0:l:4),%d3 */
-	movel	%a0@(%d0),%d3
-	jeq	enosys
-
-1:
-	movel	%sp,%d2			/* get thread_info pointer */
-	andl	#-THREAD_SIZE,%d2	/* at start of kernel stack */
-	movel	%d2,%a0
-	movel	%a0@,%a1		/* save top of frame */
-	movel	%sp,%a1@(TASK_THREAD+THREAD_ESP0)
-	btst	#(TIF_SYSCALL_TRACE%8),%a0@(TI_FLAGS+(31-TIF_SYSCALL_TRACE)/8)
-	bnes	1f
-
-	movel	%d3,%a0
-	jbsr	%a0@
-	movel	%d0,%sp@(PT_D0)		/* save the return value */
-	jra	ret_from_exception
-1:
-	movel	#-ENOSYS,%d2		/* strace needs -ENOSYS in PT_D0 */
-	movel	%d2,PT_D0(%sp)		/* on syscall entry */
-	subql	#4,%sp
-	SAVE_SWITCH_STACK
-	jbsr	syscall_trace
-	RESTORE_SWITCH_STACK
-	addql	#4,%sp
-	movel	%d3,%a0
-	jbsr	%a0@
-	movel	%d0,%sp@(PT_D0)		/* save the return value */
-	subql	#4,%sp			/* dummy return address */
-	SAVE_SWITCH_STACK
-	jbsr	syscall_trace
-
-ret_from_signal:
-	RESTORE_SWITCH_STACK
-	addql	#4,%sp
-
-ret_from_exception:
-	btst	#5,%sp@(PT_SR)		/* check if returning to kernel */
-	jeq	Luser_return		/* if so, skip resched, signals */
-
-Lkernel_return:
-	moveml	%sp@,%d1-%d5/%a0-%a2
-	lea	%sp@(32),%sp		/* space for 8 regs */
-	movel	%sp@+,%d0
-	addql	#4,%sp			/* orig d0 */
-	addl	%sp@+,%sp		/* stk adj */
-	rte
-
-Luser_return:
-	movel	%sp,%d1			/* get thread_info pointer */
-	andl	#-THREAD_SIZE,%d1	/* at base of kernel stack */
-	movel	%d1,%a0
-	movel	%a0@(TI_FLAGS),%d1	/* get thread_info->flags */
-	andl	#_TIF_WORK_MASK,%d1
-	jne	Lwork_to_do		/* still work to do */
-
-Lreturn:
-	move	#0x2700,%sr		/* disable intrs */
-	movel	sw_usp,%a0		/* get usp */
-	movel	%sp@(PT_PC),%a0@-	/* copy exception program counter */
-	movel	%sp@(PT_FORMATVEC),%a0@-/* copy exception format/vector/sr */
-	moveml	%sp@,%d1-%d5/%a0-%a2
-	lea	%sp@(32),%sp		/* space for 8 regs */
-	movel	%sp@+,%d0
-	addql	#4,%sp			/* orig d0 */
-	addl	%sp@+,%sp		/* stk adj */
-	addql	#8,%sp			/* remove exception */
-	movel	%sp,sw_ksp		/* save ksp */
-	subql	#8,sw_usp		/* set exception */
-	movel	sw_usp,%sp		/* restore usp */
-	rte
-
-Lwork_to_do:
-	movel	%a0@(TI_FLAGS),%d1	/* get thread_info->flags */
-	btst	#TIF_NEED_RESCHED,%d1
-	jne	reschedule
-
-	/* GERG: do we need something here for TRACEing?? */
-
-Lsignal_return:
-	subql	#4,%sp			/* dummy return address */
-	SAVE_SWITCH_STACK
-	pea	%sp@(SWITCH_STACK_SIZE)
-	clrl	%sp@-
-	jsr	do_signal
-	addql	#8,%sp
-	RESTORE_SWITCH_STACK
-	addql	#4,%sp
-	jmp	Lreturn
-
-/*
- * This is the generic interrupt handler (for all hardware interrupt
- * sources). Calls upto high level code to do all the work.
- */
-ENTRY(inthandler)
-	SAVE_ALL
-	moveq	#-1,%d0
-	movel	%d0,%sp@(PT_ORIG_D0)
-
-	movew	%sp@(PT_FORMATVEC),%d0	/* put exception # in d0 */
-	andl	#0x03fc,%d0		/* mask out vector only */
-
-	movel	%sp,%sp@-		/* push regs arg */
-	lsrl	#2,%d0			/* calculate real vector # */
-	movel	%d0,%sp@-		/* push vector number */
-	jbsr	do_IRQ			/* call high level irq handler */
-	lea	%sp@(8),%sp		/* pop args off stack */
-
-	bra	ret_from_interrupt	/* this was fallthrough */
-
-/*
- * This is the fast interrupt handler (for certain hardware interrupt
- * sources). Unlike the normal interrupt handler it just uses the
- * current stack (doesn't care if it is user or kernel). It also
- * doesn't bother doing the bottom half handlers.
- */
-ENTRY(fasthandler)
-	SAVE_LOCAL
-
-	movew	%sp@(PT_FORMATVEC),%d0
-	andl	#0x03fc,%d0		/* mask out vector only */
-
-	movel	%sp,%sp@-		/* push regs arg */
-	lsrl	#2,%d0			/* calculate real vector # */
-	movel	%d0,%sp@-		/* push vector number */
-	jbsr	do_IRQ			/* call high level irq handler */
-	lea	%sp@(8),%sp		/* pop args off stack */
-
-	RESTORE_LOCAL
-
-ENTRY(ret_from_interrupt)
-	jeq	2f
-1:
-	RESTORE_ALL
-2:
-	moveb	%sp@(PT_SR),%d0
-	andl	#0x7,%d0
-	jhi	1b
-
-	/* check if we need to do software interrupts */
-	movel	irq_stat+CPUSTAT_SOFTIRQ_PENDING,%d0
-	jeq	ret_from_exception
-
-	pea	ret_from_exception
-	jmp	do_softirq
-
-/*
- * Beware - when entering resume, prev (the current task) is
- * in a0, next (the new task) is in a1,so don't change these
- * registers until their contents are no longer needed.
- * This is always called in supervisor mode, so don't bother to save
- * and restore sr; user's process sr is actually in the stack.
- */
-ENTRY(resume)
-	movel	%a0, %d1			/* get prev thread in d1 */
-
-	movel	sw_usp,%d0			/* save usp */
-	movel	%d0,%a0@(TASK_THREAD+THREAD_USP)
-
-	SAVE_SWITCH_STACK
-	movel	%sp,%a0@(TASK_THREAD+THREAD_KSP) /* save kernel stack pointer */
-	movel	%a1@(TASK_THREAD+THREAD_KSP),%sp /* restore new thread stack */
-	RESTORE_SWITCH_STACK
-
-	movel	%a1@(TASK_THREAD+THREAD_USP),%a0 /* restore thread user stack */
-	movel	%a0, sw_usp
-	rts
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/5307/head.S
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/5307/head.S	2009-02-08 00:00:33.000000000 -0500
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,222 +0,0 @@
-/*****************************************************************************/
-
-/*
- *	head.S -- common startup code for ColdFire CPUs.
- *
- *	(C) Copyright 1999-2006, Greg Ungerer <gerg@snapgear.com>.
- */
-
-/*****************************************************************************/
-
-#include <linux/sys.h>
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/coldfire.h>
-#include <asm/mcfcache.h>
-#include <asm/mcfsim.h>
-
-/*****************************************************************************/
-
-/*
- *	If we don't have a fixed memory size, then lets build in code
- *	to auto detect the DRAM size. Obviously this is the prefered
- *	method, and should work for most boards. It won't work for those
- *	that do not have their RAM starting at address 0, and it only
- *	works on SDRAM (not boards fitted with SRAM).
- */
-#if CONFIG_RAMSIZE != 0
-.macro GET_MEM_SIZE
-	movel	#CONFIG_RAMSIZE,%d0	/* hard coded memory size */
-.endm
-
-#elif defined(CONFIG_M5206) || defined(CONFIG_M5206e) || \
-      defined(CONFIG_M5249) || defined(CONFIG_M527x) || \
-      defined(CONFIG_M528x) || defined(CONFIG_M5307) || \
-      defined(CONFIG_M5407)
-/*
- *	Not all these devices have exactly the same DRAM controller,
- *	but the DCMR register is virtually identical - give or take
- *	a couple of bits. The only exception is the 5272 devices, their
- *	DRAM controller is quite different.
- */
-.macro GET_MEM_SIZE
-	movel	MCF_MBAR+MCFSIM_DMR0,%d0 /* get mask for 1st bank */
-	btst	#0,%d0			/* check if region enabled */
-	beq	1f
-	andl	#0xfffc0000,%d0
-	beq	1f
-	addl	#0x00040000,%d0		/* convert mask to size */
-1:
-	movel	MCF_MBAR+MCFSIM_DMR1,%d1 /* get mask for 2nd bank */
-	btst	#0,%d1			/* check if region enabled */
-	beq	2f
-	andl	#0xfffc0000, %d1
-	beq	2f
-	addl	#0x00040000,%d1
-	addl	%d1,%d0			/* total mem size in d0 */
-2:
-.endm
-
-#elif defined(CONFIG_M5272)
-.macro GET_MEM_SIZE
-	movel	MCF_MBAR+MCFSIM_CSOR7,%d0 /* get SDRAM address mask */
-	andil	#0xfffff000,%d0		/* mask out chip select options */
-	negl	%d0			/* negate bits */
-.endm
-
-#elif defined(CONFIG_M520x)
-.macro GET_MEM_SIZE
-	clrl	%d0
-	movel	MCF_MBAR+MCFSIM_SDCS0, %d2 /* Get SDRAM chip select 0 config */
-	andl	#0x1f, %d2		/* Get only the chip select size */
-	beq	3f			/* Check if it is enabled */
-	addql	#1, %d2			/* Form exponent */
-	moveql	#1, %d0
-	lsll	%d2, %d0		/* 2 ^ exponent */
-3:
-	movel	MCF_MBAR+MCFSIM_SDCS1, %d2 /* Get SDRAM chip select 1 config */
-	andl	#0x1f, %d2		/* Get only the chip select size */
-	beq	4f			/* Check if it is enabled */
-	addql	#1, %d2			/* Form exponent */
-	moveql	#1, %d1
-	lsll	%d2, %d1		/* 2 ^ exponent */
-	addl	%d1, %d0		/* Total size of SDRAM in d0 */
-4:
-.endm
-
-#else
-#error "ERROR: I don't know how to probe your boards memory size?"
-#endif
-
-/*****************************************************************************/
-
-/*
- *	Boards and platforms can do specific early hardware setup if
- *	they need to. Most don't need this, define away if not required.
- */
-#ifndef PLATFORM_SETUP
-#define	PLATFORM_SETUP
-#endif
-
-/*****************************************************************************/
-
-.global	_start
-.global _rambase
-.global _ramvec
-.global	_ramstart
-.global	_ramend
-
-/*****************************************************************************/
-
-.data
-
-/*
- *	During startup we store away the RAM setup. These are not in the
- *	bss, since their values are determined and written before the bss
- *	has been cleared.
- */
-_rambase:
-.long	0
-_ramvec:
-.long	0
-_ramstart:
-.long	0
-_ramend:
-.long	0
-
-/*****************************************************************************/
-
-.text
-
-/*
- *	This is the codes first entry point. This is where it all
- *	begins...
- */
-
-_start:
-	nop					/* filler */
-	movew	#0x2700, %sr			/* no interrupts */
-
-	/*
-	 *	Do any platform or board specific setup now. Most boards
-	 *	don't need anything. Those exceptions are define this in
-	 *	their board specific includes.
-	 */
-	PLATFORM_SETUP
-
-	/*
-	 *	Create basic memory configuration. Set VBR accordingly,
-	 *	and size memory.
-	 */
-	movel	#CONFIG_VECTORBASE,%a7
-	movec   %a7,%VBR			/* set vectors addr */
-	movel	%a7,_ramvec
-
-	movel	#CONFIG_RAMBASE,%a7		/* mark the base of RAM */
-	movel	%a7,_rambase
-
-	GET_MEM_SIZE				/* macro code determines size */
-	addl	%a7,%d0
-	movel	%d0,_ramend			/* set end ram addr */
-
-	/*
-	 *	Now that we know what the memory is, lets enable cache
-	 *	and get things moving. This is Coldfire CPU specific.
-	 */
-	CACHE_ENABLE				/* enable CPU cache */
-
-
-#ifdef CONFIG_ROMFS_FS
-	/*
-	 *	Move ROM filesystem above bss :-)
-	 */
-	lea	_sbss,%a0			/* get start of bss */
-	lea	_ebss,%a1			/* set up destination  */
-	movel	%a0,%a2				/* copy of bss start */
-
-	movel	8(%a0),%d0			/* get size of ROMFS */
-	addql	#8,%d0				/* allow for rounding */
-	andl	#0xfffffffc, %d0		/* whole words */
-
-	addl	%d0,%a0				/* copy from end */
-	addl	%d0,%a1				/* copy from end */
-	movel	%a1,_ramstart			/* set start of ram */
-
-_copy_romfs:
-	movel	-(%a0),%d0			/* copy dword */
-	movel	%d0,-(%a1)
-	cmpl	%a0,%a2				/* check if at end */
-	bne	_copy_romfs
-
-#else /* CONFIG_ROMFS_FS */
-	lea	_ebss,%a1
-	movel	%a1,_ramstart
-#endif /* CONFIG_ROMFS_FS */
-
-
-	/*
-	 *	Zero out the bss region.
-	 */
-	lea	_sbss,%a0			/* get start of bss */
-	lea	_ebss,%a1			/* get end of bss */
-	clrl	%d0				/* set value */
-_clear_bss:
-	movel	%d0,(%a0)+			/* clear each word */
-	cmpl	%a0,%a1				/* check if at end */
-	bne	_clear_bss
-
-	/*
-	 *	Load the current task pointer and stack.
-	 */
-	lea	init_thread_union,%a0
-	lea	THREAD_SIZE(%a0),%sp
-
-	/*
-	 *	Assember start up done, start code proper.
-	 */
-	jsr	start_kernel			/* start Linux kernel */
-
-_exit:
-	jmp	_exit				/* should never get here */
-
-/*****************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/5307/pit.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/5307/pit.c	2009-02-08 00:00:33.000000000 -0500
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,97 +0,0 @@
-/***************************************************************************/
-
-/*
- *	pit.c -- Freescale ColdFire PIT timer. Currently this type of
- *	         hardware timer only exists in the Freescale ColdFire
- *		 5270/5271, 5282 and other CPUs.
- *
- *	Copyright (C) 1999-2007, Greg Ungerer (gerg@snapgear.com)
- *	Copyright (C) 2001-2004, SnapGear Inc. (www.snapgear.com)
- */
-
-/***************************************************************************/
-
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/param.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <asm/machdep.h>
-#include <asm/io.h>
-#include <asm/coldfire.h>
-#include <asm/mcfpit.h>
-#include <asm/mcfsim.h>
-
-/***************************************************************************/
-
-/*
- *	By default use timer1 as the system clock timer.
- */
-#define	TA(a)	(MCF_IPSBAR + MCFPIT_BASE1 + (a))
-
-/***************************************************************************/
-
-static irqreturn_t hw_tick(int irq, void *dummy)
-{
-	unsigned short pcsr;
-
-	/* Reset the ColdFire timer */
-	pcsr = __raw_readw(TA(MCFPIT_PCSR));
-	__raw_writew(pcsr | MCFPIT_PCSR_PIF, TA(MCFPIT_PCSR));
-
-	return arch_timer_interrupt(irq, dummy);
-}
-
-/***************************************************************************/
-
-static struct irqaction coldfire_pit_irq = {
-	.name	 = "timer",
-	.flags	 = IRQF_DISABLED | IRQF_TIMER,
-	.handler = hw_tick,
-};
-
-void hw_timer_init(void)
-{
-	volatile unsigned char *icrp;
-	volatile unsigned long *imrp;
-
-	setup_irq(MCFINT_VECBASE + MCFINT_PIT1, &coldfire_pit_irq);
-
-	icrp = (volatile unsigned char *) (MCF_IPSBAR + MCFICM_INTC0 +
-		MCFINTC_ICR0 + MCFINT_PIT1);
-	*icrp = ICR_INTRCONF;
-
-	imrp = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFPIT_IMR);
-	*imrp &= ~MCFPIT_IMR_IBIT;
-
-	/* Set up PIT timer 1 as poll clock */
-	__raw_writew(MCFPIT_PCSR_DISABLE, TA(MCFPIT_PCSR));
-	__raw_writew(((MCF_CLK / 2) / 64) / HZ, TA(MCFPIT_PMR));
-	__raw_writew(MCFPIT_PCSR_EN | MCFPIT_PCSR_PIE | MCFPIT_PCSR_OVW |
-		MCFPIT_PCSR_RLD | MCFPIT_PCSR_CLK64, TA(MCFPIT_PCSR));
-}
-
-/***************************************************************************/
-
-unsigned long hw_timer_offset(void)
-{
-	volatile unsigned long *ipr;
-	unsigned long pmr, pcntr, offset;
-
-	ipr = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 + MCFPIT_IMR);
-
-	pmr = __raw_readw(TA(MCFPIT_PMR));
-	pcntr = __raw_readw(TA(MCFPIT_PCNTR));
-
-	/*
-	 * If we are still in the first half of the upcount and a
-	 * timer interrupt is pending, then add on a ticks worth of time.
-	 */
-	offset = ((pmr - pcntr) * (1000000 / HZ)) / pmr;
-	if ((offset < (1000000 / HZ / 2)) && (*ipr & MCFPIT_IMR_IBIT))
-		offset += 1000000 / HZ;
-	return offset;	
-}
-
-/***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/5307/timers.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/5307/timers.c	2009-02-08 00:00:33.000000000 -0500
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,155 +0,0 @@
-/***************************************************************************/
-
-/*
- *	timers.c -- generic ColdFire hardware timer support.
- *
- *	Copyright (C) 1999-2007, Greg Ungerer (gerg@snapgear.com)
- */
-
-/***************************************************************************/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <asm/io.h>
-#include <asm/traps.h>
-#include <asm/machdep.h>
-#include <asm/coldfire.h>
-#include <asm/mcftimer.h>
-#include <asm/mcfsim.h>
-
-/***************************************************************************/
-
-/*
- *	By default use timer1 as the system clock timer.
- */
-#define	TA(a)	(MCF_MBAR + MCFTIMER_BASE1 + (a))
-
-/*
- *	Default the timer and vector to use for ColdFire. Some ColdFire
- *	CPU's and some boards may want different. Their sub-architecture
- *	startup code (in config.c) can change these if they want.
- */
-unsigned int	mcf_timervector = 29;
-unsigned int	mcf_profilevector = 31;
-unsigned int	mcf_timerlevel = 5;
-
-/*
- *	These provide the underlying interrupt vector support.
- *	Unfortunately it is a little different on each ColdFire.
- */
-extern void mcf_settimericr(int timer, int level);
-extern int mcf_timerirqpending(int timer);
-
-#if defined(CONFIG_M532x)
-#define	__raw_readtrr	__raw_readl
-#define	__raw_writetrr	__raw_writel
-#else
-#define	__raw_readtrr	__raw_readw
-#define	__raw_writetrr	__raw_writew
-#endif
-
-/***************************************************************************/
-
-static irqreturn_t hw_tick(int irq, void *dummy)
-{
-	/* Reset the ColdFire timer */
-	__raw_writeb(MCFTIMER_TER_CAP | MCFTIMER_TER_REF, TA(MCFTIMER_TER));
-
-	return arch_timer_interrupt(irq, dummy);
-}
-
-/***************************************************************************/
-
-static struct irqaction coldfire_timer_irq = {
-	.name	 = "timer",
-	.flags	 = IRQF_DISABLED | IRQF_TIMER,
-	.handler = hw_tick,
-};
-
-/***************************************************************************/
-
-static int ticks_per_intr;
-
-void hw_timer_init(void)
-{
-	setup_irq(mcf_timervector, &coldfire_timer_irq);
-
-	__raw_writew(MCFTIMER_TMR_DISABLE, TA(MCFTIMER_TMR));
-	ticks_per_intr = (MCF_BUSCLK / 16) / HZ;
-	__raw_writetrr(ticks_per_intr - 1, TA(MCFTIMER_TRR));
-	__raw_writew(MCFTIMER_TMR_ENORI | MCFTIMER_TMR_CLK16 |
-		MCFTIMER_TMR_RESTART | MCFTIMER_TMR_ENABLE, TA(MCFTIMER_TMR));
-
-	mcf_settimericr(1, mcf_timerlevel);
-
-#ifdef CONFIG_HIGHPROFILE
-	coldfire_profile_init();
-#endif
-}
-
-/***************************************************************************/
-
-unsigned long hw_timer_offset(void)
-{
-	unsigned long tcn, offset;
-
-	tcn = __raw_readw(TA(MCFTIMER_TCN));
-	offset = ((tcn + 1) * (1000000 / HZ)) / ticks_per_intr;
-
-	/* Check if we just wrapped the counters and maybe missed a tick */
-	if ((offset < (1000000 / HZ / 2)) && mcf_timerirqpending(1))
-		offset += 1000000 / HZ;
-	return offset;
-}
-
-/***************************************************************************/
-#ifdef CONFIG_HIGHPROFILE
-/***************************************************************************/
-
-/*
- *	By default use timer2 as the profiler clock timer.
- */
-#define	PA(a)	(MCF_MBAR + MCFTIMER_BASE2 + (a))
-
-/*
- *	Choose a reasonably fast profile timer. Make it an odd value to
- *	try and get good coverage of kernel operations.
- */
-#define	PROFILEHZ	1013
-
-/*
- *	Use the other timer to provide high accuracy profiling info.
- */
-irqreturn_t coldfire_profile_tick(int irq, void *dummy)
-{
-	/* Reset ColdFire timer2 */
-	__raw_writeb(MCFTIMER_TER_CAP | MCFTIMER_TER_REF, PA(MCFTIMER_TER));
-	if (current->pid)
-		profile_tick(CPU_PROFILING, regs);
-	return IRQ_HANDLED;
-}
-
-/***************************************************************************/
-
-void coldfire_profile_init(void)
-{
-	printk(KERN_INFO "PROFILE: lodging TIMER2 @ %dHz as profile timer\n", PROFILEHZ);
-
-	/* Set up TIMER 2 as high speed profile clock */
-	__raw_writew(MCFTIMER_TMR_DISABLE, PA(MCFTIMER_TMR));
-
-	__raw_writetrr(((MCF_CLK / 16) / PROFILEHZ), PA(MCFTIMER_TRR));
-	__raw_writew(MCFTIMER_TMR_ENORI | MCFTIMER_TMR_CLK16 |
-		MCFTIMER_TMR_RESTART | MCFTIMER_TMR_ENABLE, PA(MCFTIMER_TMR));
-
-	request_irq(mcf_profilevector, coldfire_profile_tick,
-		(IRQF_DISABLED | IRQ_FLG_FAST), "profile timer", NULL);
-	mcf_settimericr(2, 7);
-}
-
-/***************************************************************************/
-#endif	/* CONFIG_HIGHPROFILE */
-/***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/5307/vectors.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/5307/vectors.c	2009-02-08 00:00:33.000000000 -0500
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,105 +0,0 @@
-/***************************************************************************/
-
-/*
- *	linux/arch/m68knommu/platform/5307/vectors.c
- *
- *	Copyright (C) 1999-2007, Greg Ungerer <gerg@snapgear.com>
- */
-
-/***************************************************************************/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <asm/traps.h>
-#include <asm/machdep.h>
-#include <asm/coldfire.h>
-#include <asm/mcfsim.h>
-#include <asm/mcfdma.h>
-#include <asm/mcfwdebug.h>
-
-/***************************************************************************/
-
-#ifdef TRAP_DBG_INTERRUPT
-
-asmlinkage void dbginterrupt_c(struct frame *fp)
-{
-	extern void dump(struct pt_regs *fp);
-	printk(KERN_DEBUG "%s(%d): BUS ERROR TRAP\n", __FILE__, __LINE__);
-	dump((struct pt_regs *) fp);
-	asm("halt");
-}
-
-#endif
-
-/***************************************************************************/
-
-extern e_vector	*_ramvec;
-
-void set_evector(int vecnum, void (*handler)(void))
-{
-	if (vecnum >= 0 && vecnum <= 255)
-		_ramvec[vecnum] = handler;
-}
-
-/***************************************************************************/
-
-/* Assembler routines */
-asmlinkage void buserr(void);
-asmlinkage void trap(void);
-asmlinkage void system_call(void);
-asmlinkage void inthandler(void);
-
-void __init init_vectors(void)
-{
-	int i;
-
-	/*
-	 *	There is a common trap handler and common interrupt
-	 *	handler that handle almost every vector. We treat
-	 *	the system call and bus error special, they get their
-	 *	own first level handlers.
-	 */
-	for (i = 3; (i <= 23); i++)
-		_ramvec[i] = trap;
-	for (i = 33; (i <= 63); i++)
-		_ramvec[i] = trap;
-	for (i = 24; (i <= 31); i++)
-		_ramvec[i] = inthandler;
-	for (i = 64; (i < 255); i++)
-		_ramvec[i] = inthandler;
-	_ramvec[255] = 0;
-
-	_ramvec[2] = buserr;
-	_ramvec[32] = system_call;
-
-#ifdef TRAP_DBG_INTERRUPT
-	_ramvec[12] = dbginterrupt;
-#endif
-}
-
-/***************************************************************************/
-
-void enable_vector(unsigned int irq)
-{
-	/* Currently no action on ColdFire */
-}
-
-void disable_vector(unsigned int irq)
-{
-	/* Currently no action on ColdFire */
-}
-
-void ack_vector(unsigned int irq)
-{
-	/* Currently no action on ColdFire */
-}
-
-/***************************************************************************/
-
-void coldfire_reset(void)
-{
-	HARD_RESET_NOW();
-}
-
-/***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/532x/config.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/532x/config.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/532x/config.c	2009-02-08 00:00:48.000000000 -0500
@@ -21,10 +21,11 @@
 #include <linux/param.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>
+#include <linux/io.h>
 #include <asm/machdep.h>
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
+#include <asm/mcfuart.h>
 #include <asm/mcfdma.h>
 #include <asm/mcfwdebug.h>
 
@@ -38,11 +39,75 @@ extern unsigned int mcf_timerlevel;
 
 /***************************************************************************/
 
-/*
- *	DMA channel base address table.
- */
-unsigned int dma_base_addr[MAX_M68K_DMA_CHANNELS] = { };
-unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+int sys_clk_khz = 0;
+int sys_clk_mhz = 0;
+
+void wtm_init(void);
+void scm_init(void);
+void gpio_init(void);
+void fbcs_init(void);
+void sdramc_init(void);
+int  clock_pll (int fsys, int flags);
+int  clock_limp (int);
+int  clock_exit_limp (void);
+int  get_sys_clock (void);
+
+/***************************************************************************/
+
+static struct mcf_platform_uart m532x_uart_platform[] = {
+	{
+		.mapbase	= MCF_MBAR + MCFUART_BASE1,
+		.irq		= MCFINT_VECBASE + MCFINT_UART0,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE2,
+		.irq		= MCFINT_VECBASE + MCFINT_UART1,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE3,
+		.irq		= MCFINT_VECBASE + MCFINT_UART2,
+	},
+	{ },
+};
+
+static struct platform_device m532x_uart = {
+	.name			= "mcfuart",
+	.id			= 0,
+	.dev.platform_data	= m532x_uart_platform,
+};
+
+static struct platform_device *m532x_devices[] __initdata = {
+	&m532x_uart,
+};
+
+/***************************************************************************/
+
+static void __init m532x_uart_init_line(int line, int irq)
+{
+	if (line == 0) {
+		MCF_INTC0_ICR26 = 0x3;
+		MCF_INTC0_CIMR = 26;
+		/* GPIO initialization */
+		MCF_GPIO_PAR_UART |= 0x000F;
+	} else if (line == 1) {
+		MCF_INTC0_ICR27 = 0x3;
+		MCF_INTC0_CIMR = 27;
+		/* GPIO initialization */
+		MCF_GPIO_PAR_UART |= 0x0FF0;
+	} else if (line == 2) {
+		MCF_INTC0_ICR28 = 0x3;
+		MCF_INTC0_CIMR = 28;
+	}
+}
+
+static void __init m532x_uarts_init(void)
+{
+	const int nrlines = ARRAY_SIZE(m532x_uart_platform);
+	int line;
+
+	for (line = 0; (line < nrlines); line++)
+		m532x_uart_init_line(line, m532x_uart_platform[line].irq);
+}
 
 /***************************************************************************/
 
@@ -66,22 +131,11 @@ void mcf_settimericr(unsigned int timer,
 
 /***************************************************************************/
 
-int mcf_timerirqpending(int timer)
+void __init config_BSP(char *commandp, int size)
 {
-	unsigned int imr = 0;
-
-	switch (timer) {
-	case 1:  imr = 0x1; break;
-	case 2:  imr = 0x2; break;
-	default: break;
-	}
-	return (mcf_getiprh() & imr);
-}
-
-/***************************************************************************/
+	sys_clk_khz = get_sys_clock();
+	sys_clk_mhz = sys_clk_khz/1000;
 
-void config_BSP(char *commandp, int size)
-{
 	mcf_setimr(MCFSIM_IMR_MASKALL);
 
 #if !defined(CONFIG_BOOTPARAM)
@@ -99,7 +153,7 @@ void config_BSP(char *commandp, int size
 	mcf_profilevector = 64+33;
 	mach_reset = coldfire_reset;
 
-#ifdef MCF_BDM_DISABLE
+#ifdef CONFIG_BDM_DISABLE
 	/*
 	 * Disable the BDM clocking.  This also turns off most of the rest of
 	 * the BDM device.  This is good for EMC reasons. This option is not
@@ -110,6 +164,17 @@ void config_BSP(char *commandp, int size
 }
 
 /***************************************************************************/
+
+static int __init init_BSP(void)
+{
+	m532x_uarts_init();
+	platform_add_devices(m532x_devices, ARRAY_SIZE(m532x_devices));
+	return 0;
+}
+
+arch_initcall(init_BSP);
+
+/***************************************************************************/
 /* Board initialization */
 
 /********************************************************************/
@@ -152,24 +217,9 @@ void config_BSP(char *commandp, int size
 
 #define NAND_FLASH_ADDRESS	(0xD0000000)
 
-int sys_clk_khz = 0;
-int sys_clk_mhz = 0;
-
-void wtm_init(void);
-void scm_init(void);
-void gpio_init(void);
-void fbcs_init(void);
-void sdramc_init(void);
-int  clock_pll (int fsys, int flags);
-int  clock_limp (int);
-int  clock_exit_limp (void);
-int  get_sys_clock (void);
 
 asmlinkage void __init sysinit(void)
 {
-	sys_clk_khz = clock_pll(0, 0);
-	sys_clk_mhz = sys_clk_khz/1000;
-	
 	wtm_init();
 	scm_init();
 	gpio_init();
@@ -207,25 +257,61 @@ void scm_init(void)
 
 void fbcs_init(void)
 {
+#if defined(CONFIG_COBRA5329)
+	/* The COBRA5329 by senTec needs this settings */
+
+	/*
+	 * We need to give the LCD enough bandwidth
+	 */
+
+        MCF_XBS_PRS1 = MCF_XBS_PRIO_LCD(MCF_PRIO_LVL_1)
+                     | MCF_XBS_PRIO_CORE(MCF_PRIO_LVL_2)
+                     | MCF_XBS_PRIO_FEC(MCF_PRIO_LVL_3)
+                     | MCF_XBS_PRIO_USBHOST(MCF_PRIO_LVL_4)
+                     | MCF_XBS_PRIO_EDMA(MCF_PRIO_LVL_5)
+                     | MCF_XBS_PRIO_USBOTG(MCF_PRIO_LVL_6)
+                     | MCF_XBS_PRIO_FACTTEST(MCF_PRIO_LVL_7);
+
+        /* Boot Flash connected to FBCS0 */
+        MCF_FBCS0_CSAR = FLASH_ADDRESS;
+        MCF_FBCS0_CSCR = (MCF_FBCS_CSCR_PS_16
+                        | MCF_FBCS_CSCR_BEM
+                        | MCF_FBCS_CSCR_AA
+                        | MCF_FBCS_CSCR_WS(8));
+
+        MCF_FBCS0_CSMR = (MCF_FBCS_CSMR_BAM_1G
+                        | MCF_FBCS_CSMR_V);
+
+        /* Fix bug #10 in the errata */
+        MCF_FBCS1_CSAR = 0xC0000000;
+        MCF_FBCS1_CSCR = (MCF_FBCS_CSCR_PS_16
+                        | MCF_FBCS_CSCR_BEM
+                        | MCF_FBCS_CSCR_AA
+                        | MCF_FBCS_CSCR_WS(8));
+
+        MCF_FBCS1_CSMR = (0x30000000
+                        | MCF_FBCS_CSMR_V
+                        | MCF_FBCS_CSMR_WP );
+#else
 	MCF_GPIO_PAR_CS = 0x0000003E;
 
 	/* Latch chip select */
 	MCF_FBCS1_CSAR = 0x10080000;
 
-	MCF_FBCS1_CSCR = 0x002A3780;
+	MCF_FBCS1_CSCR = 0x002A3580 | (MCF_FBCS1_CSCR&0x200);
 	MCF_FBCS1_CSMR = (MCF_FBCS_CSMR_BAM_2M | MCF_FBCS_CSMR_V);
 
 	/* Initialize latch to drive signals to inactive states */
-	*((u16 *)(0x10080000)) = 0xFFFF;
+	*((u16 *)(0x10080000)) = 0xD3FF;
 
-	/* External SRAM */
-	MCF_FBCS1_CSAR = EXT_SRAM_ADDRESS;
-	MCF_FBCS1_CSCR = (MCF_FBCS_CSCR_PS_16
-			| MCF_FBCS_CSCR_AA
-			| MCF_FBCS_CSCR_SBM
-			| MCF_FBCS_CSCR_WS(1));
-	MCF_FBCS1_CSMR = (MCF_FBCS_CSMR_BAM_512K
-			| MCF_FBCS_CSMR_V);
+//	/* External SRAM */
+//	MCF_FBCS1_CSAR = EXT_SRAM_ADDRESS;
+//	MCF_FBCS1_CSCR = (MCF_FBCS_CSCR_PS_16
+//			| MCF_FBCS_CSCR_AA
+//			| MCF_FBCS_CSCR_SBM
+//			| MCF_FBCS_CSCR_WS(1));
+//	MCF_FBCS1_CSMR = (MCF_FBCS_CSMR_BAM_512K
+//			| MCF_FBCS_CSMR_V);
 
 	/* Boot Flash connected to FBCS0 */
 	MCF_FBCS0_CSAR = FLASH_ADDRESS;
@@ -236,6 +322,7 @@ void fbcs_init(void)
 			| MCF_FBCS_CSCR_WS(7));
 	MCF_FBCS0_CSMR = (MCF_FBCS_CSMR_BAM_32M
 			| MCF_FBCS_CSMR_V);
+#endif
 }
 
 void sdramc_init(void)
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/532x/spi-mcf532x.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/532x/spi-mcf532x.c	2009-02-08 00:00:48.000000000 -0500
@@ -0,0 +1,176 @@
+/***************************************************************************/
+/*
+ *	linux/arch/m68knommu/platform/532x/spi-mcf532x.c
+ *
+ *	Sub-architcture dependant initialization code for the Freescale
+ *	532x SPI module
+ *
+ *	Yaroslav Vinogradov yaroslav.vinogradov@freescale.com
+ *	Copyright Freescale Semiconductor, Inc 2006
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ */
+/***************************************************************************/
+
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/param.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/mcfqspi.h>
+#include <linux/spi/ads7843.h>
+
+#include <asm/dma.h>
+#include <asm/traps.h>
+#include <asm/machdep.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+#include <asm/mcfdma.h>
+
+#define SPI_NUM_CHIPSELECTS 	0x04
+#define SPI_PAR_VAL		0xFFF0  /* Enable DIN, DOUT, CLK */
+
+#define MCF532x_QSPI_IRQ_SOURCE	(31)
+#define MCF532x_QSPI_IRQ_VECTOR	(64 + MCF532x_QSPI_IRQ_SOURCE)
+
+#define MCF532x_QSPI_PAR	(0xFC0A405A)
+#define MCF532x_QSPI_QMR	(0xFC05C000)
+#define MCF532x_INTC0_ICR	(0xFC048040)
+#define MCF532x_INTC0_IMRL	(0xFC04800C)
+
+/* on 5329 EVB ADS7843 is connected to IRQ4 */
+#define ADS784x_IRQ_SOURCE	4
+#define ADS784x_IRQ_VECTOR	(64+ADS784x_IRQ_SOURCE)
+#define ADS7843_IRQ_LEVEL	2
+
+
+void coldfire_qspi_cs_control(u8 cs, u8 command)
+{
+}
+
+#if defined(CONFIG_TOUCHSCREEN_ADS7843)
+static struct coldfire_spi_chip ads784x_chip_info = {
+	.mode = SPI_MODE_0,
+	.bits_per_word = 8,
+	.del_cs_to_clk = 17,
+	.del_after_trans = 1,
+	.void_write_data = 0
+};
+
+static struct ads7843_platform_data ads784x_platform_data = {
+	.model = 7843,
+	.vref_delay_usecs = 0,
+	.x_plate_ohms = 580,
+	.y_plate_ohms = 410
+};
+#endif
+
+
+static struct spi_board_info spi_board_info[] = {
+#if defined(CONFIG_TOUCHSCREEN_ADS7843)
+	{
+		.modalias = "ads7843",
+		.max_speed_hz = 125000 * 16,
+		.bus_num = 1,
+		.chip_select = 1,
+		.irq = ADS784x_IRQ_VECTOR,
+		.platform_data = &ads784x_platform_data,
+		.controller_data = &ads784x_chip_info
+	}
+#endif
+};
+
+static struct coldfire_spi_master coldfire_master_info = {
+	.bus_num = 1,
+	.num_chipselect = SPI_NUM_CHIPSELECTS,
+	.irq_source = MCF532x_QSPI_IRQ_SOURCE,
+	.irq_vector = MCF532x_QSPI_IRQ_VECTOR,
+	.irq_mask = (0x01 << MCF532x_QSPI_IRQ_SOURCE),
+	.irq_lp = 0x5,  /* Level */
+	.par_val = 0,   /* not used on 532x */
+	.par_val16 = SPI_PAR_VAL,
+	.cs_control = coldfire_qspi_cs_control,
+};
+
+static struct resource coldfire_spi_resources[] = {
+	[0] = {
+		.name = "qspi-par",
+		.start = MCF532x_QSPI_PAR,
+		.end = MCF532x_QSPI_PAR,
+		.flags = IORESOURCE_MEM
+	},
+
+	[1] = {
+		.name = "qspi-module",
+		.start = MCF532x_QSPI_QMR,
+		.end = MCF532x_QSPI_QMR + 0x18,
+		.flags = IORESOURCE_MEM
+	},
+
+	[2] = {
+		.name = "qspi-int-level",
+		.start = MCF532x_INTC0_ICR + MCF532x_QSPI_IRQ_SOURCE,
+		.end = MCF532x_INTC0_ICR + MCF532x_QSPI_IRQ_SOURCE,
+		.flags = IORESOURCE_MEM
+	},
+
+	[3] = {
+		.name = "qspi-int-mask",
+		.start = MCF532x_INTC0_IMRL,
+		.end = MCF532x_INTC0_IMRL,
+		.flags = IORESOURCE_MEM
+	}
+};
+
+static struct platform_device coldfire_spi = {
+	.name = "coldfire-qspi",
+	.id = -1,
+	.resource = coldfire_spi_resources,
+	.num_resources = ARRAY_SIZE(coldfire_spi_resources),
+	.dev = {
+		.platform_data = &coldfire_master_info,
+	}
+};
+
+#if defined(CONFIG_TOUCHSCREEN_ADS7843)
+static int __init init_ads7843(void)
+{
+	/* GPIO initiaalization */
+	MCF_GPIO_PAR_IRQ = MCF_GPIO_PAR_IRQ_PAR_IRQ4(0);
+	/* EPORT initialization */
+	MCF_EPORT_EPPAR = MCF_EPORT_EPPAR_EPPA4(MCF_EPORT_EPPAR_FALLING);
+	MCF_EPORT_EPDDR = 0;
+	MCF_EPORT_EPIER = MCF_EPORT_EPIER_EPIE4;
+	/* enable interrupt source */
+	MCF_INTC0_ICR4 = ADS7843_IRQ_LEVEL;
+	MCF_INTC0_CIMR = ADS784x_IRQ_SOURCE;
+}
+#endif
+
+static int __init spi_dev_init(void)
+{
+	int retval = 0;
+#if defined(CONFIG_TOUCHSCREEN_ADS7843)
+	init_ads7843();
+#endif
+
+	retval = platform_device_register(&coldfire_spi);
+	if (retval < 0)
+		goto out;
+
+	if (ARRAY_SIZE(spi_board_info))
+		retval = spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
+
+
+out:
+	return retval;
+}
+
+arch_initcall(spi_dev_init);
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/532x/usb-mcf532x.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/532x/usb-mcf532x.c	2009-02-08 00:00:48.000000000 -0500
@@ -0,0 +1,171 @@
+/***************************************************************************
+ * usb-mcf532x.c - Platform level (mcf532x) USB initialization.
+ *
+ * Andrey Butok Andrey.Butok@freescale.com.
+ * Copyright Freescale Semiconductor, Inc 2006
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ ***************************************************************************
+ * Changes:
+ *   v0.01	31 March 2006	Andrey Butok
+ *   		Initial Release - developed on uClinux with 2.6.15.6 kernel
+ *
+ * WARNING: The MCF532x USB functionality was tested
+ *          only with low-speed USB devices (cause of HW bugs).
+ */
+
+#undef	DEBUG
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+/* Start address of HC registers.*/
+#define MCF532x_USB_HOST_REG_START	(0xfc0b4000)
+/* End address of HC registers */
+#define MCF532x_USB_HOST_REG_END	(MCF532x_USB_HOST_REG_START+0x200)
+/* USB Host Interrupt number */
+#define MCF532x_USB_HOST_INT_NUMBER	(128+48)
+
+#ifdef CONFIG_USB_OTG
+/* Start address of OTG module registers.*/
+#define MCF532x_USB_OTG_REG_START	(0xfc0b0000)
+/* End address of OTG module registers */
+#define MCF532x_USB_OTG_REG_END		(MCF532x_USB_OTG_REG_START+0x200)
+/* USB OTG Interrupt number */
+#define MCF532x_USB_OTG_INT_NUMBER	(128+47)
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+static void
+usb_release(struct device *dev)
+{
+	/* normally not freed */
+}
+
+/*
+ * USB Host module structures
+ */
+static struct resource ehci_host_resources[] = {
+	{
+	 .start = MCF532x_USB_HOST_REG_START,
+	 .end = MCF532x_USB_HOST_REG_END,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MCF532x_USB_HOST_INT_NUMBER,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct platform_device ehci_host_device = {
+	.name = "ehci",
+	.id = 1,
+	.dev = {
+		.release = usb_release,
+		.dma_mask = 0x0},
+	.num_resources = ARRAY_SIZE(ehci_host_resources),
+	.resource = ehci_host_resources,
+};
+
+/*
+ * USB OTG module structures.
+ */
+#ifdef CONFIG_USB_OTG
+static struct resource ehci_otg_resources[] = {
+	{
+	 .start = MCF532x_USB_OTG_REG_START,
+	 .end = MCF532x_USB_OTG_REG_END,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MCF532x_USB_OTG_INT_NUMBER,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct platform_device ehci_otg_device = {
+	.name = "ehci",
+	.id = 0,
+	.dev = {
+		.release = usb_release,
+		.dma_mask = 0x0},
+	.num_resources = ARRAY_SIZE(ehci_otg_resources),
+	.resource = ehci_otg_resources,
+};
+#endif
+
+typedef volatile u8		vuint8;  /*  8 bits */
+
+static int __init
+mcf532x_usb_init(void)
+{
+	int status;
+
+	/*
+	 * Initialize the clock divider for the USB:
+	 */
+#if CONFIG_CLOCK_FREQ == 240000000
+	/*
+	 * CPU oerating on 240Mhz (MISCCR[USBDIV]=1)
+	 * this is the default
+	 */
+	(*(volatile u16 *) (0xFC0A0010)) |= (0x0002);
+#elif CONFIG_CLOCK_FREQ == 180000000
+	/*
+	 * CPU oerating on 180Mhz (MISCCR[USBDIV]=0)
+	 */
+	(*(volatile u16 *) (0xFC0A0010)) &= ~(0x0002);
+#else
+	#error "CLOCK must be 240MHz or 180Mhz"
+#endif
+	/*
+	 * Register USB Host device:
+	 */
+	status = platform_device_register(&ehci_host_device);
+	if (status) {
+		pr_info
+		    ("USB-MCF532x: Can't register MCF532x USB Host device, %d\n",
+		     status);
+		return -ENODEV;
+	}
+	pr_info("USB-MCF532x: MCF532x USB Host device is registered\n");
+
+#ifdef CONFIG_USB_OTG
+	/*
+	 *  Register USB OTG device:
+	 *  Done only USB Host.
+	 *  TODO: Device and OTG functinality.
+	 */
+	status = platform_device_register(&ehci_otg_device);
+	if (status) {
+		pr_info
+		    ("USB-MCF532x: Can't register MCF532x USB OTG device, %d\n",
+		     status);
+		return -ENODEV;
+	}
+	pr_info("USB-MCF532x: MCF532x USB OTG device is registered\n");
+#endif
+
+	return 0;
+}
+
+subsys_initcall(mcf532x_usb_init);
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/5407/config.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/5407/config.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/5407/config.c	2009-02-08 00:00:48.000000000 -0500
@@ -13,11 +13,11 @@
 #include <linux/param.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>
+#include <linux/io.h>
 #include <asm/machdep.h>
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
-#include <asm/mcfdma.h>
+#include <asm/mcfuart.h>
 
 /***************************************************************************/
 
@@ -29,17 +29,51 @@ extern unsigned int mcf_timerlevel;
 
 /***************************************************************************/
 
-/*
- *	DMA channel base address table.
- */
-unsigned int   dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
-        MCF_MBAR + MCFDMA_BASE0,
-        MCF_MBAR + MCFDMA_BASE1,
-        MCF_MBAR + MCFDMA_BASE2,
-        MCF_MBAR + MCFDMA_BASE3,
+static struct mcf_platform_uart m5407_uart_platform[] = {
+	{
+		.mapbase	= MCF_MBAR + MCFUART_BASE1,
+		.irq		= 73,
+	},
+	{
+		.mapbase 	= MCF_MBAR + MCFUART_BASE2,
+		.irq		= 74,
+	},
+	{ },
 };
 
-unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+static struct platform_device m5407_uart = {
+	.name			= "mcfuart",
+	.id			= 0,
+	.dev.platform_data	= m5407_uart_platform,
+};
+
+static struct platform_device *m5407_devices[] __initdata = {
+	&m5407_uart,
+};
+
+/***************************************************************************/
+
+static void __init m5407_uart_init_line(int line, int irq)
+{
+	if (line == 0) {
+		writel(MCFSIM_ICR_LEVEL6 | MCFSIM_ICR_PRI1, MCF_MBAR + MCFSIM_UART1ICR);
+		writeb(irq, MCFUART_BASE1 + MCFUART_UIVR);
+		mcf_setimr(mcf_getimr() & ~MCFSIM_IMR_UART1);
+	} else if (line == 1) {
+		writel(MCFSIM_ICR_LEVEL6 | MCFSIM_ICR_PRI2, MCF_MBAR + MCFSIM_UART2ICR);
+		writeb(irq, MCFUART_BASE2 + MCFUART_UIVR);
+		mcf_setimr(mcf_getimr() & ~MCFSIM_IMR_UART2);
+	}
+}
+
+static void __init m5407_uarts_init(void)
+{
+	const int nrlines = ARRAY_SIZE(m5407_uart_platform);
+	int line;
+
+	for (line = 0; (line < nrlines); line++)
+		m5407_uart_init_line(line, m5407_uart_platform[line].irq);
+}
 
 /***************************************************************************/
 
@@ -76,21 +110,7 @@ void mcf_settimericr(unsigned int timer,
 
 /***************************************************************************/
 
-int mcf_timerirqpending(int timer)
-{
-	unsigned int imr = 0;
-
-	switch (timer) {
-	case 1:  imr = MCFSIM_IMR_TIMER1; break;
-	case 2:  imr = MCFSIM_IMR_TIMER2; break;
-	default: break;
-	}
-	return (mcf_getipr() & imr);
-}
-
-/***************************************************************************/
-
-void config_BSP(char *commandp, int size)
+void __init config_BSP(char *commandp, int size)
 {
 	mcf_setimr(MCFSIM_IMR_MASKALL);
 
@@ -105,3 +125,14 @@ void config_BSP(char *commandp, int size
 }
 
 /***************************************************************************/
+
+static int __init init_BSP(void)
+{
+	m5407_uarts_init();
+	platform_add_devices(m5407_devices, ARRAY_SIZE(m5407_devices));
+	return 0;
+}
+
+arch_initcall(init_BSP);
+
+/***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/68328/ints.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/68328/ints.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/68328/ints.c	2009-02-08 00:00:48.000000000 -0500
@@ -101,6 +101,8 @@ void __init init_vectors(void)
 	IMR = ~0;
 }
 
+void do_IRQ(int irq, struct pt_regs *fp);
+
 /* The 68k family did not have a good way to determine the source
  * of interrupts until later in the family.  The EC000 core does
  * not provide the vector number on the stack, we vector everything
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/68328/timers.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/68328/timers.c	2009-02-08 00:00:33.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/68328/timers.c	2009-02-08 00:00:48.000000000 -0500
@@ -19,6 +19,7 @@
 #include <linux/mm.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
+#include <linux/clocksource.h>
 #include <asm/setup.h>
 #include <asm/system.h>
 #include <asm/pgtable.h>
@@ -51,6 +52,19 @@
 #define TICKS_PER_JIFFY	10
 #endif
 
+static u32 m68328_tick_cnt;
+
+/***************************************************************************/
+
+static irqreturn_t hw_tick(int irq, void *dummy)
+{
+	/* Reset Timer1 */
+	TSTAT &= 0;
+
+	m68328_tick_cnt += TICKS_PER_JIFFY;
+	return arch_timer_interrupt(irq, dummy);
+}
+
 /***************************************************************************/
 
 static irqreturn_t hw_tick(int irq, void *dummy)
@@ -69,6 +83,33 @@ static struct irqaction m68328_timer_irq
 	.handler = hw_tick,
 };
 
+/***************************************************************************/
+
+static cycle_t m68328_read_clk(void)
+{
+	unsigned long flags;
+	u32 cycles;
+
+	local_irq_save(flags);
+	cycles = m68328_tick_cnt + TCN;
+	local_irq_restore(flags);
+
+	return cycles;
+}
+
+/***************************************************************************/
+
+static struct clocksource m68328_clk = {
+	.name	= "timer",
+	.rating	= 250,
+        .read	= m68328_read_clk,
+	.shift	= 20,
+	.mask	= CLOCKSOURCE_MASK(32),
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+/***************************************************************************/
+
 void hw_timer_init(void)
 {
 	/* disable timer 1 */
@@ -84,19 +125,8 @@ void hw_timer_init(void)
 
 	/* Enable timer 1 */
 	TCTL |= TCTL_TEN;
-}
-
-/***************************************************************************/
-
-unsigned long hw_timer_offset(void)
-{
-	unsigned long ticks = TCN, offset = 0;
-
-	/* check for pending interrupt */
-	if (ticks < (TICKS_PER_JIFFY >> 1) && (ISR & (1 << TMR_IRQ_NUM)))
-		offset = 1000000 / HZ;
-	ticks = (ticks * 1000000 / HZ) / TICKS_PER_JIFFY;
-	return ticks + offset;
+	m68328_clk.mult = clocksource_hz2mult(TICKS_PER_JIFFY*HZ, m68328_clk.shift);
+	clocksource_register(&m68328_clk);
 }
 
 /***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/68360/config.c
===================================================================
--- linux-2.6.24.7-rt27.orig/arch/m68knommu/platform/68360/config.c	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/68360/config.c	2009-02-08 00:00:48.000000000 -0500
@@ -103,11 +103,6 @@ void hw_timer_init(void)
   pquicc->timer_tgcr  = tgcr_save;
 }
 
-unsigned long hw_timer_offset(void)
-{
-  return 0;
-}
-
 void BSP_gettod (int *yearp, int *monp, int *dayp,
 		   int *hourp, int *minp, int *secp)
 {
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/Makefile	2009-02-08 00:00:48.000000000 -0500
@@ -0,0 +1,32 @@
+#
+# Makefile for the m68knommu kernel.
+#
+
+#
+# If you want to play with the HW breakpoints then you will
+# need to add define this,  which will give you a stack backtrace
+# on the console port whenever a DBG interrupt occurs. You have to
+# set up you HW breakpoints to trigger a DBG interrupt:
+#
+# EXTRA_CFLAGS += -DTRAP_DBG_INTERRUPT
+# EXTRA_AFLAGS += -DTRAP_DBG_INTERRUPT
+#
+
+ifdef CONFIG_FULLDEBUG
+AFLAGS += -DDEBUGGER_COMPATIBLE_CACHE=1
+endif
+
+obj-$(CONFIG_COLDFIRE)	+= dma.o entry.o vectors.o
+obj-$(CONFIG_M5206)	+= timers.o
+obj-$(CONFIG_M5206e)	+= timers.o
+obj-$(CONFIG_M520x)	+= pit.o
+obj-$(CONFIG_M523x)	+= pit.o dma_timer.o irq_chip.o
+obj-$(CONFIG_M5249)	+= timers.o
+obj-$(CONFIG_M527x)	+= pit.o
+obj-$(CONFIG_M5272)	+= timers.o
+obj-$(CONFIG_M528x)	+= pit.o
+obj-$(CONFIG_M5307)	+= timers.o
+obj-$(CONFIG_M532x)	+= timers.o
+obj-$(CONFIG_M5407)	+= timers.o
+
+extra-y := head.o
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/dma.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/dma.c	2009-02-08 00:00:48.000000000 -0500
@@ -0,0 +1,39 @@
+/***************************************************************************/
+
+/*
+ *	dma.c -- Freescale ColdFire DMA support
+ *
+ *	Copyright (C) 2007, Greg Ungerer (gerg@snapgear.com)
+ */
+
+/***************************************************************************/
+
+#include <linux/kernel.h>
+#include <asm/dma.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+#include <asm/mcfdma.h>
+
+/***************************************************************************/
+
+/*
+ *      DMA channel base address table.
+ */
+unsigned int dma_base_addr[MAX_M68K_DMA_CHANNELS] = {
+#ifdef MCFDMA_BASE0
+        MCF_MBAR + MCFDMA_BASE0,
+#endif
+#ifdef MCFDMA_BASE1
+        MCF_MBAR + MCFDMA_BASE1,
+#endif
+#ifdef MCFDMA_BASE2
+        MCF_MBAR + MCFDMA_BASE2,
+#endif
+#ifdef MCFDMA_BASE3
+        MCF_MBAR + MCFDMA_BASE3,
+#endif
+};
+
+unsigned int dma_device_address[MAX_M68K_DMA_CHANNELS];
+
+/***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/dma_timer.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/dma_timer.c	2009-02-08 00:00:48.000000000 -0500
@@ -0,0 +1,84 @@
+/*
+ * dma_timer.c -- Freescale ColdFire DMA Timer.
+ *
+ * Copyright (C) 2007, Benedikt Spranger <b.spranger@linutronix.de>
+ * Copyright (C) 2008. Sebastian Siewior, Linutronix
+ *
+ */
+
+#include <linux/clocksource.h>
+#include <linux/io.h>
+
+#include <asm/machdep.h>
+#include <asm/coldfire.h>
+#include <asm/mcfpit.h>
+#include <asm/mcfsim.h>
+
+#define DMA_TIMER_0	(0x00)
+#define DMA_TIMER_1	(0x40)
+#define DMA_TIMER_2	(0x80)
+#define DMA_TIMER_3	(0xc0)
+
+#define DTMR0	(MCF_IPSBAR + DMA_TIMER_0 + 0x400)
+#define DTXMR0	(MCF_IPSBAR + DMA_TIMER_0 + 0x402)
+#define DTER0	(MCF_IPSBAR + DMA_TIMER_0 + 0x403)
+#define DTRR0	(MCF_IPSBAR + DMA_TIMER_0 + 0x404)
+#define DTCR0	(MCF_IPSBAR + DMA_TIMER_0 + 0x408)
+#define DTCN0	(MCF_IPSBAR + DMA_TIMER_0 + 0x40c)
+
+#define DMA_FREQ    ((MCF_CLK / 2) / 16)
+
+/* DTMR */
+#define DMA_DTMR_RESTART	(1 << 3)
+#define DMA_DTMR_CLK_DIV_1	(1 << 1)
+#define DMA_DTMR_CLK_DIV_16	(2 << 1)
+#define DMA_DTMR_ENABLE		(1 << 0)
+
+static cycle_t cf_dt_get_cycles(void)
+{
+	return __raw_readl(DTCN0);
+}
+
+static struct clocksource clocksource_cf_dt = {
+	.name		= "coldfire_dma_timer",
+	.rating		= 200,
+	.read		= cf_dt_get_cycles,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.shift		= 20,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static int __init  init_cf_dt_clocksource(void)
+{
+	/*
+	 * We setup DMA timer 0 in free run mode. This incrementing counter is
+	 * used as a highly precious clock source. With MCF_CLOCK = 150 MHz we
+	 * get a ~213 ns resolution and the 32bit register will overflow almost
+	 * every 15 minutes.
+	 */
+	__raw_writeb(0x00, DTXMR0);
+	__raw_writeb(0x00, DTER0);
+	__raw_writel(0x00000000, DTRR0);
+	__raw_writew(DMA_DTMR_CLK_DIV_16 | DMA_DTMR_ENABLE, DTMR0);
+	clocksource_cf_dt.mult = clocksource_hz2mult(DMA_FREQ,
+						     clocksource_cf_dt.shift);
+	return clocksource_register(&clocksource_cf_dt);
+}
+
+arch_initcall(init_cf_dt_clocksource);
+
+#define CYC2NS_SCALE_FACTOR 10 /* 2^10, carefully chosen in tsc / x86 */
+#define CYC2NS_SCALE	((1000000 << CYC2NS_SCALE_FACTOR) / (DMA_FREQ / 1000))
+
+static unsigned long long cycles2ns(unsigned long cycl)
+{
+	return (unsigned long long) ((unsigned long long)cycl * CYC2NS_SCALE)
+		>> CYC2NS_SCALE_FACTOR;
+}
+
+unsigned long long sched_clock(void)
+{
+	unsigned long cycl = __raw_readl(DTCN0);
+
+	return cycles2ns(cycl);
+}
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/entry.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/entry.S	2009-02-08 00:00:48.000000000 -0500
@@ -0,0 +1,241 @@
+/*
+ *  linux/arch/m68knommu/platform/5307/entry.S
+ *
+ *  Copyright (C) 1999-2007, Greg Ungerer (gerg@snapgear.com)
+ *  Copyright (C) 1998  D. Jeff Dionne <jeff@lineo.ca>,
+ *                      Kenneth Albanowski <kjahds@kjahds.com>,
+ *  Copyright (C) 2000  Lineo Inc. (www.lineo.com)
+ *  Copyright (C) 2004-2006  Macq Electronique SA. (www.macqel.com)
+ *
+ * Based on:
+ *
+ *  linux/arch/m68k/kernel/entry.S
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file README.legal in the main directory of this archive
+ * for more details.
+ *
+ * Linux/m68k support by Hamish Macdonald
+ *
+ * 68060 fixes by Jesper Skov
+ * ColdFire support by Greg Ungerer (gerg@snapgear.com)
+ * 5307 fixes by David W. Miller
+ * linux 2.4 support David McCullough <davidm@snapgear.com>
+ * Bug, speed and maintainability fixes by Philippe De Muyter <phdm@macqel.be>
+ */
+
+#include <linux/sys.h>
+#include <linux/linkage.h>
+#include <asm/unistd.h>
+#include <asm/thread_info.h>
+#include <asm/errno.h>
+#include <asm/setup.h>
+#include <asm/segment.h>
+#include <asm/asm-offsets.h>
+#include <asm/entry.h>
+
+.bss
+
+sw_ksp:
+.long	0
+
+sw_usp:
+.long	0
+
+.text
+
+.globl system_call
+.globl resume
+.globl ret_from_exception
+.globl ret_from_signal
+.globl sys_call_table
+.globl ret_from_interrupt
+.globl inthandler
+.globl fasthandler
+
+enosys:
+	mov.l	#sys_ni_syscall,%d3
+	bra	1f
+
+ENTRY(system_call)
+	SAVE_ALL
+	move	#0x2000,%sr		/* enable intrs again */
+
+	cmpl	#NR_syscalls,%d0
+	jcc	enosys
+	lea	sys_call_table,%a0
+	lsll	#2,%d0			/* movel %a0@(%d0:l:4),%d3 */
+	movel	%a0@(%d0),%d3
+	jeq	enosys
+
+1:
+	movel	%sp,%d2			/* get thread_info pointer */
+	andl	#-THREAD_SIZE,%d2	/* at start of kernel stack */
+	movel	%d2,%a0
+	movel	%a0@,%a1		/* save top of frame */
+	movel	%sp,%a1@(TASK_THREAD+THREAD_ESP0)
+	btst	#(TIF_SYSCALL_TRACE%8),%a0@(TI_FLAGS+(31-TIF_SYSCALL_TRACE)/8)
+	bnes	1f
+
+	movel	%d3,%a0
+	jbsr	%a0@
+	movel	%d0,%sp@(PT_D0)		/* save the return value */
+	jra	ret_from_exception
+1:
+	movel	#-ENOSYS,%d2		/* strace needs -ENOSYS in PT_D0 */
+	movel	%d2,PT_D0(%sp)		/* on syscall entry */
+	subql	#4,%sp
+	SAVE_SWITCH_STACK
+	jbsr	syscall_trace
+	RESTORE_SWITCH_STACK
+	addql	#4,%sp
+	movel	%d3,%a0
+	jbsr	%a0@
+	movel	%d0,%sp@(PT_D0)		/* save the return value */
+	subql	#4,%sp			/* dummy return address */
+	SAVE_SWITCH_STACK
+	jbsr	syscall_trace
+
+ret_from_signal:
+	RESTORE_SWITCH_STACK
+	addql	#4,%sp
+
+ret_from_exception:
+	move    #0x2700,%sr             /* disable intrs */
+	btst	#5,%sp@(PT_SR)		/* check if returning to kernel */
+	jeq	Luser_return		/* if so, skip resched, signals */
+
+#ifdef CONFIG_PREEMPT
+	movel	%sp,%d1			/* get thread_info pointer */
+	andl	#-THREAD_SIZE,%d1	/* at base of kernel stack */
+	movel	%d1,%a0
+	movel	%a0@(TI_FLAGS),%d1	/* get thread_info->flags */
+	andl	#_TIF_NEED_RESCHED,%d1
+	jeq	Lkernel_return
+
+	movel	%a0@(TI_PREEMPTCOUNT),%d1
+	cmpl	#0,%d1
+	jne	Lkernel_return
+
+	pea	Lkernel_return
+	jmp	preempt_schedule_irq	/* preempt the kernel */
+#endif
+
+Lkernel_return:
+	moveml	%sp@,%d1-%d5/%a0-%a2
+	lea	%sp@(32),%sp		/* space for 8 regs */
+	movel	%sp@+,%d0
+	addql	#4,%sp			/* orig d0 */
+	addl	%sp@+,%sp		/* stk adj */
+	rte
+
+Luser_return:
+	movel	%sp,%d1			/* get thread_info pointer */
+	andl	#-THREAD_SIZE,%d1	/* at base of kernel stack */
+	movel	%d1,%a0
+	movel	%a0@(TI_FLAGS),%d1	/* get thread_info->flags */
+	andl	#_TIF_WORK_MASK,%d1
+	jne	Lwork_to_do		/* still work to do */
+
+Lreturn:
+	move	#0x2700,%sr		/* disable intrs */
+	movel	sw_usp,%a0		/* get usp */
+	movel	%sp@(PT_PC),%a0@-	/* copy exception program counter */
+	movel	%sp@(PT_FORMATVEC),%a0@-/* copy exception format/vector/sr */
+	moveml	%sp@,%d1-%d5/%a0-%a2
+	lea	%sp@(32),%sp		/* space for 8 regs */
+	movel	%sp@+,%d0
+	addql	#4,%sp			/* orig d0 */
+	addl	%sp@+,%sp		/* stk adj */
+	addql	#8,%sp			/* remove exception */
+	movel	%sp,sw_ksp		/* save ksp */
+	subql	#8,sw_usp		/* set exception */
+	movel	sw_usp,%sp		/* restore usp */
+	rte
+
+Lwork_to_do:
+	movel	%a0@(TI_FLAGS),%d1	/* get thread_info->flags */
+	move    #0x2000,%sr             /* enable intrs again */
+	btst	#TIF_NEED_RESCHED,%d1
+	jne	reschedule
+
+	/* GERG: do we need something here for TRACEing?? */
+
+Lsignal_return:
+	subql	#4,%sp			/* dummy return address */
+	SAVE_SWITCH_STACK
+	pea	%sp@(SWITCH_STACK_SIZE)
+	clrl	%sp@-
+	jsr	do_signal
+	addql	#8,%sp
+	RESTORE_SWITCH_STACK
+	addql	#4,%sp
+	jmp	Lreturn
+
+/*
+ * This is the generic interrupt handler (for all hardware interrupt
+ * sources). Calls upto high level code to do all the work.
+ */
+ENTRY(inthandler)
+	SAVE_ALL
+	moveq	#-1,%d0
+	movel	%d0,%sp@(PT_ORIG_D0)
+
+	movew	%sp@(PT_FORMATVEC),%d0	/* put exception # in d0 */
+	andl	#0x03fc,%d0		/* mask out vector only */
+
+	movel	%sp,%sp@-		/* push regs arg */
+	lsrl	#2,%d0			/* calculate real vector # */
+	movel	%d0,%sp@-		/* push vector number */
+	jbsr	do_IRQ			/* call high level irq handler */
+	lea	%sp@(8),%sp		/* pop args off stack */
+
+	bra	ret_from_interrupt	/* this was fallthrough */
+
+/*
+ * This is the fast interrupt handler (for certain hardware interrupt
+ * sources). Unlike the normal interrupt handler it just uses the
+ * current stack (doesn't care if it is user or kernel). It also
+ * doesn't bother doing the bottom half handlers.
+ */
+ENTRY(fasthandler)
+	SAVE_LOCAL
+
+	movew	%sp@(PT_FORMATVEC),%d0
+	andl	#0x03fc,%d0		/* mask out vector only */
+
+	movel	%sp,%sp@-		/* push regs arg */
+	lsrl	#2,%d0			/* calculate real vector # */
+	movel	%d0,%sp@-		/* push vector number */
+	jbsr	do_IRQ			/* call high level irq handler */
+	lea	%sp@(8),%sp		/* pop args off stack */
+
+	RESTORE_LOCAL
+
+ENTRY(ret_from_interrupt)
+	/* the fasthandler is confusing me, haven't seen any user */
+	jmp	ret_from_exception
+
+/*
+ * Beware - when entering resume, prev (the current task) is
+ * in a0, next (the new task) is in a1,so don't change these
+ * registers until their contents are no longer needed.
+ * This is always called in supervisor mode, so don't bother to save
+ * and restore sr; user's process sr is actually in the stack.
+ */
+ENTRY(resume)
+	movel	%a0, %d1			/* get prev thread in d1 */
+
+	movel	sw_usp,%d0			/* save usp */
+	movel	%d0,%a0@(TASK_THREAD+THREAD_USP)
+
+	SAVE_SWITCH_STACK
+	movel	%sp,%a0@(TASK_THREAD+THREAD_KSP) /* save kernel stack pointer */
+	movel	%a1@(TASK_THREAD+THREAD_KSP),%sp /* restore new thread stack */
+	RESTORE_SWITCH_STACK
+
+	movel	%a1@(TASK_THREAD+THREAD_USP),%a0 /* restore thread user stack */
+	movel	%a0, sw_usp
+	rts
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/head.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/head.S	2009-02-08 00:00:48.000000000 -0500
@@ -0,0 +1,222 @@
+/*****************************************************************************/
+
+/*
+ *	head.S -- common startup code for ColdFire CPUs.
+ *
+ *	(C) Copyright 1999-2006, Greg Ungerer <gerg@snapgear.com>.
+ */
+
+/*****************************************************************************/
+
+#include <linux/sys.h>
+#include <linux/linkage.h>
+#include <asm/asm-offsets.h>
+#include <asm/coldfire.h>
+#include <asm/mcfcache.h>
+#include <asm/mcfsim.h>
+
+/*****************************************************************************/
+
+/*
+ *	If we don't have a fixed memory size, then lets build in code
+ *	to auto detect the DRAM size. Obviously this is the prefered
+ *	method, and should work for most boards. It won't work for those
+ *	that do not have their RAM starting at address 0, and it only
+ *	works on SDRAM (not boards fitted with SRAM).
+ */
+#if CONFIG_RAMSIZE != 0
+.macro GET_MEM_SIZE
+	movel	#CONFIG_RAMSIZE,%d0	/* hard coded memory size */
+.endm
+
+#elif defined(CONFIG_M5206) || defined(CONFIG_M5206e) || \
+      defined(CONFIG_M5249) || defined(CONFIG_M527x) || \
+      defined(CONFIG_M528x) || defined(CONFIG_M5307) || \
+      defined(CONFIG_M5407)
+/*
+ *	Not all these devices have exactly the same DRAM controller,
+ *	but the DCMR register is virtually identical - give or take
+ *	a couple of bits. The only exception is the 5272 devices, their
+ *	DRAM controller is quite different.
+ */
+.macro GET_MEM_SIZE
+	movel	MCF_MBAR+MCFSIM_DMR0,%d0 /* get mask for 1st bank */
+	btst	#0,%d0			/* check if region enabled */
+	beq	1f
+	andl	#0xfffc0000,%d0
+	beq	1f
+	addl	#0x00040000,%d0		/* convert mask to size */
+1:
+	movel	MCF_MBAR+MCFSIM_DMR1,%d1 /* get mask for 2nd bank */
+	btst	#0,%d1			/* check if region enabled */
+	beq	2f
+	andl	#0xfffc0000, %d1
+	beq	2f
+	addl	#0x00040000,%d1
+	addl	%d1,%d0			/* total mem size in d0 */
+2:
+.endm
+
+#elif defined(CONFIG_M5272)
+.macro GET_MEM_SIZE
+	movel	MCF_MBAR+MCFSIM_CSOR7,%d0 /* get SDRAM address mask */
+	andil	#0xfffff000,%d0		/* mask out chip select options */
+	negl	%d0			/* negate bits */
+.endm
+
+#elif defined(CONFIG_M520x)
+.macro GET_MEM_SIZE
+	clrl	%d0
+	movel	MCF_MBAR+MCFSIM_SDCS0, %d2 /* Get SDRAM chip select 0 config */
+	andl	#0x1f, %d2		/* Get only the chip select size */
+	beq	3f			/* Check if it is enabled */
+	addql	#1, %d2			/* Form exponent */
+	moveql	#1, %d0
+	lsll	%d2, %d0		/* 2 ^ exponent */
+3:
+	movel	MCF_MBAR+MCFSIM_SDCS1, %d2 /* Get SDRAM chip select 1 config */
+	andl	#0x1f, %d2		/* Get only the chip select size */
+	beq	4f			/* Check if it is enabled */
+	addql	#1, %d2			/* Form exponent */
+	moveql	#1, %d1
+	lsll	%d2, %d1		/* 2 ^ exponent */
+	addl	%d1, %d0		/* Total size of SDRAM in d0 */
+4:
+.endm
+
+#else
+#error "ERROR: I don't know how to probe your boards memory size?"
+#endif
+
+/*****************************************************************************/
+
+/*
+ *	Boards and platforms can do specific early hardware setup if
+ *	they need to. Most don't need this, define away if not required.
+ */
+#ifndef PLATFORM_SETUP
+#define	PLATFORM_SETUP
+#endif
+
+/*****************************************************************************/
+
+.global	_start
+.global _rambase
+.global _ramvec
+.global	_ramstart
+.global	_ramend
+
+/*****************************************************************************/
+
+.data
+
+/*
+ *	During startup we store away the RAM setup. These are not in the
+ *	bss, since their values are determined and written before the bss
+ *	has been cleared.
+ */
+_rambase:
+.long	0
+_ramvec:
+.long	0
+_ramstart:
+.long	0
+_ramend:
+.long	0
+
+/*****************************************************************************/
+
+.text
+
+/*
+ *	This is the codes first entry point. This is where it all
+ *	begins...
+ */
+
+_start:
+	nop					/* filler */
+	movew	#0x2700, %sr			/* no interrupts */
+
+	/*
+	 *	Do any platform or board specific setup now. Most boards
+	 *	don't need anything. Those exceptions are define this in
+	 *	their board specific includes.
+	 */
+	PLATFORM_SETUP
+
+	/*
+	 *	Create basic memory configuration. Set VBR accordingly,
+	 *	and size memory.
+	 */
+	movel	#CONFIG_VECTORBASE,%a7
+	movec   %a7,%VBR			/* set vectors addr */
+	movel	%a7,_ramvec
+
+	movel	#CONFIG_RAMBASE,%a7		/* mark the base of RAM */
+	movel	%a7,_rambase
+
+	GET_MEM_SIZE				/* macro code determines size */
+	addl	%a7,%d0
+	movel	%d0,_ramend			/* set end ram addr */
+
+	/*
+	 *	Now that we know what the memory is, lets enable cache
+	 *	and get things moving. This is Coldfire CPU specific.
+	 */
+	CACHE_ENABLE				/* enable CPU cache */
+
+
+#ifdef CONFIG_ROMFS_FS
+	/*
+	 *	Move ROM filesystem above bss :-)
+	 */
+	lea	_sbss,%a0			/* get start of bss */
+	lea	_ebss,%a1			/* set up destination  */
+	movel	%a0,%a2				/* copy of bss start */
+
+	movel	8(%a0),%d0			/* get size of ROMFS */
+	addql	#8,%d0				/* allow for rounding */
+	andl	#0xfffffffc, %d0		/* whole words */
+
+	addl	%d0,%a0				/* copy from end */
+	addl	%d0,%a1				/* copy from end */
+	movel	%a1,_ramstart			/* set start of ram */
+
+_copy_romfs:
+	movel	-(%a0),%d0			/* copy dword */
+	movel	%d0,-(%a1)
+	cmpl	%a0,%a2				/* check if at end */
+	bne	_copy_romfs
+
+#else /* CONFIG_ROMFS_FS */
+	lea	_ebss,%a1
+	movel	%a1,_ramstart
+#endif /* CONFIG_ROMFS_FS */
+
+
+	/*
+	 *	Zero out the bss region.
+	 */
+	lea	_sbss,%a0			/* get start of bss */
+	lea	_ebss,%a1			/* get end of bss */
+	clrl	%d0				/* set value */
+_clear_bss:
+	movel	%d0,(%a0)+			/* clear each word */
+	cmpl	%a0,%a1				/* check if at end */
+	bne	_clear_bss
+
+	/*
+	 *	Load the current task pointer and stack.
+	 */
+	lea	init_thread_union,%a0
+	lea	THREAD_SIZE(%a0),%sp
+
+	/*
+	 *	Assember start up done, start code proper.
+	 */
+	jsr	start_kernel			/* start Linux kernel */
+
+_exit:
+	jmp	_exit				/* should never get here */
+
+/*****************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/irq_chip.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/irq_chip.c	2009-02-08 00:00:48.000000000 -0500
@@ -0,0 +1,110 @@
+/*
+ * IRQ-Chip implementation for Coldfire
+ *
+ * Author: Sebastian Siewior <bigeasy@linutronix.de>
+ */
+
+#include <linux/types.h>
+#include <linux/irq.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+
+static inline void *coldfire_irqnum_to_mem(unsigned int irq)
+{
+	u32 imrp;
+
+	imrp = MCF_IPSBAR;
+#if defined(MCFINT_INTC1_VECBASE)
+	if (irq > MCFINT_INTC1_VECBASE) {
+		imrp += MCFICM_INTC1;
+		irq -= MCFINT_PER_INTC;
+	} else
+#endif
+		imrp += MCFICM_INTC0;
+
+	irq -= MCFINT_VECBASE;
+
+	if (irq > 32)
+		imrp += MCFINTC_IMRH;
+	else
+		imrp += MCFINTC_IMRL;
+
+	return (void *)imrp;
+}
+
+static inline unsigned int coldfire_irqnum_to_bit(unsigned int irq)
+{
+	irq -= MCFINT_VECBASE;
+
+	if (irq > 32)
+		irq -= 32;
+
+	return irq;
+}
+
+static void coldfire_mask(unsigned int irq)
+{
+	volatile unsigned long *imrp;
+	u32 mask;
+	u32 irq_bit;
+
+	imrp = coldfire_irqnum_to_mem(irq);
+	irq_bit = coldfire_irqnum_to_bit(irq);
+
+	mask = 1 << irq_bit;
+	*imrp |= mask;
+}
+
+static void coldfire_unmask(unsigned int irq)
+{
+	volatile unsigned long *imrp;
+	u32 mask;
+	u32 irq_bit;
+
+	imrp = coldfire_irqnum_to_mem(irq);
+	irq_bit = coldfire_irqnum_to_bit(irq);
+
+	mask = 1 << irq_bit;
+	*imrp &= ~mask;
+}
+
+static void coldfire_nop(unsigned int irq)
+{
+}
+
+static struct irq_chip m_irq_chip = {
+	.name           = "M68K-INTC",
+	.ack            = coldfire_nop,
+	.mask           = coldfire_mask,
+	.unmask         = coldfire_unmask,
+};
+
+void __init coldfire_init_irq_chip(void)
+{
+	volatile u32 *imrp;
+	volatile u8 *icrp;
+	u32 irq;
+	u32 i;
+
+	for (irq = 0; irq < NR_IRQS; irq++)
+		set_irq_chip_and_handler_name(irq, &m_irq_chip,
+				handle_level_irq, m_irq_chip.name);
+
+	/* setup prios for interrupt sources (first field is reserved) */
+	icrp = (u8 *)MCF_IPSBAR + MCFICM_INTC0 + MCFINTC_ICR0;
+	for (i = 1; i <= 63; i++)
+		icrp[i] = i;
+
+	/* remove the disable all flag, disable all interrupt sources */
+	imrp = coldfire_irqnum_to_mem(MCFINT_VECBASE);
+	*imrp = 0xfffffffe;
+
+#if defined(MCFINT_INTC1_VECBASE)
+	icrp = (u8 *)MCF_IPSBAR + MCFICM_INTC1 + MCFINTC_ICR0;
+	for (i = 1; i <= 63; i++)
+		icrp[i] = i;
+
+	imrp = coldfire_irqnum_to_mem(MCFINT_INTC1_VECBASE);
+	*imrp = 0xfffffffe;
+#endif
+}
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/pit.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/pit.c	2009-02-08 00:00:48.000000000 -0500
@@ -0,0 +1,180 @@
+/***************************************************************************/
+
+/*
+ *	pit.c -- Freescale ColdFire PIT timer. Currently this type of
+ *	         hardware timer only exists in the Freescale ColdFire
+ *		 5270/5271, 5282 and 5208 CPUs. No doubt newer ColdFire
+ *		 family members will probably use it too.
+ *
+ *	Copyright (C) 1999-2008, Greg Ungerer (gerg@snapgear.com)
+ *	Copyright (C) 2001-2004, SnapGear Inc. (www.snapgear.com)
+ */
+
+/***************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/param.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/clockchips.h>
+#include <asm/machdep.h>
+#include <asm/io.h>
+#include <asm/coldfire.h>
+#include <asm/mcfpit.h>
+#include <asm/mcfsim.h>
+
+/***************************************************************************/
+
+/*
+ *	By default use timer1 as the system clock timer.
+ */
+#define	FREQ	((MCF_CLK / 2) / 64)
+#define	TA(a)	(MCF_IPSBAR + MCFPIT_BASE1 + (a))
+#define	INTC0	(MCF_IPSBAR + MCFICM_INTC0)
+#define PIT_CYCLES_PER_JIFFY (FREQ / HZ)
+
+static u32 pit_cnt;
+
+/*
+ * Initialize the PIT timer.
+ *
+ * This is also called after resume to bring the PIT into operation again.
+ */
+
+static void init_cf_pit_timer(enum clock_event_mode mode,
+                             struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+
+		__raw_writew(MCFPIT_PCSR_DISABLE, TA(MCFPIT_PCSR));
+		__raw_writew(PIT_CYCLES_PER_JIFFY, TA(MCFPIT_PMR));
+		__raw_writew(MCFPIT_PCSR_EN | MCFPIT_PCSR_PIE | \
+				MCFPIT_PCSR_OVW | MCFPIT_PCSR_RLD | \
+				MCFPIT_PCSR_CLK64, TA(MCFPIT_PCSR));
+		break;
+
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_UNUSED:
+
+		__raw_writew(MCFPIT_PCSR_DISABLE, TA(MCFPIT_PCSR));
+		break;
+
+	case CLOCK_EVT_MODE_ONESHOT:
+
+		__raw_writew(MCFPIT_PCSR_DISABLE, TA(MCFPIT_PCSR));
+		__raw_writew(MCFPIT_PCSR_EN | MCFPIT_PCSR_PIE | \
+				MCFPIT_PCSR_OVW | MCFPIT_PCSR_CLK64, \
+				TA(MCFPIT_PCSR));
+		break;
+
+	case CLOCK_EVT_MODE_RESUME:
+		/* Nothing to do here */
+		break;
+	}
+}
+
+/*
+ * Program the next event in oneshot mode
+ *
+ * Delta is given in PIT ticks
+ */
+static int cf_pit_next_event(unsigned long delta,
+		struct clock_event_device *evt)
+{
+	__raw_writew(delta, TA(MCFPIT_PMR));
+	return 0;
+}
+
+struct clock_event_device cf_pit_clockevent = {
+	.name		= "pit",
+	.features	= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode	= init_cf_pit_timer,
+	.set_next_event	= cf_pit_next_event,
+	.shift		= 32,
+	.irq		= MCFINT_VECBASE + MCFINT_PIT1,
+};
+
+
+
+/***************************************************************************/
+
+static irqreturn_t pit_tick(int irq, void *dummy)
+{
+	struct clock_event_device *evt = &cf_pit_clockevent;
+	u16 pcsr;
+
+	/* Reset the ColdFire timer */
+	pcsr = __raw_readw(TA(MCFPIT_PCSR));
+	__raw_writew(pcsr | MCFPIT_PCSR_PIF, TA(MCFPIT_PCSR));
+
+	pit_cnt += PIT_CYCLES_PER_JIFFY;
+	evt->event_handler(evt);
+	return IRQ_HANDLED;
+}
+
+/***************************************************************************/
+
+static struct irqaction pit_irq = {
+	.name	 = "timer",
+	.flags	 = IRQF_DISABLED | IRQF_TIMER,
+	.handler = pit_tick,
+};
+
+/***************************************************************************/
+
+static cycle_t pit_read_clk(void)
+{
+	unsigned long flags;
+	u32 cycles;
+	u16 pcntr;
+
+	local_irq_save(flags);
+	pcntr = __raw_readw(TA(MCFPIT_PCNTR));
+	cycles = pit_cnt;
+	local_irq_restore(flags);
+
+	return cycles + PIT_CYCLES_PER_JIFFY - pcntr;
+}
+
+/***************************************************************************/
+
+static struct clocksource pit_clk = {
+	.name	= "pit",
+	.rating	= 100,
+	.read	= pit_read_clk,
+	.shift	= 20,
+	.mask	= CLOCKSOURCE_MASK(32),
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+/***************************************************************************/
+
+void hw_timer_init(void)
+{
+	u32 imr;
+
+	cf_pit_clockevent.cpumask = cpumask_of_cpu(smp_processor_id());
+	cf_pit_clockevent.mult = div_sc(FREQ, NSEC_PER_SEC, 32);
+	cf_pit_clockevent.max_delta_ns =
+		clockevent_delta2ns(0xFFFF, &cf_pit_clockevent);
+	cf_pit_clockevent.min_delta_ns =
+		clockevent_delta2ns(0x3f, &cf_pit_clockevent);
+	clockevents_register_device(&cf_pit_clockevent);
+
+	setup_irq(MCFINT_VECBASE + MCFINT_PIT1, &pit_irq);
+
+#if !defined(CONFIG_M523x)
+	__raw_writeb(ICR_INTRCONF, INTC0 + MCFINTC_ICR0 + MCFINT_PIT1);
+	imr = __raw_readl(INTC0 + MCFPIT_IMR);
+	imr &= ~MCFPIT_IMR_IBIT;
+	__raw_writel(imr, INTC0 + MCFPIT_IMR);
+
+#endif
+	pit_clk.mult = clocksource_hz2mult(FREQ, pit_clk.shift);
+	clocksource_register(&pit_clk);
+}
+
+/***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/timers.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/timers.c	2009-02-08 00:00:48.000000000 -0500
@@ -0,0 +1,182 @@
+/***************************************************************************/
+
+/*
+ *	timers.c -- generic ColdFire hardware timer support.
+ *
+ *	Copyright (C) 1999-2008, Greg Ungerer <gerg@snapgear.com>
+ */
+
+/***************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/profile.h>
+#include <linux/clocksource.h>
+#include <asm/io.h>
+#include <asm/traps.h>
+#include <asm/machdep.h>
+#include <asm/coldfire.h>
+#include <asm/mcftimer.h>
+#include <asm/mcfsim.h>
+
+/***************************************************************************/
+
+/*
+ *	By default use timer1 as the system clock timer.
+ */
+#define	FREQ	(MCF_BUSCLK / 16)
+#define	TA(a)	(MCF_MBAR + MCFTIMER_BASE1 + (a))
+
+/*
+ *	Default the timer and vector to use for ColdFire. Some ColdFire
+ *	CPU's and some boards may want different. Their sub-architecture
+ *	startup code (in config.c) can change these if they want.
+ */
+unsigned int	mcf_timervector = 29;
+unsigned int	mcf_profilevector = 31;
+unsigned int	mcf_timerlevel = 5;
+
+/*
+ *	These provide the underlying interrupt vector support.
+ *	Unfortunately it is a little different on each ColdFire.
+ */
+extern void mcf_settimericr(int timer, int level);
+void coldfire_profile_init(void);
+
+#if defined(CONFIG_M532x)
+#define	__raw_readtrr	__raw_readl
+#define	__raw_writetrr	__raw_writel
+#else
+#define	__raw_readtrr	__raw_readw
+#define	__raw_writetrr	__raw_writew
+#endif
+
+static u32 mcftmr_cycles_per_jiffy;
+static u32 mcftmr_cnt;
+
+/***************************************************************************/
+
+static irqreturn_t mcftmr_tick(int irq, void *dummy)
+{
+	/* Reset the ColdFire timer */
+	__raw_writeb(MCFTIMER_TER_CAP | MCFTIMER_TER_REF, TA(MCFTIMER_TER));
+
+	mcftmr_cnt += mcftmr_cycles_per_jiffy;
+	return arch_timer_interrupt(irq, dummy);
+}
+
+/***************************************************************************/
+
+static struct irqaction mcftmr_timer_irq = {
+	.name	 = "timer",
+	.flags	 = IRQF_DISABLED | IRQF_TIMER,
+	.handler = mcftmr_tick,
+};
+
+/***************************************************************************/
+
+static cycle_t mcftmr_read_clk(void)
+{
+	unsigned long flags;
+	u32 cycles;
+	u16 tcn;
+
+	local_irq_save(flags);
+	tcn = __raw_readw(TA(MCFTIMER_TCN));
+	cycles = mcftmr_cnt;
+	local_irq_restore(flags);
+
+	return cycles + tcn;
+}
+
+/***************************************************************************/
+
+static struct clocksource mcftmr_clk = {
+	.name	= "tmr",
+	.rating	= 250,
+	.read	= mcftmr_read_clk,
+	.shift	= 20,
+	.mask	= CLOCKSOURCE_MASK(32),
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+/***************************************************************************/
+
+void hw_timer_init(void)
+{
+	setup_irq(mcf_timervector, &mcftmr_timer_irq);
+
+	__raw_writew(MCFTIMER_TMR_DISABLE, TA(MCFTIMER_TMR));
+	mcftmr_cycles_per_jiffy = FREQ / HZ;
+	__raw_writetrr(mcftmr_cycles_per_jiffy, TA(MCFTIMER_TRR));
+	__raw_writew(MCFTIMER_TMR_ENORI | MCFTIMER_TMR_CLK16 |
+		MCFTIMER_TMR_RESTART | MCFTIMER_TMR_ENABLE, TA(MCFTIMER_TMR));
+
+	mcftmr_clk.mult = clocksource_hz2mult(FREQ, mcftmr_clk.shift);
+	clocksource_register(&mcftmr_clk);
+
+	mcf_settimericr(1, mcf_timerlevel);
+
+#ifdef CONFIG_HIGHPROFILE
+	coldfire_profile_init();
+#endif
+}
+
+/***************************************************************************/
+#ifdef CONFIG_HIGHPROFILE
+/***************************************************************************/
+
+/*
+ *	By default use timer2 as the profiler clock timer.
+ */
+#define	PA(a)	(MCF_MBAR + MCFTIMER_BASE2 + (a))
+
+/*
+ *	Choose a reasonably fast profile timer. Make it an odd value to
+ *	try and get good coverage of kernel operations.
+ */
+#define	PROFILEHZ	1013
+
+/*
+ *	Use the other timer to provide high accuracy profiling info.
+ */
+irqreturn_t coldfire_profile_tick(int irq, void *dummy)
+{
+	/* Reset ColdFire timer2 */
+	__raw_writeb(MCFTIMER_TER_CAP | MCFTIMER_TER_REF, PA(MCFTIMER_TER));
+	if (current->pid)
+		profile_tick(CPU_PROFILING);
+	return IRQ_HANDLED;
+}
+
+/***************************************************************************/
+
+static struct irqaction coldfire_profile_irq = {
+	.name	 = "profile timer",
+	.flags	 = IRQF_DISABLED | IRQF_TIMER,
+	.handler = coldfire_profile_tick,
+};
+
+void coldfire_profile_init(void)
+{
+	printk(KERN_INFO "PROFILE: lodging TIMER2 @ %dHz as profile timer\n",
+	       PROFILEHZ);
+
+	setup_irq(mcf_profilevector, &coldfire_profile_irq);
+
+	/* Set up TIMER 2 as high speed profile clock */
+	__raw_writew(MCFTIMER_TMR_DISABLE, PA(MCFTIMER_TMR));
+
+	__raw_writetrr(((MCF_BUSCLK / 16) / PROFILEHZ), PA(MCFTIMER_TRR));
+	__raw_writew(MCFTIMER_TMR_ENORI | MCFTIMER_TMR_CLK16 |
+		MCFTIMER_TMR_RESTART | MCFTIMER_TMR_ENABLE, PA(MCFTIMER_TMR));
+
+	mcf_settimericr(2, 7);
+}
+
+/***************************************************************************/
+#endif	/* CONFIG_HIGHPROFILE */
+/***************************************************************************/
Index: linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/vectors.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.24.7-rt27/arch/m68knommu/platform/coldfire/vectors.c	2009-02-08 00:00:48.000000000 -0500
@@ -0,0 +1,105 @@
+/***************************************************************************/
+
+/*
+ *	linux/arch/m68knommu/platform/5307/vectors.c
+ *
+ *	Copyright (C) 1999-2007, Greg Ungerer <gerg@snapgear.com>
+ */
+
+/***************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/traps.h>
+#include <asm/machdep.h>
+#include <asm/coldfire.h>
+#include <asm/mcfsim.h>
+#include <asm/mcfdma.h>
+#include <asm/mcfwdebug.h>
+
+/***************************************************************************/
+
+#ifdef TRAP_DBG_INTERRUPT
+
+asmlinkage void dbginterrupt_c(struct frame *fp)
+{
+	extern void dump(struct pt_regs *fp);
+	printk(KERN_DEBUG "%s(%d): BUS ERROR TRAP\n", __FILE__, __LINE__);
+	dump((struct pt_regs *) fp);
+	asm("halt");
+}
+
+#endif
+
+/***************************************************************************/
+
+extern e_vector	*_ramvec;
+
+void set_evector(int vecnum, void (*handler)(void))
+{
+	if (vecnum >= 0 && vecnum <= 255)
+		_ramvec[vecnum] = handler;
+}
+
+/***************************************************************************/
+
+/* Assembler routines */
+asmlinkage void buserr(void);
+asmlinkage void trap(void);
+asmlinkage void system_call(void);
+asmlinkage void inthandler(void);
+
+void __init init_vectors(void)
+{
+	int i;
+
+	/*
+	 *	There is a common trap handler and common interrupt
+	 *	handler that handle almost every vector. We treat
+	 *	the system call and bus error special, they get their
+	 *	own first level handlers.
+	 */
+	for (i = 3; (i <= 23); i++)
+		_ramvec[i] = trap;
+	for (i = 33; (i <= 63); i++)
+		_ramvec[i] = trap;
+	for (i = 24; (i <= 31); i++)
+		_ramvec[i] = inthandler;
+	for (i = 64; (i < 255); i++)
+		_ramvec[i] = inthandler;
+	_ramvec[255] = 0;
+
+	_ramvec[2] = buserr;
+	_ramvec[32] = system_call;
+
+#ifdef TRAP_DBG_INTERRUPT
+	_ramvec[12] = dbginterrupt;
+#endif
+}
+
+/***************************************************************************/
+
+void enable_vector(unsigned int irq)
+{
+	/* Currently no action on ColdFire */
+}
+
+void disable_vector(unsigned int irq)
+{
+	/* Currently no action on ColdFire */
+}
+
+void ack_vector(unsigned int irq)
+{
+	/* Currently no action on ColdFire */
+}
+
+/***************************************************************************/
+
+void coldfire_reset(void)
+{
+	HARD_RESET_NOW();
+}
+
+/***************************************************************************/
Index: linux-2.6.24.7-rt27/drivers/net/fec.c
===================================================================
--- linux-2.6.24.7-rt27.orig/drivers/net/fec.c	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/drivers/net/fec.c	2009-02-08 00:00:48.000000000 -0500
@@ -2,12 +2,6 @@
  * Fast Ethernet Controller (FEC) driver for Motorola MPC8xx.
  * Copyright (c) 1997 Dan Malek (dmalek@jlc.net)
  *
- * This version of the driver is specific to the FADS implementation,
- * since the board contains control registers external to the processor
- * for the control of the LevelOne LXT970 transceiver.  The MPC860T manual
- * describes connections using the internal parallel port I/O, which
- * is basically all of Port D.
- *
  * Right now, I am very wasteful with the buffers.  I allocate memory
  * pages and then divide them into 2K frame buffers.  This way I know I
  * have buffers large enough to hold one frame within one buffer descriptor.
@@ -49,17 +43,9 @@
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
 
-#if defined(CONFIG_M523x) || defined(CONFIG_M527x) || \
-    defined(CONFIG_M5272) || defined(CONFIG_M528x) || \
-    defined(CONFIG_M520x) || defined(CONFIG_M532x)
 #include <asm/coldfire.h>
 #include <asm/mcfsim.h>
 #include "fec.h"
-#else
-#include <asm/8xx_immap.h>
-#include <asm/mpc8xx.h>
-#include "commproc.h"
-#endif
 
 #if defined(CONFIG_FEC2)
 #define	FEC_MAX_PORTS	2
@@ -67,6 +53,7 @@
 #define	FEC_MAX_PORTS	1
 #endif
 
+
 /*
  * Define the fixed address of the FEC hardware.
  */
@@ -79,15 +66,15 @@ static unsigned int fec_hw[] = {
 #elif defined(CONFIG_M523x) || defined(CONFIG_M528x)
 	(MCF_MBAR + 0x1000),
 #elif defined(CONFIG_M520x)
-	(MCF_MBAR+0x30000),
+	(MCF_MBAR + 0x30000),
 #elif defined(CONFIG_M532x)
-	(MCF_MBAR+0xfc030000),
+	(MCF_MBAR + 0xfc030000),
 #else
-	&(((immap_t *)IMAP_ADDR)->im_cpm.cp_fec),
+	&(((immap_t *) IMAP_ADDR)->im_cpm.cp_fec),
 #endif
 };
 
-static unsigned char	fec_mac_default[] = {
+static unsigned char fec_mac_default[] = {
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 };
 
@@ -101,20 +88,20 @@ static unsigned char	fec_mac_default[] =
 #define	FEC_FLASHMAC	0xf0006000
 #elif defined(CONFIG_CANCam)
 #define	FEC_FLASHMAC	0xf0020000
-#elif defined (CONFIG_M5272C3)
+#elif defined(CONFIG_M5272C3)
 #define	FEC_FLASHMAC	(0xffe04000 + 4)
 #elif defined(CONFIG_MOD5272)
-#define FEC_FLASHMAC 	0xffc0406b
+#define FEC_FLASHMAC	0xffc0406b
 #else
 #define	FEC_FLASHMAC	0
 #endif
 
 /* Forward declarations of some structures to support different PHYs
 */
-
+typedef void (mii_func)(uint val, struct net_device *dev);
 typedef struct {
 	uint mii_data;
-	void (*funct)(uint mii_reg, struct net_device *dev);
+	mii_func *funct;
 } phy_cmd_t;
 
 typedef struct {
@@ -165,7 +152,6 @@ typedef struct {
 #define PKT_MINBUF_SIZE		64
 #define PKT_MAXBLR_SIZE		1520
 
-
 /*
  * The 5270/5271/5280/5282/532x RX control register also contains maximum frame
  * size bits. Other FEC hardware does not, so we need to take that into
@@ -188,75 +174,67 @@ typedef struct {
  */
 struct fec_enet_private {
 	/* Hardware registers of the FEC device */
-	volatile fec_t	*hwp;
+	volatile fec_t *hwp;
 
 	struct net_device *netdev;
 
 	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
 	unsigned char *tx_bounce[TX_RING_SIZE];
-	struct	sk_buff* tx_skbuff[TX_RING_SIZE];
-	ushort	skb_cur;
-	ushort	skb_dirty;
+	struct sk_buff *tx_skbuff[TX_RING_SIZE];
+	ushort skb_cur;
+	ushort skb_dirty;
 
 	/* CPM dual port RAM relative addresses.
-	*/
-	cbd_t	*rx_bd_base;		/* Address of Rx and Tx buffers. */
-	cbd_t	*tx_bd_base;
-	cbd_t	*cur_rx, *cur_tx;		/* The next free ring entry */
-	cbd_t	*dirty_tx;	/* The ring entries to be free()ed. */
-	uint	tx_full;
-	spinlock_t lock;
-
-	uint	phy_id;
-	uint	phy_id_done;
-	uint	phy_status;
-	uint	phy_speed;
-	phy_info_t const	*phy;
+	 */
+	cbd_t *rx_bd_base;	/* Address of Rx and Tx buffers. */
+	cbd_t *tx_bd_base;
+	cbd_t *cur_rx, *cur_tx;	/* The next free ring entry */
+	cbd_t *dirty_tx;	/* The ring entries to be free()ed. */
+	uint tx_full;
+	/* hold while accessing the HW like ringbuffer for tx/rx but not MAC */
+	spinlock_t hw_lock;
+	/* hold while accessing the mii_list_t() elements */
+	spinlock_t mii_lock;
+
+	uint phy_id;
+	uint phy_id_done;
+	uint phy_status;
+	uint phy_speed;
+	phy_info_t const *phy;
 	struct work_struct phy_task;
 
-	uint	sequence_done;
-	uint	mii_phy_task_queued;
+	uint sequence_done;
+	uint mii_phy_task_queued;
+
+	uint phy_addr;
 
-	uint	phy_addr;
+	int index;
+	int opened;
+	int link;
+	int old_link;
+	int full_duplex;
+};
 
-	int	index;
-	int	opened;
-	int	link;
-	int	old_link;
-	int	full_duplex;
-};
-
-static int fec_enet_open(struct net_device *dev);
-static int fec_enet_start_xmit(struct sk_buff *skb, struct net_device *dev);
-static void fec_enet_mii(struct net_device *dev);
-static irqreturn_t fec_enet_interrupt(int irq, void * dev_id);
-static void fec_enet_tx(struct net_device *dev);
-static void fec_enet_rx(struct net_device *dev);
-static int fec_enet_close(struct net_device *dev);
-static void set_multicast_list(struct net_device *dev);
 static void fec_restart(struct net_device *dev, int duplex);
 static void fec_stop(struct net_device *dev);
-static void fec_set_mac_address(struct net_device *dev);
-
 
 /* MII processing.  We keep this as simple as possible.  Requests are
  * placed on the list (if there is room).  When the request is finished
  * by the MII, an optional function may be called.
  */
 typedef struct mii_list {
-	uint	mii_regval;
-	void	(*mii_func)(uint val, struct net_device *dev);
-	struct	mii_list *mii_next;
+	uint mii_regval;
+	void (*mii_func)(uint val, struct net_device *dev);
+	struct mii_list *mii_next;
 } mii_list_t;
 
-#define		NMII	20
-static mii_list_t	mii_cmds[NMII];
-static mii_list_t	*mii_free;
-static mii_list_t	*mii_head;
-static mii_list_t	*mii_tail;
+#define NMII 20
+static mii_list_t mii_cmds[NMII];
+static mii_list_t *mii_free;
+static mii_list_t *mii_head;
+static mii_list_t *mii_tail;
 
-static int	mii_queue(struct net_device *dev, int request,
-				void (*func)(uint, struct net_device *));
+static int mii_queue(struct net_device *dev, int request, mii_func *funct);
 
 /* Make MII read/write commands for the FEC.
 */
@@ -272,52 +250,52 @@ static int	mii_queue(struct net_device *
 /* Register definitions for the PHY.
 */
 
-#define MII_REG_CR          0  /* Control Register                         */
-#define MII_REG_SR          1  /* Status Register                          */
-#define MII_REG_PHYIR1      2  /* PHY Identification Register 1            */
-#define MII_REG_PHYIR2      3  /* PHY Identification Register 2            */
-#define MII_REG_ANAR        4  /* A-N Advertisement Register               */
-#define MII_REG_ANLPAR      5  /* A-N Link Partner Ability Register        */
-#define MII_REG_ANER        6  /* A-N Expansion Register                   */
-#define MII_REG_ANNPTR      7  /* A-N Next Page Transmit Register          */
-#define MII_REG_ANLPRNPR    8  /* A-N Link Partner Received Next Page Reg. */
+#define MII_REG_CR          0	/* Control Register                         */
+#define MII_REG_SR          1	/* Status Register                          */
+#define MII_REG_PHYIR1      2	/* PHY Identification Register 1            */
+#define MII_REG_PHYIR2      3	/* PHY Identification Register 2            */
+#define MII_REG_ANAR        4	/* A-N Advertisement Register               */
+#define MII_REG_ANLPAR      5	/* A-N Link Partner Ability Register        */
+#define MII_REG_ANER        6	/* A-N Expansion Register                   */
+#define MII_REG_ANNPTR      7	/* A-N Next Page Transmit Register          */
+#define MII_REG_ANLPRNPR    8	/* A-N Link Partner Received Next Page Reg. */
 
 /* values for phy_status */
 
-#define PHY_CONF_ANE	0x0001  /* 1 auto-negotiation enabled */
-#define PHY_CONF_LOOP	0x0002  /* 1 loopback mode enabled */
-#define PHY_CONF_SPMASK	0x00f0  /* mask for speed */
-#define PHY_CONF_10HDX	0x0010  /* 10 Mbit half duplex supported */
-#define PHY_CONF_10FDX	0x0020  /* 10 Mbit full duplex supported */
-#define PHY_CONF_100HDX	0x0040  /* 100 Mbit half duplex supported */
-#define PHY_CONF_100FDX	0x0080  /* 100 Mbit full duplex supported */
-
-#define PHY_STAT_LINK	0x0100  /* 1 up - 0 down */
-#define PHY_STAT_FAULT	0x0200  /* 1 remote fault */
-#define PHY_STAT_ANC	0x0400  /* 1 auto-negotiation complete	*/
-#define PHY_STAT_SPMASK	0xf000  /* mask for speed */
-#define PHY_STAT_10HDX	0x1000  /* 10 Mbit half duplex selected	*/
-#define PHY_STAT_10FDX	0x2000  /* 10 Mbit full duplex selected	*/
-#define PHY_STAT_100HDX	0x4000  /* 100 Mbit half duplex selected */
-#define PHY_STAT_100FDX	0x8000  /* 100 Mbit full duplex selected */
+#define PHY_CONF_ANE	0x0001	/* 1 auto-negotiation enabled */
+#define PHY_CONF_LOOP	0x0002	/* 1 loopback mode enabled */
+#define PHY_CONF_SPMASK	0x00f0	/* mask for speed */
+#define PHY_CONF_10HDX	0x0010	/* 10 Mbit half duplex supported */
+#define PHY_CONF_10FDX	0x0020	/* 10 Mbit full duplex supported */
+#define PHY_CONF_100HDX	0x0040	/* 100 Mbit half duplex supported */
+#define PHY_CONF_100FDX	0x0080	/* 100 Mbit full duplex supported */
+
+#define PHY_STAT_LINK	0x0100	/* 1 up - 0 down */
+#define PHY_STAT_FAULT	0x0200	/* 1 remote fault */
+#define PHY_STAT_ANC	0x0400	/* 1 auto-negotiation complete  */
+#define PHY_STAT_SPMASK	0xf000	/* mask for speed */
+#define PHY_STAT_10HDX	0x1000	/* 10 Mbit half duplex selected */
+#define PHY_STAT_10FDX	0x2000	/* 10 Mbit full duplex selected */
+#define PHY_STAT_100HDX	0x4000	/* 100 Mbit half duplex selected */
+#define PHY_STAT_100FDX	0x8000	/* 100 Mbit full duplex selected */
 
-
-static int
-fec_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)
+static int fec_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct fec_enet_private *fep;
-	volatile fec_t	*fecp;
-	volatile cbd_t	*bdp;
-	unsigned short	status;
+	volatile fec_t *fecp;
+	volatile cbd_t *bdp;
+	unsigned short status;
+	unsigned long flags;
 
 	fep = netdev_priv(dev);
-	fecp = (volatile fec_t*)dev->base_addr;
+	fecp = (volatile fec_t *)dev->base_addr;
 
 	if (!fep->link) {
 		/* Link is down or autonegotiation is in progress. */
 		return 1;
 	}
 
+	spin_lock_irqsave(&fep->hw_lock, flags);
 	/* Fill in a Tx ring entry */
 	bdp = fep->cur_tx;
 
@@ -328,6 +306,7 @@ fec_enet_start_xmit(struct sk_buff *skb,
 		 * This should not happen, since dev->tbusy should be set.
 		 */
 		printk("%s: tx queue full!.\n", dev->name);
+		spin_unlock_irqrestore(&fep->hw_lock, flags);
 		return 1;
 	}
 #endif
@@ -337,28 +316,29 @@ fec_enet_start_xmit(struct sk_buff *skb,
 	status &= ~BD_ENET_TX_STATS;
 
 	/* Set buffer length and buffer pointer.
-	*/
+	 */
 	bdp->cbd_bufaddr = __pa(skb->data);
 	bdp->cbd_datlen = skb->len;
 
 	/*
-	 *	On some FEC implementations data must be aligned on
-	 *	4-byte boundaries. Use bounce buffers to copy data
-	 *	and get it aligned. Ugh.
+	 *      On some FEC implementations data must be aligned on
+	 *      4-byte boundaries. Use bounce buffers to copy data
+	 *      and get it aligned. Ugh.
 	 */
 	if (bdp->cbd_bufaddr & 0x3) {
 		unsigned int index;
 		index = bdp - fep->tx_bd_base;
-		memcpy(fep->tx_bounce[index], (void *) bdp->cbd_bufaddr, bdp->cbd_datlen);
+		memcpy(fep->tx_bounce[index], (void *)bdp->cbd_bufaddr,
+		       bdp->cbd_datlen);
 		bdp->cbd_bufaddr = __pa(fep->tx_bounce[index]);
 	}
 
 	/* Save skb pointer.
-	*/
+	 */
 	fep->tx_skbuff[fep->skb_cur] = skb;
 
 	dev->stats.tx_bytes += skb->len;
-	fep->skb_cur = (fep->skb_cur+1) & TX_RING_MOD_MASK;
+	fep->skb_cur = (fep->skb_cur + 1) & TX_RING_MOD_MASK;
 
 	/* Push the data cache so the CPM does not get stale memory
 	 * data.
@@ -366,14 +346,13 @@ fec_enet_start_xmit(struct sk_buff *skb,
 	flush_dcache_range((unsigned long)skb->data,
 			   (unsigned long)skb->data + skb->len);
 
-	spin_lock_irq(&fep->lock);
 
 	/* Send it on its way.  Tell FEC it's ready, interrupt when done,
 	 * it's the last BD of the frame, and to put the CRC on the end.
 	 */
 
 	status |= (BD_ENET_TX_READY | BD_ENET_TX_INTR
-			| BD_ENET_TX_LAST | BD_ENET_TX_TC);
+		   | BD_ENET_TX_LAST | BD_ENET_TX_TC);
 	bdp->cbd_sc = status;
 
 	dev->trans_start = jiffies;
@@ -382,7 +361,7 @@ fec_enet_start_xmit(struct sk_buff *skb,
 	fecp->fec_x_des_active = 0;
 
 	/* If this was the last BD in the ring, start at the beginning again.
-	*/
+	 */
 	if (status & BD_ENET_TX_WRAP) {
 		bdp = fep->tx_bd_base;
 	} else {
@@ -394,15 +373,14 @@ fec_enet_start_xmit(struct sk_buff *skb,
 		netif_stop_queue(dev);
 	}
 
-	fep->cur_tx = (cbd_t *)bdp;
+	fep->cur_tx = (cbd_t *) bdp;
 
-	spin_unlock_irq(&fep->lock);
+	spin_unlock_irqrestore(&fep->hw_lock, flags);
 
 	return 0;
 }
 
-static void
-fec_timeout(struct net_device *dev)
+static void fec_timeout(struct net_device *dev)
 {
 	struct fec_enet_private *fep = netdev_priv(dev);
 
@@ -410,115 +388,200 @@ fec_timeout(struct net_device *dev)
 	dev->stats.tx_errors++;
 #ifndef final_version
 	{
-	int	i;
-	cbd_t	*bdp;
+		int i;
+		cbd_t *bdp;
 
-	printk("Ring data dump: cur_tx %lx%s, dirty_tx %lx cur_rx: %lx\n",
-	       (unsigned long)fep->cur_tx, fep->tx_full ? " (full)" : "",
-	       (unsigned long)fep->dirty_tx,
-	       (unsigned long)fep->cur_rx);
+		printk
+		    ("Ring data dump: cur_tx %lx%s, dirty_tx %lx cur_rx: %lx\n",
+		     (unsigned long)fep->cur_tx, fep->tx_full ? " (full)" : "",
+		     (unsigned long)fep->dirty_tx, (unsigned long)fep->cur_rx);
 
-	bdp = fep->tx_bd_base;
-	printk(" tx: %u buffers\n",  TX_RING_SIZE);
-	for (i = 0 ; i < TX_RING_SIZE; i++) {
-		printk("  %08x: %04x %04x %08x\n",
-		       (uint) bdp,
-		       bdp->cbd_sc,
-		       bdp->cbd_datlen,
-		       (int) bdp->cbd_bufaddr);
-		bdp++;
-	}
+		bdp = fep->tx_bd_base;
+		printk(" tx: %u buffers\n", TX_RING_SIZE);
+		for (i = 0; i < TX_RING_SIZE; i++) {
+			printk("  %08x: %04x %04x %08x\n",
+			       (uint) bdp,
+			       bdp->cbd_sc,
+			       bdp->cbd_datlen, (int)bdp->cbd_bufaddr);
+			bdp++;
+		}
 
-	bdp = fep->rx_bd_base;
-	printk(" rx: %lu buffers\n",  (unsigned long) RX_RING_SIZE);
-	for (i = 0 ; i < RX_RING_SIZE; i++) {
-		printk("  %08x: %04x %04x %08x\n",
-		       (uint) bdp,
-		       bdp->cbd_sc,
-		       bdp->cbd_datlen,
-		       (int) bdp->cbd_bufaddr);
-		bdp++;
-	}
+		bdp = fep->rx_bd_base;
+		printk(" rx: %lu buffers\n", (unsigned long)RX_RING_SIZE);
+		for (i = 0; i < RX_RING_SIZE; i++) {
+			printk("  %08x: %04x %04x %08x\n",
+			       (uint) bdp,
+			       bdp->cbd_sc,
+			       bdp->cbd_datlen, (int)bdp->cbd_bufaddr);
+			bdp++;
+		}
 	}
 #endif
 	fec_restart(dev, fep->full_duplex);
 	netif_wake_queue(dev);
 }
 
-/* The interrupt handler.
- * This is called from the MPC core interrupt.
+/* During a receive, the cur_rx points to the current incoming buffer.
+ * When we update through the ring, if the next incoming buffer has
+ * not been given to the system, we just set the empty indicator,
+ * effectively tossing the packet.
  */
-static irqreturn_t
-fec_enet_interrupt(int irq, void * dev_id)
+static void fec_enet_rx(struct net_device *dev)
 {
-	struct	net_device *dev = dev_id;
-	volatile fec_t	*fecp;
-	uint	int_events;
-	int handled = 0;
+	struct fec_enet_private *fep;
+	volatile fec_t *fecp;
+	volatile cbd_t *bdp;
+	unsigned short status;
+	struct sk_buff *skb;
+	ushort pkt_len;
+	__u8 *data;
 
-	fecp = (volatile fec_t*)dev->base_addr;
+#ifdef CONFIG_M532x
+	flush_cache_all();
+#endif
 
-	/* Get the interrupt events that caused us to be here.
-	*/
-	while ((int_events = fecp->fec_ievent) != 0) {
-		fecp->fec_ievent = int_events;
+	fep = netdev_priv(dev);
+	spin_lock_irq(&fep->hw_lock);
+	fecp = (volatile fec_t *)dev->base_addr;
 
-		/* Handle receive event in its own function.
+	/* First, grab all of the stats for the incoming packet.
+	 * These get messed up if we get called due to a busy condition.
+	 */
+	bdp = fep->cur_rx;
+
+	while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) {
+
+#ifndef final_version
+		/* Since we have allocated space to hold a complete frame,
+		 * the last indicator should be set.
 		 */
-		if (int_events & FEC_ENET_RXF) {
-			handled = 1;
-			fec_enet_rx(dev);
+		if ((status & BD_ENET_RX_LAST) == 0)
+			printk("FEC ENET: rcv is not +last\n");
+#endif
+
+		if (!fep->opened)
+			goto rx_processing_done;
+
+		/* Check for errors. */
+		if (status & (BD_ENET_RX_LG | BD_ENET_RX_SH | BD_ENET_RX_NO |
+			      BD_ENET_RX_CR | BD_ENET_RX_OV)) {
+			dev->stats.rx_errors++;
+			if (status & (BD_ENET_RX_LG | BD_ENET_RX_SH)) {
+				/* Frame too long or too short. */
+				dev->stats.rx_length_errors++;
+			}
+			if (status & BD_ENET_RX_NO)	/* Frame alignment */
+				dev->stats.rx_frame_errors++;
+			if (status & BD_ENET_RX_CR)	/* CRC Error */
+				dev->stats.rx_crc_errors++;
+			if (status & BD_ENET_RX_OV)	/* FIFO overrun */
+				dev->stats.rx_fifo_errors++;
 		}
 
-		/* Transmit OK, or non-fatal error. Update the buffer
-		   descriptors. FEC handles all errors, we just discover
-		   them as part of the transmit process.
-		*/
-		if (int_events & FEC_ENET_TXF) {
-			handled = 1;
-			fec_enet_tx(dev);
+		/* Report late collisions as a frame error.
+		 * On this error, the BD is closed, but we don't know what we
+		 * have in the buffer.  So, just drop this frame on the floor.
+		 */
+		if (status & BD_ENET_RX_CL) {
+			dev->stats.rx_errors++;
+			dev->stats.rx_frame_errors++;
+			goto rx_processing_done;
 		}
 
-		if (int_events & FEC_ENET_MII) {
-			handled = 1;
-			fec_enet_mii(dev);
+		/* Process the incoming frame.
+		 */
+		dev->stats.rx_packets++;
+		pkt_len = bdp->cbd_datlen;
+		dev->stats.rx_bytes += pkt_len;
+		data = (__u8 *) __va(bdp->cbd_bufaddr);
+
+		/* This does 16 byte alignment, exactly what we need.
+		 * The packet length includes FCS, but we don't want to
+		 * include that when passing upstream as it messes up
+		 * bridging applications.
+		 */
+		skb = dev_alloc_skb(pkt_len - 4);
+
+		if (skb == NULL) {
+			printk("%s: Memory squeeze, dropping packet.\n",
+			       dev->name);
+			dev->stats.rx_dropped++;
+		} else {
+			skb_put(skb, pkt_len - 4);	/* Make room */
+			skb_copy_to_linear_data(skb, data, pkt_len - 4);
+			skb->protocol = eth_type_trans(skb, dev);
+			netif_rx(skb);
 		}
+rx_processing_done:
 
-	}
-	return IRQ_RETVAL(handled);
-}
+		/* Clear the status flags for this buffer.
+		 */
+		status &= ~BD_ENET_RX_STATS;
 
+		/* Mark the buffer empty.
+		 */
+		status |= BD_ENET_RX_EMPTY;
+		bdp->cbd_sc = status;
 
-static void
-fec_enet_tx(struct net_device *dev)
+		/* Update BD pointer to next entry.
+		 */
+		if (status & BD_ENET_RX_WRAP)
+			bdp = fep->rx_bd_base;
+		else
+			bdp++;
+
+#if 1
+		/* Doing this here will keep the FEC running while we process
+		 * incoming frames.  On a heavily loaded network, we should be
+		 * able to keep up at the expense of system resources.
+		 */
+		fecp->fec_r_des_active = 0;
+#endif
+	}	/* while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) */
+	fep->cur_rx = (cbd_t *) bdp;
+
+#if 0
+	/* Doing this here will allow us to process all frames in the
+	 * ring before the FEC is allowed to put more there.  On a heavily
+	 * loaded network, some frames may be lost.  Unfortunately, this
+	 * increases the interrupt overhead since we can potentially work
+	 * our way back to the interrupt return only to come right back
+	 * here.
+	 */
+	fecp->fec_r_des_active = 0;
+#endif
+	spin_unlock_irq(&fep->hw_lock);
+}
+
+static void fec_enet_tx(struct net_device *dev)
 {
-	struct	fec_enet_private *fep;
-	volatile cbd_t	*bdp;
+	struct fec_enet_private *fep;
+	volatile cbd_t *bdp;
 	unsigned short status;
-	struct	sk_buff	*skb;
+	struct sk_buff *skb;
 
 	fep = netdev_priv(dev);
-	spin_lock(&fep->lock);
+	spin_lock_irq(&fep->hw_lock);
 	bdp = fep->dirty_tx;
 
 	while (((status = bdp->cbd_sc) & BD_ENET_TX_READY) == 0) {
-		if (bdp == fep->cur_tx && fep->tx_full == 0) break;
+		if (bdp == fep->cur_tx && fep->tx_full == 0)
+			break;
 
 		skb = fep->tx_skbuff[fep->skb_dirty];
 		/* Check for errors. */
 		if (status & (BD_ENET_TX_HB | BD_ENET_TX_LC |
-				   BD_ENET_TX_RL | BD_ENET_TX_UN |
-				   BD_ENET_TX_CSL)) {
+			      BD_ENET_TX_RL | BD_ENET_TX_UN | BD_ENET_TX_CSL)) {
 			dev->stats.tx_errors++;
-			if (status & BD_ENET_TX_HB)  /* No heartbeat */
+			if (status & BD_ENET_TX_HB)	/* No heartbeat */
 				dev->stats.tx_heartbeat_errors++;
-			if (status & BD_ENET_TX_LC)  /* Late collision */
+			if (status & BD_ENET_TX_LC)	/* Late collision */
 				dev->stats.tx_window_errors++;
-			if (status & BD_ENET_TX_RL)  /* Retrans limit */
+			if (status & BD_ENET_TX_RL)	/* Retrans limit */
 				dev->stats.tx_aborted_errors++;
-			if (status & BD_ENET_TX_UN)  /* Underrun */
+			if (status & BD_ENET_TX_UN)	/* Underrun */
 				dev->stats.tx_fifo_errors++;
-			if (status & BD_ENET_TX_CSL) /* Carrier lost */
+			if (status & BD_ENET_TX_CSL)	/* Carrier lost */
 				dev->stats.tx_carrier_errors++;
 		} else {
 			dev->stats.tx_packets++;
@@ -556,164 +619,32 @@ fec_enet_tx(struct net_device *dev)
 				netif_wake_queue(dev);
 		}
 	}
-	fep->dirty_tx = (cbd_t *)bdp;
-	spin_unlock(&fep->lock);
-}
-
-
-/* During a receive, the cur_rx points to the current incoming buffer.
- * When we update through the ring, if the next incoming buffer has
- * not been given to the system, we just set the empty indicator,
- * effectively tossing the packet.
- */
-static void
-fec_enet_rx(struct net_device *dev)
-{
-	struct	fec_enet_private *fep;
-	volatile fec_t	*fecp;
-	volatile cbd_t *bdp;
-	unsigned short status;
-	struct	sk_buff	*skb;
-	ushort	pkt_len;
-	__u8 *data;
-
-#ifdef CONFIG_M532x
-	flush_cache_all();
-#endif
-
-	fep = netdev_priv(dev);
-	fecp = (volatile fec_t*)dev->base_addr;
-
-	/* First, grab all of the stats for the incoming packet.
-	 * These get messed up if we get called due to a busy condition.
-	 */
-	bdp = fep->cur_rx;
-
-while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) {
-
-#ifndef final_version
-	/* Since we have allocated space to hold a complete frame,
-	 * the last indicator should be set.
-	 */
-	if ((status & BD_ENET_RX_LAST) == 0)
-		printk("FEC ENET: rcv is not +last\n");
-#endif
-
-	if (!fep->opened)
-		goto rx_processing_done;
-
-	/* Check for errors. */
-	if (status & (BD_ENET_RX_LG | BD_ENET_RX_SH | BD_ENET_RX_NO |
-			   BD_ENET_RX_CR | BD_ENET_RX_OV)) {
-		dev->stats.rx_errors++;
-		if (status & (BD_ENET_RX_LG | BD_ENET_RX_SH)) {
-		/* Frame too long or too short. */
-			dev->stats.rx_length_errors++;
-		}
-		if (status & BD_ENET_RX_NO)	/* Frame alignment */
-			dev->stats.rx_frame_errors++;
-		if (status & BD_ENET_RX_CR)	/* CRC Error */
-			dev->stats.rx_crc_errors++;
-		if (status & BD_ENET_RX_OV)	/* FIFO overrun */
-			dev->stats.rx_fifo_errors++;
-	}
-
-	/* Report late collisions as a frame error.
-	 * On this error, the BD is closed, but we don't know what we
-	 * have in the buffer.  So, just drop this frame on the floor.
-	 */
-	if (status & BD_ENET_RX_CL) {
-		dev->stats.rx_errors++;
-		dev->stats.rx_frame_errors++;
-		goto rx_processing_done;
-	}
-
-	/* Process the incoming frame.
-	 */
-	dev->stats.rx_packets++;
-	pkt_len = bdp->cbd_datlen;
-	dev->stats.rx_bytes += pkt_len;
-	data = (__u8*)__va(bdp->cbd_bufaddr);
-
-	/* This does 16 byte alignment, exactly what we need.
-	 * The packet length includes FCS, but we don't want to
-	 * include that when passing upstream as it messes up
-	 * bridging applications.
-	 */
-	skb = dev_alloc_skb(pkt_len-4);
-
-	if (skb == NULL) {
-		printk("%s: Memory squeeze, dropping packet.\n", dev->name);
-		dev->stats.rx_dropped++;
-	} else {
-		skb_put(skb,pkt_len-4);	/* Make room */
-		skb_copy_to_linear_data(skb, data, pkt_len-4);
-		skb->protocol=eth_type_trans(skb,dev);
-		netif_rx(skb);
-	}
-  rx_processing_done:
-
-	/* Clear the status flags for this buffer.
-	*/
-	status &= ~BD_ENET_RX_STATS;
-
-	/* Mark the buffer empty.
-	*/
-	status |= BD_ENET_RX_EMPTY;
-	bdp->cbd_sc = status;
-
-	/* Update BD pointer to next entry.
-	*/
-	if (status & BD_ENET_RX_WRAP)
-		bdp = fep->rx_bd_base;
-	else
-		bdp++;
-
-#if 1
-	/* Doing this here will keep the FEC running while we process
-	 * incoming frames.  On a heavily loaded network, we should be
-	 * able to keep up at the expense of system resources.
-	 */
-	fecp->fec_r_des_active = 0;
-#endif
-   } /* while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) */
-	fep->cur_rx = (cbd_t *)bdp;
-
-#if 0
-	/* Doing this here will allow us to process all frames in the
-	 * ring before the FEC is allowed to put more there.  On a heavily
-	 * loaded network, some frames may be lost.  Unfortunately, this
-	 * increases the interrupt overhead since we can potentially work
-	 * our way back to the interrupt return only to come right back
-	 * here.
-	 */
-	fecp->fec_r_des_active = 0;
-#endif
+	fep->dirty_tx = (cbd_t *) bdp;
+	spin_unlock_irq(&fep->hw_lock);
 }
 
-
 /* called from interrupt context */
-static void
-fec_enet_mii(struct net_device *dev)
+static void fec_enet_mii(struct net_device *dev)
 {
-	struct	fec_enet_private *fep;
-	volatile fec_t	*ep;
-	mii_list_t	*mip;
-	uint		mii_reg;
+	struct fec_enet_private *fep;
+	volatile fec_t *ep;
+	mii_list_t *mip;
+	uint mii_reg;
+	mii_func *mii_func = NULL;
 
 	fep = netdev_priv(dev);
+	spin_lock_irq(&fep->mii_lock);
+
 	ep = fep->hwp;
 	mii_reg = ep->fec_mii_data;
 
-	spin_lock(&fep->lock);
-
 	if ((mip = mii_head) == NULL) {
 		printk("MII and no head!\n");
 		goto unlock;
 	}
 
 	if (mip->mii_func != NULL)
-		(*(mip->mii_func))(mii_reg, dev);
+		mii_func = *(mip->mii_func);
 
 	mii_head = mip->mii_next;
 	mip->mii_next = mii_free;
@@ -723,26 +654,71 @@ fec_enet_mii(struct net_device *dev)
 		ep->fec_mii_data = mip->mii_regval;
 
 unlock:
-	spin_unlock(&fep->lock);
+	spin_unlock_irq(&fep->mii_lock);
+	if (mii_func)
+		mii_func(mii_reg, dev);
 }
 
-static int
-mii_queue(struct net_device *dev, int regval, void (*func)(uint, struct net_device *))
+/* The interrupt handler.
+ * This is called from the MPC core interrupt.
+ */
+static irqreturn_t fec_enet_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	volatile fec_t *fecp;
+	uint int_events;
+	irqreturn_t ret = IRQ_NONE;
+
+	fecp = (volatile fec_t *)dev->base_addr;
+
+	/* Get the interrupt events that caused us to be here.
+	 */
+	do {
+		int_events = fecp->fec_ievent;
+		fecp->fec_ievent = int_events;
+
+		/* Handle receive event in its own function.
+		 */
+		if (int_events & FEC_ENET_RXF) {
+			ret = IRQ_HANDLED;
+			fec_enet_rx(dev);
+		}
+
+		/* Transmit OK, or non-fatal error. Update the buffer
+		   descriptors. FEC handles all errors, we just discover
+		   them as part of the transmit process.
+		 */
+		if (int_events & FEC_ENET_TXF) {
+			ret = IRQ_HANDLED;
+			fec_enet_tx(dev);
+		}
+
+		if (int_events & FEC_ENET_MII) {
+			ret = IRQ_HANDLED;
+			fec_enet_mii(dev);
+		}
+
+	} while (int_events);
+
+	return ret;
+}
+
+
+static int mii_queue(struct net_device *dev, int regval, mii_func *func)
 {
 	struct fec_enet_private *fep;
-	unsigned long	flags;
-	mii_list_t	*mip;
-	int		retval;
+	unsigned long flags;
+	mii_list_t *mip;
+	int retval;
 
 	/* Add PHY address to register command.
-	*/
+	 */
 	fep = netdev_priv(dev);
-	regval |= fep->phy_addr << 23;
+	spin_lock_irqsave(&fep->mii_lock, flags);
 
+	regval |= fep->phy_addr << 23;
 	retval = 0;
 
-	spin_lock_irqsave(&fep->lock,flags);
-
 	if ((mip = mii_free) != NULL) {
 		mii_free = mip->mii_next;
 		mip->mii_regval = regval;
@@ -759,14 +735,13 @@ mii_queue(struct net_device *dev, int re
 		retval = 1;
 	}
 
-	spin_unlock_irqrestore(&fep->lock,flags);
-
-	return(retval);
+	spin_unlock_irqrestore(&fep->mii_lock, flags);
+	return retval;
 }
 
 static void mii_do_cmd(struct net_device *dev, const phy_cmd_t *c)
 {
-	if(!c)
+	if (!c)
 		return;
 
 	for (; c->mii_data != mk_mii_end; c++)
@@ -827,11 +802,11 @@ static void mii_parse_anar(uint mii_reg,
 /* ------------------------------------------------------------------------- */
 /* The Level one LXT970 is used by many boards				     */
 
-#define MII_LXT970_MIRROR    16  /* Mirror register           */
-#define MII_LXT970_IER       17  /* Interrupt Enable Register */
-#define MII_LXT970_ISR       18  /* Interrupt Status Register */
-#define MII_LXT970_CONFIG    19  /* Configuration Register    */
-#define MII_LXT970_CSR       20  /* Chip Status Register      */
+#define MII_LXT970_MIRROR    16	/* Mirror register           */
+#define MII_LXT970_IER       17	/* Interrupt Enable Register */
+#define MII_LXT970_ISR       18	/* Interrupt Status Register */
+#define MII_LXT970_CONFIG    19	/* Configuration Register    */
+#define MII_LXT970_CSR       20	/* Chip Status Register      */
 
 static void mii_parse_lxt970_csr(uint mii_reg, struct net_device *dev)
 {
@@ -855,28 +830,28 @@ static void mii_parse_lxt970_csr(uint mi
 }
 
 static phy_cmd_t const phy_cmd_lxt970_config[] = {
-		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
-		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
-		{ mk_mii_end, }
-	};
-static phy_cmd_t const phy_cmd_lxt970_startup[] = { /* enable interrupts */
-		{ mk_mii_write(MII_LXT970_IER, 0x0002), NULL },
-		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
-		{ mk_mii_end, }
-	};
+	{mk_mii_read(MII_REG_CR), mii_parse_cr},
+	{mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_lxt970_startup[] = {	/* enable interrupts */
+	{mk_mii_write(MII_LXT970_IER, 0x0002), NULL},
+	{mk_mii_write(MII_REG_CR, 0x1200), NULL},	/* autonegotiate */
+	{mk_mii_end,}
+};
 static phy_cmd_t const phy_cmd_lxt970_ack_int[] = {
-		/* read SR and ISR to acknowledge */
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_read(MII_LXT970_ISR), NULL },
-
-		/* find out the current status */
-		{ mk_mii_read(MII_LXT970_CSR), mii_parse_lxt970_csr },
-		{ mk_mii_end, }
-	};
-static phy_cmd_t const phy_cmd_lxt970_shutdown[] = { /* disable interrupts */
-		{ mk_mii_write(MII_LXT970_IER, 0x0000), NULL },
-		{ mk_mii_end, }
-	};
+	/* read SR and ISR to acknowledge */
+	{mk_mii_read(MII_REG_SR), mii_parse_sr},
+	{mk_mii_read(MII_LXT970_ISR), NULL},
+
+	/* find out the current status */
+	{mk_mii_read(MII_LXT970_CSR), mii_parse_lxt970_csr},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_lxt970_shutdown[] = {	/* disable interrupts */
+	{mk_mii_write(MII_LXT970_IER, 0x0000), NULL},
+	{mk_mii_end,}
+};
 static phy_info_t const phy_info_lxt970 = {
 	.id = 0x07810000,
 	.name = "LXT970",
@@ -891,12 +866,12 @@ static phy_info_t const phy_info_lxt970 
 
 /* register definitions for the 971 */
 
-#define MII_LXT971_PCR       16  /* Port Control Register     */
-#define MII_LXT971_SR2       17  /* Status Register 2         */
-#define MII_LXT971_IER       18  /* Interrupt Enable Register */
-#define MII_LXT971_ISR       19  /* Interrupt Status Register */
-#define MII_LXT971_LCR       20  /* LED Control Register      */
-#define MII_LXT971_TCR       30  /* Transmit Control Register */
+#define MII_LXT971_PCR       16	/* Port Control Register     */
+#define MII_LXT971_SR2       17	/* Status Register 2         */
+#define MII_LXT971_IER       18	/* Interrupt Enable Register */
+#define MII_LXT971_ISR       19	/* Interrupt Status Register */
+#define MII_LXT971_LCR       20	/* LED Control Register      */
+#define MII_LXT971_TCR       30	/* Transmit Control Register */
 
 /*
  * I had some nice ideas of running the MDIO faster...
@@ -938,35 +913,35 @@ static void mii_parse_lxt971_sr2(uint mi
 }
 
 static phy_cmd_t const phy_cmd_lxt971_config[] = {
-		/* limit to 10MBit because my prototype board
-		 * doesn't work with 100. */
-		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
-		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
-		{ mk_mii_read(MII_LXT971_SR2), mii_parse_lxt971_sr2 },
-		{ mk_mii_end, }
-	};
-static phy_cmd_t const phy_cmd_lxt971_startup[] = {  /* enable interrupts */
-		{ mk_mii_write(MII_LXT971_IER, 0x00f2), NULL },
-		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
-		{ mk_mii_write(MII_LXT971_LCR, 0xd422), NULL }, /* LED config */
-		/* Somehow does the 971 tell me that the link is down
-		 * the first read after power-up.
-		 * read here to get a valid value in ack_int */
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_end, }
-	};
+	/* limit to 10MBit because my prototype board
+	 * doesn't work with 100. */
+	{mk_mii_read(MII_REG_CR), mii_parse_cr},
+	{mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+	{mk_mii_read(MII_LXT971_SR2), mii_parse_lxt971_sr2},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_lxt971_startup[] = {	/* enable interrupts */
+	{mk_mii_write(MII_LXT971_IER, 0x00f2), NULL},
+	{mk_mii_write(MII_REG_CR, 0x1200), NULL},	/* autonegotiate */
+	{mk_mii_write(MII_LXT971_LCR, 0xd422), NULL},	/* LED config */
+	/* Somehow does the 971 tell me that the link is down
+	 * the first read after power-up.
+	 * read here to get a valid value in ack_int */
+	{mk_mii_read(MII_REG_SR), mii_parse_sr},
+	{mk_mii_end,}
+};
 static phy_cmd_t const phy_cmd_lxt971_ack_int[] = {
-		/* acknowledge the int before reading status ! */
-		{ mk_mii_read(MII_LXT971_ISR), NULL },
-		/* find out the current status */
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_read(MII_LXT971_SR2), mii_parse_lxt971_sr2 },
-		{ mk_mii_end, }
-	};
-static phy_cmd_t const phy_cmd_lxt971_shutdown[] = { /* disable interrupts */
-		{ mk_mii_write(MII_LXT971_IER, 0x0000), NULL },
-		{ mk_mii_end, }
-	};
+	/* acknowledge the int before reading status ! */
+	{mk_mii_read(MII_LXT971_ISR), NULL},
+	/* find out the current status */
+	{mk_mii_read(MII_REG_SR), mii_parse_sr},
+	{mk_mii_read(MII_LXT971_SR2), mii_parse_lxt971_sr2},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_lxt971_shutdown[] = {	/* disable interrupts */
+	{mk_mii_write(MII_LXT971_IER, 0x0000), NULL},
+	{mk_mii_end,}
+};
 static phy_info_t const phy_info_lxt971 = {
 	.id = 0x0001378e,
 	.name = "LXT971",
@@ -981,12 +956,12 @@ static phy_info_t const phy_info_lxt971 
 
 /* register definitions */
 
-#define MII_QS6612_MCR       17  /* Mode Control Register      */
-#define MII_QS6612_FTR       27  /* Factory Test Register      */
-#define MII_QS6612_MCO       28  /* Misc. Control Register     */
-#define MII_QS6612_ISR       29  /* Interrupt Source Register  */
-#define MII_QS6612_IMR       30  /* Interrupt Mask Register    */
-#define MII_QS6612_PCR       31  /* 100BaseTx PHY Control Reg. */
+#define MII_QS6612_MCR       17	/* Mode Control Register      */
+#define MII_QS6612_FTR       27	/* Factory Test Register      */
+#define MII_QS6612_MCO       28	/* Misc. Control Register     */
+#define MII_QS6612_ISR       29	/* Interrupt Source Register  */
+#define MII_QS6612_IMR       30	/* Interrupt Mask Register    */
+#define MII_QS6612_PCR       31	/* 100BaseTx PHY Control Reg. */
 
 static void mii_parse_qs6612_pcr(uint mii_reg, struct net_device *dev)
 {
@@ -996,46 +971,54 @@ static void mii_parse_qs6612_pcr(uint mi
 
 	status = *s & ~(PHY_STAT_SPMASK);
 
-	switch((mii_reg >> 2) & 7) {
-	case 1: status |= PHY_STAT_10HDX; break;
-	case 2: status |= PHY_STAT_100HDX; break;
-	case 5: status |= PHY_STAT_10FDX; break;
-	case 6: status |= PHY_STAT_100FDX; break;
-}
+	switch ((mii_reg >> 2) & 7) {
+	case 1:
+		status |= PHY_STAT_10HDX;
+		break;
+	case 2:
+		status |= PHY_STAT_100HDX;
+		break;
+	case 5:
+		status |= PHY_STAT_10FDX;
+		break;
+	case 6:
+		status |= PHY_STAT_100FDX;
+		break;
+	}
 
 	*s = status;
 }
 
 static phy_cmd_t const phy_cmd_qs6612_config[] = {
-		/* The PHY powers up isolated on the RPX,
-		 * so send a command to allow operation.
-		 */
-		{ mk_mii_write(MII_QS6612_PCR, 0x0dc0), NULL },
+	/* The PHY powers up isolated on the RPX,
+	 * so send a command to allow operation.
+	 */
+	{mk_mii_write(MII_QS6612_PCR, 0x0dc0), NULL},
 
-		/* parse cr and anar to get some info */
-		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
-		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
-		{ mk_mii_end, }
-	};
-static phy_cmd_t const phy_cmd_qs6612_startup[] = {  /* enable interrupts */
-		{ mk_mii_write(MII_QS6612_IMR, 0x003a), NULL },
-		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
-		{ mk_mii_end, }
-	};
+	/* parse cr and anar to get some info */
+	{mk_mii_read(MII_REG_CR), mii_parse_cr},
+	{mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_qs6612_startup[] = {	/* enable interrupts */
+	{mk_mii_write(MII_QS6612_IMR, 0x003a), NULL},
+	{mk_mii_write(MII_REG_CR, 0x1200), NULL},	/* autonegotiate */
+	{mk_mii_end,}
+};
 static phy_cmd_t const phy_cmd_qs6612_ack_int[] = {
-		/* we need to read ISR, SR and ANER to acknowledge */
-		{ mk_mii_read(MII_QS6612_ISR), NULL },
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_read(MII_REG_ANER), NULL },
-
-		/* read pcr to get info */
-		{ mk_mii_read(MII_QS6612_PCR), mii_parse_qs6612_pcr },
-		{ mk_mii_end, }
-	};
-static phy_cmd_t const phy_cmd_qs6612_shutdown[] = { /* disable interrupts */
-		{ mk_mii_write(MII_QS6612_IMR, 0x0000), NULL },
-		{ mk_mii_end, }
-	};
+	/* we need to read ISR, SR and ANER to acknowledge */
+	{mk_mii_read(MII_QS6612_ISR), NULL},
+	{mk_mii_read(MII_REG_SR), mii_parse_sr},
+	{mk_mii_read(MII_REG_ANER), NULL},
+
+	/* read pcr to get info */
+	{mk_mii_read(MII_QS6612_PCR), mii_parse_qs6612_pcr},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_qs6612_shutdown[] = {	/* disable interrupts */
+	{mk_mii_write(MII_QS6612_IMR, 0x0000), NULL},
+	{mk_mii_end,}
+};
 static phy_info_t const phy_info_qs6612 = {
 	.id = 0x00181440,
 	.name = "QS6612",
@@ -1050,13 +1033,13 @@ static phy_info_t const phy_info_qs6612 
 
 /* register definitions for the 874 */
 
-#define MII_AM79C874_MFR       16  /* Miscellaneous Feature Register */
-#define MII_AM79C874_ICSR      17  /* Interrupt/Status Register      */
-#define MII_AM79C874_DR        18  /* Diagnostic Register            */
-#define MII_AM79C874_PMLR      19  /* Power and Loopback Register    */
-#define MII_AM79C874_MCR       21  /* ModeControl Register           */
-#define MII_AM79C874_DC        23  /* Disconnect Counter             */
-#define MII_AM79C874_REC       24  /* Recieve Error Counter          */
+#define MII_AM79C874_MFR       16	/* Miscellaneous Feature Register */
+#define MII_AM79C874_ICSR      17	/* Interrupt/Status Register      */
+#define MII_AM79C874_DR        18	/* Diagnostic Register            */
+#define MII_AM79C874_PMLR      19	/* Power and Loopback Register    */
+#define MII_AM79C874_MCR       21	/* ModeControl Register           */
+#define MII_AM79C874_DC        23	/* Disconnect Counter             */
+#define MII_AM79C874_REC       24	/* Recieve Error Counter          */
 
 static void mii_parse_am79c874_dr(uint mii_reg, struct net_device *dev)
 {
@@ -1069,37 +1052,39 @@ static void mii_parse_am79c874_dr(uint m
 	if (mii_reg & 0x0080)
 		status |= PHY_STAT_ANC;
 	if (mii_reg & 0x0400)
-		status |= ((mii_reg & 0x0800) ? PHY_STAT_100FDX : PHY_STAT_100HDX);
+		status |=
+		    ((mii_reg & 0x0800) ? PHY_STAT_100FDX : PHY_STAT_100HDX);
 	else
-		status |= ((mii_reg & 0x0800) ? PHY_STAT_10FDX : PHY_STAT_10HDX);
+		status |=
+		    ((mii_reg & 0x0800) ? PHY_STAT_10FDX : PHY_STAT_10HDX);
 
 	*s = status;
 }
 
 static phy_cmd_t const phy_cmd_am79c874_config[] = {
-		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
-		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
-		{ mk_mii_read(MII_AM79C874_DR), mii_parse_am79c874_dr },
-		{ mk_mii_end, }
-	};
-static phy_cmd_t const phy_cmd_am79c874_startup[] = {  /* enable interrupts */
-		{ mk_mii_write(MII_AM79C874_ICSR, 0xff00), NULL },
-		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_end, }
-	};
+	{mk_mii_read(MII_REG_CR), mii_parse_cr},
+	{mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+	{mk_mii_read(MII_AM79C874_DR), mii_parse_am79c874_dr},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_am79c874_startup[] = {	/* enable interrupts */
+	{mk_mii_write(MII_AM79C874_ICSR, 0xff00), NULL},
+	{mk_mii_write(MII_REG_CR, 0x1200), NULL},	/* autonegotiate */
+	{mk_mii_read(MII_REG_SR), mii_parse_sr},
+	{mk_mii_end,}
+};
 static phy_cmd_t const phy_cmd_am79c874_ack_int[] = {
-		/* find out the current status */
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_read(MII_AM79C874_DR), mii_parse_am79c874_dr },
-		/* we only need to read ISR to acknowledge */
-		{ mk_mii_read(MII_AM79C874_ICSR), NULL },
-		{ mk_mii_end, }
-	};
-static phy_cmd_t const phy_cmd_am79c874_shutdown[] = { /* disable interrupts */
-		{ mk_mii_write(MII_AM79C874_ICSR, 0x0000), NULL },
-		{ mk_mii_end, }
-	};
+	/* find out the current status */
+	{mk_mii_read(MII_REG_SR), mii_parse_sr},
+	{mk_mii_read(MII_AM79C874_DR), mii_parse_am79c874_dr},
+	/* we only need to read ISR to acknowledge */
+	{mk_mii_read(MII_AM79C874_ICSR), NULL},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_am79c874_shutdown[] = {	/* disable interrupts */
+	{mk_mii_write(MII_AM79C874_ICSR, 0x0000), NULL},
+	{mk_mii_end,}
+};
 static phy_info_t const phy_info_am79c874 = {
 	.id = 0x00022561,
 	.name = "AM79C874",
@@ -1109,7 +1094,6 @@ static phy_info_t const phy_info_am79c87
 	.shutdown = phy_cmd_am79c874_shutdown
 };
 
-
 /* ------------------------------------------------------------------------- */
 /* Kendin KS8721BL phy                                                       */
 
@@ -1120,27 +1104,27 @@ static phy_info_t const phy_info_am79c87
 #define	MII_KS8721BL_PHYCR	31
 
 static phy_cmd_t const phy_cmd_ks8721bl_config[] = {
-		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
-		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
-		{ mk_mii_end, }
-	};
-static phy_cmd_t const phy_cmd_ks8721bl_startup[] = {  /* enable interrupts */
-		{ mk_mii_write(MII_KS8721BL_ICSR, 0xff00), NULL },
-		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_end, }
-	};
+	{mk_mii_read(MII_REG_CR), mii_parse_cr},
+	{mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_ks8721bl_startup[] = {	/* enable interrupts */
+	{mk_mii_write(MII_KS8721BL_ICSR, 0xff00), NULL},
+	{mk_mii_write(MII_REG_CR, 0x1200), NULL},	/* autonegotiate */
+	{mk_mii_read(MII_REG_SR), mii_parse_sr},
+	{mk_mii_end,}
+};
 static phy_cmd_t const phy_cmd_ks8721bl_ack_int[] = {
-		/* find out the current status */
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		/* we only need to read ISR to acknowledge */
-		{ mk_mii_read(MII_KS8721BL_ICSR), NULL },
-		{ mk_mii_end, }
-	};
-static phy_cmd_t const phy_cmd_ks8721bl_shutdown[] = { /* disable interrupts */
-		{ mk_mii_write(MII_KS8721BL_ICSR, 0x0000), NULL },
-		{ mk_mii_end, }
-	};
+	/* find out the current status */
+	{mk_mii_read(MII_REG_SR), mii_parse_sr},
+	/* we only need to read ISR to acknowledge */
+	{mk_mii_read(MII_KS8721BL_ICSR), NULL},
+	{mk_mii_end,}
+};
+static phy_cmd_t const phy_cmd_ks8721bl_shutdown[] = {	/* disable interrupts */
+	{mk_mii_write(MII_KS8721BL_ICSR, 0x0000), NULL},
+	{mk_mii_end,}
+};
 static phy_info_t const phy_info_ks8721bl = {
 	.id = 0x00022161,
 	.name = "KS8721BL",
@@ -1153,7 +1137,7 @@ static phy_info_t const phy_info_ks8721b
 /* ------------------------------------------------------------------------- */
 /* register definitions for the DP83848 */
 
-#define MII_DP8384X_PHYSTST    16  /* PHY Status Register */
+#define MII_DP8384X_PHYSTST    16	/* PHY Status Register */
 
 static void mii_parse_dp8384x_sr2(uint mii_reg, struct net_device *dev)
 {
@@ -1169,15 +1153,19 @@ static void mii_parse_dp8384x_sr2(uint m
 	} else
 		fep->link = 0;
 	/* Status of link */
-	if (mii_reg & 0x0010)   /* Autonegotioation complete */
+	if (mii_reg & 0x0010)	/* Autonegotioation complete */
 		*s |= PHY_STAT_ANC;
-	if (mii_reg & 0x0002) {   /* 10MBps? */
-		if (mii_reg & 0x0004)   /* Full Duplex? */
+	/* 10MBps? */
+	if (mii_reg & 0x0002) {
+		/* Full Duplex? */
+		if (mii_reg & 0x0004)
 			*s |= PHY_STAT_10FDX;
 		else
 			*s |= PHY_STAT_10HDX;
-	} else {                  /* 100 Mbps? */
-		if (mii_reg & 0x0004)   /* Full Duplex? */
+	} else {
+		/* 100 Mbps then */
+		/* Full Duplex? */
+		if (mii_reg & 0x0004)
 			*s |= PHY_STAT_100FDX;
 		else
 			*s |= PHY_STAT_100HDX;
@@ -1186,32 +1174,33 @@ static void mii_parse_dp8384x_sr2(uint m
 		*s |= PHY_STAT_FAULT;
 }
 
-static phy_info_t phy_info_dp83848= {
+static phy_info_t phy_info_dp83848 = {
 	0x020005c9,
 	"DP83848",
 
-	(const phy_cmd_t []) {  /* config */
-		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
-		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
-		{ mk_mii_read(MII_DP8384X_PHYSTST), mii_parse_dp8384x_sr2 },
-		{ mk_mii_end, }
+	(const phy_cmd_t[]){	/* config */
+		{mk_mii_read(MII_REG_CR), mii_parse_cr},
+		{mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+		{mk_mii_read(MII_DP8384X_PHYSTST),
+			mii_parse_dp8384x_sr2},
+		{mk_mii_end,}
 	},
-	(const phy_cmd_t []) {  /* startup - enable interrupts */
-		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
-		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
-		{ mk_mii_end, }
+	(const phy_cmd_t[]){	/* startup - enable interrupts */
+		{mk_mii_write(MII_REG_CR, 0x1200), NULL}, /* autonegotiate */
+		{mk_mii_read(MII_REG_SR), mii_parse_sr},
+		{mk_mii_end,}
 	},
-	(const phy_cmd_t []) { /* ack_int - never happens, no interrupt */
-		{ mk_mii_end, }
+	(const phy_cmd_t[]){	/* ack_int - never happens, no interrupt */
+		{mk_mii_end,}
 	},
-	(const phy_cmd_t []) {  /* shutdown */
-		{ mk_mii_end, }
+	(const phy_cmd_t[]){	/* shutdown */
+		{mk_mii_end,}
 	},
 };
 
 /* ------------------------------------------------------------------------- */
 
-static phy_info_t const * const phy_info[] = {
+static phy_info_t const *const phy_info[] = {
 	&phy_info_lxt970,
 	&phy_info_lxt971,
 	&phy_info_qs6612,
@@ -1221,22 +1210,38 @@ static phy_info_t const * const phy_info
 	NULL
 };
 
-/* ------------------------------------------------------------------------- */
-#if !defined(CONFIG_M532x)
-#ifdef CONFIG_RPXCLASSIC
-static void
-mii_link_interrupt(void *dev_id);
-#else
-static irqreturn_t
-mii_link_interrupt(int irq, void * dev_id);
-#endif
+#if defined(CONFIG_M5272)
+static void fec_phy_ack_intr(void)
+{
+	volatile unsigned long *icrp;
+	/* Acknowledge the interrupt */
+	icrp = (volatile unsigned long *)(MCF_MBAR + MCFSIM_ICR1);
+	*icrp = 0x0d000000;
+}
+
+/* This interrupt occurs when the PHY detects a link change.
+*/
+static irqreturn_t mii_link_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	struct fec_enet_private *fep = netdev_priv(dev);
+
+	fec_phy_ack_intr();
+
+#if 0
+	disable_irq(fep->mii_irq);	/* disable now, enable later */
 #endif
 
-#if defined(CONFIG_M5272)
+	mii_do_cmd(dev, fep->phy->ack_int);
+	mii_do_cmd(dev, phy_cmd_relink);	/* restart and display status */
+
+	return IRQ_HANDLED;
+}
+
 /*
  *	Code specific to Coldfire 5272 setup.
  */
-static void __inline__ fec_request_intrs(struct net_device *dev)
+static void __init fec_request_intrs(struct net_device *dev)
 {
 	volatile unsigned long *icrp;
 	static const struct idesc {
@@ -1244,27 +1249,36 @@ static void __inline__ fec_request_intrs
 		unsigned short irq;
 		irq_handler_t handler;
 	} *idp, id[] = {
-		{ "fec(RX)", 86, fec_enet_interrupt },
-		{ "fec(TX)", 87, fec_enet_interrupt },
-		{ "fec(OTHER)", 88, fec_enet_interrupt },
-		{ "fec(MII)", 66, mii_link_interrupt },
-		{ NULL },
+		/*
+		 * Available but not allocated because not handled:
+		 * fec(OTHER) 88
+		 */
+		{ "fec(RX)", 86, fec_enet_interrupt},
+		{ "fec(TX)", 87, fec_enet_interrupt},
+		{ "fec(MII)", 66, mii_link_interrupt},
+		{ NULL, 0 },
 	};
 
 	/* Setup interrupt handlers. */
 	for (idp = id; idp->name; idp++) {
-		if (request_irq(idp->irq, idp->handler, 0, idp->name, dev) != 0)
-			printk("FEC: Could not allocate %s IRQ(%d)!\n", idp->name, idp->irq);
+	    int ret;
+
+	    ret =request_irq(idp->irq, idp->handler, IRQF_DISABLED, idp->name,
+		    dev);
+	    if (ret)
+		printk("FEC: Could not allocate %s IRQ(%d)!\n",
+			idp->name, idp->irq);
 	}
 
 	/* Unmask interrupt at ColdFire 5272 SIM */
-	icrp = (volatile unsigned long *) (MCF_MBAR + MCFSIM_ICR3);
+	icrp = (volatile unsigned long *)(MCF_MBAR + MCFSIM_ICR3);
 	*icrp = 0x00000ddd;
-	icrp = (volatile unsigned long *) (MCF_MBAR + MCFSIM_ICR1);
+	icrp = (volatile unsigned long *)(MCF_MBAR + MCFSIM_ICR1);
 	*icrp = 0x0d000000;
 }
 
-static void __inline__ fec_set_mii(struct net_device *dev, struct fec_enet_private *fep)
+static void __init fec_set_mii(struct net_device *dev,
+				   struct fec_enet_private *fep)
 {
 	volatile fec_t *fecp;
 
@@ -1282,7 +1296,7 @@ static void __inline__ fec_set_mii(struc
 	fec_restart(dev, 0);
 }
 
-static void __inline__ fec_get_mac(struct net_device *dev)
+static void __init fec_get_mac(struct net_device *dev)
 {
 	struct fec_enet_private *fep = netdev_priv(dev);
 	volatile fec_t *fecp;
@@ -1303,8 +1317,8 @@ static void __inline__ fec_get_mac(struc
 		    (iap[3] == 0xff) && (iap[4] == 0xff) && (iap[5] == 0xff))
 			iap = fec_mac_default;
 	} else {
-		*((unsigned long *) &tmpaddr[0]) = fecp->fec_addr_low;
-		*((unsigned short *) &tmpaddr[4]) = (fecp->fec_addr_high >> 16);
+		*((unsigned long *)&tmpaddr[0]) = fecp->fec_addr_low;
+		*((unsigned short *)&tmpaddr[4]) = (fecp->fec_addr_high >> 16);
 		iap = &tmpaddr[0];
 	}
 
@@ -1312,36 +1326,29 @@ static void __inline__ fec_get_mac(struc
 
 	/* Adjust MAC if using default MAC address */
 	if (iap == fec_mac_default)
-		 dev->dev_addr[ETH_ALEN-1] = fec_mac_default[ETH_ALEN-1] + fep->index;
+		dev->dev_addr[ETH_ALEN - 1] =
+		    fec_mac_default[ETH_ALEN - 1] + fep->index;
 }
 
-static void __inline__ fec_enable_phy_intr(void)
+static void fec_enable_phy_intr(void)
 {
 }
 
-static void __inline__ fec_disable_phy_intr(void)
+static void fec_disable_phy_intr(void)
 {
 	volatile unsigned long *icrp;
-	icrp = (volatile unsigned long *) (MCF_MBAR + MCFSIM_ICR1);
+	icrp = (volatile unsigned long *)(MCF_MBAR + MCFSIM_ICR1);
 	*icrp = 0x08000000;
 }
 
-static void __inline__ fec_phy_ack_intr(void)
-{
-	volatile unsigned long *icrp;
-	/* Acknowledge the interrupt */
-	icrp = (volatile unsigned long *) (MCF_MBAR + MCFSIM_ICR1);
-	*icrp = 0x0d000000;
-}
-
-static void __inline__ fec_localhw_setup(void)
+static void fec_localhw_setup(void)
 {
 }
 
 /*
  *	Do not need to make region uncached on 5272.
  */
-static void __inline__ fec_uncache(unsigned long addr)
+static void __init fec_uncache(unsigned long addr)
 {
 }
 
@@ -1353,7 +1360,7 @@ static void __inline__ fec_uncache(unsig
  *	Code specific to Coldfire 5230/5231/5232/5234/5235,
  *	the 5270/5271/5274/5275 and 5280/5282 setups.
  */
-static void __inline__ fec_request_intrs(struct net_device *dev)
+static void __init fec_request_intrs(struct net_device *dev)
 {
 	struct fec_enet_private *fep;
 	int b;
@@ -1361,20 +1368,16 @@ static void __inline__ fec_request_intrs
 		char *name;
 		unsigned short irq;
 	} *idp, id[] = {
-		{ "fec(TXF)", 23 },
-		{ "fec(TXB)", 24 },
-		{ "fec(TXFIFO)", 25 },
-		{ "fec(TXCR)", 26 },
-		{ "fec(RXF)", 27 },
-		{ "fec(RXB)", 28 },
-		{ "fec(MII)", 29 },
-		{ "fec(LC)", 30 },
-		{ "fec(HBERR)", 31 },
-		{ "fec(GRA)", 32 },
-		{ "fec(EBERR)", 33 },
-		{ "fec(BABT)", 34 },
-		{ "fec(BABR)", 35 },
-		{ NULL },
+		/*
+		 * Available but not allocated because not handled:
+		 * fec(TXB) 24, fec(TXFIFO) 25, fec(TXCR) 26, fec(RXB) 28,
+		 * fec(LC) 30, fec(HBERR) 31, fec(GRA) 32, fec(EBERR) 33,
+		 * fec(BABT) 34, fec(BABR), 35
+		 */
+		{ "fec(TXF)", 23},
+		{ "fec(RXF)", 27},
+		{ "fec(MII)", 29},
+		{ NULL, 0},
 	};
 
 	fep = netdev_priv(dev);
@@ -1382,43 +1385,47 @@ static void __inline__ fec_request_intrs
 
 	/* Setup interrupt handlers. */
 	for (idp = id; idp->name; idp++) {
-		if (request_irq(b+idp->irq, fec_enet_interrupt, 0, idp->name, dev) != 0)
-			printk("FEC: Could not allocate %s IRQ(%d)!\n", idp->name, b+idp->irq);
-	}
+	    int ret;
 
+	    ret = request_irq(b + idp->irq, fec_enet_interrupt, IRQF_DISABLED,
+		    idp->name, dev);
+	    if (ret)
+		printk("FEC: Could not allocate %s IRQ(%d)!\n",
+			idp->name, b + idp->irq);
+	}
+#if defined(CONFIG_M527x) || defined(CONFIG_M528x)
 	/* Unmask interrupts at ColdFire 5280/5282 interrupt controller */
 	{
-		volatile unsigned char  *icrp;
-		volatile unsigned long  *imrp;
+		volatile unsigned char *icrp;
+		volatile unsigned long *imrp;
 		int i, ilip;
 
 		b = (fep->index) ? MCFICM_INTC1 : MCFICM_INTC0;
-		icrp = (volatile unsigned char *) (MCF_IPSBAR + b +
-			MCFINTC_ICR0);
+		icrp = (volatile unsigned char *)(MCF_IPSBAR + b +
+						  MCFINTC_ICR0);
 		for (i = 23, ilip = 0x28; (i < 36); i++)
 			icrp[i] = ilip--;
 
-		imrp = (volatile unsigned long *) (MCF_IPSBAR + b +
-			MCFINTC_IMRH);
+		imrp = (volatile unsigned long *)(MCF_IPSBAR + b +
+						  MCFINTC_IMRH);
 		*imrp &= ~0x0000000f;
-		imrp = (volatile unsigned long *) (MCF_IPSBAR + b +
-			MCFINTC_IMRL);
+		imrp = (volatile unsigned long *)(MCF_IPSBAR + b +
+						  MCFINTC_IMRL);
 		*imrp &= ~0xff800001;
 	}
-
+#endif
 #if defined(CONFIG_M528x)
 	/* Set up gpio outputs for MII lines */
 	{
 		volatile u16 *gpio_paspar;
 		volatile u8 *gpio_pehlpar;
 
-		gpio_paspar = (volatile u16 *) (MCF_IPSBAR + 0x100056);
-		gpio_pehlpar = (volatile u16 *) (MCF_IPSBAR + 0x100058);
+		gpio_paspar = (volatile u16 *)(MCF_IPSBAR + 0x100056);
+		gpio_pehlpar = (volatile u16 *)(MCF_IPSBAR + 0x100058);
 		*gpio_paspar |= 0x0f00;
 		*gpio_pehlpar = 0xc0;
 	}
 #endif
-
 #if defined(CONFIG_M527x)
 	/* Set up gpio outputs for MII lines */
 	{
@@ -1443,7 +1450,8 @@ static void __inline__ fec_request_intrs
 #endif /* CONFIG_M527x */
 }
 
-static void __inline__ fec_set_mii(struct net_device *dev, struct fec_enet_private *fep)
+static void __init fec_set_mii(struct net_device *dev,
+				   struct fec_enet_private *fep)
 {
 	volatile fec_t *fecp;
 
@@ -1461,7 +1469,7 @@ static void __inline__ fec_set_mii(struc
 	fec_restart(dev, 0);
 }
 
-static void __inline__ fec_get_mac(struct net_device *dev)
+static void __init fec_get_mac(struct net_device *dev)
 {
 	struct fec_enet_private *fep = netdev_priv(dev);
 	volatile fec_t *fecp;
@@ -1482,8 +1490,8 @@ static void __inline__ fec_get_mac(struc
 		    (iap[3] == 0xff) && (iap[4] == 0xff) && (iap[5] == 0xff))
 			iap = fec_mac_default;
 	} else {
-		*((unsigned long *) &tmpaddr[0]) = fecp->fec_addr_low;
-		*((unsigned short *) &tmpaddr[4]) = (fecp->fec_addr_high >> 16);
+		*((unsigned long *)&tmpaddr[0]) = fecp->fec_addr_low;
+		*((unsigned short *)&tmpaddr[4]) = (fecp->fec_addr_high >> 16);
 		iap = &tmpaddr[0];
 	}
 
@@ -1491,29 +1499,26 @@ static void __inline__ fec_get_mac(struc
 
 	/* Adjust MAC if using default MAC address */
 	if (iap == fec_mac_default)
-		dev->dev_addr[ETH_ALEN-1] = fec_mac_default[ETH_ALEN-1] + fep->index;
+		dev->dev_addr[ETH_ALEN - 1] =
+		    fec_mac_default[ETH_ALEN - 1] + fep->index;
 }
 
-static void __inline__ fec_enable_phy_intr(void)
+static void fec_enable_phy_intr(void)
 {
 }
 
-static void __inline__ fec_disable_phy_intr(void)
+static void fec_disable_phy_intr(void)
 {
 }
 
-static void __inline__ fec_phy_ack_intr(void)
-{
-}
-
-static void __inline__ fec_localhw_setup(void)
+static void fec_localhw_setup(void)
 {
 }
 
 /*
  *	Do not need to make region uncached on 5272.
  */
-static void __inline__ fec_uncache(unsigned long addr)
+static void __init fec_uncache(unsigned long addr)
 {
 }
 
@@ -1524,7 +1529,7 @@ static void __inline__ fec_uncache(unsig
 /*
  *	Code specific to Coldfire 520x
  */
-static void __inline__ fec_request_intrs(struct net_device *dev)
+static void __init fec_request_intrs(struct net_device *dev)
 {
 	struct fec_enet_private *fep;
 	int b;
@@ -1532,20 +1537,16 @@ static void __inline__ fec_request_intrs
 		char *name;
 		unsigned short irq;
 	} *idp, id[] = {
-		{ "fec(TXF)", 23 },
-		{ "fec(TXB)", 24 },
-		{ "fec(TXFIFO)", 25 },
-		{ "fec(TXCR)", 26 },
-		{ "fec(RXF)", 27 },
-		{ "fec(RXB)", 28 },
-		{ "fec(MII)", 29 },
-		{ "fec(LC)", 30 },
-		{ "fec(HBERR)", 31 },
-		{ "fec(GRA)", 32 },
-		{ "fec(EBERR)", 33 },
-		{ "fec(BABT)", 34 },
-		{ "fec(BABR)", 35 },
-		{ NULL },
+		/*
+		 * Available but not allocated because not handled:
+		 * fec(TXB) 24, fec(TXFIFO) 25, fec(TXCR) 26, fec(RXB) 28,
+		 * fec(LC) 30, fec(HBERR) 31, fec(GRA) 32, fec(EBERR) 33,
+		 * fec(BABT) 34, fec(BABR) 35
+		 */
+		{ "fec(TXF)", 23},
+		{ "fec(RXF)", 27},
+		{ "fec(MII)", 29},
+		{ NULL, 0},
 	};
 
 	fep = netdev_priv(dev);
@@ -1553,28 +1554,34 @@ static void __inline__ fec_request_intrs
 
 	/* Setup interrupt handlers. */
 	for (idp = id; idp->name; idp++) {
-		if (request_irq(b+idp->irq,fec_enet_interrupt,0,idp->name,dev)!=0)
-			printk("FEC: Could not allocate %s IRQ(%d)!\n", idp->name, b+idp->irq);
+	    int ret;
+
+	    ret = request_irq(b + idp->irq, fec_enet_interrupt, IRQF_DISABLED,
+		    idp->name, dev);
+	    if (ret)
+		printk("FEC: Could not allocate %s IRQ(%d)!\n",
+			idp->name, b + idp->irq);
 	}
 
 	/* Unmask interrupts at ColdFire interrupt controller */
 	{
-		volatile unsigned char  *icrp;
-		volatile unsigned long  *imrp;
+		volatile unsigned char *icrp;
+		volatile unsigned long *imrp;
 
-		icrp = (volatile unsigned char *) (MCF_IPSBAR + MCFICM_INTC0 +
-			MCFINTC_ICR0);
+		icrp = (volatile unsigned char *)(MCF_IPSBAR + MCFICM_INTC0 +
+						  MCFINTC_ICR0);
 		for (b = 36; (b < 49); b++)
 			icrp[b] = 0x04;
-		imrp = (volatile unsigned long *) (MCF_IPSBAR + MCFICM_INTC0 +
-			MCFINTC_IMRH);
+		imrp = (volatile unsigned long *)(MCF_IPSBAR + MCFICM_INTC0 +
+						  MCFINTC_IMRH);
 		*imrp &= ~0x0001FFF0;
 	}
 	*(volatile unsigned char *)(MCF_IPSBAR + MCF_GPIO_PAR_FEC) |= 0xf0;
 	*(volatile unsigned char *)(MCF_IPSBAR + MCF_GPIO_PAR_FECI2C) |= 0x0f;
 }
 
-static void __inline__ fec_set_mii(struct net_device *dev, struct fec_enet_private *fep)
+static void __init fec_set_mii(struct net_device *dev,
+				   struct fec_enet_private *fep)
 {
 	volatile fec_t *fecp;
 
@@ -1592,7 +1599,7 @@ static void __inline__ fec_set_mii(struc
 	fec_restart(dev, 0);
 }
 
-static void __inline__ fec_get_mac(struct net_device *dev)
+static void __init fec_get_mac(struct net_device *dev)
 {
 	struct fec_enet_private *fep = netdev_priv(dev);
 	volatile fec_t *fecp;
@@ -1607,14 +1614,14 @@ static void __inline__ fec_get_mac(struc
 		 */
 		iap = FEC_FLASHMAC;
 		if ((iap[0] == 0) && (iap[1] == 0) && (iap[2] == 0) &&
-		   (iap[3] == 0) && (iap[4] == 0) && (iap[5] == 0))
+		    (iap[3] == 0) && (iap[4] == 0) && (iap[5] == 0))
 			iap = fec_mac_default;
 		if ((iap[0] == 0xff) && (iap[1] == 0xff) && (iap[2] == 0xff) &&
-		   (iap[3] == 0xff) && (iap[4] == 0xff) && (iap[5] == 0xff))
+		    (iap[3] == 0xff) && (iap[4] == 0xff) && (iap[5] == 0xff))
 			iap = fec_mac_default;
 	} else {
-		*((unsigned long *) &tmpaddr[0]) = fecp->fec_addr_low;
-		*((unsigned short *) &tmpaddr[4]) = (fecp->fec_addr_high >> 16);
+		*((unsigned long *)&tmpaddr[0]) = fecp->fec_addr_low;
+		*((unsigned short *)&tmpaddr[4]) = (fecp->fec_addr_high >> 16);
 		iap = &tmpaddr[0];
 	}
 
@@ -1622,26 +1629,23 @@ static void __inline__ fec_get_mac(struc
 
 	/* Adjust MAC if using default MAC address */
 	if (iap == fec_mac_default)
-		dev->dev_addr[ETH_ALEN-1] = fec_mac_default[ETH_ALEN-1] + fep->index;
-}
-
-static void __inline__ fec_enable_phy_intr(void)
-{
+		dev->dev_addr[ETH_ALEN - 1] =
+		    fec_mac_default[ETH_ALEN - 1] + fep->index;
 }
 
-static void __inline__ fec_disable_phy_intr(void)
+static void fec_enable_phy_intr(void)
 {
 }
 
-static void __inline__ fec_phy_ack_intr(void)
+static void fec_disable_phy_intr(void)
 {
 }
 
-static void __inline__ fec_localhw_setup(void)
+static void fec_localhw_setup(void)
 {
 }
 
-static void __inline__ fec_uncache(unsigned long addr)
+static void __init fec_uncache(unsigned long addr)
 {
 }
 
@@ -1651,7 +1655,7 @@ static void __inline__ fec_uncache(unsig
 /*
  * Code specific for M532x
  */
-static void __inline__ fec_request_intrs(struct net_device *dev)
+static void __init fec_request_intrs(struct net_device *dev)
 {
 	struct fec_enet_private *fep;
 	int b;
@@ -1659,20 +1663,16 @@ static void __inline__ fec_request_intrs
 		char *name;
 		unsigned short irq;
 	} *idp, id[] = {
-	    { "fec(TXF)", 36 },
-	    { "fec(TXB)", 37 },
-	    { "fec(TXFIFO)", 38 },
-	    { "fec(TXCR)", 39 },
-	    { "fec(RXF)", 40 },
-	    { "fec(RXB)", 41 },
-	    { "fec(MII)", 42 },
-	    { "fec(LC)", 43 },
-	    { "fec(HBERR)", 44 },
-	    { "fec(GRA)", 45 },
-	    { "fec(EBERR)", 46 },
-	    { "fec(BABT)", 47 },
-	    { "fec(BABR)", 48 },
-	    { NULL },
+		/*
+		 * Available but not allocated because not handled:
+		 * fec(TXB) 37, fec(TXFIFO) 38, fec(TXCR) 39, fec(RXB) 41,
+		 * fec(LC) 43, fec(HBERR) 44, fec(GRA) 45, fec(EBERR) 46,
+		 * fec(BABT) 47, fec(BABR) 48
+		 */
+		{ "fec(TXF)", 36},
+		{ "fec(RXF)", 40},
+		{ "fec(MII)", 42},
+		{ NULL, 0},
 	};
 
 	fep = netdev_priv(dev);
@@ -1680,9 +1680,13 @@ static void __inline__ fec_request_intrs
 
 	/* Setup interrupt handlers. */
 	for (idp = id; idp->name; idp++) {
-		if (request_irq(b+idp->irq,fec_enet_interrupt,0,idp->name,dev)!=0)
-			printk("FEC: Could not allocate %s IRQ(%d)!\n",
-				idp->name, b+idp->irq);
+	    int ret;
+
+	    ret = request_irq(b + idp->irq, fec_enet_interrupt, IRQF_DISABLED,
+		    idp->name, dev);
+	   if (ret)
+	       printk("FEC: Could not allocate %s IRQ(%d)!\n",
+		       idp->name, b + idp->irq);
 	}
 
 	/* Unmask interrupts */
@@ -1700,31 +1704,31 @@ static void __inline__ fec_request_intrs
 	MCF_INTC0_ICR47 = 0x2;
 	MCF_INTC0_ICR48 = 0x2;
 
-	MCF_INTC0_IMRH &= ~(
-		MCF_INTC_IMRH_INT_MASK36 |
-		MCF_INTC_IMRH_INT_MASK37 |
-		MCF_INTC_IMRH_INT_MASK38 |
-		MCF_INTC_IMRH_INT_MASK39 |
-		MCF_INTC_IMRH_INT_MASK40 |
-		MCF_INTC_IMRH_INT_MASK41 |
-		MCF_INTC_IMRH_INT_MASK42 |
-		MCF_INTC_IMRH_INT_MASK43 |
-		MCF_INTC_IMRH_INT_MASK44 |
-		MCF_INTC_IMRH_INT_MASK45 |
-		MCF_INTC_IMRH_INT_MASK46 |
-		MCF_INTC_IMRH_INT_MASK47 |
-		MCF_INTC_IMRH_INT_MASK48 );
+	MCF_INTC0_IMRH &= ~(MCF_INTC_IMRH_INT_MASK36 |
+			    MCF_INTC_IMRH_INT_MASK37 |
+			    MCF_INTC_IMRH_INT_MASK38 |
+			    MCF_INTC_IMRH_INT_MASK39 |
+			    MCF_INTC_IMRH_INT_MASK40 |
+			    MCF_INTC_IMRH_INT_MASK41 |
+			    MCF_INTC_IMRH_INT_MASK42 |
+			    MCF_INTC_IMRH_INT_MASK43 |
+			    MCF_INTC_IMRH_INT_MASK44 |
+			    MCF_INTC_IMRH_INT_MASK45 |
+			    MCF_INTC_IMRH_INT_MASK46 |
+			    MCF_INTC_IMRH_INT_MASK47 |
+			    MCF_INTC_IMRH_INT_MASK48);
 
 	/* Set up gpio outputs for MII lines */
 	MCF_GPIO_PAR_FECI2C |= (0 |
-		MCF_GPIO_PAR_FECI2C_PAR_MDC_EMDC |
-		MCF_GPIO_PAR_FECI2C_PAR_MDIO_EMDIO);
+				MCF_GPIO_PAR_FECI2C_PAR_MDC_EMDC |
+				MCF_GPIO_PAR_FECI2C_PAR_MDIO_EMDIO);
 	MCF_GPIO_PAR_FEC = (0 |
-		MCF_GPIO_PAR_FEC_PAR_FEC_7W_FEC |
-		MCF_GPIO_PAR_FEC_PAR_FEC_MII_FEC);
+			    MCF_GPIO_PAR_FEC_PAR_FEC_7W_FEC |
+			    MCF_GPIO_PAR_FEC_PAR_FEC_MII_FEC);
 }
 
-static void __inline__ fec_set_mii(struct net_device *dev, struct fec_enet_private *fep)
+static void __init fec_set_mii(struct net_device *dev,
+				   struct fec_enet_private *fep)
 {
 	volatile fec_t *fecp;
 
@@ -1741,7 +1745,7 @@ static void __inline__ fec_set_mii(struc
 	fec_restart(dev, 0);
 }
 
-static void __inline__ fec_get_mac(struct net_device *dev)
+static void __init fec_get_mac(struct net_device *dev)
 {
 	struct fec_enet_private *fep = netdev_priv(dev);
 	volatile fec_t *fecp;
@@ -1762,8 +1766,8 @@ static void __inline__ fec_get_mac(struc
 		    (iap[3] == 0xff) && (iap[4] == 0xff) && (iap[5] == 0xff))
 			iap = fec_mac_default;
 	} else {
-		*((unsigned long *) &tmpaddr[0]) = fecp->fec_addr_low;
-		*((unsigned short *) &tmpaddr[4]) = (fecp->fec_addr_high >> 16);
+		*((unsigned long *)&tmpaddr[0]) = fecp->fec_addr_low;
+		*((unsigned short *)&tmpaddr[4]) = (fecp->fec_addr_high >> 16);
 		iap = &tmpaddr[0];
 	}
 
@@ -1771,143 +1775,109 @@ static void __inline__ fec_get_mac(struc
 
 	/* Adjust MAC if using default MAC address */
 	if (iap == fec_mac_default)
-		dev->dev_addr[ETH_ALEN-1] = fec_mac_default[ETH_ALEN-1] + fep->index;
-}
-
-static void __inline__ fec_enable_phy_intr(void)
-{
+		dev->dev_addr[ETH_ALEN - 1] =
+		    fec_mac_default[ETH_ALEN - 1] + fep->index;
 }
 
-static void __inline__ fec_disable_phy_intr(void)
+static void fec_enable_phy_intr(void)
 {
 }
 
-static void __inline__ fec_phy_ack_intr(void)
+static void fec_disable_phy_intr(void)
 {
 }
 
-static void __inline__ fec_localhw_setup(void)
+static void fec_localhw_setup(void)
 {
 }
 
 /*
  *	Do not need to make region uncached on 532x.
  */
-static void __inline__ fec_uncache(unsigned long addr)
+static void __init fec_uncache(unsigned long addr)
 {
 }
 
 /* ------------------------------------------------------------------------- */
 
-
 #else
 
 /*
  *	Code specific to the MPC860T setup.
  */
-static void __inline__ fec_request_intrs(struct net_device *dev)
+static void __init fec_request_intrs(struct net_device *dev)
 {
 	volatile immap_t *immap;
 
-	immap = (immap_t *)IMAP_ADDR;	/* pointer to internal registers */
+	immap = (immap_t *) IMAP_ADDR;	/* pointer to internal registers */
 
-	if (request_8xxirq(FEC_INTERRUPT, fec_enet_interrupt, 0, "fec", dev) != 0)
+	if (request_8xxirq(FEC_INTERRUPT, fec_enet_interrupt, 0, "fec", dev) !=
+	    0)
 		panic("Could not allocate FEC IRQ!");
-
-#ifdef CONFIG_RPXCLASSIC
-	/* Make Port C, bit 15 an input that causes interrupts.
-	*/
-	immap->im_ioport.iop_pcpar &= ~0x0001;
-	immap->im_ioport.iop_pcdir &= ~0x0001;
-	immap->im_ioport.iop_pcso &= ~0x0001;
-	immap->im_ioport.iop_pcint |= 0x0001;
-	cpm_install_handler(CPMVEC_PIO_PC15, mii_link_interrupt, dev);
-
-	/* Make LEDS reflect Link status.
-	*/
-	*((uint *) RPX_CSR_ADDR) &= ~BCSR2_FETHLEDMODE;
-#endif
-#ifdef CONFIG_FADS
-	if (request_8xxirq(SIU_IRQ2, mii_link_interrupt, 0, "mii", dev) != 0)
-		panic("Could not allocate MII IRQ!");
-#endif
 }
 
-static void __inline__ fec_get_mac(struct net_device *dev)
+static void __init fec_get_mac(struct net_device *dev)
 {
 	bd_t *bd;
 
-	bd = (bd_t *)__res;
+	bd = (bd_t *) __res;
 	memcpy(dev->dev_addr, bd->bi_enetaddr, ETH_ALEN);
-
-#ifdef CONFIG_RPXCLASSIC
-	/* The Embedded Planet boards have only one MAC address in
-	 * the EEPROM, but can have two Ethernet ports.  For the
-	 * FEC port, we create another address by setting one of
-	 * the address bits above something that would have (up to
-	 * now) been allocated.
-	 */
-	dev->dev_adrd[3] |= 0x80;
-#endif
 }
 
-static void __inline__ fec_set_mii(struct net_device *dev, struct fec_enet_private *fep)
+static void __init fec_set_mii(struct net_device *dev,
+				   struct fec_enet_private *fep)
 {
 	extern uint _get_IMMR(void);
 	volatile immap_t *immap;
 	volatile fec_t *fecp;
 
 	fecp = fep->hwp;
-	immap = (immap_t *)IMAP_ADDR;	/* pointer to internal registers */
+	immap = (immap_t *) IMAP_ADDR;	/* pointer to internal registers */
 
 	/* Configure all of port D for MII.
-	*/
+	 */
 	immap->im_ioport.iop_pdpar = 0x1fff;
 
 	/* Bits moved from Rev. D onward.
-	*/
+	 */
 	if ((_get_IMMR() & 0xffff) < 0x0501)
 		immap->im_ioport.iop_pddir = 0x1c58;	/* Pre rev. D */
 	else
 		immap->im_ioport.iop_pddir = 0x1fff;	/* Rev. D and later */
 
 	/* Set MII speed to 2.5 MHz
-	*/
+	 */
 	fecp->fec_mii_speed = fep->phy_speed =
-		((bd->bi_busfreq * 1000000) / 2500000) & 0x7e;
+	    ((bd->bi_busfreq * 1000000) / 2500000) & 0x7e;
 }
 
-static void __inline__ fec_enable_phy_intr(void)
+static void fec_enable_phy_intr(void)
 {
 	volatile fec_t *fecp;
 
 	fecp = fep->hwp;
 
 	/* Enable MII command finished interrupt
-	*/
-	fecp->fec_ivec = (FEC_INTERRUPT/2) << 29;
-}
-
-static void __inline__ fec_disable_phy_intr(void)
-{
+	 */
+	fecp->fec_ivec = (FEC_INTERRUPT / 2) << 29;
 }
 
-static void __inline__ fec_phy_ack_intr(void)
+static void fec_disable_phy_intr(void)
 {
 }
 
-static void __inline__ fec_localhw_setup(void)
+static void fec_localhw_setup(void)
 {
 	volatile fec_t *fecp;
 
 	fecp = fep->hwp;
 	fecp->fec_r_hash = PKT_MAXBUF_SIZE;
 	/* Enable big endian and don't care about SDMA FC.
-	*/
+	 */
 	fecp->fec_fun_code = 0x78000000;
 }
 
-static void __inline__ fec_uncache(unsigned long addr)
+static void __init fec_uncache(unsigned long addr)
 {
 	pte_t *pte;
 	pte = va_to_pte(mem_addr);
@@ -1936,11 +1906,19 @@ static void mii_display_status(struct ne
 	} else {
 		printk("link up");
 
-		switch(*s & PHY_STAT_SPMASK) {
-		case PHY_STAT_100FDX: printk(", 100MBit Full Duplex"); break;
-		case PHY_STAT_100HDX: printk(", 100MBit Half Duplex"); break;
-		case PHY_STAT_10FDX: printk(", 10MBit Full Duplex"); break;
-		case PHY_STAT_10HDX: printk(", 10MBit Half Duplex"); break;
+		switch (*s & PHY_STAT_SPMASK) {
+		case PHY_STAT_100FDX:
+			printk(", 100MBit Full Duplex");
+			break;
+		case PHY_STAT_100HDX:
+			printk(", 100MBit Half Duplex");
+			break;
+		case PHY_STAT_10FDX:
+			printk(", 10MBit Full Duplex");
+			break;
+		case PHY_STAT_10HDX:
+			printk(", 10MBit Half Duplex");
+			break;
 		default:
 			printk(", Unknown speed/duplex");
 		}
@@ -1957,14 +1935,15 @@ static void mii_display_status(struct ne
 
 static void mii_display_config(struct work_struct *work)
 {
-	struct fec_enet_private *fep = container_of(work, struct fec_enet_private, phy_task);
+	struct fec_enet_private *fep =
+	    container_of(work, struct fec_enet_private, phy_task);
 	struct net_device *dev = fep->netdev;
 	uint status = fep->phy_status;
 
 	/*
-	** When we get here, phy_task is already removed from
-	** the workqueue.  It is thus safe to allow to reuse it.
-	*/
+	 ** When we get here, phy_task is already removed from
+	 ** the workqueue.  It is thus safe to allow to reuse it.
+	 */
 	fep->mii_phy_task_queued = 0;
 	printk("%s: config: auto-negotiation ", dev->name);
 
@@ -1994,14 +1973,15 @@ static void mii_display_config(struct wo
 
 static void mii_relink(struct work_struct *work)
 {
-	struct fec_enet_private *fep = container_of(work, struct fec_enet_private, phy_task);
+	struct fec_enet_private *fep =
+	    container_of(work, struct fec_enet_private, phy_task);
 	struct net_device *dev = fep->netdev;
 	int duplex;
 
 	/*
-	** When we get here, phy_task is already removed from
-	** the workqueue.  It is thus safe to allow to reuse it.
-	*/
+	 ** When we get here, phy_task is already removed from
+	 ** the workqueue.  It is thus safe to allow to reuse it.
+	 */
 	fep->mii_phy_task_queued = 0;
 	fep->link = (fep->phy_status & PHY_STAT_LINK) ? 1 : 0;
 	mii_display_status(dev);
@@ -2009,8 +1989,7 @@ static void mii_relink(struct work_struc
 
 	if (fep->link) {
 		duplex = 0;
-		if (fep->phy_status
-		    & (PHY_STAT_100FDX | PHY_STAT_10FDX))
+		if (fep->phy_status & (PHY_STAT_100FDX | PHY_STAT_10FDX))
 			duplex = 1;
 		fec_restart(dev, duplex);
 	} else
@@ -2028,12 +2007,12 @@ static void mii_queue_relink(uint mii_re
 	struct fec_enet_private *fep = netdev_priv(dev);
 
 	/*
-	** We cannot queue phy_task twice in the workqueue.  It
-	** would cause an endless loop in the workqueue.
-	** Fortunately, if the last mii_relink entry has not yet been
-	** executed now, it will do the job for the current interrupt,
-	** which is just what we want.
-	*/
+	 ** We cannot queue phy_task twice in the workqueue.  It
+	 ** would cause an endless loop in the workqueue.
+	 ** Fortunately, if the last mii_relink entry has not yet been
+	 ** executed now, it will do the job for the current interrupt,
+	 ** which is just what we want.
+	 */
 	if (fep->mii_phy_task_queued)
 		return;
 
@@ -2056,18 +2035,17 @@ static void mii_queue_config(uint mii_re
 }
 
 phy_cmd_t const phy_cmd_relink[] = {
-	{ mk_mii_read(MII_REG_CR), mii_queue_relink },
-	{ mk_mii_end, }
-	};
+	{mk_mii_read(MII_REG_CR), mii_queue_relink},
+	{mk_mii_end,}
+};
 phy_cmd_t const phy_cmd_config[] = {
-	{ mk_mii_read(MII_REG_CR), mii_queue_config },
-	{ mk_mii_end, }
-	};
+	{mk_mii_read(MII_REG_CR), mii_queue_config},
+	{mk_mii_end,}
+};
 
 /* Read remainder of PHY ID.
 */
-static void
-mii_discover_phy3(uint mii_reg, struct net_device *dev)
+static void mii_discover_phy3(uint mii_reg, struct net_device *dev)
 {
 	struct fec_enet_private *fep;
 	int i;
@@ -2076,8 +2054,8 @@ mii_discover_phy3(uint mii_reg, struct n
 	fep->phy_id |= (mii_reg & 0xffff);
 	printk("fec: PHY @ 0x%x, ID 0x%08x", fep->phy_addr, fep->phy_id);
 
-	for(i = 0; phy_info[i]; i++) {
-		if(phy_info[i]->id == (fep->phy_id >> 4))
+	for (i = 0; phy_info[i]; i++) {
+		if (phy_info[i]->id == (fep->phy_id >> 4))
 			break;
 	}
 
@@ -2093,8 +2071,7 @@ mii_discover_phy3(uint mii_reg, struct n
 /* Scan all of the MII PHY addresses looking for someone to respond
  * with a valid ID.  This usually happens quickly.
  */
-static void
-mii_discover_phy(uint mii_reg, struct net_device *dev)
+static void mii_discover_phy(uint mii_reg, struct net_device *dev)
 {
 	struct fec_enet_private *fep;
 	volatile fec_t *fecp;
@@ -2107,14 +2084,14 @@ mii_discover_phy(uint mii_reg, struct ne
 		if ((phytype = (mii_reg & 0xffff)) != 0xffff && phytype != 0) {
 
 			/* Got first part of ID, now get remainder.
-			*/
+			 */
 			fep->phy_id = phytype << 16;
 			mii_queue(dev, mk_mii_read(MII_REG_PHYIR2),
-							mii_discover_phy3);
+				  mii_discover_phy3);
 		} else {
 			fep->phy_addr++;
 			mii_queue(dev, mk_mii_read(MII_REG_PHYIR1),
-							mii_discover_phy);
+				  mii_discover_phy);
 		}
 	} else {
 		printk("FEC: No PHY device found.\n");
@@ -2124,33 +2101,23 @@ mii_discover_phy(uint mii_reg, struct ne
 	}
 }
 
-/* This interrupt occurs when the PHY detects a link change.
-*/
-#ifdef CONFIG_RPXCLASSIC
-static void
-mii_link_interrupt(void *dev_id)
-#else
-static irqreturn_t
-mii_link_interrupt(int irq, void * dev_id)
-#endif
+/* Set a MAC change in hardware.
+ */
+static void fec_set_mac_address(struct net_device *dev)
 {
-	struct	net_device *dev = dev_id;
-	struct fec_enet_private *fep = netdev_priv(dev);
-
-	fec_phy_ack_intr();
+	volatile fec_t *fecp;
 
-#if 0
-	disable_irq(fep->mii_irq);  /* disable now, enable later */
-#endif
+	fecp = ((struct fec_enet_private *)netdev_priv(dev))->hwp;
 
-	mii_do_cmd(dev, fep->phy->ack_int);
-	mii_do_cmd(dev, phy_cmd_relink);  /* restart and display status */
+	/* Set station address. */
+	fecp->fec_addr_low = dev->dev_addr[3] | (dev->dev_addr[2] << 8) |
+	    (dev->dev_addr[1] << 16) | (dev->dev_addr[0] << 24);
+	fecp->fec_addr_high = (dev->dev_addr[5] << 16) |
+	    (dev->dev_addr[4] << 24);
 
-	return IRQ_HANDLED;
 }
 
-static int
-fec_enet_open(struct net_device *dev)
+static int fec_enet_open(struct net_device *dev)
 {
 	struct fec_enet_private *fep = netdev_priv(dev);
 
@@ -2165,7 +2132,7 @@ fec_enet_open(struct net_device *dev)
 	if (fep->phy) {
 		mii_do_cmd(dev, fep->phy->ack_int);
 		mii_do_cmd(dev, fep->phy->config);
-		mii_do_cmd(dev, phy_cmd_config);  /* display configuration */
+		mii_do_cmd(dev, phy_cmd_config);	/* display configuration */
 
 		/* Poll until the PHY tells us its configuration
 		 * (not link state).
@@ -2174,7 +2141,7 @@ fec_enet_open(struct net_device *dev)
 		 * This should take about 25 usec per register at 2.5 MHz,
 		 * and we read approximately 5 registers.
 		 */
-		while(!fep->sequence_done)
+		while (!fep->sequence_done)
 			schedule();
 
 		mii_do_cmd(dev, fep->phy->startup);
@@ -2185,7 +2152,7 @@ fec_enet_open(struct net_device *dev)
 		 */
 		fep->link = 1;
 	} else {
-		fep->link = 1; /* lets just try it and see */
+		fep->link = 1;	/* lets just try it and see */
 		/* no phy,  go full duplex,  it's most likely a hub chip */
 		fec_restart(dev, 1);
 	}
@@ -2195,13 +2162,12 @@ fec_enet_open(struct net_device *dev)
 	return 0;		/* Success */
 }
 
-static int
-fec_enet_close(struct net_device *dev)
+static int fec_enet_close(struct net_device *dev)
 {
 	struct fec_enet_private *fep = netdev_priv(dev);
 
 	/* Don't know what to do yet.
-	*/
+	 */
 	fep->opened = 0;
 	netif_stop_queue(dev);
 	fec_stop(dev);
@@ -2219,7 +2185,7 @@ fec_enet_close(struct net_device *dev)
  * this kind of feature?).
  */
 
-#define HASH_BITS	6		/* #bits in hash */
+#define HASH_BITS	6	/* #bits in hash */
 #define CRC32_POLY	0xEDB88320
 
 static void set_multicast_list(struct net_device *dev)
@@ -2233,76 +2199,61 @@ static void set_multicast_list(struct ne
 	fep = netdev_priv(dev);
 	ep = fep->hwp;
 
-	if (dev->flags&IFF_PROMISC) {
+	if (dev->flags & IFF_PROMISC) {
 		ep->fec_r_cntrl |= 0x0008;
-	} else {
+		return ;
+	}
 
-		ep->fec_r_cntrl &= ~0x0008;
+	ep->fec_r_cntrl &= ~0x0008;
 
-		if (dev->flags & IFF_ALLMULTI) {
-			/* Catch all multicast addresses, so set the
-			 * filter to all 1's.
-			 */
-			ep->fec_hash_table_high = 0xffffffff;
-			ep->fec_hash_table_low = 0xffffffff;
-		} else {
-			/* Clear filter and add the addresses in hash register.
-			*/
-			ep->fec_hash_table_high = 0;
-			ep->fec_hash_table_low = 0;
-
-			dmi = dev->mc_list;
-
-			for (j = 0; j < dev->mc_count; j++, dmi = dmi->next)
-			{
-				/* Only support group multicast for now.
-				*/
-				if (!(dmi->dmi_addr[0] & 1))
-					continue;
-
-				/* calculate crc32 value of mac address
-				*/
-				crc = 0xffffffff;
-
-				for (i = 0; i < dmi->dmi_addrlen; i++)
-				{
-					data = dmi->dmi_addr[i];
-					for (bit = 0; bit < 8; bit++, data >>= 1)
-					{
-						crc = (crc >> 1) ^
-						(((crc ^ data) & 1) ? CRC32_POLY : 0);
-					}
-				}
-
-				/* only upper 6 bits (HASH_BITS) are used
-				   which point to specific bit in he hash registers
-				*/
-				hash = (crc >> (32 - HASH_BITS)) & 0x3f;
-
-				if (hash > 31)
-					ep->fec_hash_table_high |= 1 << (hash - 32);
-				else
-					ep->fec_hash_table_low |= 1 << hash;
-			}
-		}
+	if (dev->flags & IFF_ALLMULTI) {
+		/* Catch all multicast addresses, so set the
+		 * filter to all 1's.
+		 */
+		ep->fec_hash_table_high = 0xffffffff;
+		ep->fec_hash_table_low = 0xffffffff;
+		return ;
 	}
-}
+	/*
+	 * Clear filter and add the addresses in hash register.
+	 */
+	ep->fec_hash_table_high = 0;
+	ep->fec_hash_table_low = 0;
 
-/* Set a MAC change in hardware.
- */
-static void
-fec_set_mac_address(struct net_device *dev)
-{
-	volatile fec_t *fecp;
+	dmi = dev->mc_list;
 
-	fecp = ((struct fec_enet_private *)netdev_priv(dev))->hwp;
+	for (j = 0; j < dev->mc_count; j++, dmi = dmi->next) {
+		/* Only support group multicast for now.
+		*/
+		if (!(dmi->dmi_addr[0] & 1))
+			continue;
 
-	/* Set station address. */
-	fecp->fec_addr_low = dev->dev_addr[3] | (dev->dev_addr[2] << 8) |
-		(dev->dev_addr[1] << 16) | (dev->dev_addr[0] << 24);
-	fecp->fec_addr_high = (dev->dev_addr[5] << 16) |
-		(dev->dev_addr[4] << 24);
+		/* calculate crc32 value of mac address
+		*/
+		crc = 0xffffffff;
+
+		for (i = 0; i < dmi->dmi_addrlen; i++) {
+			data = dmi->dmi_addr[i];
+			for (bit = 0; bit < 8;
+					bit++, data >>= 1) {
+				crc =
+					(crc >> 1) ^
+					(((crc ^ data) & 1) ?
+					 CRC32_POLY : 0);
+			}
+		}
 
+		/* only upper 6 bits (HASH_BITS) are used
+		   which point to specific bit in he hash registers
+		   */
+		hash = (crc >> (32 - HASH_BITS)) & 0x3f;
+
+		if (hash > 31)
+			ep->fec_hash_table_high |=
+				1 << (hash - 32);
+		else
+			ep->fec_hash_table_low |= 1 << hash;
+	}
 }
 
 /* Initialize the FEC Ethernet on 860T (or ColdFire 5272).
@@ -2310,38 +2261,40 @@ fec_set_mac_address(struct net_device *d
  /*
   * XXX:  We need to clean up on failure exits here.
   */
+static int index;
 int __init fec_enet_init(struct net_device *dev)
 {
 	struct fec_enet_private *fep = netdev_priv(dev);
-	unsigned long	mem_addr;
-	volatile cbd_t	*bdp;
-	cbd_t		*cbd_base;
-	volatile fec_t	*fecp;
-	int 		i, j;
-	static int	index = 0;
+	unsigned long mem_addr;
+	volatile cbd_t *bdp;
+	cbd_t *cbd_base;
+	volatile fec_t *fecp;
+	int i, j;
 
 	/* Only allow us to be probed once. */
 	if (index >= FEC_MAX_PORTS)
 		return -ENXIO;
 
 	/* Allocate memory for buffer descriptors.
-	*/
+	 */
 	mem_addr = __get_free_page(GFP_KERNEL);
 	if (mem_addr == 0) {
 		printk("FEC: allocate descriptor memory failed?\n");
 		return -ENOMEM;
 	}
 
+	spin_lock_init(&fep->hw_lock);
+	spin_lock_init(&fep->mii_lock);
 	/* Create an Ethernet device instance.
-	*/
-	fecp = (volatile fec_t *) fec_hw[index];
+	 */
+	fecp = (volatile fec_t *)fec_hw[index];
 
 	fep->index = index;
 	fep->hwp = fecp;
 	fep->netdev = dev;
 
 	/* Whack a reset.  We should wait for this.
-	*/
+	 */
 	fecp->fec_ecntrl = 1;
 	udelay(10);
 
@@ -2353,13 +2306,12 @@ int __init fec_enet_init(struct net_devi
 	 */
 	fec_get_mac(dev);
 
-	cbd_base = (cbd_t *)mem_addr;
-	/* XXX: missing check for allocation failure */
+	cbd_base = (cbd_t *) mem_addr;
 
 	fec_uncache(mem_addr);
 
 	/* Set receive and transmit descriptor base.
-	*/
+	 */
 	fep->rx_bd_base = cbd_base;
 	fep->tx_bd_base = cbd_base + RX_RING_SIZE;
 
@@ -2369,20 +2321,20 @@ int __init fec_enet_init(struct net_devi
 	fep->skb_cur = fep->skb_dirty = 0;
 
 	/* Initialize the receive buffer descriptors.
-	*/
+	 */
 	bdp = fep->rx_bd_base;
-	for (i=0; i<FEC_ENET_RX_PAGES; i++) {
+	for (i = 0; i < FEC_ENET_RX_PAGES; i++) {
 
 		/* Allocate a page.
-		*/
+		 */
 		mem_addr = __get_free_page(GFP_KERNEL);
 		/* XXX: missing check for allocation failure */
 
 		fec_uncache(mem_addr);
 
 		/* Initialize the BD for every fragment in the page.
-		*/
-		for (j=0; j<FEC_ENET_RX_FRPPG; j++) {
+		 */
+		for (j = 0; j < FEC_ENET_RX_FRPPG; j++) {
 			bdp->cbd_sc = BD_ENET_RX_EMPTY;
 			bdp->cbd_bufaddr = __pa(mem_addr);
 			mem_addr += FEC_ENET_RX_FRSIZE;
@@ -2391,43 +2343,44 @@ int __init fec_enet_init(struct net_devi
 	}
 
 	/* Set the last buffer to wrap.
-	*/
+	 */
 	bdp--;
 	bdp->cbd_sc |= BD_SC_WRAP;
 
 	/* ...and the same for transmmit.
-	*/
+	 */
 	bdp = fep->tx_bd_base;
-	for (i=0, j=FEC_ENET_TX_FRPPG; i<TX_RING_SIZE; i++) {
+	for (i = 0, j = FEC_ENET_TX_FRPPG; i < TX_RING_SIZE; i++) {
 		if (j >= FEC_ENET_TX_FRPPG) {
+			/* XXX: missing check for allocation failure */
 			mem_addr = __get_free_page(GFP_KERNEL);
 			j = 1;
 		} else {
 			mem_addr += FEC_ENET_TX_FRSIZE;
 			j++;
 		}
-		fep->tx_bounce[i] = (unsigned char *) mem_addr;
+		fep->tx_bounce[i] = (unsigned char *)mem_addr;
 
 		/* Initialize the BD for every fragment in the page.
-		*/
+		 */
 		bdp->cbd_sc = 0;
 		bdp->cbd_bufaddr = 0;
 		bdp++;
 	}
 
 	/* Set the last buffer to wrap.
-	*/
+	 */
 	bdp--;
 	bdp->cbd_sc |= BD_SC_WRAP;
 
 	/* Set receive and transmit descriptor base.
-	*/
-	fecp->fec_r_des_start = __pa((uint)(fep->rx_bd_base));
-	fecp->fec_x_des_start = __pa((uint)(fep->tx_bd_base));
+	 */
+	fecp->fec_r_des_start = __pa((uint) (fep->rx_bd_base));
+	fecp->fec_x_des_start = __pa((uint) (fep->tx_bd_base));
 
 	/* Install our interrupt handlers. This varies depending on
 	 * the architecture.
-	*/
+	 */
 	fec_request_intrs(dev);
 
 	fecp->fec_hash_table_high = 0;
@@ -2446,8 +2399,8 @@ int __init fec_enet_init(struct net_devi
 	dev->stop = fec_enet_close;
 	dev->set_multicast_list = set_multicast_list;
 
-	for (i=0; i<NMII-1; i++)
-		mii_cmds[i].mii_next = &mii_cmds[i+1];
+	for (i = 0; i < NMII - 1; i++)
+		mii_cmds[i].mii_next = &mii_cmds[i + 1];
 	mii_free = mii_cmds;
 
 	/* setup MII interface */
@@ -2455,8 +2408,7 @@ int __init fec_enet_init(struct net_devi
 
 	/* Clear and enable interrupts */
 	fecp->fec_ievent = 0xffc00000;
-	fecp->fec_imask = (FEC_ENET_TXF | FEC_ENET_TXB |
-		FEC_ENET_RXF | FEC_ENET_RXB | FEC_ENET_MII);
+	fecp->fec_imask = (FEC_ENET_TXF | FEC_ENET_RXF | FEC_ENET_MII);
 
 	/* Queue up command to detect the PHY and initialize the
 	 * remainder of the interface.
@@ -2473,8 +2425,7 @@ int __init fec_enet_init(struct net_devi
  * change.  This only happens when switching between half and full
  * duplex.
  */
-static void
-fec_restart(struct net_device *dev, int duplex)
+static void fec_restart(struct net_device *dev, int duplex)
 {
 	struct fec_enet_private *fep;
 	volatile cbd_t *bdp;
@@ -2485,42 +2436,42 @@ fec_restart(struct net_device *dev, int 
 	fecp = fep->hwp;
 
 	/* Whack a reset.  We should wait for this.
-	*/
+	 */
 	fecp->fec_ecntrl = 1;
 	udelay(10);
 
 	/* Clear any outstanding interrupt.
-	*/
+	 */
 	fecp->fec_ievent = 0xffc00000;
 	fec_enable_phy_intr();
 
 	/* Set station address.
-	*/
+	 */
 	fec_set_mac_address(dev);
 
 	/* Reset all multicast.
-	*/
+	 */
 	fecp->fec_hash_table_high = 0;
 	fecp->fec_hash_table_low = 0;
 
 	/* Set maximum receive buffer size.
-	*/
+	 */
 	fecp->fec_r_buff_size = PKT_MAXBLR_SIZE;
 
 	fec_localhw_setup();
 
 	/* Set receive and transmit descriptor base.
-	*/
-	fecp->fec_r_des_start = __pa((uint)(fep->rx_bd_base));
-	fecp->fec_x_des_start = __pa((uint)(fep->tx_bd_base));
+	 */
+	fecp->fec_r_des_start = __pa((uint) (fep->rx_bd_base));
+	fecp->fec_x_des_start = __pa((uint) (fep->tx_bd_base));
 
 	fep->dirty_tx = fep->cur_tx = fep->tx_bd_base;
 	fep->cur_rx = fep->rx_bd_base;
 
 	/* Reset SKB transmit buffers.
-	*/
+	 */
 	fep->skb_cur = fep->skb_dirty = 0;
-	for (i=0; i<=TX_RING_MOD_MASK; i++) {
+	for (i = 0; i <= TX_RING_MOD_MASK; i++) {
 		if (fep->tx_skbuff[i] != NULL) {
 			dev_kfree_skb_any(fep->tx_skbuff[i]);
 			fep->tx_skbuff[i] = NULL;
@@ -2528,43 +2479,43 @@ fec_restart(struct net_device *dev, int 
 	}
 
 	/* Initialize the receive buffer descriptors.
-	*/
+	 */
 	bdp = fep->rx_bd_base;
-	for (i=0; i<RX_RING_SIZE; i++) {
+	for (i = 0; i < RX_RING_SIZE; i++) {
 
 		/* Initialize the BD for every fragment in the page.
-		*/
+		 */
 		bdp->cbd_sc = BD_ENET_RX_EMPTY;
 		bdp++;
 	}
 
 	/* Set the last buffer to wrap.
-	*/
+	 */
 	bdp--;
 	bdp->cbd_sc |= BD_SC_WRAP;
 
 	/* ...and the same for transmmit.
-	*/
+	 */
 	bdp = fep->tx_bd_base;
-	for (i=0; i<TX_RING_SIZE; i++) {
+	for (i = 0; i < TX_RING_SIZE; i++) {
 
 		/* Initialize the BD for every fragment in the page.
-		*/
+		 */
 		bdp->cbd_sc = 0;
 		bdp->cbd_bufaddr = 0;
 		bdp++;
 	}
 
 	/* Set the last buffer to wrap.
-	*/
+	 */
 	bdp--;
 	bdp->cbd_sc |= BD_SC_WRAP;
 
 	/* Enable MII mode.
-	*/
+	 */
 	if (duplex) {
-		fecp->fec_r_cntrl = OPT_FRAME_SIZE | 0x04;/* MII enable */
-		fecp->fec_x_cntrl = 0x04;		  /* FD enable */
+		fecp->fec_r_cntrl = OPT_FRAME_SIZE | 0x04;	/* MII enable */
+		fecp->fec_x_cntrl = 0x04;	/* FD enable */
 	} else {
 		/* MII enable|No Rcv on Xmit */
 		fecp->fec_r_cntrl = OPT_FRAME_SIZE | 0x06;
@@ -2573,22 +2524,20 @@ fec_restart(struct net_device *dev, int 
 	fep->full_duplex = duplex;
 
 	/* Set MII speed.
-	*/
+	 */
 	fecp->fec_mii_speed = fep->phy_speed;
 
 	/* And last, enable the transmit and receive processing.
-	*/
+	 */
 	fecp->fec_ecntrl = 2;
 	fecp->fec_r_des_active = 0;
 
 	/* Enable interrupts we wish to service.
-	*/
-	fecp->fec_imask = (FEC_ENET_TXF | FEC_ENET_TXB |
-		FEC_ENET_RXF | FEC_ENET_RXB | FEC_ENET_MII);
+	 */
+	fecp->fec_imask = (FEC_ENET_TXF | FEC_ENET_RXF | FEC_ENET_MII);
 }
 
-static void
-fec_stop(struct net_device *dev)
+static void fec_stop(struct net_device *dev)
 {
 	volatile fec_t *fecp;
 	struct fec_enet_private *fep;
@@ -2597,23 +2546,23 @@ fec_stop(struct net_device *dev)
 	fecp = fep->hwp;
 
 	/*
-	** We cannot expect a graceful transmit stop without link !!!
-	*/
-	if (fep->link)
-		{
+	 ** We cannot expect a graceful transmit stop without link !!!
+	 */
+	if (fep->link) {
 		fecp->fec_x_cntrl = 0x01;	/* Graceful transmit stop */
 		udelay(10);
 		if (!(fecp->fec_ievent & FEC_ENET_GRA))
-			printk("fec_stop : Graceful transmit stop did not complete !\n");
-		}
+			printk
+			    ("fec_stop : Graceful transmit stop did not complete !\n");
+	}
 
 	/* Whack a reset.  We should wait for this.
-	*/
+	 */
 	fecp->fec_ecntrl = 1;
 	udelay(10);
 
 	/* Clear outstanding MII command interrupts.
-	*/
+	 */
 	fecp->fec_ievent = FEC_ENET_MII;
 	fec_enable_phy_intr();
 
@@ -2624,7 +2573,7 @@ fec_stop(struct net_device *dev)
 static int __init fec_enet_module_init(void)
 {
 	struct net_device *dev;
-	int i, j, err;
+	int i, err;
 	DECLARE_MAC_BUF(mac);
 
 	printk("FEC ENET Version 0.2\n");
@@ -2651,5 +2600,4 @@ static int __init fec_enet_module_init(v
 }
 
 module_init(fec_enet_module_init);
-
 MODULE_LICENSE("GPL");
Index: linux-2.6.24.7-rt27/drivers/serial/68328serial.c
===================================================================
--- linux-2.6.24.7-rt27.orig/drivers/serial/68328serial.c	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/drivers/serial/68328serial.c	2009-02-08 00:00:48.000000000 -0500
@@ -1410,7 +1410,7 @@ rs68328_init(void)
 
 	    if (request_irq(uart_irqs[i],
 			    rs_interrupt,
-			    IRQ_FLG_STD,
+			    IRQF_DISABLED,
 			    "M68328_UART", NULL))
                 panic("Unable to attach 68328 serial interrupt\n");
 	}
Index: linux-2.6.24.7-rt27/drivers/serial/mcf.c
===================================================================
--- linux-2.6.24.7-rt27.orig/drivers/serial/mcf.c	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/drivers/serial/mcf.c	2009-02-08 00:00:48.000000000 -0500
@@ -69,7 +69,7 @@ static unsigned int mcf_tx_empty(struct 
 
 static unsigned int mcf_get_mctrl(struct uart_port *port)
 {
-	struct mcf_uart *pp = (struct mcf_uart *) port;
+	struct mcf_uart *pp = container_of(port, struct mcf_uart, port);
 	unsigned long flags;
 	unsigned int sigs;
 
@@ -87,7 +87,7 @@ static unsigned int mcf_get_mctrl(struct
 
 static void mcf_set_mctrl(struct uart_port *port, unsigned int sigs)
 {
-	struct mcf_uart *pp = (struct mcf_uart *) port;
+	struct mcf_uart *pp = container_of(port, struct mcf_uart, port);
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
@@ -104,7 +104,7 @@ static void mcf_set_mctrl(struct uart_po
 
 static void mcf_start_tx(struct uart_port *port)
 {
-	struct mcf_uart *pp = (struct mcf_uart *) port;
+	struct mcf_uart *pp = container_of(port, struct mcf_uart, port);
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
@@ -117,7 +117,7 @@ static void mcf_start_tx(struct uart_por
 
 static void mcf_stop_tx(struct uart_port *port)
 {
-	struct mcf_uart *pp = (struct mcf_uart *) port;
+	struct mcf_uart *pp = container_of(port, struct mcf_uart, port);
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
@@ -130,7 +130,7 @@ static void mcf_stop_tx(struct uart_port
 
 static void mcf_stop_rx(struct uart_port *port)
 {
-	struct mcf_uart *pp = (struct mcf_uart *) port;
+	struct mcf_uart *pp = container_of(port, struct mcf_uart, port);
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
@@ -163,7 +163,7 @@ static void mcf_enable_ms(struct uart_po
 
 static int mcf_startup(struct uart_port *port)
 {
-	struct mcf_uart *pp = (struct mcf_uart *) port;
+	struct mcf_uart *pp = container_of(port, struct mcf_uart, port);
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
@@ -189,7 +189,7 @@ static int mcf_startup(struct uart_port 
 
 static void mcf_shutdown(struct uart_port *port)
 {
-	struct mcf_uart *pp = (struct mcf_uart *) port;
+	struct mcf_uart *pp = container_of(port, struct mcf_uart, port);
 	unsigned long flags;
 
 	spin_lock_irqsave(&port->lock, flags);
@@ -273,7 +273,7 @@ static void mcf_set_termios(struct uart_
 
 static void mcf_rx_chars(struct mcf_uart *pp)
 {
-	struct uart_port *port = (struct uart_port *) pp;
+	struct uart_port *port = &pp->port;
 	unsigned char status, ch, flag;
 
 	while ((status = readb(port->membase + MCFUART_USR)) & MCFUART_USR_RXREADY) {
@@ -319,7 +319,7 @@ static void mcf_rx_chars(struct mcf_uart
 
 static void mcf_tx_chars(struct mcf_uart *pp)
 {
-	struct uart_port *port = (struct uart_port *) pp;
+	struct uart_port *port = &pp->port;
 	struct circ_buf *xmit = &port->info->xmit;
 
 	if (port->x_char) {
@@ -352,7 +352,7 @@ static void mcf_tx_chars(struct mcf_uart
 static irqreturn_t mcf_interrupt(int irq, void *data)
 {
 	struct uart_port *port = data;
-	struct mcf_uart *pp = (struct mcf_uart *) port;
+	struct mcf_uart *pp = container_of(port, struct mcf_uart, port);
 	unsigned int isr;
 
 	isr = readb(port->membase + MCFUART_UISR) & pp->imr;
@@ -434,7 +434,7 @@ static struct uart_ops mcf_uart_ops = {
 
 static struct mcf_uart mcf_ports[3];
 
-#define	MCF_MAXPORTS	(sizeof(mcf_ports) / sizeof(struct mcf_uart))
+#define	MCF_MAXPORTS	ARRAY_SIZE(mcf_ports)
 
 /****************************************************************************/
 #if defined(CONFIG_SERIAL_MCF_CONSOLE)
Index: linux-2.6.24.7-rt27/drivers/serial/mcfserial.c
===================================================================
--- linux-2.6.24.7-rt27.orig/drivers/serial/mcfserial.c	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/drivers/serial/mcfserial.c	2009-02-08 00:00:48.000000000 -0500
@@ -65,7 +65,8 @@ struct timer_list mcfrs_timer_struct;
 #define CONSOLE_BAUD_RATE 	115200
 #define DEFAULT_CBAUD		B115200
 #elif defined(CONFIG_ARNEWSH) || defined(CONFIG_FREESCALE) || \
-      defined(CONFIG_senTec) || defined(CONFIG_SNEHA) || defined(CONFIG_AVNET)
+      defined(CONFIG_senTec) || defined(CONFIG_SNEHA) || defined(CONFIG_AVNET) || \
+      defined(CONFIG_SAVANT)
 #define	CONSOLE_BAUD_RATE	19200
 #define	DEFAULT_CBAUD		B19200
 #endif
@@ -324,7 +325,7 @@ static void mcfrs_start(struct tty_struc
  * -----------------------------------------------------------------------
  */
 
-static inline void receive_chars(struct mcf_serial *info)
+static noinline void receive_chars(struct mcf_serial *info)
 {
 	volatile unsigned char	*uartp;
 	struct tty_struct	*tty = info->tty;
@@ -369,7 +370,7 @@ static inline void receive_chars(struct 
 	return;
 }
 
-static inline void transmit_chars(struct mcf_serial *info)
+static noinline void transmit_chars(struct mcf_serial *info)
 {
 	volatile unsigned char	*uartp;
 
@@ -1489,14 +1490,28 @@ int mcfrs_open(struct tty_struct *tty, s
 /*
  *	Based on the line number set up the internal interrupt stuff.
  */
-static void mcfrs_irqinit(struct mcf_serial *info)
+static int mcfrs_irqinit(struct mcf_serial *info)
 {
+	volatile unsigned char *uartp;
+	int ret;
+
+	uartp = info->addr;
+	/* Clear mask, so no surprise interrupts. */
+	uartp[MCFUART_UIMR] = 0;
+
+	ret = request_irq(info->irq, mcfrs_interrupt, IRQF_DISABLED,
+			"ColdFire UART", NULL);
+	if (ret) {
+		printk("MCFRS: Unable to attach ColdFire UART %d interrupt "
+				"vector=%d, error: %d\n", info->line,
+				info->irq, ret);
+		return ret;
+	}
+
 #if defined(CONFIG_M5272)
 	volatile unsigned long	*icrp;
 	volatile unsigned long	*portp;
-	volatile unsigned char	*uartp;
 
-	uartp = info->addr;
 	icrp = (volatile unsigned long *) (MCF_MBAR + MCFSIM_ICR2);
 
 	switch (info->line) {
@@ -1518,11 +1533,10 @@ static void mcfrs_irqinit(struct mcf_ser
 	portp = (volatile unsigned long *) (MCF_MBAR + MCFSIM_PDCNT);
 	*portp = (*portp & ~0x000003fc) | 0x000002a8;
 #elif defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x)
-	volatile unsigned char *icrp, *uartp;
+#if !defined(CONFIG_M523x)
+	volatile unsigned char *icrp;
 	volatile unsigned long *imrp;
 
-	uartp = info->addr;
-
 	icrp = (volatile unsigned char *) (MCF_MBAR + MCFICM_INTC0 +
 		MCFINTC_ICR0 + MCFINT_UART0 + info->line);
 	*icrp = 0x30 + info->line; /* level 6, line based priority */
@@ -1530,6 +1544,14 @@ static void mcfrs_irqinit(struct mcf_ser
 	imrp = (volatile unsigned long *) (MCF_MBAR + MCFICM_INTC0 +
 		MCFINTC_IMRL);
 	*imrp &= ~((1 << (info->irq - MCFINT_VECBASE)) | 1);
+#endif
+#if defined(CONFIG_M523x)
+	{
+		volatile unsigned short *par_uartp;
+		par_uartp = (volatile unsigned short *) (MCF_MBAR + MCF523x_GPIO_PAR_UART);
+		*par_uartp = 0x3FFF; /* setup GPIO for UART0, UART1 & UART2 */
+	}
+#endif
 #if defined(CONFIG_M527x)
 	{
 		/*
@@ -1554,37 +1576,38 @@ static void mcfrs_irqinit(struct mcf_ser
 	}
 #endif
 #elif defined(CONFIG_M520x)
-	volatile unsigned char *icrp, *uartp;
-	volatile unsigned long *imrp;
-
-	uartp = info->addr;
-
-	icrp = (volatile unsigned char *) (MCF_MBAR + MCFICM_INTC0 +
-		MCFINTC_ICR0 + MCFINT_UART0 + info->line);
-	*icrp = 0x03;
+	{
+		volatile unsigned char *icrp;
+		volatile unsigned long *imrp;
 
-	imrp = (volatile unsigned long *) (MCF_MBAR + MCFICM_INTC0 +
-		MCFINTC_IMRL);
-	*imrp &= ~((1 << (info->irq - MCFINT_VECBASE)) | 1);
-	if (info->line < 2) {
-		unsigned short *uart_par;
-		uart_par = (unsigned short *)(MCF_IPSBAR + MCF_GPIO_PAR_UART);
-		if (info->line == 0)
-			*uart_par |=  MCF_GPIO_PAR_UART_PAR_UTXD0
-				  | MCF_GPIO_PAR_UART_PAR_URXD0;
-		else if (info->line == 1)
-			*uart_par |=  MCF_GPIO_PAR_UART_PAR_UTXD1
-				  | MCF_GPIO_PAR_UART_PAR_URXD1;
+		icrp = (volatile unsigned char *) (MCF_MBAR + MCFICM_INTC0 +
+				MCFINTC_ICR0 + MCFINT_UART0 + info->line);
+		*icrp = 0x03;
+
+		imrp = (volatile unsigned long *) (MCF_MBAR + MCFICM_INTC0 +
+				MCFINTC_IMRL);
+		*imrp &= ~((1 << (info->irq - MCFINT_VECBASE)) | 1);
+		if (info->line < 2) {
+			unsigned short *uart_par;
+			uart_par = (unsigned short *)(MCF_IPSBAR +
+					MCF_GPIO_PAR_UART);
+			if (info->line == 0)
+				*uart_par |=  MCF_GPIO_PAR_UART_PAR_UTXD0
+					| MCF_GPIO_PAR_UART_PAR_URXD0;
+			else if (info->line == 1)
+				*uart_par |=  MCF_GPIO_PAR_UART_PAR_UTXD1
+					| MCF_GPIO_PAR_UART_PAR_URXD1;
 		} else if (info->line == 2) {
 			unsigned char *feci2c_par;
-			feci2c_par = (unsigned char *)(MCF_IPSBAR +  MCF_GPIO_PAR_FECI2C);
+			feci2c_par = (unsigned char *)(MCF_IPSBAR +
+					MCF_GPIO_PAR_FECI2C);
 			*feci2c_par &= ~0x0F;
 			*feci2c_par |=  MCF_GPIO_PAR_FECI2C_PAR_SCL_UTXD2
-				    | MCF_GPIO_PAR_FECI2C_PAR_SDA_URXD2;
+				| MCF_GPIO_PAR_FECI2C_PAR_SDA_URXD2;
 		}
+	}
 #elif defined(CONFIG_M532x)
-	volatile unsigned char *uartp;
-	uartp = info->addr;
+
 	switch (info->line) {
 	case 0:
 		MCF_INTC0_ICR26 = 0x3;
@@ -1605,7 +1628,6 @@ static void mcfrs_irqinit(struct mcf_ser
 		break;
 	}
 #else
-	volatile unsigned char	*icrp, *uartp;
 
 	switch (info->line) {
 	case 0:
@@ -1623,23 +1645,12 @@ static void mcfrs_irqinit(struct mcf_ser
 	default:
 		printk("MCFRS: don't know how to handle UART %d interrupt?\n",
 			info->line);
-		return;
+		return -ENODEV;
 	}
 
-	uartp = info->addr;
 	uartp[MCFUART_UIVR] = info->irq;
 #endif
-
-	/* Clear mask, so no surprise interrupts. */
-	uartp[MCFUART_UIMR] = 0;
-
-	if (request_irq(info->irq, mcfrs_interrupt, IRQF_DISABLED,
-	    "ColdFire UART", NULL)) {
-		printk("MCFRS: Unable to attach ColdFire UART %d interrupt "
-			"vector=%d\n", info->line, info->irq);
-	}
-
-	return;
+	return 0;
 }
 
 
@@ -1729,7 +1740,6 @@ static int __init
 mcfrs_init(void)
 {
 	struct mcf_serial	*info;
-	unsigned long		flags;
 	int			i;
 
 	/* Setup base handler, and timer table. */
@@ -1769,12 +1779,12 @@ mcfrs_init(void)
 		return(-EBUSY);
 	}
 
-	local_irq_save(flags);
-
 	/*
 	 *	Configure all the attached serial ports.
 	 */
 	for (i = 0, info = mcfrs_table; (i < NR_PORTS); i++, info++) {
+		int ret;
+
 		info->magic = SERIAL_MAGIC;
 		info->line = i;
 		info->tty = 0;
@@ -1792,14 +1802,11 @@ mcfrs_init(void)
 
 		info->imr = 0;
 		mcfrs_setsignals(info, 0, 0);
-		mcfrs_irqinit(info);
-
-		printk("ttyS%d at 0x%04x (irq = %d)", info->line,
-			(unsigned int) info->addr, info->irq);
-		printk(" is a builtin ColdFire UART\n");
+		ret = mcfrs_irqinit(info);
+		if (!ret)
+			printk("ttyS%d at 0x%p (irq = %d) is a builtin "
+			"ColdFire UART\n", info->line, info->addr, info->irq);
 	}
-
-	local_irq_restore(flags);
 	return 0;
 }
 
Index: linux-2.6.24.7-rt27/fs/nfs/file.c
===================================================================
--- linux-2.6.24.7-rt27.orig/fs/nfs/file.c	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/fs/nfs/file.c	2009-02-08 00:00:48.000000000 -0500
@@ -64,7 +64,11 @@ const struct file_operations nfs_file_op
 	.write		= do_sync_write,
 	.aio_read	= nfs_file_read,
 	.aio_write	= nfs_file_write,
+#ifdef CONFIG_MMU
 	.mmap		= nfs_file_mmap,
+#else
+	.mmap		= generic_file_mmap,
+#endif
 	.open		= nfs_file_open,
 	.flush		= nfs_file_flush,
 	.release	= nfs_file_release,
Index: linux-2.6.24.7-rt27/include/asm-generic/vmlinux.lds.h
===================================================================
--- linux-2.6.24.7-rt27.orig/include/asm-generic/vmlinux.lds.h	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/include/asm-generic/vmlinux.lds.h	2009-02-08 00:00:48.000000000 -0500
@@ -6,6 +6,10 @@
 #define VMLINUX_SYMBOL(_sym_) _sym_
 #endif
 
+#ifndef OUTPUT_DATA_SECTION
+#define OUTPUT_DATA_SECTION
+#endif
+
 /* Align . to a 8 byte boundary equals to maximum function alignment. */
 #define ALIGN_FUNCTION()  . = ALIGN(8)
 
@@ -25,11 +29,11 @@
 		*(.rodata) *(.rodata.*)					\
 		*(__vermagic)		/* Kernel version magic */	\
 		*(__markers_strings)	/* Markers: strings */		\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	.rodata1          : AT(ADDR(.rodata1) - LOAD_OFFSET) {		\
 		*(.rodata1)						\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* PCI quirks */						\
 	.pci_fixup        : AT(ADDR(.pci_fixup) - LOAD_OFFSET) {	\
@@ -48,89 +52,89 @@
 		VMLINUX_SYMBOL(__start_pci_fixups_resume) = .;		\
 		*(.pci_fixup_resume)					\
 		VMLINUX_SYMBOL(__end_pci_fixups_resume) = .;		\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* RapidIO route ops */						\
 	.rio_route        : AT(ADDR(.rio_route) - LOAD_OFFSET) {	\
 		VMLINUX_SYMBOL(__start_rio_route_ops) = .;		\
 		*(.rio_route_ops)					\
 		VMLINUX_SYMBOL(__end_rio_route_ops) = .;		\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* Kernel symbol table: Normal symbols */			\
 	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
 		VMLINUX_SYMBOL(__start___ksymtab) = .;			\
 		*(__ksymtab)						\
 		VMLINUX_SYMBOL(__stop___ksymtab) = .;			\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* Kernel symbol table: GPL-only symbols */			\
 	__ksymtab_gpl     : AT(ADDR(__ksymtab_gpl) - LOAD_OFFSET) {	\
 		VMLINUX_SYMBOL(__start___ksymtab_gpl) = .;		\
 		*(__ksymtab_gpl)					\
 		VMLINUX_SYMBOL(__stop___ksymtab_gpl) = .;		\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* Kernel symbol table: Normal unused symbols */		\
 	__ksymtab_unused  : AT(ADDR(__ksymtab_unused) - LOAD_OFFSET) {	\
 		VMLINUX_SYMBOL(__start___ksymtab_unused) = .;		\
 		*(__ksymtab_unused)					\
 		VMLINUX_SYMBOL(__stop___ksymtab_unused) = .;		\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* Kernel symbol table: GPL-only unused symbols */		\
 	__ksymtab_unused_gpl : AT(ADDR(__ksymtab_unused_gpl) - LOAD_OFFSET) { \
 		VMLINUX_SYMBOL(__start___ksymtab_unused_gpl) = .;	\
 		*(__ksymtab_unused_gpl)					\
 		VMLINUX_SYMBOL(__stop___ksymtab_unused_gpl) = .;	\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* Kernel symbol table: GPL-future-only symbols */		\
 	__ksymtab_gpl_future : AT(ADDR(__ksymtab_gpl_future) - LOAD_OFFSET) { \
 		VMLINUX_SYMBOL(__start___ksymtab_gpl_future) = .;	\
 		*(__ksymtab_gpl_future)					\
 		VMLINUX_SYMBOL(__stop___ksymtab_gpl_future) = .;	\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* Kernel symbol table: Normal symbols */			\
 	__kcrctab         : AT(ADDR(__kcrctab) - LOAD_OFFSET) {		\
 		VMLINUX_SYMBOL(__start___kcrctab) = .;			\
 		*(__kcrctab)						\
 		VMLINUX_SYMBOL(__stop___kcrctab) = .;			\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* Kernel symbol table: GPL-only symbols */			\
 	__kcrctab_gpl     : AT(ADDR(__kcrctab_gpl) - LOAD_OFFSET) {	\
 		VMLINUX_SYMBOL(__start___kcrctab_gpl) = .;		\
 		*(__kcrctab_gpl)					\
 		VMLINUX_SYMBOL(__stop___kcrctab_gpl) = .;		\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* Kernel symbol table: Normal unused symbols */		\
 	__kcrctab_unused  : AT(ADDR(__kcrctab_unused) - LOAD_OFFSET) {	\
 		VMLINUX_SYMBOL(__start___kcrctab_unused) = .;		\
 		*(__kcrctab_unused)					\
 		VMLINUX_SYMBOL(__stop___kcrctab_unused) = .;		\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* Kernel symbol table: GPL-only unused symbols */		\
 	__kcrctab_unused_gpl : AT(ADDR(__kcrctab_unused_gpl) - LOAD_OFFSET) { \
 		VMLINUX_SYMBOL(__start___kcrctab_unused_gpl) = .;	\
 		*(__kcrctab_unused_gpl)					\
 		VMLINUX_SYMBOL(__stop___kcrctab_unused_gpl) = .;	\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* Kernel symbol table: GPL-future-only symbols */		\
 	__kcrctab_gpl_future : AT(ADDR(__kcrctab_gpl_future) - LOAD_OFFSET) { \
 		VMLINUX_SYMBOL(__start___kcrctab_gpl_future) = .;	\
 		*(__kcrctab_gpl_future)					\
 		VMLINUX_SYMBOL(__stop___kcrctab_gpl_future) = .;	\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* Kernel symbol table: strings */				\
         __ksymtab_strings : AT(ADDR(__ksymtab_strings) - LOAD_OFFSET) {	\
 		*(__ksymtab_strings)					\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	/* Built-in module parameters. */				\
 	__param : AT(ADDR(__param) - LOAD_OFFSET) {			\
@@ -138,7 +142,7 @@
 		*(__param)						\
 		VMLINUX_SYMBOL(__stop___param) = .;			\
 		VMLINUX_SYMBOL(__end_rodata) = .;			\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 									\
 	. = ALIGN((align));
 
@@ -227,7 +231,7 @@
 		__start___bug_table = .;				\
 		*(__bug_table)						\
 		__stop___bug_table = .;					\
-	}
+	} OUTPUT_DATA_SECTION
 
 #define NOTES								\
 	.notes : AT(ADDR(.notes) - LOAD_OFFSET) {			\
@@ -261,5 +265,5 @@
 	.data.percpu  : AT(ADDR(.data.percpu) - LOAD_OFFSET) {		\
 		*(.data.percpu)						\
 		*(.data.percpu.shared_aligned)				\
-	}								\
+	} OUTPUT_DATA_SECTION						\
 	__per_cpu_end = .;
Index: linux-2.6.24.7-rt27/include/asm-m68knommu/bitops.h
===================================================================
--- linux-2.6.24.7-rt27.orig/include/asm-m68knommu/bitops.h	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/include/asm-m68knommu/bitops.h	2009-02-08 00:00:48.000000000 -0500
@@ -14,8 +14,38 @@
 #error only <linux/bitops.h> can be included directly
 #endif
 
+#if defined (__mcfisaaplus__) || defined (__mcfisac__)
+static inline int ffs(unsigned int val)
+{
+        if (!val)
+                return 0;
+
+        asm volatile(
+                        "bitrev %0\n\t"
+                        "ff1 %0\n\t"
+                        : "=d" (val)
+                        : "0" (val)
+		    );
+        val++;
+        return val;
+}
+
+static inline int __ffs(unsigned int val)
+{
+        asm volatile(
+                        "bitrev %0\n\t"
+                        "ff1 %0\n\t"
+                        : "=d" (val)
+                        : "0" (val)
+		    );
+        return val;
+}
+
+#else
 #include <asm-generic/bitops/ffs.h>
 #include <asm-generic/bitops/__ffs.h>
+#endif
+
 #include <asm-generic/bitops/sched.h>
 #include <asm-generic/bitops/ffz.h>
 
Index: linux-2.6.24.7-rt27/include/asm-m68knommu/byteorder.h
===================================================================
--- linux-2.6.24.7-rt27.orig/include/asm-m68knommu/byteorder.h	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/include/asm-m68knommu/byteorder.h	2009-02-08 00:00:48.000000000 -0500
@@ -1,13 +1,27 @@
 #ifndef _M68KNOMMU_BYTEORDER_H
 #define _M68KNOMMU_BYTEORDER_H
 
-#include <asm/types.h>
+#include <linux/types.h>
 
 #if defined(__GNUC__) && !defined(__STRICT_ANSI__) || defined(__KERNEL__)
 #  define __BYTEORDER_HAS_U64__
 #  define __SWAB_64_THRU_32__
 #endif
 
+#if defined (__mcfisaaplus__) || defined (__mcfisac__)
+static inline __attribute_const__ __u32 ___arch__swab32(__u32 val)
+{
+	asm(
+			"byterev %0"
+			: "=d" (val)
+			: "0" (val)
+	   );
+	return val;
+}
+
+#define __arch__swab32(x) ___arch__swab32(x)
+#endif
+
 #include <linux/byteorder/big_endian.h>
 
 #endif /* _M68KNOMMU_BYTEORDER_H */
Index: linux-2.6.24.7-rt27/include/asm-m68knommu/cacheflush.h
===================================================================
--- linux-2.6.24.7-rt27.orig/include/asm-m68knommu/cacheflush.h	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/include/asm-m68knommu/cacheflush.h	2009-02-08 00:00:48.000000000 -0500
@@ -53,7 +53,7 @@ static inline void __flush_cache_all(voi
 #endif /* CONFIG_M5407 */
 #if defined(CONFIG_M527x) || defined(CONFIG_M528x)
 	__asm__ __volatile__ (
-        	"movel	#0x81400100, %%d0\n\t"
+        	"movel	#0x81000200, %%d0\n\t"
         	"movec	%%d0, %%CACR\n\t"
 		"nop\n\t"
 		: : : "d0" );
Index: linux-2.6.24.7-rt27/include/asm-m68knommu/commproc.h
===================================================================
--- linux-2.6.24.7-rt27.orig/include/asm-m68knommu/commproc.h	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/include/asm-m68knommu/commproc.h	2009-02-08 00:00:48.000000000 -0500
@@ -519,25 +519,6 @@ typedef struct scc_enet {
 #define SICR_ENET_CLKRT	((uint)0x00002c00)
 #endif
 
-#ifdef CONFIG_RPXCLASSIC
-/* Bits in parallel I/O port registers that have to be set/cleared
- * to configure the pins for SCC1 use.
- */
-#define PA_ENET_RXD	((ushort)0x0001)
-#define PA_ENET_TXD	((ushort)0x0002)
-#define PA_ENET_TCLK	((ushort)0x0200)
-#define PA_ENET_RCLK	((ushort)0x0800)
-#define PB_ENET_TENA	((uint)0x00001000)
-#define PC_ENET_CLSN	((ushort)0x0010)
-#define PC_ENET_RENA	((ushort)0x0020)
-
-/* Control bits in the SICR to route TCLK (CLK2) and RCLK (CLK4) to
- * SCC1.  Also, make sure GR1 (bit 24) and SC1 (bit 25) are zero.
- */
-#define SICR_ENET_MASK	((uint)0x000000ff)
-#define SICR_ENET_CLKRT	((uint)0x0000003d)
-#endif
-
 /* SCC Event register as used by Ethernet.
 */
 #define SCCE_ENET_GRA	((ushort)0x0080)	/* Graceful stop complete */
Index: linux-2.6.24.7-rt27/include/asm-m68knommu/dma.h
===================================================================
--- linux-2.6.24.7-rt27.orig/include/asm-m68knommu/dma.h	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/include/asm-m68knommu/dma.h	2009-02-08 00:00:48.000000000 -0500
@@ -35,7 +35,8 @@
 /*
  * Set number of channels of DMA on ColdFire for different implementations.
  */
-#if defined(CONFIG_M5249) || defined(CONFIG_M5307) || defined(CONFIG_M5407)
+#if defined(CONFIG_M5249) || defined(CONFIG_M5307) || defined(CONFIG_M5407) || \
+	defined(CONFIG_M523x) || defined(CONFIG_M527x) || defined(CONFIG_M528x)
 #define MAX_M68K_DMA_CHANNELS 4
 #elif defined(CONFIG_M5272)
 #define MAX_M68K_DMA_CHANNELS 1
Index: linux-2.6.24.7-rt27/include/asm-m68knommu/m523xsim.h
===================================================================
--- linux-2.6.24.7-rt27.orig/include/asm-m68knommu/m523xsim.h	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/include/asm-m68knommu/m523xsim.h	2009-02-08 00:00:48.000000000 -0500
@@ -11,7 +11,6 @@
 #define	m523xsim_h
 /****************************************************************************/
 
-
 /*
  *	Define the 523x SIM register set addresses.
  */
@@ -27,10 +26,35 @@
 #define	MCFINTC_IACKL		0x19		/* */
 #define	MCFINTC_ICR0		0x40		/* Base ICR register */
 
+/* INTC0 - interrupt numbers */
 #define	MCFINT_VECBASE		64		/* Vector base number */
-#define	MCFINT_UART0		13		/* Interrupt number for UART0 */
-#define	MCFINT_PIT1		36		/* Interrupt number for PIT1 */
-#define MCFINT_QSPI		18		/* Interrupt number for QSPI */
+#define	MCFINT_EPF4		4		/* EPORT4 */
+#define	MCFINT_EPF5		5		/* EPORT5 */
+#define	MCFINT_EPF6		6		/* EPORT6 */
+#define	MCFINT_EPF7		7		/* EPORT7 */
+#define	MCFINT_UART0		13		/* UART0 */
+#define	MCFINT_QSPI		18		/* QSPI */
+#define	MCFINT_PIT1		36		/* PIT1 */
+#define	MCFINT_PER_INTC		64
+
+/* INTC1 - interrupt numbers */
+#define	MCFINT_INTC1_VECBASE	(MCFINT_VECBASE + MCFINT_PER_INTC)
+#define	MCFINT_TC0F		27		/* eTPU Channel 0 */
+#define	MCFINT_TC1F		28		/* eTPU Channel 1 */
+#define	MCFINT_TC2F		29		/* eTPU Channel 2 */
+#define	MCFINT_TC3F		30		/* eTPU Channel 3 */
+#define	MCFINT_TC4F		31		/* eTPU Channel 4 */
+#define	MCFINT_TC5F		32		/* eTPU Channel 5 */
+#define	MCFINT_TC6F		33		/* eTPU Channel 6 */
+#define	MCFINT_TC7F		34		/* eTPU Channel 7 */
+#define	MCFINT_TC8F		35		/* eTPU Channel 8 */
+#define	MCFINT_TC9F		36		/* eTPU Channel 9 */
+#define	MCFINT_TC10F		37		/* eTPU Channel 10 */
+#define	MCFINT_TC11F		38		/* eTPU Channel 11 */
+#define	MCFINT_TC12F		39		/* eTPU Channel 12 */
+#define	MCFINT_TC13F		40		/* eTPU Channel 13 */
+#define	MCFINT_TC14F		41		/* eTPU Channel 14 */
+#define	MCFINT_TC15F		42		/* eTPU Channel 15 */
 
 /*
  *	SDRAM configuration registers.
@@ -41,5 +65,120 @@
 #define	MCFSIM_DACR1		0x50		/* SDRAM base address 1 */
 #define	MCFSIM_DMR1		0x54		/* SDRAM address mask 1 */
 
+/*
+ *	GPIO Registers and Pin Assignments
+ */
+#define	MCF_GPIO_PAR_FECI2C		0x100047 /* FEC Pin Assignment reg */
+#define	MCF523x_GPIO_PAR_UART		0x100048 /* UART Pin Assignment reg */
+#define	MCF523x_GPIO_PAR_QSPI		0x10004a /* QSPI Pin Assignment reg */
+#define	MCF523x_GPIO_PAR_TIMER		0x10004c /* TIMER Pin Assignment reg */
+#define	MCF523x_GPIO_PDDR_QSPI		0x10001a /* QSPI Pin Direction reg */
+#define	MCF523x_GPIO_PDDR_TIMER		0x10001b /* TIMER Pin Direction reg */
+#define	MCF523x_GPIO_PPDSDR_QSPI	0x10002a /* QSPI Pin Data reg */
+#define	MCF523x_GPIO_PPDSDR_TIMER	0x10002b /* TIMER Pin Data reg */
+
+#define	MCF_GPIO_PAR_FECI2C_PAR_SDA(x)	(((x) & 0x03) << 0)
+#define	MCF_GPIO_PAR_FECI2C_PAR_SCL(x)	(((x) & 0x03) << 2)
+
+/*
+ *	eTPU Registers
+ */
+#define	MCF523x_ETPU		0x1d0000	/* eTPU Base */
+#define	MCF523x_ETPU_CIOSR	0x00220		/* eTPU Intr Overflow Status */
+#define	MCF523x_ETPU_CIER	0x00240		/* eTPU Intr Enable */
+#define	MCF523x_ETPU_CR(c)	(0x00400 + ((c) * 0x10)) /* eTPU c Config */
+#define	MCF523x_ETPU_SCR(c)	(0x00404 + ((c) * 0x10)) /* eTPU c Status & Ctrl */
+#define	MCF523x_ETPU_SDM	0x08000		/* eTPU Shared Data Memory */
+
+/*
+ *	WDOG registers
+ */
+#define	MCF523x_WCR		((volatile uint16_t *) (MCF_IPSBAR + 0x140000)) /* control register 16 bits */
+#define	MCF523x_WMR		((volatile uint16_t *) (MCF_IPSBAR + 0x140002)) /* modulus status 16 bits */
+#define	MCF523x_MCNTR		((volatile uint16_t *) (MCF_IPSBAR + 0x140004)) /* count register 16 bits */
+#define	MCF523x_WSR		((volatile uint16_t *) (MCF_IPSBAR + 0x140006)) /* service register 16 bits */
+
+/*
+ *	Reset registers
+ */
+#define	MCF523x_RSR		((volatile uint8_t *) (MCF_IPSBAR + 0x110001)) /* reset reason codes */
+
+/*
+ *	WDOG bit level definitions and macros.
+ */
+#define	MCF523x_WCR_ENABLE_BIT	0x0001
+
+#define	MCF523x_WCR_ENABLE	0x0001
+#define	MCF523x_WCR_DISABLE	0x0000
+#define	MCF523x_WCR_HALTEDSTOP	0x0002
+#define	MCF523x_WCR_HALTEDRUN	0x0000
+#define	MCF523x_WCR_DOZESTOP	0x0004
+#define	MCF523x_WCR_DOZERUN	0x0000
+#define	MCF523x_WCR_WAITSTOP	0x0008
+#define	MCF523x_WCR_WAITRUN	0x0000
+
+#define	MCF523x_WMR_DEFAULT_VALUE	0xffff
+
+/*
+ *	Inter-IC (I2C) Module
+ *	Read/Write access macros for general use
+ */
+#define	MCF_I2C_I2ADR		((volatile u8 *) (MCF_IPSBAR + 0x0300)) /* Address */
+#define	MCF_I2C_I2FDR		((volatile u8 *) (MCF_IPSBAR + 0x0304)) /* Freq Divider */
+#define	MCF_I2C_I2CR		((volatile u8 *) (MCF_IPSBAR + 0x0308)) /* Control */
+#define	MCF_I2C_I2SR		((volatile u8 *) (MCF_IPSBAR + 0x030C)) /* Status */
+#define	MCF_I2C_I2DR		((volatile u8 *) (MCF_IPSBAR + 0x0310)) /* Data I/O */
+
+/*
+ *	Bit level definitions and macros
+ */
+#define	MCF_I2C_I2ADR_ADDR(x)	(((x) & 0x7F) << 0x01)
+#define	MCF_I2C_I2FDR_IC(x)	((x) & 0x3F)
+
+#define	MCF_I2C_I2CR_IEN	0x80	/* I2C enable */
+#define	MCF_I2C_I2CR_IIEN	0x40	/* interrupt enable */
+#define	MCF_I2C_I2CR_MSTA	0x20	/* master/slave mode */
+#define	MCF_I2C_I2CR_MTX	0x10	/* transmit/receive mode */
+#define	MCF_I2C_I2CR_TXAK	0x08	/* transmit acknowledge enable */
+#define	MCF_I2C_I2CR_RSTA	0x04	/* repeat start */
+
+#define	MCF_I2C_I2SR_ICF	0x80	/* data transfer bit */
+#define	MCF_I2C_I2SR_IAAS	0x40	/* I2C addressed as a slave */
+#define	MCF_I2C_I2SR_IBB	0x20	/* I2C bus busy */
+#define	MCF_I2C_I2SR_IAL	0x10	/* aribitration lost */
+#define	MCF_I2C_I2SR_SRW	0x04	/* slave read/write */
+#define	MCF_I2C_I2SR_IIF	0x02	/* I2C interrupt */
+#define	MCF_I2C_I2SR_RXAK	0x01	/* received acknowledge */
+
+/*
+ *	Edge Port (EPORT) Module
+ */
+#define	MCF523x_EPPAR		0x130000
+#define	MCF523x_EPDDR		0x130002
+#define	MCF523x_EPIER		0x130003
+#define	MCF523x_EPDR		0x130004
+#define	MCF523x_EPPDR		0x130005
+#define	MCF523x_EPFR		0x130006
+
+/*
+ *	Chip Select (CS) Module
+ */
+#define	MCF523x_CSAR0		0x80
+#define	MCF523x_CSAR3		0xA4
+#define	MCF523x_CSMR3		0xA8
+
+/*
+ *	System Access Control Unit (SACU)
+ */
+#define	MCF523x_PACR1		0x25
+#define	MCF523x_PACR2		0x26
+#define	MCF523x_PACR3		0x27
+#define	MCF523x_PACR4		0x28
+#define	MCF523x_PACR5		0x2A
+#define	MCF523x_PACR6		0x2B
+#define	MCF523x_PACR7		0x2C
+#define	MCF523x_PACR8		0x2E
+#define	MCF523x_GPACR		0x30
+
 /****************************************************************************/
 #endif	/* m523xsim_h */
Index: linux-2.6.24.7-rt27/include/asm-m68knommu/m528xsim.h
===================================================================
--- linux-2.6.24.7-rt27.orig/include/asm-m68knommu/m528xsim.h	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/include/asm-m68knommu/m528xsim.h	2009-02-08 00:00:48.000000000 -0500
@@ -30,6 +30,9 @@
 #define	MCFINT_VECBASE		64		/* Vector base number */
 #define	MCFINT_UART0		13		/* Interrupt number for UART0 */
 #define	MCFINT_PIT1		55		/* Interrupt number for PIT1 */
+#define	MCFINT_QSPI		18		/* Interrupt number for QSPI */
+
+#define	MCF5282_INTC0		(MCF_IPSBAR + MCFICM_INTC0)
 
 /*
  *	SDRAM configuration registers.
@@ -50,44 +53,53 @@
 /* Port UA Pin Assignment Register (8 Bit) */
 #define MCF5282_GPIO_PUAPAR	0x10005C
 
+#define MCF5282_GPIO_PORTQS     (*(volatile u8 *)  (MCF_IPSBAR + 0x0010000D))
+#define MCF5282_GPIO_DDRQS      (*(volatile u8 *)  (MCF_IPSBAR + 0x00100021))
+#define MCF5282_GPIO_PORTQSP    (*(volatile u8 *)  (MCF_IPSBAR + 0x00100035))
+#define MCF5282_GPIO_PQSPAR     (*(volatile u8 *)  (MCF_IPSBAR + 0x00100059))
+
+#define MCF5282_GPIO_PEPAR      (*(volatile u16 *) (MCF_IPSBAR + 0x00100052))
+
+#define MCF5282_GPIO_PORTE      (*(volatile u8 *)  (MCF_IPSBAR + 0x00100004))
+#define MCF5282_GPIO_DDRE       (*(volatile u8 *)  (MCF_IPSBAR + 0x00100018))
+#define MCF5282_GPIO_PORTEP     (*(volatile u8 *)  (MCF_IPSBAR + 0x0010002C))
+
 /* Interrupt Mask Register Register Low */ 
 #define MCF5282_INTC0_IMRL      (volatile u32 *) (MCF_IPSBAR + 0x0C0C)
 /* Interrupt Control Register 7 */
 #define MCF5282_INTC0_ICR17     (volatile u8 *) (MCF_IPSBAR + 0x0C51)
 
-
-
 /*********************************************************************
 *
 * Inter-IC (I2C) Module
 *
 *********************************************************************/
 /* Read/Write access macros for general use */
-#define MCF5282_I2C_I2ADR       (volatile u8 *) (MCF_IPSBAR + 0x0300) // Address 
-#define MCF5282_I2C_I2FDR       (volatile u8 *) (MCF_IPSBAR + 0x0304) // Freq Divider
-#define MCF5282_I2C_I2CR        (volatile u8 *) (MCF_IPSBAR + 0x0308) // Control
-#define MCF5282_I2C_I2SR        (volatile u8 *) (MCF_IPSBAR + 0x030C) // Status
-#define MCF5282_I2C_I2DR        (volatile u8 *) (MCF_IPSBAR + 0x0310) // Data I/O
+#define MCF_I2C_I2ADR       (volatile u8 *) (MCF_IPSBAR + 0x0300) // Address
+#define MCF_I2C_I2FDR       (volatile u8 *) (MCF_IPSBAR + 0x0304) // Freq Divider
+#define MCF_I2C_I2CR        (volatile u8 *) (MCF_IPSBAR + 0x0308) // Control
+#define MCF_I2C_I2SR        (volatile u8 *) (MCF_IPSBAR + 0x030C) // Status
+#define MCF_I2C_I2DR        (volatile u8 *) (MCF_IPSBAR + 0x0310) // Data I/O
 
 /* Bit level definitions and macros */
-#define MCF5282_I2C_I2ADR_ADDR(x)                       (((x)&0x7F)<<0x01)
+#define MCF_I2C_I2ADR_ADDR(x)                       (((x)&0x7F)<<0x01)
 
-#define MCF5282_I2C_I2FDR_IC(x)                         (((x)&0x3F))
+#define MCF_I2C_I2FDR_IC(x)                         (((x)&0x3F))
 
-#define MCF5282_I2C_I2CR_IEN    (0x80)	// I2C enable
-#define MCF5282_I2C_I2CR_IIEN   (0x40)  // interrupt enable
-#define MCF5282_I2C_I2CR_MSTA   (0x20)  // master/slave mode
-#define MCF5282_I2C_I2CR_MTX    (0x10)  // transmit/receive mode
-#define MCF5282_I2C_I2CR_TXAK   (0x08)  // transmit acknowledge enable
-#define MCF5282_I2C_I2CR_RSTA   (0x04)  // repeat start
-
-#define MCF5282_I2C_I2SR_ICF    (0x80)  // data transfer bit
-#define MCF5282_I2C_I2SR_IAAS   (0x40)  // I2C addressed as a slave
-#define MCF5282_I2C_I2SR_IBB    (0x20)  // I2C bus busy
-#define MCF5282_I2C_I2SR_IAL    (0x10)  // aribitration lost
-#define MCF5282_I2C_I2SR_SRW    (0x04)  // slave read/write
-#define MCF5282_I2C_I2SR_IIF    (0x02)  // I2C interrupt
-#define MCF5282_I2C_I2SR_RXAK   (0x01)  // received acknowledge
+#define MCF_I2C_I2CR_IEN    (0x80)	// I2C enable
+#define MCF_I2C_I2CR_IIEN   (0x40)  // interrupt enable
+#define MCF_I2C_I2CR_MSTA   (0x20)  // master/slave mode
+#define MCF_I2C_I2CR_MTX    (0x10)  // transmit/receive mode
+#define MCF_I2C_I2CR_TXAK   (0x08)  // transmit acknowledge enable
+#define MCF_I2C_I2CR_RSTA   (0x04)  // repeat start
+
+#define MCF_I2C_I2SR_ICF    (0x80)  // data transfer bit
+#define MCF_I2C_I2SR_IAAS   (0x40)  // I2C addressed as a slave
+#define MCF_I2C_I2SR_IBB    (0x20)  // I2C bus busy
+#define MCF_I2C_I2SR_IAL    (0x10)  // aribitration lost
+#define MCF_I2C_I2SR_SRW    (0x04)  // slave read/write
+#define MCF_I2C_I2SR_IIF    (0x02)  // I2C interrupt
+#define MCF_I2C_I2SR_RXAK   (0x01)  // received acknowledge
 
 
 
@@ -107,6 +119,11 @@
 #define MCF5282_QSPI_QDR        MCF_IPSBAR + 0x0354
 #define MCF5282_QSPI_QCR        MCF_IPSBAR + 0x0354
 
+#define MCF5282_QSPI_PAR  	(MCF_IPSBAR + 0x00100059)
+
+#define MCF5282_QSPI_IRQ_SOURCE   18
+#define MCF5282_QSPI_IRQ_VECTOR   (64 + MCF5282_QSPI_IRQ_SOURCE)
+
 /* Bit level definitions and macros */
 #define MCF5282_QSPI_QMR_MSTR                           (0x8000)
 #define MCF5282_QSPI_QMR_DOHIE                          (0x4000)
Index: linux-2.6.24.7-rt27/include/asm-m68knommu/m532xsim.h
===================================================================
--- linux-2.6.24.7-rt27.orig/include/asm-m68knommu/m532xsim.h	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/include/asm-m68knommu/m532xsim.h	2009-02-08 00:00:48.000000000 -0500
@@ -16,6 +16,7 @@
 #define MCFINT_VECBASE      64
 #define MCFINT_UART0        26          /* Interrupt number for UART0 */
 #define MCFINT_UART1        27          /* Interrupt number for UART1 */
+#define MCFINT_UART2        28          /* Interrupt number for UART2 */
 
 #define MCF_WTM_WCR	MCF_REG16(0xFC098000)
 
@@ -72,9 +73,21 @@
 #define	mcf_getimr()		\
 	*((volatile unsigned long *) (MCF_MBAR + MCFSIM_IMR))
 
+#define	mcf_getimrh()		\
+	*((volatile unsigned long *) (MCF_MBAR + MCFSIM_IMRH))
+
+#define	mcf_getimrl()		\
+	*((volatile unsigned long *) (MCF_MBAR + MCFSIM_IMRL))
+
 #define	mcf_setimr(imr)		\
 	*((volatile unsigned long *) (MCF_MBAR + MCFSIM_IMR)) = (imr);
 
+#define	mcf_setimrh(imr)		\
+	*((volatile unsigned long *) (MCF_MBAR + MCFSIM_IMRH)) = (imr);
+
+#define	mcf_setimrl(imr)		\
+	*((volatile unsigned long *) (MCF_MBAR + MCFSIM_IMRL)) = (imr);
+
 #define	mcf_getipr()		\
 	*((volatile unsigned long *) (MCF_MBAR + MCFSIM_IPR))
 
@@ -131,31 +144,31 @@
  *********************************************************************/
 
 /* Read/Write access macros for general use */
-#define MCF532x_I2C_I2ADR       (volatile u8 *) (0xFC058000) // Address 
-#define MCF532x_I2C_I2FDR       (volatile u8 *) (0xFC058004) // Freq Divider
-#define MCF532x_I2C_I2CR        (volatile u8 *) (0xFC058008) // Control
-#define MCF532x_I2C_I2SR        (volatile u8 *) (0xFC05800C) // Status
-#define MCF532x_I2C_I2DR        (volatile u8 *) (0xFC058010) // Data I/O
+#define MCF_I2C_I2ADR       (volatile u8 *) (0xFC058000) /* Address */
+#define MCF_I2C_I2FDR       (volatile u8 *) (0xFC058004) /* Freq Divider */
+#define MCF_I2C_I2CR        (volatile u8 *) (0xFC058008) /* Control */
+#define MCF_I2C_I2SR        (volatile u8 *) (0xFC05800C) /* Status */
+#define MCF_I2C_I2DR        (volatile u8 *) (0xFC058010) /* Data I/O */
 
 /* Bit level definitions and macros */
-#define MCF532x_I2C_I2ADR_ADDR(x)                       (((x)&0x7F)<<0x01)
+#define MCF_I2C_I2ADR_ADDR(x)                       (((x)&0x7F)<<0x01)
 
-#define MCF532x_I2C_I2FDR_IC(x)                         (((x)&0x3F))
+#define MCF_I2C_I2FDR_IC(x)                         (((x)&0x3F))
 
-#define MCF532x_I2C_I2CR_IEN    (0x80)	// I2C enable
-#define MCF532x_I2C_I2CR_IIEN   (0x40)  // interrupt enable
-#define MCF532x_I2C_I2CR_MSTA   (0x20)  // master/slave mode
-#define MCF532x_I2C_I2CR_MTX    (0x10)  // transmit/receive mode
-#define MCF532x_I2C_I2CR_TXAK   (0x08)  // transmit acknowledge enable
-#define MCF532x_I2C_I2CR_RSTA   (0x04)  // repeat start
-
-#define MCF532x_I2C_I2SR_ICF    (0x80)  // data transfer bit
-#define MCF532x_I2C_I2SR_IAAS   (0x40)  // I2C addressed as a slave
-#define MCF532x_I2C_I2SR_IBB    (0x20)  // I2C bus busy
-#define MCF532x_I2C_I2SR_IAL    (0x10)  // aribitration lost
-#define MCF532x_I2C_I2SR_SRW    (0x04)  // slave read/write
-#define MCF532x_I2C_I2SR_IIF    (0x02)  // I2C interrupt
-#define MCF532x_I2C_I2SR_RXAK   (0x01)  // received acknowledge
+#define MCF_I2C_I2CR_IEN    (0x80)  /* I2C enable */
+#define MCF_I2C_I2CR_IIEN   (0x40)  /* interrupt enable */
+#define MCF_I2C_I2CR_MSTA   (0x20)  /* master/slave mode */
+#define MCF_I2C_I2CR_MTX    (0x10)  /* transmit/receive mode */
+#define MCF_I2C_I2CR_TXAK   (0x08)  /* transmit acknowledge enable */
+#define MCF_I2C_I2CR_RSTA   (0x04)  /* repeat start */
+
+#define MCF_I2C_I2SR_ICF    (0x80)  /* data transfer bit */
+#define MCF_I2C_I2SR_IAAS   (0x40)  /* I2C addressed as a slave */
+#define MCF_I2C_I2SR_IBB    (0x20)  /* I2C bus busy */
+#define MCF_I2C_I2SR_IAL    (0x10)  /* aribitration lost */
+#define MCF_I2C_I2SR_SRW    (0x04)  /* slave read/write */
+#define MCF_I2C_I2SR_IIF    (0x02)  /* I2C interrupt */
+#define MCF_I2C_I2SR_RXAK   (0x01)  /* received acknowledge */
 
 #define MCF532x_PAR_FECI2C	(volatile u8 *) (0xFC0A4053)
 
@@ -2234,5 +2247,36 @@
 #define MCF_EPORT_EPFR_EPF6            (0x40)
 #define MCF_EPORT_EPFR_EPF7            (0x80)
 
+/*********************************************************************
+ *
+ * Cross-Bar Switch (XBS)
+ *
+ *********************************************************************/
+#define MCF_XBS_PRS1                   MCF_REG32(0xFC004100)
+#define MCF_XBS_CRS1                   MCF_REG32(0xFC004110)
+#define MCF_XBS_PRS4                   MCF_REG32(0xFC004400)
+#define MCF_XBS_CRS4                   MCF_REG32(0xFC004410)
+#define MCF_XBS_PRS6                   MCF_REG32(0xFC004600)
+#define MCF_XBS_CRS6                   MCF_REG32(0xFC004610)
+#define MCF_XBS_PRS7                   MCF_REG32(0xFC004700)
+#define MCF_XBS_CRS7                   MCF_REG32(0xFC004710)
+
+#define MCF_XBS_PRIO_FACTTEST(x)       (((x)&0x7) << 28)
+#define MCF_XBS_PRIO_USBOTG(x)         (((x)&0x7) << 24)
+#define MCF_XBS_PRIO_USBHOST(x)        (((x)&0x7) << 20)
+#define MCF_XBS_PRIO_LCD(x)            (((x)&0x7) << 16)
+#define MCF_XBS_PRIO_FEC(x)            (((x)&0x7) << 8)
+#define MCF_XBS_PRIO_EDMA(x)           (((x)&0x7) << 4)
+#define MCF_XBS_PRIO_CORE(x)           (((x)&0x7) << 0)
+
+#define MCF_PRIO_LVL_1                 (0)
+#define MCF_PRIO_LVL_2                 (1)
+#define MCF_PRIO_LVL_3                 (2)
+#define MCF_PRIO_LVL_4                 (3)
+#define MCF_PRIO_LVL_5                 (4)
+#define MCF_PRIO_LVL_6                 (5)
+#define MCF_PRIO_LVL_7                 (6)
+
+
 /********************************************************************/
 #endif	/* m532xsim_h */
Index: linux-2.6.24.7-rt27/include/asm-m68knommu/mcfcache.h
===================================================================
--- linux-2.6.24.7-rt27.orig/include/asm-m68knommu/mcfcache.h	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/include/asm-m68knommu/mcfcache.h	2009-02-08 00:00:48.000000000 -0500
@@ -60,7 +60,7 @@
 	nop
 	movel	#0x0000c020, %d0	/* Set SDRAM cached only */
 	movec	%d0, %ACR0
-	movel	#0xff00c000, %d0	/* Cache Flash also */
+	movel	#0x00000000, %d0	/* No other regions cached */
 	movec	%d0, %ACR1
 	movel	#0x80000200, %d0	/* Setup cache mask */
 	movec	%d0, %CACR		/* Enable cache */
Index: linux-2.6.24.7-rt27/include/asm-m68knommu/mcfuart.h
===================================================================
--- linux-2.6.24.7-rt27.orig/include/asm-m68knommu/mcfuart.h	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/include/asm-m68knommu/mcfuart.h	2009-02-08 00:00:48.000000000 -0500
@@ -12,7 +12,6 @@
 #define	mcfuart_h
 /****************************************************************************/
 
-
 /*
  *	Define the base address of the UARTS within the MBAR address
  *	space.
@@ -33,7 +32,7 @@
 #define MCFUART_BASE2		0x240           /* Base address of UART2 */
 #define MCFUART_BASE3		0x280           /* Base address of UART3 */
 #elif defined(CONFIG_M5249) || defined(CONFIG_M5307) || defined(CONFIG_M5407)
-#if defined(CONFIG_NETtel) || defined(CONFIG_DISKtel) || defined(CONFIG_SECUREEDGEMP3)
+#if defined(CONFIG_NETtel) || defined(CONFIG_SECUREEDGEMP3)
 #define MCFUART_BASE1		0x200           /* Base address of UART1 */
 #define MCFUART_BASE2		0x1c0           /* Base address of UART2 */
 #else
Index: linux-2.6.24.7-rt27/mm/nommu.c
===================================================================
--- linux-2.6.24.7-rt27.orig/mm/nommu.c	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/mm/nommu.c	2009-02-08 00:00:48.000000000 -0500
@@ -952,6 +952,16 @@ unsigned long do_mmap_pgoff(struct file 
 	if (ret < 0)
 		goto error;
 
+	/*
+	 * If the driver implemented his own mmap(), the
+	 * base addr could have changed. Therefor
+	 * vm_end musst be updated to.
+	 *
+	 * See comment of DaveM in mm/mmap.c as reference
+	 */
+	if(addr != vma->vm_start)
+		vma->vm_end = vma->vm_start + len;
+
 	/* okay... we have a mapping; now we have to register it */
 	result = (void *) vma->vm_start;
 
Index: linux-2.6.24.7-rt27/mm/page_alloc.c
===================================================================
--- linux-2.6.24.7-rt27.orig/mm/page_alloc.c	2009-02-08 00:00:34.000000000 -0500
+++ linux-2.6.24.7-rt27/mm/page_alloc.c	2009-02-08 00:00:48.000000000 -0500
@@ -4317,6 +4317,14 @@ void *__init alloc_large_system_hash(con
 	if (numentries > max)
 		numentries = max;
 
+	/*
+	 * we will allocate at least a page (even on low memory systems)
+	 * so do a fixup here to ensure we utilise the space that will be
+	 * allocated,  this also prevents us reporting -ve orders
+	 */
+	if (bucketsize * numentries < PAGE_SIZE)
+		numentries = (PAGE_SIZE + bucketsize - 1) / bucketsize;
+
 	log2qty = ilog2(numentries);
 
 	do {
