From afd95eb42c9eefb06bdeb721aa58113a1b5ed040 Mon Sep 17 00:00:00 2001
From: Sujith Thomas <sujith.thomas@intel.com>
Date: Wed, 12 Dec 2007 11:12:16 +0530
Subject: [PATCH] Added brightness_levels attribute to sysfs backlight class

Signed-off-by: Sujith Thomas <sujith.thomas@intel.com>

Added callbacks for brightness_levels in ACPI video driver
Fixed bugs in acpi_video driver while registering with backlight sysfs driver
---
 drivers/acpi/video.c                |   46 +++++++++++++++++++++++++---------
 drivers/video/backlight/backlight.c |   17 +++++++++++++
 include/linux/backlight.h           |    4 +++
 3 files changed, 55 insertions(+), 12 deletions(-)

diff --git a/drivers/acpi/video.c b/drivers/acpi/video.c
index a595d2c..77ab1a1 100644
--- a/drivers/acpi/video.c
+++ b/drivers/acpi/video.c
@@ -301,18 +301,39 @@ static int acpi_video_get_brightness(struct backlight_device *bd)
 	acpi_video_device_lcd_get_level_current(vd, &cur_level);
 	return (int) cur_level;
 }
+static int acpi_video_get_brightness_levels(struct backlight_device *bd
+					    , char *buf)
+{
+	int i;
+	struct acpi_video_device *vd =
+		(struct acpi_video_device *)bl_get_data(bd);
+	for (i = 0; i < vd->brightness->count; i++)
+		buf += sprintf(buf, "%d ", vd->brightness->levels[i]);
+
+	buf += sprintf(buf, "\n");
+
+	return 0;
+}
 
 static int acpi_video_set_brightness(struct backlight_device *bd)
 {
+	int i;
 	int request_level = bd->props.brightness;
 	struct acpi_video_device *vd =
 		(struct acpi_video_device *)bl_get_data(bd);
-	acpi_video_device_lcd_set_level(vd, request_level);
-	return 0;
+	for (i = 0; i < vd->brightness->count; i++) {
+		if (request_level == vd->brightness->levels[i]) {
+			acpi_video_device_lcd_set_level(vd, request_level);
+			vd->brightness->curr = request_level;
+			return 0;
+		}
+	}
+	return -EINVAL;
 }
 
 static struct backlight_ops acpi_backlight_ops = {
 	.get_brightness = acpi_video_get_brightness,
+	.get_brightness_levels = acpi_video_get_brightness_levels,
 	.update_status  = acpi_video_set_brightness,
 };
 
@@ -579,6 +600,8 @@ static void acpi_video_device_find_cap(struct acpi_video_device *device)
 	u32 max_level = 0;
 	union acpi_object *obj = NULL;
 	struct acpi_video_device_brightness *br = NULL;
+	unsigned long tmp;
+	struct backlight_device *bd = NULL;
 
 
 	memset(&device->cap, 0, 4);
@@ -656,22 +679,21 @@ static void acpi_video_device_find_cap(struct acpi_video_device *device)
 	kfree(obj);
 
 	if (device->cap._BCL && device->cap._BCM && device->cap._BQC && max_level > 0){
-		unsigned long tmp;
-		static int count = 0;
-		char *name;
-		name = kzalloc(MAX_NAME_LEN, GFP_KERNEL);
-		if (!name)
+		acpi_video_device_lcd_get_level_current(device, &tmp);
+		device->brightness->curr = (int)tmp;
+
+		bd = backlight_device_register(device->dev->pnp.bus_id,
+					       &device->dev->dev
+					       , device
+					       , &acpi_backlight_ops);
+		if (IS_ERR(bd))
 			return;
 
-		sprintf(name, "acpi_video%d", count++);
-		acpi_video_device_lcd_get_level_current(device, &tmp);
-		device->backlight = backlight_device_register(name,
-			NULL, device, &acpi_backlight_ops);
+		device->backlight = bd;
 		device->backlight->props.max_brightness = max_level;
 		device->backlight->props.brightness = (int)tmp;
 		backlight_update_status(device->backlight);
 
-		kfree(name);
 	}
 	if (device->cap._DCS && device->cap._DSS){
 		static int count = 0;
diff --git a/drivers/video/backlight/backlight.c b/drivers/video/backlight/backlight.c
index 4840fe2..9b32208 100644
--- a/drivers/video/backlight/backlight.c
+++ b/drivers/video/backlight/backlight.c
@@ -166,6 +166,20 @@ static ssize_t backlight_show_actual_brightness(struct device *dev,
 
 static struct class *backlight_class;
 
+static ssize_t backlight_show_brightness_levels(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int rc = -ENXIO;
+	struct backlight_device *bd = to_backlight_device(dev);
+
+	mutex_lock(&bd->ops_lock);
+	if (bd->ops && bd->ops->get_brightness_levels)
+		rc = bd->ops->get_brightness_levels(bd, buf);
+	mutex_unlock(&bd->ops_lock);
+
+	return strlen(buf);
+}
+
 static void bl_device_release(struct device *dev)
 {
 	struct backlight_device *bd = to_backlight_device(dev);
@@ -179,6 +193,8 @@ static struct device_attribute bl_device_attributes[] = {
 	__ATTR(actual_brightness, 0444, backlight_show_actual_brightness,
 		     NULL),
 	__ATTR(max_brightness, 0444, backlight_show_max_brightness, NULL),
+	__ATTR(brightness_levels, 0444
+		     , backlight_show_brightness_levels, NULL),
 	__ATTR_NULL,
 };
 
@@ -262,6 +278,7 @@ void backlight_device_unregister(struct backlight_device *bd)
 	mutex_unlock(&bd->ops_lock);
 
 	backlight_unregister_fb(bd);
+
 	device_unregister(&bd->dev);
 }
 EXPORT_SYMBOL(backlight_device_unregister);
diff --git a/include/linux/backlight.h b/include/linux/backlight.h
index 1ee9488..5a2d070 100644
--- a/include/linux/backlight.h
+++ b/include/linux/backlight.h
@@ -11,6 +11,7 @@
 #include <linux/device.h>
 #include <linux/mutex.h>
 #include <linux/notifier.h>
+#include <linux/thermal.h>
 
 /* Notes on locking:
  *
@@ -36,6 +37,8 @@ struct backlight_ops {
 	/* Return the current backlight brightness (accounting for power,
 	   fb_blank etc.) */
 	int (*get_brightness)(struct backlight_device *);
+	/* Return the levels of brightness supported by device */
+	int (*get_brightness_levels)(struct backlight_device  *bd, char *buf);
 	/* Check if given framebuffer device is the one bound to this backlight;
 	   return 0 if not, !=0 if it is. If NULL, backlight always matches the fb. */
 	int (*check_fb)(struct fb_info *);
@@ -71,6 +74,7 @@ struct backlight_device {
 	struct notifier_block fb_notif;
 
 	struct device dev;
+	struct thermal_device *td;
 };
 
 static inline void backlight_update_status(struct backlight_device *bd)
-- 
1.5.3.7-dirty

