#! /bin/sh /usr/share/dpatch/dpatch-run
diff --git a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
index 89441b6..a9c8743 100644
--- a/drivers/acpi/Kconfig
+++ b/drivers/acpi/Kconfig
@@ -190,6 +190,13 @@ config ACPI_THERMAL
 	  recommended that this option be enabled, as your processor(s)
 	  may be damaged without it.
 
+config INTEL_MENLOW_SENSOR
+	tristate "Intel's Menlow thermal sensor driver"
+	depends on  THERMAL_SYSFS
+	default y
+	help
+	  This driver adds support for AUX trip programming of sensors withing ACPI thermal zones. This is an intel platform specific driver.
+
 config ACPI_NUMA
 	bool "NUMA support"
 	depends on NUMA
diff --git a/drivers/acpi/Makefile b/drivers/acpi/Makefile
index 456446f..5f098ba 100644
--- a/drivers/acpi/Makefile
+++ b/drivers/acpi/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_ACPI_POWER)	+= power.o
 obj-$(CONFIG_ACPI_PROCESSOR)	+= processor.o
 obj-$(CONFIG_ACPI_CONTAINER)	+= container.o
 obj-$(CONFIG_ACPI_THERMAL)	+= thermal.o
+obj-$(CONFIG_INTEL_MENLOW_SENSOR)+= intel_menlow_sensor.o
 obj-$(CONFIG_ACPI_SYSTEM)	+= system.o event.o
 obj-$(CONFIG_ACPI_DEBUG)	+= debug.o
 obj-$(CONFIG_ACPI_NUMA)		+= numa.o
diff --git a/drivers/acpi/intel_menlow_sensor.c b/drivers/acpi/intel_menlow_sensor.c
new file mode 100644
index 0000000..36dabed
--- /dev/null
+++ b/drivers/acpi/intel_menlow_sensor.c
@@ -0,0 +1,376 @@
+/*
+ *  thermal_sensor.c - Platform specific sensor Driver ($Revision: 1 $)
+ *  Copyright (C) 2001, 2002 Sujith Thomas <sujith.thomas@intel.com>
+
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This driver fully implements the platform sensor driver aux progamming
+ *  for intel formfactor device 'crownbeach'
+ *
+ *  It makes use of the proprietory ACPI methods to get/set aux trips.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/thermal.h>
+
+#include <acpi/acpi_bus.h>
+
+MODULE_AUTHOR("Sujith Thomas");
+MODULE_DESCRIPTION("Thermal sensor driver");
+MODULE_LICENSE("GPL");
+
+/*Macros for reading an ACPI object from ACPI namespace*/
+static acpi_handle root_handle;
+
+#define THERMAL_AUX0 0
+#define THERMAL_AUX1 1
+#define MAX_PATH_LEN 10
+#define TZ_PATH "\\_TZ."
+#define TZ_ROOT "\\_TZ"
+
+#define GET_AUX0 "GAX0"
+#define GET_AUX1 "GAX1"
+#define SET_AUX0 "SAX0"
+#define SET_AUX1 "SAX1"
+#define DABNEY_BIOS_VAR "DSTS"
+
+/*
+ * thermal_acpi_evaluate_object
+ * ----------------------------
+ * Function for executing proprietory ACPI methods
+ * path: Path as in ACPI namespace
+ * method : Method name as in ASL code
+ * in_value: Input argument to the ASL method
+ * out_value: Return value from the ASL method
+ */
+static int thermal_acpi_evaluate_object(char *path, char *method, int *in_value,
+					int *out_value)
+{
+	acpi_handle handle;
+
+	struct acpi_buffer result;
+	struct acpi_buffer *resultp = NULL;
+	union acpi_object out_obj;
+	acpi_status status = AE_OK;
+
+	struct acpi_object_list obj_list;
+	struct acpi_object_list *pobj_list = NULL;
+	union acpi_object in_obj;
+
+	if (!path || !method)
+		return -EINVAL;
+
+	/* Get handle to the ACPI object */
+	status = acpi_get_handle(root_handle, path, &handle);
+	if (ACPI_FAILURE(status))
+		return -EINVAL;
+
+	if (in_value) {
+		in_obj.type = ACPI_TYPE_INTEGER;
+		in_obj.integer.value = *in_value;
+
+		obj_list.count = 1;
+		obj_list.pointer = &in_obj;
+
+		pobj_list = &obj_list;
+	}
+
+	result.length = sizeof(out_obj);
+	result.pointer = &out_obj;
+	resultp = &result;
+
+	status = acpi_evaluate_object(handle, method, pobj_list, resultp);
+	if (ACPI_FAILURE(status)) {
+		return -EINVAL;
+	} else {
+		if (out_value) {
+			*out_value = out_obj.integer.value;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * sensor_get_auxtrip
+ * -----------------
+ * get the current auxtrip value from sensor through proprietory ACPI methods
+ * name: Thermalzone name
+ * auxtype : AUX0/AUX1
+ * buf: syfs buffer
+ */
+static int sensor_get_auxtrip(const char *name, const int auxtype, char *buf)
+{
+	int ret = 0;
+	int data;
+	char path[MAX_PATH_LEN] = { 0 };
+
+	if (!name || !buf || strlen(name) > MAX_PATH_LEN - strlen(TZ_PATH))
+		return -EINVAL;
+
+	strcat(path, TZ_PATH);
+	strcat(path, name);
+
+	switch (auxtype) {
+	case THERMAL_AUX0:
+		ret = thermal_acpi_evaluate_object(path, GET_AUX0, NULL, &data);
+		break;
+
+	case THERMAL_AUX1:
+		ret = thermal_acpi_evaluate_object(path, GET_AUX1, NULL, &data);
+		break;
+
+	default:
+		return -EIO;
+	}
+
+	if (ret)
+		return -EIO;
+
+	sprintf(buf, "%lu \n", KELVIN_TO_CELSIUS(data));
+
+	return ret;
+}
+
+/*
+ * sensor_set_auxtrip
+ * -----------------
+ * set the new auxtrip value to sensor through proprietory ACPI methods
+ * name: Thermalzone name
+ * auxtype : AUX0/AUX1
+ * buf: syfs buffer
+ */
+static int sensor_set_auxtrip(const char *name, const int auxtype,
+			      int aux_temperature)
+{
+	int ret = 0;
+	int other_aux_temperature;
+	char path[MAX_PATH_LEN] = { 0 };
+
+	if (!name || strlen(name) > MAX_PATH_LEN - strlen(TZ_PATH))
+		return -EINVAL;
+
+	strcat(path, TZ_PATH);
+	strcat(path, name);
+
+	switch (auxtype) {
+	case THERMAL_AUX0:
+		ret =
+		    thermal_acpi_evaluate_object(path, GET_AUX1, NULL,
+						 &other_aux_temperature);
+		if (ret || aux_temperature > other_aux_temperature)
+			return -EINVAL;
+		ret =
+		    thermal_acpi_evaluate_object(path, SET_AUX0,
+						 &aux_temperature, NULL);
+		break;
+
+	case THERMAL_AUX1:
+		ret =
+		    thermal_acpi_evaluate_object(path, GET_AUX0, NULL,
+						 &other_aux_temperature);
+		if (ret || aux_temperature < other_aux_temperature)
+			return -EINVAL;
+		ret =
+		    thermal_acpi_evaluate_object(path, SET_AUX1,
+						 &aux_temperature, NULL);
+		break;
+
+	}
+
+	if (ret)
+		return -EIO;
+
+	return ret;
+}
+
+static ssize_t aux0_show(struct thermal_device *td,
+			 struct thermal_device_attribute *attr, char *buf)
+{
+	if (!td || !buf)
+		return -EINVAL;
+
+	sensor_get_auxtrip(td->name, THERMAL_AUX0, buf);
+
+	return strlen(buf);
+}
+
+static ssize_t aux0_store(struct thermal_device *td,
+			  struct thermal_device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	int critical_temperature;
+	int aux_temperature;
+
+	if (!td || !buf)
+		return -EINVAL;
+
+	/* Can change the AUX trips if userspace algo has taken over */
+	if (THERMAL_USERSPACE != thermal_get_algo_mode())
+		return -EFAULT;
+
+	/*Sanity check; should be integer */
+	if (!sscanf(buf, "%d", &aux_temperature))
+		return -EINVAL;
+
+	if (td->ops->
+	    thermal_get_critical(td->devdata, NULL, &critical_temperature))
+		return -EFAULT;
+
+	/* Programmable aux values should be less than _CRT */
+	if (aux_temperature < 0 || aux_temperature >= critical_temperature)
+		return -EINVAL;
+
+	aux_temperature = CELSIUS_TO_KELVIN(aux_temperature);
+
+	sensor_set_auxtrip(td->name, THERMAL_AUX0, aux_temperature);
+	return count;
+}
+
+static ssize_t aux1_show(struct thermal_device *td,
+			 struct thermal_device_attribute *attr, char *buf)
+{
+	if (!td || !buf)
+		return -EINVAL;
+
+	sensor_get_auxtrip(td->name, THERMAL_AUX1, buf);
+
+	return strlen(buf);
+}
+
+static ssize_t aux1_store(struct thermal_device *td,
+			  struct thermal_device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	int critical_temperature;
+	int aux_temperature;
+
+	if (!td || !buf)
+		return -EINVAL;
+
+	/* Can change the AUX trips if userspace algo has taken over */
+	if (THERMAL_USERSPACE != thermal_get_algo_mode())
+		return -EFAULT;
+
+	/*Sanity check; should be integer */
+	if (!sscanf(buf, "%d", &aux_temperature))
+		return -EINVAL;
+
+	if (td->ops->
+	    thermal_get_critical(td->devdata, NULL, &critical_temperature))
+		return -EFAULT;
+
+	/* Programmable aux values should be less than _CRT */
+	if (aux_temperature < 0 || aux_temperature >= critical_temperature)
+		return -EINVAL;
+
+	aux_temperature = CELSIUS_TO_KELVIN(aux_temperature);
+
+	sensor_set_auxtrip(td->name, THERMAL_AUX1, aux_temperature);
+	return count;
+}
+
+/* AUX0/AUX1 attributes*/
+static THERMAL_DEVICE_ATTR(aux0, 0644, aux0_show, aux0_store);
+static THERMAL_DEVICE_ATTR(aux1, 0644, aux1_show, aux1_store);
+
+static struct thermal_device_attribute *thermal_device_extn_attrs[] = {
+	&thermal_device_attr_aux0,
+	&thermal_device_attr_aux1,
+	NULL,
+};
+
+/*
+ * thermal_sensor_event_handler
+ * ---------------------------
+ * This callback will be called by thermal_sysfs driver whenever
+ * a new thermal device is added/removed. This driver will have to
+ * add/remove aux0/aux1 attributes during that event
+ * event_type: THERMAL_SYSFS_EVENT_ADD_TD /THERMAL_SYSFS_EVENT_RMV_TD
+ * sysfs_data: pointer to thermal_device
+ * private: Context information of this driver sent during registration
+ */
+int thermal_sensor_event_handler(int event_type,
+				 void *sysfs_data, void *private)
+{
+	char path[MAX_PATH_LEN] = { 0 };
+	int aux_temperature;
+	struct thermal_device *td;
+
+	if (!sysfs_data)
+		return -EINVAL;
+	td = (struct thermal_device *)sysfs_data;
+
+	if (strlen(td->name) > MAX_PATH_LEN - strlen(TZ_PATH))
+		return -EINVAL;
+
+	strcat(path, TZ_PATH);
+	strcat(path, td->name);
+	switch (event_type) {
+	case THERMAL_SYSFS_EVENT_ADD_TD:
+		/* Add aux0/aux1 attribute only if proper ASL methods
+		   are implemented in BIOS */
+		if (!thermal_acpi_evaluate_object
+		    (path, GET_AUX0, NULL, &aux_temperature)
+		    && !thermal_acpi_evaluate_object(path, GET_AUX1, NULL,
+						     &aux_temperature))
+			thermal_attribute_register(td,
+						   thermal_device_extn_attrs);
+		break;
+
+	case THERMAL_SYSFS_EVENT_RMV_TD:
+		thermal_attribute_unregister(td, thermal_device_extn_attrs);
+		break;
+	}
+
+	return 0;
+}
+
+static struct thermal_sysfs_event_listener sensor_event_listener = {
+	.thermal_sysfs_event_handler = thermal_sensor_event_handler,
+	.event_type = THERMAL_SYSFS_EVENT_ADD_TD | THERMAL_SYSFS_EVENT_RMV_TD,
+};
+
+static int __init thermalsensor_start(void)
+{
+
+	int dabney_enabled;
+
+	thermal_event_register(&sensor_event_listener,
+			       THERMAL_SYSFS_REPORT_EXISTING);
+
+	/*Check whether the user application is enabled in BIOS */
+	if (thermal_acpi_evaluate_object
+	    (TZ_ROOT, DABNEY_BIOS_VAR, NULL, &dabney_enabled)
+	    || !dabney_enabled)
+		thermal_set_userenabled(THERMAL_USER_DISABLED);
+
+	return 0;
+}
+
+static void __exit thermalsensor_end(void)
+{
+	thermal_event_unregister(&sensor_event_listener,
+				 THERMAL_SYSFS_REPORT_EXISTING);
+}
+
+module_init(thermalsensor_start);
+module_exit(thermalsensor_end);
-- 
1.5.2.5

