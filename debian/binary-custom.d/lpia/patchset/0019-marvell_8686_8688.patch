#! /bin/sh /usr/share/dpatch/dpatch-run
diff --git a/drivers/net/wireless/8686_wlan/Makefile b/drivers/net/wireless/8686_wlan/Makefile
new file mode 100644
index 0000000..50d3eb4
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/Makefile
@@ -0,0 +1,71 @@
+CONFIG_DEBUG=4
+
+# Proc in /proc/net/wlan
+CONFIG_PROC_DEBUG=y
+
+# Linux Power Management
+CONFIG_ENABLE_PM=n
+
+# Re-association in driver
+CONFIG_REASSOCIATION=y
+
+# Manufacturing firmware support
+CONFIG_MFG_CMD_SUPPORT=y
+
+ifeq ($(CONFIG_DEBUG),1)
+	EXTRA_CFLAGS += -DDEBUG_LEVEL1
+endif
+
+ifeq ($(CONFIG_DEBUG),2)
+	EXTRA_CFLAGS += -DDEBUG_LEVEL1
+	EXTRA_CFLAGS += -DDEBUG_LEVEL2
+	DBG=	-dbg
+endif
+
+ifeq ($(CONFIG_PROC_DEBUG),y)
+	EXTRA_CFLAGS += -DPROC_DEBUG
+	export CONFIG_PROC_DEBUG
+endif
+
+ifeq ($(CONFIG_ENABLE_PM),y)
+	EXTRA_CFLAGS += -DENABLE_PM
+endif
+
+ifeq ($(CONFIG_REASSOCIATION),y)
+	EXTRA_CFLAGS += -DREASSOCIATION
+endif
+
+ifeq ($(CONFIG_MFG_CMD_SUPPORT),y)
+	EXTRA_CFLAGS += -DMFG_CMD_SUPPORT
+endif
+
+sd8xxx-objs =	wlan/wlan_main.o wlan/wlan_fw.o wlan/wlan_wext.o \
+		wlan/wlan_rx.o wlan/wlan_tx.o \
+		wlan/wlan_cmd.o wlan/wlan_cmdresp.o \
+		wlan/wlan_proc.o wlan/wlan_scan.o wlan/wlan_join.o \
+		wlan/wlan_wmm.o wlan/wlan_11d.o \
+		if/if_sdio_fb/if_sdio.o
+
+ifeq ($(CONFIG_PROC_DEBUG), y)
+sd8xxx-objs += wlan/wlan_debug.o
+endif
+
+obj-$(CONFIG_MMC_SD8686) += sd8xxx.o
+
+	EXTRA_CFLAGS += -DFPNUM='"13"'
+	EXTRA_CFLAGS += -DFB
+
+ifdef CONFIG_MMC_SD8686
+	EXTRA_CFLAGS += -Idrivers/net/wireless/8686_wlan/os/linux -Idrivers/net/wireless/8686_wlan/wlan
+
+
+ifdef CONFIG_MMC_DEBUG
+#	EXTRA_CFLAGS += -DDEBUG_LEVEL1
+#	EXTRA_CFLAGS += -DDEBUG_LEVEL2
+#	EXTRA_CFLAGS += -DDEBUG_LEVEL3
+#	EXTRA_CFLAGS += -DDEBUG_LEVEL4
+#	DBG=    -dbg
+endif
+
+endif
+
diff --git a/drivers/net/wireless/8686_wlan/README b/drivers/net/wireless/8686_wlan/README
new file mode 100644
index 0000000..deb8260
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/README
@@ -0,0 +1,1405 @@
+===============================================================================
+			U S E R  M A N U A L
+
+ (c) Copyright © 2003-2007, Marvell International Ltd. 
+
+ This software file (the "File") is distributed by Marvell International 
+ Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ (the "License").  You may use, redistribute and/or modify this File in 
+ accordance with the terms and conditions of the License, a copy of which 
+ is available along with the File in the gpl.txt file or by writing to 
+ the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+ THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ this warranty disclaimer.
+
+===============================================================================
+
+1) FOR DRIVER INSTALL
+
+2) FOR DRIVER PROC & DEBUG
+
+	The following info are provided in /proc/net/wlan/info,
+
+	driver_name = "wlan"
+	driver_version = <chip id, firmware version and driver version>
+	InterfaceName = "ethX"
+	Mode = "Ad-hoc" | "Managed" | "Auto" | "Unknown"
+	State = "Disconnected" | "Connected"
+	MACAddress = <6-byte adapter MAC address>
+	MCCount = <multicast address count>
+	ESSID = <current SSID>
+	Channel = <current channel>
+	region_code = <current region code>
+	MCAddr[n] = <multicast address>
+	num_tx_bytes = <number of bytes sent to device>
+	num_rx_bytes = <number of bytes received from device and sent to kernel>
+	num_tx_pkts = <number of packets sent to device>
+	num_rx_pkts = <number of packets received from device and sent to kernel>
+	num_tx_pkts_dropped = <number of tx packets dropped by driver>
+	num_rx_pkts_dropped = <number of rx packets dropped by driver>
+	num_tx_pkts_err = <number of tx packets failed to send to device>
+	num_rx_pkts_err = <number of rx packets failed to receive from device>
+	carrier "on" | "off"
+	tx queue "stopped" | "started"
+	CurCmd "NULL" | <current command id and action>
+
+	The following debug info are provided in /proc/net/wlan/debug,
+
+	IntCounter = <interrupt count, cleared when interrupt handled>
+	ConnectStatus = <0/1, disconnected/connected>
+	TxSkbNum = <number of tx packets in tx skb queue>
+	PSMode = <0/1, CAM mode/PS mode>
+	PSState = <0/1/2/3, full power state/awake state/pre-sleep state/sleep state>
+	HS_Configured = <0/1, host sleep not configured/configured>
+	WakeupDevReq = <0/1, wakeup device not required/required>
+	WakeupTries = <wakeup device count, cleared when device awake>
+	num_tx_timeout = <number of tx timeout>
+	num_cmd_timeout = <number of timeout commands>
+	TimeoutCmdId = <command id of the last timeout command>
+	TimeoutCmdAct = <command action of the last timeout command>
+	LastCmdId = <command id of the last command sent to device>
+	LastCmdRespId = <command id of the last command response received from device>
+	num_cmd_h2c_fail = <number of commands failed to send to device>
+	num_cmd_sleep_cfm_fail = <number of sleep confirm failed to send to device>
+	num_tx_h2c_fail = <number of data packets failed to send to device>
+	num_evt_deauth = <number of deauthenticated events received from device>
+	num_evt_disassoc = <number of disassociated events received from device>
+	num_evt_link_lost = <number of link lost events received from device>
+	num_cmd_deauth = <number of deauthenticate commands sent to device>
+	num_cmd_assoc_ok = <number of associate commands with success return>
+	num_cmd_assoc_fail = <number of associate commands with failure return>
+	dnld_sent = <0/1/2, send resources available/sending data to device/sending command to device>
+
+	Use dmesg or cat /var/log/debug to check driver debug messages.
+	To log driver debug messages to file,
+	a) Edit /etc/syslog.conf, add one line "*.debug		/var/log/debug"
+	b) touch /var/log/debug (if the file doesn't exist)
+	c) service syslog restart
+
+	Update /proc/sys/kernel/printk to change message log levels.
+	For example,
+	echo 6 > /proc/sys/kernel/printk    (messages with a higher priority than 6 
+	                                     will be printed to the console)
+	echo 15 > /proc/sys/kernel/printk   (all messages will be printed to console)
+
+3) FOR IWPRIV COMMAND
+
+NAME
+	This manual describes the usage of private commands used in Marvell WLAN
+	Linux Driver. All the commands available in Wlanconfig will not be available 
+	in the iwpriv.
+
+	To use parameters as hex format, a'0x' must precede it for the parameters to 
+	be parsed properly. 
+
+SYNOPSIS
+	iwpriv <ethX> <command> [sub-command] ...
+
+	iwpriv ethX version
+	iwpriv ethX scantype [sub-command]
+	iwpriv ethX getSNR <n>
+	iwpriv ethX getNF <n>
+	iwpriv ethX getRSSI <n>
+	iwpriv ethX setrxant <n>
+	iwpriv ethX getrxant
+	iwpriv ethX settxant <n>
+	iwpriv ethX gettxant
+	iwpriv ethX authalgs <n>
+	iwpriv ethX encryptionmode <n>
+	iwpriv ethX setregioncode <n>
+	iwpriv ethX getregioncode 
+	iwpriv ethX setbcnavg <n>
+	iwpriv ethX getbcnavg
+	iwpriv ethX setdataavg <n>
+	iwpriv ethX getdataavg
+	iwpriv ethX setlisteninter <n>
+	iwpriv ethX getlisteninter
+	iwpriv ethX setmultipledtim <n>
+	iwpriv ethX getmultipledtim
+	iwpriv ethX atimwindow <n>
+	iwpriv ethX deepsleep <n>
+	iwpriv ethX hostsleepcfg <n>
+	iwpriv ethX hscfg <n>
+	iwpriv ethX deauth
+	iwpriv ethX adhocstop
+	iwpriv ethX radioon
+	iwpriv ethX radiooff
+	iwpriv ethX reasso-on
+	iwpriv ethX reasso-off
+	iwpriv ethX scanmode  [sub-command]
+	iwpriv ethX setwpaie <n>
+	iwpriv ethX setaeskey <n>
+	iwpriv ethX getaeskey 
+	iwpriv ethX rmaeskey
+	iwpriv ethX getcis
+	iwpriv ethX getlog
+	iwpriv ethX getadhocstatus
+	iwpriv ethX adhocgrate <n>
+
+Version 4 Command:
+	iwpriv ethX inactvityto <n>
+	iwpriv ethX sleeppd <n>
+	iwpriv ethX enable11d <n>
+	iwpriv ethX bgscan <n>
+	iwpriv ethX wmm <n>
+	iwpriv ethX tpccfg <n>
+	iwpriv ethX setafc <n>
+	iwpriv ethX getafc
+	iwpriv ethX sdioclock <n>
+
+Version 5 Command:
+	iwpriv ethX ledgpio <n>
+	iwpriv ethX wmm_qosinfo <n>
+	iwpriv ethX scanprobes <n>
+	iwpriv ethX lolisteninter <n>
+ 	iwpriv ethX rateadapt <n> <m> <l> <k>
+	iwpriv ethX fwwakeupmethod <n>
+	iwpriv ethX txcontrol <n>
+	iwpriv ethX uapsdnullgen <n>
+	iwpriv ethX psnullinterval <n>
+	iwpriv ethX prescan <n>
+	iwpriv ethX getrxinfo
+	iwpriv ethX gettxrate
+	iwpriv ethX bcninterval [n]
+	iwpriv ethX setcoalescing <n>
+	iwpriv ethX adhocawakepd <n>
+	iwpriv ethX scantime [s] [a] [p]
+	iwpriv ethX ldocfg [n]
+
+	iwpriv ethX drvdbg [n] [m]
+	iwpriv ethX getrate 
+
+DESCRIPTION
+	Those commands are used to send additional commands to the Marvell WLAN
+	card via the Linux device driver.
+
+	The ethX parameter specifies the network device that is to be used to 
+		perform this command on. it could be eth0, eth1 etc.
+
+version	
+	This is used to get the current version of the driver and the firmware.
+
+scantype	
+	This command is used to set the scan type to be used by the driver in 
+	the scan command. This setting will not be used while performing a scan
+	for a specific SSID, as it is always done with scan type being active. 
+	
+	where the sub-commands are: - 
+			active 	-- to set the scan type to active
+			passive -- to set the scan type to passive
+			get 	-- to get the scan type set in the driver
+
+getSNR  
+	This command gets the average and non average value of Signal to Noise 
+	Ratio of Beacon and Data.
+	
+	where value is:
+			0 	-- Beacon non-average.
+	        	1 	-- Beacon average.
+	        	2 	-- Data non-average.
+	        	3 	-- Data average.
+
+	If no value is given, all four values are returned in the order mentioned
+	above.
+
+	Note: This command is available only when STA is connected.
+
+getRSSI	
+	This command gets the average and non average value os Receive Signal 
+	Strength of Beacon and Data.
+	
+	where value is:
+			0 	-- Beacon non-average.
+	        	1 	-- Beacon average.
+	        	2 	-- Data non-average.
+	        	3 	-- Data average.
+
+	Note: This command is available only when STA is connected.
+
+getNF   
+	This command gets the average and non average value of Noise Floor of 
+	Beacon and Data.
+	
+	where value is:
+			0 	-- Beacon non-average.
+	        	1 	-- Beacon average.
+	        	2 	-- Data non-average.
+	        	3 	-- Data average.
+
+	Note: This command is available only when STA is connected.
+
+setrxant	
+	This command is used to set the mode for Rx antenna. 
+	
+	The options that can be sent are:- 
+			1 	-- Antenna 1. 
+			2 	-- Antenna 2.
+			0xFFFF 	-- Diversity.
+
+	Usage:
+		iwpriv ethX setrxant 0x01: select Antenna 1.
+
+getrxant                    
+	This command is used to get the mode for Rx antenna.
+
+settxant	
+	This command is used to set the mode for Tx antenna.
+		The options that can be sent are:- 
+			1 	-- Antenna 1. 
+			2 	-- Antenna 2.
+			0xFFFF 	-- Diversity.
+	Usage:
+		iwpriv ethX settxant 0x01: select Antenna 1.
+
+gettxant                    
+	This command is used to get the mode for Tx antenna.
+
+authalgs	
+	This command is used by the WPA supplicant to set the authentication 
+	algorithms in the station.
+
+encryptionmode
+	This command is used by the WPA supplicant to set the encryption algorithm.
+		
+	where values can be:-
+			0 	-- NONE
+			1 	-- WEP40
+			2 	-- TKIP
+			3 	-- CCMP
+			4 	-- WEP104
+
+setregioncode           
+	This command is used to set the region code in the station.
+	where value is 'region code' for various regions like
+	USA FCC, Canada IC, France, Europe ETSI, Japan ...
+
+	Usage:
+		iwpriv ethX setregioncode 0x10: set region code to USA (0x10).
+
+getregioncode           
+	This command is used to get the region code information set in the 
+	station. 
+
+setbcnavg
+	Set the weighting factor for calculating beacon average RSSI and SNR.
+	where value can be:
+			0 	-- default beacon averaging factor (8)
+			1-8 	-- beacon averaging factor
+	Usage:
+		iwpriv ethX setbcnavg 0
+		iwpriv ethX setbcnavg 8
+
+getbcnavg
+	Get the weighting factor for calculating beacon average RSSI and SNR.
+	Usage:
+		iwpriv ethX getbcnavg
+
+setdataavg
+	Set the weighting factor for calculating data average RSSI and SNR.
+	where value can be:
+			0 	-- default data averaging factor (8)
+			1-8 	-- data averaging factor
+	Usage:
+		iwpriv ethX setdataavg 0
+		iwpriv ethX setdataavg 8
+
+getdataavg
+	Get the weighting factor for calculating data average RSSI and SNR.
+	Usage:
+		iwpriv ethX getdataavg
+
+setlisteninter             
+	This command is used to set the listen interval in the 
+	station.
+	
+	where the value ranges between 1 - 255
+
+getlisteninter            
+	This command is used to get the listen interval value set in the 
+	station.
+
+setmultipledtim         
+	This command is used to set the multiple dtim value in the 
+	station.
+		where the value is 1,2,3,4,5,0xfffe
+		65534 (0xfffe) means that the dtim will be ignored in firmware,
+		listen interval or local listen interval will be used.
+
+getmultipledtim        
+	This command is used to get the multiple dtim value set in the station.
+
+atimwindow         
+	This command is used to set atim value in the station when an argument is given, 
+        return the atim value set by the user and the current atim value if adapter is in connected state. 
+        The valid atimwindow is between 0 - 50.
+
+	Usage:
+		iwpriv ethX atimwindow 0  (set atimwindow to 0)
+		
+		not connected:
+		iwpriv ethX atimwindow    (get atimwindow value set by user)
+		
+		connected:
+		iwpriv ethX atimwindow     (get atimwindow set by user previously
+                                                         and current atimwindow)
+
+deauth                      
+	This command is used to send the de-authentication to the AP with which 
+	the station is associated. This command is valid only when 
+	station is in Infrastructure mode.
+
+	Note: This command is available only when STA is connected.
+
+reasso-on                  
+	This command is used to enable re-association function in dirver.
+
+reasso-off                  
+	This command is used to disable re-association function in driver
+
+adhocstop                 
+	This command is used to stop beacon transmission from the station and 
+	go into idle state in ad-hoc mode.
+	
+	Note: This command is available only when STA is connected.
+
+radioon                     
+	This command is used to turn on the RF antenna.
+
+radiooff                    
+	This command is sued to turn off the RF antenna.   
+
+scanmode                 
+	This command is used to set the station to scan for either IBSS 
+	networks or BSS networks or both BSS and IBSS networks. This 
+	command can be used with sub commands,
+
+	where the value for 
+			bss 	-- Scan All the BSS networks.
+			ibss 	-- Scan All the IBSS networks.
+			any 	-- Scan both BSS and IBSS networks.
+			
+deepsleep                    
+	This command is used to configure the station in deepsleep mode.
+
+	where the option is:
+			1 	-- Enable deepsleep mode
+			0 	-- Disable deepsleep mode. 
+
+hostsleepcfg	
+	This command is used to configure the host sleep parameters.
+		(Condition, GPIO pin , Gap).
+
+	where Condition is:
+		bit 0 = 1 	-- broadcast data
+		bit 1 = 1 	-- unicast data
+		bit 2 = 1 	-- mac event
+		bit 3 = 1 	-- multicast packet
+
+	where GPIO is the pin number of GPIO used to wakeup the host.
+ 		It could be any valid pin # (e.g. 0-7) or 0xff (Interface, e.g. SDIO will be used instead).
+		
+	where Gap is the gap in milli seconds between wakeup signal and wakeup event.
+
+	Where GPIO and Gap are one byte Hexical data.
+
+	Usage:
+		iwpriv eth1 hostsleepcfg  "2 1 80"		# unicast data
+								# GPIO 1
+								# gap: 128ms
+
+		iwpriv eth1 hostsleepcfg  "2 0ff 0"		# unicast data
+								# Interface (e.g. SDIO) is used
+								# gap: 0ms
+
+		iwpriv eth1 hostsleepcfg  "0ffffffff 0 0"	# cancel host sleep config
+
+	Note: if the condition is 0ffffffff, the GPIO and GAP values will be ignored.
+
+hscfg	
+	This command is used to configure the host sleep parameters.
+
+		iwpriv ethX hscfg Condition [GPIO# [Gap]]
+
+	Note:
+
+	1) This command takes one (Condition) or two (Condition and GPIO#) or three (Condition, GPIO# and gap)
+	parameters.
+
+		where Condition is:
+			bit 0 = 1 	-- broadcast data
+			bit 1 = 1 	-- unicast data
+			bit 2 = 1 	-- mac event
+			bit 3 = 1 	-- multicast packet
+
+		where GPIO is the pin number of GPIO used to wakeup the host. It could be any valid
+		GPIO pin# (e.g. 0-7) or 0xff (Interface, e.g. SDIO will be used instead).
+		
+		where Gap is the gap in milli seconds between wakeup signal and wakeup event
+
+	2) the Host Sleep mode will be cancelled if condition is set to -1.
+	
+	3) Usage:
+		iwpriv eth1 hscfg -1			# cancel host sleep mode
+
+		iwpriv eth1 hscfg 3			# broadcast and unicast data
+							# use GPIO and GAP set previously
+	
+		iwpriv eth1 hscfg 2 0x3			# unicast data
+							# use GPIO 3
+							# use GAP set previously
+
+		iwpriv eth1 hscfg 2 1 0xa0		# unicast data
+							# use GPIO 1
+							# gap: 160 ms
+
+		iwpriv eth1 hscfg 2 0xff		# unicast data
+							# use Interface (e.g. SDIO)
+							# use GAP set previously
+
+setwpaie                      
+	This command is used by WPA supplicant to send the WPA-IE to the driver. 
+
+setaeskey
+	This command is used to set the AES key, when the station is in Ad-hoc
+	mode.
+
+	where value can be any 16 byte value.
+
+	Usage:
+		iwpriv ethX setaeskey 12345678901234567890123456789012
+
+getaeskey
+	This command is used to get the AES key, when the station is in Ad-hoc
+	mode.
+
+rmaeskey
+	This command is used to remove the Ad-Hoc AES key that is previously set.
+	It will disable ad-hoc AES as well.
+
+getcis
+	This command is used to read the Card Info Structure Table.
+	
+getlog
+	This command is used to get the 802.11 statistics available in the 
+		station.
+	
+	Note: This command is available only when STA is connected.
+
+getadhocstatus
+	This command is used to get the ad-hoc Network Status.
+
+	The various status codes are:
+		AdhocStarted
+		AdhocJoined
+		AdhocIdle
+		InfraMode
+		AutoUnknownMode
+
+	Note: This command is available only when STA is connected.
+
+adhocgrate
+	This command is used to enable(1) g_rate, Disable(0) g_rate 
+	and request(2) the status which g_rate is disabled/enabled,
+	for Ad-hoc creator.
+
+	where value is:
+		0	-- Disable
+		1	-- Enable
+		2	-- Get
+
+ledgpio
+	This command is used to set/get LED settings.
+
+	iwpriv ethX ledgpio <LEDs>
+		will set the corresponding LED for the GPIO Line.
+
+	iwpriv ethX ledgpio
+		will get the current LEDs settings.
+
+	Usage:
+		iwpriv eth1 ledgpio 1 0 2 1 3 16
+			LED 1 -> GPIO 0
+			LED 2 -> GPIO 1
+			LED 3 -> disable
+
+		iwpriv eth1 ledgpio 
+			shows LED information in the format as mentioned above.
+
+	Note: LED 0 is invalid
+	      Maximum Number of LEDs are 3.
+	
+inactivityto
+	This command is used by the host to set/get the inactivity timeout value, 
+	which specifies when WLAN device is put to sleep.
+	
+	Usage:
+		iwpriv ethX inactivityto [<timeout>]
+
+	where the parameter are:
+		timeout: timeout value in milliseconds.
+
+	Example:
+		iwpriv eth1 inactivityto
+			"get the timeout value"
+
+		iwpriv eth1 inactivityto X 
+			"set timeout value to X ms"
+
+sleeppd
+	This command is used to configure the sleep period of the WLAN device.
+
+	Usage:
+		iwpriv ethX sleeppd [<sleep period>]
+
+	where the parameter are:
+		Period: sleep period in milliseconds. Range 10~60.
+
+	Example:
+		iwpriv eth1 sleeppd 10 
+			"set period as 10 ms"
+		iwpriv eth1 sleeppd
+			"get the sleep period configuration"
+
+enable11d
+	This command is used to control 11d
+	where value is:
+		1	-- Enable
+		0	-- Disable
+		2	-- Get
+
+wmm
+	This command is used to control WMM
+
+	where value is:
+		0	-- Disable
+		1	-- Enable
+		2	-- Get
+
+	
+bgscan
+	Enables or disables the Background scan.
+
+	The configuration for bg scan must be set using wlanconfig
+
+	Usage:
+		wlanconfig ethX bgscanconfig bg_scan_config.conf
+		iwpriv ethX bgscan 0 (disable)
+		iwpriv ethX bgscan 1 (enable)
+		iwpriv ethX bgscan 2 (display enable or disable)
+
+tpccfg
+	Enables or disables automatic transmit power control.
+
+	The first parameter turns this feature on (1) or off (0).  When turning 
+	on, the user must also supply four more parameters in the following 
+	order:
+		-UseSNR (Use SNR (in addition to PER) for TPC algorithm),
+		-P0 (P0 power level for TPC),
+		-P1 (P1 power level for TPC),
+		-P2 (P2 power level for TPC).
+
+	Usage:
+		iwpriv ethX tpccfg: Get current configuration
+		iwpriv ethX tpccfg 0: disable auto TPC
+		iwpriv ethX tpccfg 0x01 0x00 0x05 0x0a 0x0d: enable auto TPC; do not use SNR;
+							     P0=0x05; P1=0x0a; P2=0x0d;
+		iwpriv ethX tpccfg 0x01 0x01 0x05 0x0a 0x0d: enable auto TPC; use SNR;
+							     P0=0x05; P1=0x0a; P2=0x0d.
+
+getafc
+	This command returns automatic frequency control parameters.  It returns
+	three integers:
+		-P0: automatic is on (1), or off (0),
+		-P1: current timing offset in PPM (part per million), and
+		-P2: current frequency offset in PPM.
+
+setafc
+	Set automatic frequency control options.
+
+	The first parameter turns automatic on (1) or off (0).
+	The user must supply two more parameters in either case, in the following
+  order:
+
+  When auto is on:
+
+		-P0 (automatic adjustment frequency threshold in PPM),
+		-P1 (automatic adjustment period in beacon period),
+
+  When auto is off:
+
+		-P0 (manual adjustment timing offset in PPM), and
+		-P1 (manual adjustment frequency offset in PPM).
+
+	Usage:
+		iwpriv ethX setafc 0 10 10: manual adjustment, both timing and frequcncy 
+    offset are 10 PPM.
+
+		iwpriv ethX setafc 1 10 10 enable afc, automatic adjustment,
+    frequency threshold 10 PPM, for every 10 beacon periods.
+
+sdioclock
+	Turn On(1) or Off(0) the SDIO clock.
+
+	Usage:
+		iwpriv ethX sdioclock 1 (on)
+		iwpriv ethX sdioclock 0 (off)
+
+wmm_qosinfo
+	This command sets WMM IE QOS info when an argument is given, and gets current WMM
+	IE QOS info when no argument is given.
+
+	Usage:
+		iwpriv ethX wmm_qosinfo 0x0f (set WMM IE QOS info to 0x0f)
+		iwpriv ethX wmm_qosinfo      (get WMM IE QOS info)
+
+scanprobes
+	This command sets number of probe requests per channel.
+
+	Usage:
+		iwpriv ethX scanprobes 3 (set scan probes to 3)
+		iwpriv ethX scanprobes   (get scan probes)
+
+lolisteninter
+	This command sets the value of listen interval.
+
+	Usage:
+	iwpriv ethX lolisteninter 234 (set the lolisteninter to 234)
+	iwpriv ethX lolisteninter     (get the lolisteninter value)
+
+rateadapt
+	This command sets the data rates bitmap.
+	Where <n>
+ 		0: no HW rate drop
+		1: HW table rate drop
+		2: HW single rate drop
+	      <m>
+		 data rate bitmap
+			Bit	Data rate
+			0	1 Mbps
+			1	2 Mbps
+			2	5.5 Mbps
+			3	11 Mbps
+			4	Reserved
+			5	6 Mbps
+			6	9 Mbps
+			7	12 Mbps
+			8	18 Mbps
+			9	24 Mbps
+			10	36 Mbps
+			11	48 Mbps
+			12	54 Mbps
+			12-15	Reserved
+		<l> Threshold, Number of same rate retries before switch to Final rate.
+		    Used only if HW single rate drop is selected. Typical values are from 3 to 6.
+
+		<k> Final Rate, This value is used only if HW single rate drop is selected.
+			value	Data rate
+			0	1 Mbps
+			1	2 Mbps
+			2	5.5 Mbps
+			3	11 Mbps
+			4	Reserved
+			5	6 Mbps
+			6	9 Mbps
+			7	12 Mbps
+			8	18 Mbps
+			9	24 Mbps
+			10	36 Mbps
+			11	48 Mbps
+			12	54 Mbps
+			13-15	Reserved
+	Usage:
+	iwpriv ethX rateadapt
+			read the currect data rate setting
+	iwpriv ethX rateadapt 1 0x07
+			enable hardware auto data rate adapt and 
+			data rates are 1Mbps, 2Mbsp and 5.5Mbps
+	iwpriv ethX rateadapt 2 0x0f 6 2
+			use HW single rate drop, data rates are 1Mbps, 2Mbsp and 5.5Mbps, 11Mbps
+			Threshold is 6, Final Rate is 5.5 Mbps
+
+fwwakeupmethod
+	This command is used to set the firmware wakeup method.
+
+	where value <n> is:
+		0	-- Leave the current method to wakeup firmware unchanged
+		1	-- Firmware wakeup through the interface command interrupt
+			-- (default setting for SDIO/GSPI)
+		2	-- Firmware wakeup through the GPIO pin
+			-- (default setting for CF)
+
+	Usage:
+	iwpriv ethX fwwakeupmethod
+			Read the currect firmware wakeup method setting
+	iwpriv ethX fwwakeupmethod 0
+			Leave the current method to wakeup firmware unchanged
+	iwpriv ethX fwwakeupmethod 1
+			Firmware wakeup through the interface command interrupt
+	iwpriv ethX fwwakeupmethod 2
+			Firmware wakeup through the GPIO pin
+
+txcontrol
+	This command is used to set the Tx rate, ack policy, and retry limit on a per packet basis.
+
+	Where value <n> is:
+	    if bit[4] == 1:
+		bit[3:0]        -- 0   1   2   3   4   5   6   7   8   9   10   11   12   13-16
+		Data Rate(Mbps) -- 1   2   5.5 11  Rsv 6   9   12  18  24  36   48   54   Rsv
+
+	    bit[12:8] 
+		if bit[12] == 1, bit[11:8] specifies the Tx retry limit.
+
+	    bit[14:13] specifies per packet ack policy:
+		bit[14:13]   
+		     1  0	use immediate ack policy for this packet
+		     1  1       use no ack policy for this packet
+		     0  x	use the per-packet ack policy setting
+			
+	Usage:
+	iwpriv ethX txcontrol 0x7513
+			Use no-ack policy, 5 retires for Tx, 11Mbps rate
+
+uapsdnullgen
+	This command is used to enable(1) UAPSD null package generation, 
+	Disable(0) UAPSD null package generation, and request(2) the status 
+	which null package generation is disabled/enabled,
+	for Ad-hoc creator.
+
+	where value is:
+		0	-- Disable
+		1	-- Enable
+		2	-- Get
+
+psnullinterval
+	This command is used to set/request NULL package interval for Power Save
+	under infrastructure mode.
+
+	where value is:
+		-1	-- Disable
+		n>0	-- Set interval as n (seconds)
+
+prescan
+	This command is used to enable (1)/disable(0) auto prescan before assoicate to the ap 
+
+	where value is:
+		0	-- Disable
+		1	-- Enable
+		2       -- Get
+
+getrxinfo
+	This command gets non average value of Signal to Noise Ratio of Data and rate index.
+
+	The following table shows RateIndex and Rate
+
+		     RateIndex	Data rate
+			0	1 Mbps
+			1	2 Mbps
+			2	5.5 Mbps
+			3	11 Mbps
+			4	Reserved
+			5	6 Mbps
+			6	9 Mbps
+			7	12 Mbps
+			8	18 Mbps
+			9	24 Mbps
+			10	36 Mbps
+			11	48 Mbps
+			12	54 Mbps
+			13-15	Reserved
+
+gettxrate	 
+	This command gets current Tx rate index of the first packet associated with Rate Adaptation.
+
+	The following table shows RateIndex and Rate
+
+		     RateIndex	Data rate
+			0	1 Mbps
+			1	2 Mbps
+			2	5.5 Mbps
+			3	11 Mbps
+			4	Reserved
+			5	6 Mbps
+			6	9 Mbps
+			7	12 Mbps
+			8	18 Mbps
+			9	24 Mbps
+			10	36 Mbps
+			11	48 Mbps
+			12	54 Mbps
+			13-15	Reserved
+
+bcninterval 
+	This command is used to set beacon interval in adhoc mode when an argument is given, 
+	return the value set by the user and the current adhoc beacon interval if adapter is in connected state. 
+        The valid beacon interval is between 20 - 1000, default beacon interval is 100.
+
+	Usage:
+		iwpriv ethX bcninterval 100  (set adhoc beacon interval to 100)
+		
+		not connected:
+		iwpriv ethX bcninterval      (get adhoc beacon interval set by user)
+		
+		connected:
+		iwpriv ethX bcninterval      (get adhoc beacon interval set by user previously
+                                              and current beacon interval)
+                 
+setcoalescing
+	This command is used to disable/enable IBSS coalescing function, and get IBSS coalescing status.
+
+	where value is:
+		0	-- Disable IBSS coalescing function
+		1	-- Enable IBSS coalescing function
+		2	-- Get current IBSS coalescing status
+
+adhocawakepd 
+	This command is used to set/get adhoc awake period for Power Save Mode.
+
+	where value is:
+		0xff -- firmware will go to sleep after send out beacon
+		0--no change 
+		1--31 (beacon interval) 
+
+scantime
+	This command is used to set/get scan time per channel in milliseconds.
+	The current setting will be returned every time.
+
+	Usage:
+		iwpriv ethX scantime [s] [a] [p]
+	
+	where the parameters are,
+		[s]: specific SSID/BSSID scan time, default 100 ms, max 500 ms
+		[a]: active scan time, default 100 ms, max 500 ms
+		[p]: passive scan time, default 100 ms, max 2000 ms
+		No change if the parameter is 0 or the parameter is not provided.
+
+	For example:
+		iwpriv ethX scantime 30         (set specific scan time to 30 ms)
+		iwpriv ethX scantime 0 100      (set active scan time to 100 ms)
+		iwpriv ethX scantime 30 80 200  (set specific scan time to 30 ms,
+		                                 set active scan time to 80 ms,
+		                                 set passive scan time to 200 ms)
+
+ldocfg
+	This command is used to set/get internal/external core power voltage source.
+	By default firmware uses internal LDO for 1.2V core power supply.
+	The current setting will be returned if no parameter provided.
+
+	Usage:
+		iwpriv ethX ldocfg [n]
+	
+	where the parameter is,
+		0	-- internal
+		1	-- external
+
+drvdbg
+	This command is used to set/get the bit masks of driver debug message control.
+
+	Usage:
+		iwpriv ethX drvdbg [n] [m]
+
+	Where the parameter <n> is the generic debug message control bit mask.
+	The following types of driver debug messages can be dynamically enabled or 
+	disabled by setting or clearing the corresponding bits, 
+		bit 0:  MSG  		PRINTM(MSG,...)
+		bit 1:  FATAL		PRINTM(FATAL,...)
+		bit 2:  ERROR		PRINTM(ERROR,...)
+		bit 3:  DATA 		PRINTM(DATA,...)
+		bit 4:  CMND 		PRINTM(CMND,...)
+		bit 5:  EVENT		PRINTM(EVENT,...)
+		bit 6:  INTR 		PRINTM(INTR,...)
+		...
+		bit 16: DAT_D		PRINTM(DAT_D,...), DBG_HEXDUMP(DAT_D,...)
+		bit 17: CMD_D		PRINTM(CMD_D,...), DBG_HEXDUMP(CMD_D,...)
+		bit 18: FW_D		PRINTM(FW_D,...)
+		...
+		bit 28: ENTRY		PRINTM(ENTRY,...), ENTER(), LEAVE()
+		bit 29: WARN 		PRINTM(WARN,...)
+		bit 30: INFO 		PRINTM(INFO,...)
+
+	Where the parameter <m> is the extended interface module debug message control 
+	bit mask. The following types of debug messages can be controlled.
+
+		bit 0:  IF_D 		PRINTM(IF_D,...),  DBG_HEXDUMP(IF_D,...)
+
+	If CONFIG_DEBUG=2, all kinds of debug messages can be configured. 
+	By default all debug messages are enabled except for EVENT and IF_D.
+
+	If CONFIG_DEBUG=1, all kinds of debug messages can be configured except 
+	for ENTRY, WARN and INFO. By default MSG and FATAL are enabled.
+
+	Some special debug messages,
+		'*'		// WLAN driver ISR is called (bit 6 INTR enabled)
+		'|'		// PS awake event is received (bit 5 EVENT enabled)
+		'_'		// PS sleep event is received (bit 5 EVENT enabled)
+		'+'		// PS sleep confirm is sent (bit 5 EVENT enabled)
+
+	For example:
+		iwpriv ethX drvdbg          (get the current driver debug masks)
+		iwpriv ethX drvdbg 0 0      (disable all the debug messages)
+		iwpriv ethX drvdbg 7        (enable MSG, FATAL and ERROR messages,
+		                             no change for if debug control)
+		iwpriv ethX drvdbg 3 1      (enable MSG and FATAL messages,
+		                             enable IF_D message)
+		iwpriv ethX drvdbg -1 -1    (enable all the debug messages)
+
+getrate 
+	This command is used to get the supported rates. Returned rates are in 0.5M unit.
+
+
+===============================================================================
+
+		U S E R  M A N U A L  F O R  W L A N _ C O N F I G 
+
+NAME
+wlanconfig - configure the additional parameters available for the Marvell 
+		WLAN Linux Driver.
+
+SYNOPSIS
+wlanconfig -v
+wlanconfig <ethX> <command> [parameters] ...
+
+wlanconfig ethX version
+wlanconfig ethX <rdmac|rdbbp|rdrf> <offset>
+wlanconfig ethX <wrmac|wrbbp|wrrf> <offset> <n>
+wlanconfig ethX sdcmd52r  <FN no.>  <address>
+wlanconfig ethX sdcmd52w  <FN no.>  <address> <data>
+wlanconfig ethX caldataext <filename>
+wlanconfig ethX rdeeprom <offset> <length>
+wlanconfig ethX sleepparams <config values>
+wlanconfig ethX bca-ts <config values>
+wlanconfig ethX extscan <ssid>
+wlanconfig ethX getscanlist
+
+Version 4 Command:
+wlanconfig ethX bgscanconfig <filename>
+wlanconfig ethx wmmtspec <filename>
+wlanconfig ethx wmmparaie <filename>
+wlanconfig ethx wmm_ack_policy <AC> <Ack Policy>
+
+Version 5 Command:
+wlanconfig ethX hostcmd <hostcmd.conf> <subevent_get>
+wlanconfig ethX hostcmd <hostcmd.conf> <subevent_set>
+wlanconfig ethX reassociate <current bssid> <desired bssid> <desired ssid>
+
+Version 6 Command:
+wlanconfig ethX setuserscan [ARGS]
+wlanconfig ethX getscantable
+wlanconfig ethX getassocrsp
+
+Version 8
+wlanconfig ethX addts <filename.conf> <section# of tspec> <timeout in ms>
+wlanconfig ethX delts <filename.conf> <section# of tspec>
+wlanconfig ethX qconfig set msdu <lifetime in TUs> [Queue Id: 0-3]
+wlanconfig ethX qconfig get [Queue Id: 0-3]
+wlanconfig ethX qconfig def [Queue Id: 0-3]
+wlanconfig ethX qstats on  [Queue Id: 0-3]
+wlanconfig ethX qstats off [Queue Id: 0-3]
+wlanconfig ethX qstats get [Queue Id: 0-3]
+wlanconfig ethX hostcmd <hostcmd.conf> <pa_cfg_ext_get>
+wlanconfig ethX hostcmd <hostcmd.conf> <pa_cfg_ext_set>
+wlanconfig ethX hostcmd <hostcmd.conf> <arp_filter>
+wlanconfig ethX hostcmd <hostcmd.conf> <auto_tx_get>
+wlanconfig ethX hostcmd <hostcmd.conf> <NatKeepAlive>
+wlanconfig ethX hostcmd <hostcmd.conf> <auto_tx_unreg>
+wlanconfig ethX arpfilter <arpfilter.conf>
+
+DESCRIPTION
+
+those commands are used in Marvell specic applicaion called wlanconfig.
+
+===========
+-v
+	This command is used to display the version of wlanconfig utility.
+	Usage:	
+		wlanconfig -v
+ 
+rdmac 
+rdbbp
+rdrf	
+	These commands are used to read the MAC, BBP and RF registers from the 
+	card.  These commands take one parameter that specifies the offset 
+	location that is to be read.  This parameter can be specified either in 
+	decimal or in hexadecimal (by preceding the number with a "0x").
+		
+	Usage:	
+		wlanconfig ethX rdmac 0xa123
+		wlanconfig ethX rdbbp 0x0123
+		wlanconfig ethX rdrf 0x0123
+
+wrmac 
+wrbbp
+wrrf	
+	These commands are used to write the MAC, BBP and RF registers in the 
+	card.  These commands take two parameters that specify the offset 
+	location and the value that is to be written. This parameters can be 
+	specified either in decimal or in hexadecimal (by preceding the number 
+	with a "0x").
+	
+	Usage:
+		wlanconfig ethX wrmac 0xa123 0xaa
+		wlanconfig ethX wrbbp 0x0123 0xaa
+		wlanconfig ethX wrrf 0x0123 0xaa
+
+sdcmd52r  
+	This command is used to read a controller register in 
+	Secure Digital I/O Interfaces.
+	
+	wlanconfig eth1 sdcmd52r <function number> <register address> 
+
+	Usage:
+		wlanconfig eth1 sdcmd52r 0x00 0x07
+
+sdcmd52w
+	This command is used to write to a controller register in 
+	Secure Digital I/O Interfaces. 
+	
+	wlanconfig eth1 sdcmd52w <function number> <register address> <value>
+
+	Usage:
+		wlanconfig eth1 sdcmd52w 0x00 0x02 0x0a
+
+caldataext
+	In order to overcome the situation without EEPROM in the WLAN module, 
+	we send the extension calibration command to modify the existing 
+	hardware-spec command. This command takes one parameter that specifies 
+	the file name of the configuration file.
+
+	Usage:
+	wlanconfig eth1 caldataext <cal_data_ext_set_<version>.conf>
+		cal_data_ext_set_<version>.conf is a configuration file to the 
+		wlanconfig to set the calibration values. The 3 existing 
+		versions are v5, vA and v7. 
+		Example:
+		  wlanconfig eth1 caldataext cal_data_ext_set_v5.conf
+		Edit this file for changing calibration values.			
+
+rdeeprom
+	To read the EEPROM contents of the card.
+	
+	Usage:
+	wlanconfig ethX rdeeprom 0x00 0x10
+	
+sleepparams       
+	This command is used to set the sleepclock configurations
+	
+	Usage:
+		wlanconfig ethX sleepparams get: reads the current sleepclock configuration
+	
+		wlanconfig ethX sleepparams set p1 p2 p3 p4 p5 p6: writes the sleepclock configuration.
+			
+		where:
+			p1 is Sleep clock error in ppm (0-65535)
+			p2 is Wakeup offset in usec (0-65535)
+			p3 is Clock stabilization time in usec (0-65535)
+			p4 is Control periodic calibration (0-2)
+			p5 is Control the use of external sleep clock (0-2)
+			p6 is reserved for debug (0-65535)
+
+bca-ts
+	This command is used to set/get the BCA timeshare parameters.
+ 
+	This command only works after BCA been enabled. 
+	
+	Usage:
+		wlanconfig ethX bca-ts <Traffic Type> <TimeShareInterval> <BTTime>
+
+		where:
+			Traffic Type 0 - Wlan and bluetooth are low priority.
+				     1 - Wlan and bluetooth are high priority.
+ 	
+			TimeShareInterval value is not multiple of 10 then floor value 
+			is taken and the valid range is < 20 ... 60,000 > in milliseconds.
+
+			BTTime value is  not multiple of 10 then floor value is
+			taken and the valid range is < 0 ... TimeShareInterval value >
+			in milliseconds.
+
+	Example:
+		wlanconfig ethX bca-ts get 1  
+				get the BCA timeshare settings when wlan and bluetooth are set to high priority.  
+
+		wlanconfig ethX bca-ts set 1 30 20
+				set wlan and bluetooth to high priority, wlan TimeShareInterval to 30ms, BTTime to 20ms.
+				
+
+bgscanconfig
+	This will configure the various parameters for background scan.
+
+	wlanconfig ethX bgscanconfig bg_scan_config.conf
+	
+	bg_scan_config.conf is the configuration file to wlanconfig
+	
+	Edit this file for changing bg scan values.
+
+wmmtspec/wmmparaie
+	This will configure the various command for wmm.
+	A single configuration is used for both the commands.
+	The configuration may contain all the command. The configuration of
+	each command should be in [command] Configuration [/command].
+
+wmm_ack_policy
+	This command will set the acknowledgement policy for a particular AC.
+
+	Usage:
+		"wlanconfig eth1 wmm_ack_policy" - This will get the Ack Policy
+		for all the AC and will display it to the user.
+		
+		"wlanconfig eth1 wmm_ack_policy <AC> <Ack Policy>" - This
+		will set the given <Ack Policy> to a given <AC>.
+		<AC>: 0 for AC_BE
+		      1 for AC_BK
+		      2 for AC_VI
+		      3 for AC_VO
+		<Ack Policy>: 0 for IMM_ACK
+			      1 for NO_ACK
+
+hostcmd <hostcmd.conf> <subevent_get>
+hostcmd <hostcmd.conf> <subevent_set>
+	This command is used to set the configurations for 
+		event descriptor interface command.
+	hostcmd.conf is a generic configuration file containing multiple configuration enties
+		for subscrive event API
+	subsvent_get: get subscribed event parameters
+	subsvent_set: set subscribed event parameters
+
+	Usage:
+		wlanconfig ethX hostcmd hostcmd.conf subevent_get
+		wlanconfig ethX hostcmd hostcmd.conf subevent_set
+
+extscan
+	This command is used to do a specific scan.
+	
+	Usage: wlanconfig ethX extscan <SSID>
+
+	Example:
+		wlanconfig ethX extscan LINKSYS-AP
+
+	To see the results of use getscanlist command.
+
+getscanlist
+	This command is used to get the scan results.
+
+	Usage: wlanconfig ethX getscanlist
+		
+	Example:
+		wlanconfig ethX getscanlist
+
+reassociate
+    Send a reassociation request to the desired bssid or ssid
+
+    Usage:  
+       reassociate <xx:xx:xx:xx:xx:xx> <yy:yy:yy:yy:yy:yy> <ssid string>
+    
+      where xx..xx is the current AP BSSID to be included in the reassoc req
+            yy..yy is the desired AP to send the reassoc req to
+            <ssid string> is the desired AP SSID to send the reassoc req to.
+    
+      The current and desired AP BSSIDs are required.  
+      The SSID string can be omitted if the desired BSSID is provided.
+    
+      If we fail to find the desired BSSID, we attempt the SSID.
+      If the desired BSSID is set to all 0's, the ssid string is used.
+
+setuserscan
+    Initiate a customized scan and retrieve the results
+
+    Usage:
+       wlanconfig ethX setuserscan [ARGS]
+
+         where [ARGS]: 
+
+      chan=[chan#][band][mode] where band is [a,b,g] and mode is 
+                               blank for active or 'p' for passive
+      bssid=xx:xx:xx:xx:xx:xx  specify a BSSID filter for the scan
+      ssid="[SSID]"            specify a SSID filter for the scan
+      keep=[0 or 1]            keep the previous scan results (1), discard (0)
+      dur=[scan time]          time to scan for each channel in milliseconds
+      probes=[#]               number of probe requests to send on each chan
+      type=[1,2,3]             BSS type: 1 (Infra), 2(Adhoc), 3(Any)
+ 
+    Any combination of the above arguments can be supplied on the command line.
+      If the chan token is absent, a full channel scan will be completed by 
+      the driver.  If the dur or probes tokens are absent, the driver default
+      setting will be used.  The bssid and ssid fields, if blank, 
+      will produce an unfiltered scan. The type field will default to 3 (Any)
+      and the keep field will default to 0 (Discard).
+
+    Examples:
+    1) Perform an active scan on channels 1, 6, and 11 in the 'g' band:
+            setuserscan chan=1g,6g,11g
+
+    2) Perform a passive scan on channel 11 for 20 ms:
+            setuserscan chan=11gp dur=20
+
+    3) Perform an active scan on channels 1, 6, and 11; and a passive scan on
+       channel 36 in the 'a' band:
+            setuserscan chan=1g,6g,11g,36ap
+
+    4) Perform an active scan on channel 6 and 36 for a specific SSID:
+            setuserscan chan=6g,36a ssid="TestAP"
+
+    5) Scan all available channels (B/G, A bands) for a specific BSSID, keep
+       the current scan table intact, update existing or append new scan data:
+            setuserscan bssid=00:50:43:20:12:82 keep=1
+
+    6) Scan channel 6, for all infrastructure networks, sending two probe 
+       requests.  Keep the previous scan table intact. Update any duplicate
+       BSSID/SSID matches with the new scan data:
+            setuserscan chan=6g type=1 probes=2 keep=1
+
+    All entries in the scan table (not just the new scan data when keep=1) 
+    will be displayed upon completion by use of the getscantable ioctl.
+
+getscantable
+    Display the current contents of the driver scan table
+
+    Usage:
+       wlanconfig ethX getscantable
+
+getassocrsp
+    Display the contents of the driver association response buffer
+
+    Usage:
+       wlanconfig ethX getassocrsp
+
+setmrvltlv
+    Setup a test Marvell TLV for the driver to insert in the next 
+       association command to the firmware.  
+
+    wlanconfig will provision a test TLV that can be verified in the assoc.
+       response to the AP.  Used to test the IOCTL functionality.
+
+    Usage:
+       wlanconfig ethX setmrvltlv
+
+addts
+    Send an ADDTS command to the associated AP.
+
+    Process a given conf file for a specific TSPEC data block.  Send the
+      TSPEC along with any other IEs to the driver/firmware for transmission
+      in an ADDTS request to the associated AP.  
+ 
+    Return the execution status of the command as well as the ADDTS response
+      from the AP if any.
+   
+    Usage:
+       wlanconfig ethX addts <filename.conf> <section# of tspec> <timeout(ms)>
+
+delts
+    Send a DELTS command to the associated AP.
+
+    Process a given conf file for a specific TSPEC data block.  Send the
+      TSPEC along with any other IEs to the driver/firmware for transmission
+      in a DELTS request to the associated AP.  
+ 
+    Return the execution status of the command.  There is no response to a
+      DELTS from the AP.
+   
+    Usage:
+       wlanconfig ethX delts <filename.conf> <section# of tspec>
+
+qconfig
+    Send a WMM AC Queue configuration command to get/set/default params
+ 
+    Configure or get the parameters of a WMM AC queue. The command takes
+      an optional Queue Id as a last parameter.  Without the queue id, all
+      queues will be acted upon.
+ 
+    Usage:  
+       wlanconfig ethX qconfig set msdu <lifetime in TUs> [Queue Id: 0-3]
+       wlanconfig ethX qconfig get [Queue Id: 0-3]
+       wlanconfig ethX qconfig def [Queue Id: 0-3]
+
+qstats
+    Turn on/off or retrieve and clear the queue statistics for an AC
+
+    Turn the queue statistics collection on/off for a given AC or retrieve the
+      current accumulated stats and clear them from the firmware.  The command
+      takes an optional Queue Id as a last parameter.  Without the queue id,
+      all queues will be acted upon.
+ 
+    Usage:
+       wlanconfig ethX qstats on  [Queue Id: 0-3]
+       wlanconfig ethX qstats off [Queue Id: 0-3]
+       wlanconfig ethX qstats get [Queue Id: 0-3]
+
+hostcmd <hostcmd.conf> <pa_cfg_ext_get>
+hostcmd <hostcmd.conf> <pa_cfg_ext_set>
+    This configures the power adaptation paramemters
+
+    Usage:
+	wlanconfig ethX hostcmd hostcmd.conf pa_cfg_ext_get
+	wlanconfig ethX hostcmd hostcmd.conf pa_cfg_ext_set
+	
+	hostcmd.conf is a generic configuration file containing multiple configuration enties
+		for power adapation
+	pa_cfg_ext_get: get pa_cfg_ext parameters
+	pa_cfg_ext_set: set pa_cfg_ext parameters
+	
+	The following table shows the bitmap of the rates (bit 0 is the least significant bit):
+
+		        Bit	Data rate
+			0	1 Mbps
+			1	2 Mbps
+			2	5.5 Mbps
+			3	11 Mbps
+			4	Reserved
+			5	6 Mbps
+			6	9 Mbps
+			7	12 Mbps
+			8	18 Mbps
+			9	24 Mbps
+			10	36 Mbps
+			11	48 Mbps
+			12	54 Mbps
+			13-15	Reserved
+
+	Up to 5 power level groups are supported.
+
+	The default power adaptation groups:
+
+		Power Level	Rate Bitmap (Mbps)
+		13 dbm		0x1800 (54, 48)
+		15 dbm		0x07e0 (36, 24, 18, 12, 9, 6)
+		18 dbm		0x000f (11, 5.5, 2, 1)
+
+	Edit the hostcmd.conf file to change the settings
+
+hostcmd <hostcmd.conf> <arp_filter>
+	This is an extended host_sleep_cfg command to configure the ARP filtering parameters.
+
+	Usage:
+		wlanconfig ethX hostcmd hostcmd.conf arp_filter
+
+	Edit the arp_filter section in hostcmd.conf file to change the settings
+
+hostcmd <hostcmd.conf> <auto_tx_get>
+hostcmd <hostcmd.conf> <NatKeepAlive>
+hostcmd <hostcmd.conf> <auto_tx_unreg>
+    This configures the Frame Auto Transmission paramemters
+
+    Usage:
+	wlanconfig ethX hostcmd hostcmd.conf auto_tx_get
+	wlanconfig ethX hostcmd hostcmd.conf NatKeepAlive
+	wlanconfig ethX hostcmd hostcmd.conf auto_tx_unreg
+	
+	hostcmd.conf is a generic configuration file containing multiple configuration enties
+		for Frame Auto Transmission
+	auto_tx_get: get auto_tx parameters
+	NatKeepAlive: register to firmware for sending NAT Keep Alive packet
+	auto_tx_unreg: unregister to firmware auto_tx
+	
+	Edit the auto_tx section in hostcmd.conf file to change the settings
+
+arpfilter <arpfilter.conf>
+	This command is used to configure the ARP filtering parameters.
+
+	Usage:
+		wlanconfig ethX arpfilter arpfilter.conf
+
+	Edit arpfilter.conf file to change the settings
+==============================================================================
diff --git a/drivers/net/wireless/8686_wlan/app/wlanconfig/Makefile b/drivers/net/wireless/8686_wlan/app/wlanconfig/Makefile
new file mode 100644
index 0000000..60d43bb
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/app/wlanconfig/Makefile
@@ -0,0 +1,61 @@
+# File: app/Makefile
+#
+# (c) Copyright © 2003-2006, Marvell International Ltd. 
+#
+# This software file (the "File") is distributed by Marvell International 
+# Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+# (the "License").  You may use, redistribute and/or modify this File in 
+# accordance with the terms and conditions of the License, a copy of which 
+# is available along with the File in the gpl.txt file or by writing to 
+# the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+# 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+#
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+# IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+# ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+# this warranty disclaimer.
+#
+
+# Path to the top directory of the wlan distribution
+PATH_TO_TOP = ../..
+
+# Determine how we should copy things to the install directory
+ABSPATH := $(filter /%, $(INSTALLDIR))
+RELPATH := $(filter-out /%, $(INSTALLDIR))
+INSTALLPATH := $(ABSPATH)
+ifeq ($(strip $(INSTALLPATH)),)
+INSTALLPATH := $(PATH_TO_TOP)/$(RELPATH)
+endif
+
+# Override CFLAGS for application sources, remove __ kernel namespace defines
+CFLAGS := $(filter-out -D__%, $(CFLAGS))
+
+
+# Add the wlan driver directory to the preprocessor include path
+CFLAGS +=  -I$(PATH_TO_TOP)/wlan
+
+
+#
+# List of application executables to create
+#
+TARGETS := wlanconfig
+
+#
+# Make target rules
+#
+
+# All rule compiles list of TARGETS using builtin program target from src rule
+all : $(TARGETS)
+
+# Install rule; INSTALLPATH calculated above from passed INSTALLDIR variable
+$(INSTALLPATH)/% : ./%
+	@cp -f $< $@
+
+# Map build and install invocation to the install rule for each TARGET file
+build install: $(addprefix $(INSTALLPATH)/, $(TARGETS))
+
+clean:
+	@rm -f $(TARGETS)
+
+distclean: clean
+	@rm -f *~ core
diff --git a/drivers/net/wireless/8686_wlan/app/wlanconfig/wlanconfig.c b/drivers/net/wireless/8686_wlan/app/wlanconfig/wlanconfig.c
new file mode 100644
index 0000000..2c1c97c
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/app/wlanconfig/wlanconfig.c
@@ -0,0 +1,4276 @@
+/** @file  wlanconfig.c
+  * @brief Program to configure addition paramters into the wlan driver
+  * 
+  * (c) Copyright © 2003-2007, Marvell International Ltd. 
+  *
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	10/12/05: Add Doxygen format comments
+	11/03/05: Load priv ioctls on demand, ifdef code for features in driver
+	11/04/05: Add crypto_test 
+	12/14/05: Support wildcard SSID in BGSCAN	
+	01/11/06: Add getscantable, setuserscan, setmrvltlv, getassocrsp 
+	01/31/06: Add support to selectively enabe the FW Scan channel filter	
+	02/24/06: fix getscanlist function not work on linux 2.6.15 X86
+	04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+	04/10/06: Add hostcmd generic API and power_adapt_cfg_ext command
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+		  implementation through generic hostcmd API
+	05/03/06: Add auto_tx hostcmd
+	05/15/06: Support EMBEDDED_TCPIP with Linux 2.6.9
+********************************************************/
+
+#include    <stdio.h>
+#include    <unistd.h>
+#include    <time.h>
+#include    <ctype.h>
+#include    <sys/types.h>
+#include    <sys/socket.h>
+#include    <string.h>
+#include    <stdlib.h>
+#include    <linux/if.h>
+#include    <sys/ioctl.h>
+#include    <linux/wireless.h>
+#include    <linux/if_ether.h>
+#include    <linux/byteorder/swab.h>
+#include    <errno.h>
+
+#define WLANCONFIG_VER "1.00"   /* wlanconfig Version number */
+
+#ifdef 	BYTE_SWAP
+#define 	cpu_to_le16(x)	__swab16(x)
+#else
+#define		cpu_to_le16(x)	(x)
+#endif
+
+#ifndef __ATTRIB_ALIGN__
+#define __ATTRIB_ALIGN__ __attribute__((aligned(4)))
+#endif
+
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__  __attribute__((packed))
+#endif
+
+/*
+ *  ctype from older glib installations defines BIG_ENDIAN.  Check it 
+ *   and undef it if necessary to correctly process the wlan header
+ *   files
+ */
+#if (BYTE_ORDER == LITTLE_ENDIAN)
+#undef BIG_ENDIAN
+#endif
+
+#include	"wlan_types.h"
+#include	"wlan_defs.h"
+#include    "wlan_wmm.h"
+#include    "wlan_11d.h"
+
+#include	"host.h"
+#include	"hostcmd.h"
+#include    "wlan_scan.h"
+#include    "wlan_join.h"
+#include	"wlan_wext.h"
+#include	"wlanconfig.h"
+
+#ifndef MIN
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+#endif /* MIN */
+
+enum COMMANDS
+{
+    CMD_HOSTCMD,
+    CMD_RDMAC,
+    CMD_WRMAC,
+    CMD_RDBBP,
+    CMD_WRBBP,
+    CMD_RDRF,
+    CMD_WRRF,
+    CMD_RDEEPROM,
+    CMD_CMD52R,
+    CMD_CMD52W,
+    CMD_CMD53R,
+    CMD_CMD53W,
+    CMD_BG_SCAN_CONFIG,
+    CMD_ADDTS,
+    CMD_DELTS,
+    CMD_QCONFIG,
+    CMD_QSTATS,
+    CMD_WMM_QSTATUS,
+    CMD_WMM_ACK_POLICY,
+    CMD_WMM_AC_WPAIE,
+    CMD_CAL_DATA_EXT,
+    CMD_GETRATE,
+    CMD_SLEEPPARAMS,
+    CMD_BCA_TS,
+    CMD_REASSOCIATE,
+    CMD_EXTSCAN,
+    CMD_SCAN_LIST,
+    CMD_SET_GEN_IE,
+    CMD_GET_SCAN_RSP,
+    CMD_SET_USER_SCAN,
+    CMD_SET_MRVL_TLV,
+    CMD_GET_ASSOC_RSP,
+    CMD_ARPFILTER,
+};
+
+#define IW_MAX_PRIV_DEF		128
+
+/********************************************************
+		Local Variables
+********************************************************/
+static s8 *commands[] = {
+    "hostcmd",
+    "rdmac",
+    "wrmac",
+    "rdbbp",
+    "wrbbp",
+    "rdrf",
+    "wrrf",
+    "rdeeprom",
+    "sdcmd52r",
+    "sdcmd52w",
+    "sdcmd53r",
+    "sdcmd53w",
+    "bgscanconfig",
+    "addts",
+    "delts",
+    "qconfig",
+    "qstats",
+    "qstatus",
+    "wmm_ack_policy",
+    "wmmparaie",
+    "caldataext",
+    "getrate",
+    "sleepparams",
+    "bca-ts",
+    "reassociate",
+    "extscan",
+    "getscanlist",
+    "setgenie",
+    "getscantable",
+    "setuserscan",
+    "setmrvltlv",
+    "getassocrsp",
+    "arpfilter",
+};
+
+static s8 *usage[] = {
+    "Usage: ",
+    "   	wlanconfig -v  (version)",
+    "	wlanconfig <ethX> <cmd> [...]",
+    "	where",
+    "	ethX	: wireless network interface",
+    "	cmd	: hostcmd, rdmac, wrmac, rdbbp, wrbbp, rdrf, wrrf",
+    "		: sdcmd52r, sdcmd52w, sdcmd53r",
+    "		: caldataext",
+    "		: rdeeprom,sleepparams",
+    "		: bca-ts",
+    "		: bgscanconfig",
+    "		: qstatus, wmmparaie, wmm_ack_policy",
+    "		: addts, delts, qconfig, qstats",
+    "		: reassociate",
+    "		: setgenie",
+    "		: getscantable, setuserscan",
+    "		: setmrvltlv, getassocrsp",
+    "		: arpfilter",
+    "	[...]	: additional parameters for read registers are",
+    "		:	<offset>",
+    "		: additional parameters for write registers are",
+    "		:	<offset> <value>",
+    "		: additonal parameter for hostcmd",
+    "		: 	<filename> <cmd>",
+    "		: addition parameters for caldataext",
+    "		: 	<filename>",
+    "		: additional parameters for reassociate are:",
+    "		:	XX:XX:XX:XX:XX:XX YY:YY:YY:YY:YY:YY < string max 32>",
+    "		:	< Current BSSID > < Desired BSSID > < Desired SSID >",
+    "		: additonal parameter for arpfilter",
+    "		: 	<filename>",
+};
+
+static s32 sockfd;
+static s8 dev_name[IFNAMSIZ + 1];
+static struct iw_priv_args Priv_args[IW_MAX_PRIV_DEF];
+static int we_version_compiled = 0;
+#define MRV_EV_POINT_OFF (((char *) &(((struct iw_point *) NULL)->length)) - \
+			  (char *) NULL)
+
+static u16 TLVChanSize;
+static u16 TLVSsidSize;
+static u16 TLVProbeSize;
+static u16 TLVSnrSize;
+static u16 TLVBcProbeSize;
+static u16 TLVNumSsidProbeSize;
+static u16 ActualPos = sizeof(HostCmd_DS_802_11_BG_SCAN_CONFIG);
+
+char rate_bitmap[16][16] =
+    { "1", "2", "5.5", "11", "reserved", "6", "9", "12", "18", "24", "36",
+"48", "54", "reserved", "reserved", "reserved" };
+
+static s8 *wlan_config_get_line(s8 * s, s32 size, FILE * stream, int *line);
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+/** 
+ *  @brief convert char to hex integer
+ * 
+ *  @param chr 		char to convert
+ *  @return      	hex integer or 0
+ */
+static int
+hexval(s32 chr)
+{
+    if (chr >= '0' && chr <= '9')
+        return chr - '0';
+    if (chr >= 'A' && chr <= 'F')
+        return chr - 'A' + 10;
+    if (chr >= 'a' && chr <= 'f')
+        return chr - 'a' + 10;
+
+    return 0;
+}
+
+/** 
+ *  @brief Hump hex data
+ *
+ *  @param prompt	A pointer prompt buffer
+ *  @param p		A pointer to data buffer
+ *  @param len		the len of data buffer
+ *  @param delim	delim char
+ *  @return            	hex integer
+ */
+static void
+hexdump(s8 * prompt, void *p, s32 len, s8 delim)
+{
+    s32 i;
+    u8 *s = p;
+
+    if (prompt) {
+        printf("%s: len=%d\n", prompt, (int) len);
+    }
+    for (i = 0; i < len; i++) {
+        if (i != len - 1)
+            printf("%02x%c", *s++, delim);
+        else
+            printf("%02x\n", *s);
+        if ((i + 1) % 16 == 0)
+            printf("\n");
+    }
+}
+
+/** 
+ *  @brief convert char to hex integer
+ *
+ *  @param chr		char
+ *  @return            	hex integer
+ */
+static u8
+hexc2bin(s8 chr)
+{
+    if (chr >= '0' && chr <= '9')
+        chr -= '0';
+    else if (chr >= 'A' && chr <= 'F')
+        chr -= ('A' - 10);
+    else if (chr >= 'a' && chr <= 'f')
+        chr -= ('a' - 10);
+
+    return chr;
+}
+
+/** 
+ *  @brief convert string to hex integer
+ *
+ *  @param s		A pointer string buffer
+ *  @return            	hex integer
+ */
+static u32
+a2hex(s8 * s)
+{
+    u32 val = 0;
+    while (*s && isxdigit(*s)) {
+        val = (val << 4) + hexc2bin(*s++);
+    }
+
+    return val;
+}
+
+/* 
+ *  @brief convert String to integer
+ *  
+ *  @param value	A pointer to string
+ *  @return             integer
+ */
+static u32
+a2hex_or_atoi(s8 * value)
+{
+    if (value[0] == '0' && (value[1] == 'X' || value[1] == 'x'))
+        return a2hex(value + 2);
+    else
+        return atoi(value);
+}
+
+/** 
+ *  @brief convert string to integer
+ * 
+ *  @param ptr		A pointer to data buffer
+ *  @param chr 		A pointer to return integer
+ *  @return      	A pointer to next data field
+ */
+s8 *
+convert2hex(s8 * ptr, u8 * chr)
+{
+    u8 val;
+
+    for (val = 0; *ptr && isxdigit(*ptr); ptr++) {
+        val = (val * 16) + hexval(*ptr);
+    }
+
+    *chr = val;
+
+    return ptr;
+}
+
+/** 
+ *  @brief Get private info.
+ *   
+ *  @param ifname   A pointer to net name
+ *  @return 	    WLAN_STATUS_SUCCESS--success, otherwise --fail
+ */
+static int
+get_private_info(const s8 * ifname)
+{
+    /* This function sends the SIOCGIWPRIV command which is
+     * handled by the kernel. and gets the total number of
+     * private ioctl's available in the host driver.
+     */
+    struct iwreq iwr;
+    int s, ret = WLAN_STATUS_SUCCESS;
+    struct iw_priv_args *pPriv = Priv_args;
+
+    s = socket(PF_INET, SOCK_DGRAM, 0);
+    if (s < 0) {
+        perror("socket[PF_INET,SOCK_DGRAM]");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    memset(&iwr, 0, sizeof(iwr));
+    strncpy(iwr.ifr_name, ifname, IFNAMSIZ);
+    iwr.u.data.pointer = (caddr_t) pPriv;
+    iwr.u.data.length = IW_MAX_PRIV_DEF;
+    iwr.u.data.flags = 0;
+
+    if (ioctl(s, SIOCGIWPRIV, &iwr) < 0) {
+        perror("ioctl[SIOCGIWPRIV]");
+        ret = WLAN_STATUS_FAILURE;
+    } else {
+        /* Return the number of private ioctls */
+        ret = iwr.u.data.length;
+    }
+
+    close(s);
+
+    return ret;
+}
+
+/** 
+ *  @brief Get Sub command ioctl number
+ *   
+ *  @param i        command index
+ *  @param priv_cnt     Total number of private ioctls availabe in driver
+ *  @param ioctl_val    A pointer to return ioctl number
+ *  @param subioctl_val A pointer to return sub-ioctl number
+ *  @return 	        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+marvell_get_subioctl_no(s32 i,
+                        s32 priv_cnt, int *ioctl_val, int *subioctl_val)
+{
+    s32 j;
+
+    if (Priv_args[i].cmd >= SIOCDEVPRIVATE) {
+        *ioctl_val = Priv_args[i].cmd;
+        *subioctl_val = 0;
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    j = -1;
+
+    /* Find the matching *real* ioctl */
+
+    while ((++j < priv_cnt)
+           && ((Priv_args[j].name[0] != '\0') ||
+               (Priv_args[j].set_args != Priv_args[i].set_args) ||
+               (Priv_args[j].get_args != Priv_args[i].get_args))) {
+    }
+
+    /* If not found... */
+    if (j == priv_cnt) {
+        printf("%s: Invalid private ioctl definition for: 0x%x\n",
+               dev_name, Priv_args[i].cmd);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /* Save ioctl numbers */
+    *ioctl_val = Priv_args[j].cmd;
+    *subioctl_val = Priv_args[i].cmd;
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get ioctl number
+ *   
+ *  @param ifname   	A pointer to net name
+ *  @param priv_cmd	A pointer to priv command buffer
+ *  @param ioctl_val    A pointer to return ioctl number
+ *  @param subioctl_val A pointer to return sub-ioctl number
+ *  @return 	        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+marvell_get_ioctl_no(const s8 * ifname,
+                     const s8 * priv_cmd, int *ioctl_val, int *subioctl_val)
+{
+    s32 i;
+    s32 priv_cnt;
+
+    priv_cnt = get_private_info(ifname);
+
+    /* Are there any private ioctls? */
+    if (priv_cnt <= 0) {
+        /* Could skip this message ? */
+        printf("%-8.8s  no private ioctls.\n", ifname);
+    } else {
+        for (i = 0; i < priv_cnt; i++) {
+            if (Priv_args[i].name[0] && !strcmp(Priv_args[i].name, priv_cmd)) {
+                return marvell_get_subioctl_no(i, priv_cnt,
+                                               ioctl_val, subioctl_val);
+            }
+        }
+    }
+
+    return WLAN_STATUS_FAILURE;
+}
+
+/** 
+ *  @brief Retrieve the ioctl and sub-ioctl numbers for the given ioctl string
+ *   
+ *  @param ifname       Private IOCTL string name
+ *  @param ioctl_val    A pointer to return ioctl number
+ *  @param subioctl_val A pointer to return sub-ioctl number
+ *
+ *  @return             WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+get_priv_ioctl(char *ioctl_name, int *ioctl_val, int *subioctl_val)
+{
+    int retval;
+
+    retval = marvell_get_ioctl_no(dev_name,
+                                  ioctl_name, ioctl_val, subioctl_val);
+
+#if 0
+    /* Debug print discovered IOCTL values */
+    printf("ioctl %s: %x, %x\n", ioctl_name, *ioctl_val, *subioctl_val);
+#endif
+
+    return retval;
+}
+
+/** 
+ *  @brief  get range 
+ *   
+ *  @return	WLAN_STATUS_SUCCESS--success, otherwise --fail
+ */
+static int
+get_range(void)
+{
+    struct iw_range *range;
+    struct iwreq iwr;
+    size_t buflen;
+    WCON_HANDLE mhandle, *pHandle = &mhandle;
+
+    buflen = sizeof(struct iw_range) + 500;
+    range = malloc(buflen);
+    if (range == NULL)
+        return WLAN_STATUS_FAILURE;
+    memset(range, 0, buflen);
+
+    memset(pHandle, 0, sizeof(WCON_HANDLE));
+    memset(&iwr, 0, sizeof(struct iwreq));
+
+    iwr.u.data.pointer = (caddr_t) range;
+    iwr.u.data.length = buflen;
+
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+
+    if ((ioctl(sockfd, SIOCGIWRANGE, &iwr)) < 0) {
+        printf("Get Range Results Failed\n");
+        free(range);
+        return WLAN_STATUS_FAILURE;
+    }
+    we_version_compiled = range->we_version_compiled;
+    printf("Driver build with Wireless Extension %d\n",
+           range->we_version_compiled);
+    free(range);
+    return WLAN_STATUS_SUCCESS;
+}
+
+#define WLAN_MAX_RATES	14
+#define	GIGA		1e9
+#define	MEGA		1e6
+#define	KILO		1e3
+
+/** 
+ *  @brief print bit rate
+ *   
+ *  @param rate  	rate to be print
+ *  @param current      if current is TRUE, data rate not need convert
+ *  @param fixed        not used
+ *  @return 	        WLAN_STATUS_SUCCESS
+ */
+static int
+print_bitrate(double rate, s32 current, s32 fixed)
+{
+    s8 scale = 'k', buf[128];
+    s32 divisor = KILO;
+
+    if (!current)
+        rate *= 500000;
+
+    if (rate >= GIGA) {
+        scale = 'G';
+        divisor = GIGA;
+    } else if (rate >= MEGA) {
+        scale = 'M';
+        divisor = MEGA;
+    }
+
+    snprintf(buf, sizeof(buf), "%g %cb/s", rate / divisor, scale);
+
+    if (current) {
+        printf("\t  Current Bit Rate%c%s\n\n", (fixed) ? '=' : ':', buf);
+    } else {
+        printf("\t  %s\n", buf);
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief get hostcmd data
+ *  
+ *  @param fp			A pointer to file stream
+ *  @param ln			A pointer to line number
+ *  @param buf			A pointer to hostcmd data
+ *  @param size			A pointer to the return size of hostcmd buffer
+ *  @return      		WLAN_STATUS_SUCCESS
+ */
+static int
+wlan_get_hostcmd_data(FILE * fp, int *ln, u8 * buf, u16 * size)
+{
+    s32 errors = 0, i;
+    s8 line[256], *pos, *pos1, *pos2, *pos3;
+    u16 len;
+
+    while ((pos = wlan_config_get_line(line, sizeof(line), fp, ln))) {
+        (*ln)++;
+        if (strcmp(pos, "}") == 0) {
+            break;
+        }
+
+        pos1 = strchr(pos, ':');
+        if (pos1 == NULL) {
+            printf("Line %d: Invalid hostcmd line '%s'\n", *ln, pos);
+            errors++;
+            continue;
+        }
+        *pos1++ = '\0';
+
+        pos2 = strchr(pos1, '=');
+        if (pos2 == NULL) {
+            printf("Line %d: Invalid hostcmd line '%s'\n", *ln, pos);
+            errors++;
+            continue;
+        }
+        *pos2++ = '\0';
+
+        len = a2hex_or_atoi(pos1);
+        if (len < 1 || len > MRVDRV_SIZE_OF_CMD_BUFFER) {
+            printf("Line %d: Invalid hostcmd line '%s'\n", *ln, pos);
+            errors++;
+            continue;
+        }
+
+        *size += len;
+
+        if (*pos2 == '"') {
+            pos2++;
+            if ((pos3 = strchr(pos2, '"')) == NULL) {
+                printf("Line %d: invalid quotation '%s'\n", *ln, pos);
+                errors++;
+                continue;
+            }
+            *pos3 = '\0';
+            memset(buf, 0, len);
+            memmove(buf, pos2, MIN(strlen(pos2), len));
+            buf += len;
+        } else if (*pos2 == '\'') {
+            pos2++;
+            if ((pos3 = strchr(pos2, '\'')) == NULL) {
+                printf("Line %d: invalid quotation '%s'\n", *ln, pos);
+                errors++;
+                continue;
+            }
+            *pos3 = ',';
+            for (i = 0; i < len; i++) {
+                if ((pos3 = strchr(pos2, ',')) != NULL) {
+                    *pos3 = '\0';
+                    *buf++ = (u8) a2hex_or_atoi(pos2);
+                    pos2 = pos3 + 1;
+                } else
+                    *buf++ = 0;
+            }
+        } else if (*pos2 == '{') {
+            u16 *tlvlen = (u16 *) buf;
+            wlan_get_hostcmd_data(fp, ln, buf + len, tlvlen);
+            *size += *tlvlen;
+            buf += len + *tlvlen;
+        } else {
+            u32 value = a2hex_or_atoi(pos2);
+            while (len--) {
+                *buf++ = (u8) (value & 0xff);
+                value >>= 8;
+            }
+        }
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Process host_cmd 
+ *  @param argc		number of arguments
+ *  @param argv		A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_host_cmd(int argc, char *argv[])
+{
+    s8 line[256], cmdname[256], *pos;
+    u8 *buf;
+    FILE *fp;
+    HostCmd_DS_GEN *hostcmd;
+    struct iwreq iwr;
+    int ln = 0;
+    int cmdname_found = 0, cmdcode_found = 0;
+    int ret = WLAN_STATUS_SUCCESS;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("hostcmd",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    if (argc < 5) {
+        printf("Error: invalid no of arguments\n");
+        printf
+            ("Syntax: ./wlanconfig eth1 hostcmd <hostcmd.conf> <cmdname>\n");
+        exit(1);
+    }
+
+    if ((fp = fopen(argv[3], "r")) == NULL) {
+        fprintf(stderr, "Cannot open file %s\n", argv[3]);
+        exit(1);
+    }
+
+    buf = (u8 *) malloc(MRVDRV_SIZE_OF_CMD_BUFFER);
+    if (buf == NULL) {
+        printf("Error: allocate memory for hostcmd failed\n");
+        return -ENOMEM;
+    }
+    memset(buf, 0, MRVDRV_SIZE_OF_CMD_BUFFER);
+    hostcmd = (PHostCmd_DS_GEN) buf;
+
+    hostcmd->Command = 0xffff;
+
+    sprintf(cmdname, "%s={", argv[4]);
+    cmdname_found = 0;
+    while ((pos = wlan_config_get_line(line, sizeof(line), fp, &ln))) {
+        if (strcmp(pos, cmdname) == 0) {
+            cmdname_found = 1;
+            sprintf(cmdname, "CmdCode=");
+            cmdcode_found = 0;
+            while ((pos = wlan_config_get_line(line, sizeof(line), fp, &ln))) {
+                if (strncmp(pos, cmdname, strlen(cmdname)) == 0) {
+                    cmdcode_found = 1;
+                    hostcmd->Command = a2hex_or_atoi(pos + strlen(cmdname));
+                    hostcmd->Size = S_DS_GEN;
+                    wlan_get_hostcmd_data(fp, &ln, buf + hostcmd->Size,
+                                          &hostcmd->Size);
+                    break;
+                }
+            }
+            if (!cmdcode_found) {
+                fprintf(stderr,
+                        "wlanconfig: CmdCode not found in file '%s'\n",
+                        argv[3]);
+            }
+            break;
+        }
+    }
+
+    fclose(fp);
+
+    if (!cmdname_found)
+        fprintf(stderr, "wlanconfig: cmdname '%s' not found in file '%s'\n",
+                argv[4], argv[3]);
+
+    if (!cmdname_found || !cmdcode_found) {
+        ret = -1;
+        goto _exit_;
+    }
+
+    buf = (u8 *) hostcmd;
+
+    hostcmd->SeqNum = 0;
+    hostcmd->Result = 0;
+
+    memset(&iwr, 0, sizeof(iwr));
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = (u8 *) hostcmd;
+    iwr.u.data.length = hostcmd->Size;
+
+    iwr.u.data.flags = 0;
+    if (ioctl(sockfd, ioctl_val, &iwr)) {
+        fprintf(stderr, "wlanconfig: WLANHOSTCMD is not supported by %s\n",
+                dev_name);
+        ret = -1;
+        goto _exit_;
+    }
+
+    if (!hostcmd->Result) {
+        switch (hostcmd->Command) {
+        case HostCmd_RET_MEM_ACCESS:
+            {
+                PHostCmd_DS_MEM_ACCESS ma =
+                    (PHostCmd_DS_MEM_ACCESS) (buf + S_DS_GEN);
+                if (ma->Action == HostCmd_ACT_GET) {
+                    printf("Address: %#08lx   Value=%#08lx\n", ma->Addr,
+                           ma->Value);
+                }
+                break;
+            }
+        case HostCmd_RET_802_11_POWER_ADAPT_CFG_EXT:
+            {
+                PHostCmd_DS_802_11_POWER_ADAPT_CFG_EXT pace =
+                    (PHostCmd_DS_802_11_POWER_ADAPT_CFG_EXT) (buf + S_DS_GEN);
+                int i, j;
+                printf("EnablePA=%#04x\n", pace->EnablePA);
+                for (i = 0;
+                     i <
+                     pace->PowerAdaptGroup.Header.Len / sizeof(PA_Group_t);
+                     i++) {
+                    printf("PA Group #%d: level=%ddbm, Rate Bitmap=%#04x (",
+                           i,
+                           pace->PowerAdaptGroup.PA_Group[i].PowerAdaptLevel,
+                           pace->PowerAdaptGroup.PA_Group[i].RateBitmap);
+                    for (j =
+                         8 *
+                         sizeof(pace->PowerAdaptGroup.PA_Group[i].
+                                RateBitmap) - 1; j >= 0; j--) {
+                        if ((j == 4) || (j >= 13))      // reserved
+                            continue;
+                        if (pace->PowerAdaptGroup.PA_Group[i].
+                            RateBitmap & (1 << j))
+                            printf("%s ", rate_bitmap[j]);
+                    }
+                    printf("Mbps)\n");
+                }
+                break;
+            }
+        case HostCmd_RET_802_11_SUBSCRIBE_EVENT:
+            {
+                HostCmd_DS_802_11_SUBSCRIBE_EVENT *se =
+                    (HostCmd_DS_802_11_SUBSCRIBE_EVENT *) (buf + S_DS_GEN);
+                if (se->Action == HostCmd_ACT_GET) {
+                    int len =
+                        S_DS_GEN + sizeof(HostCmd_DS_802_11_SUBSCRIBE_EVENT);
+                    printf("\nEvent\t\tValue\tFreq\tsubscribed\n\n");
+                    while (len < hostcmd->Size) {
+                        MrvlIEtypesHeader_t *header =
+                            (MrvlIEtypesHeader_t *) (buf + len);
+                        switch (header->Type) {
+                        case TLV_TYPE_RSSI_LOW:
+                            {
+                                MrvlIEtypes_RssiParamSet_t *LowRssi =
+                                    (MrvlIEtypes_RssiParamSet_t *) (buf +
+                                                                    len);
+                                printf("Low RSSI\t%d\t%d\t%s\n",
+                                       LowRssi->RSSIValue, LowRssi->RSSIFreq,
+                                       (se->Events & 0x0001) ? "yes" : "no");
+                                len += sizeof(MrvlIEtypes_RssiParamSet_t);
+                                break;
+                            }
+                        case TLV_TYPE_SNR_LOW:
+                            {
+                                MrvlIEtypes_SnrThreshold_t *LowSnr =
+                                    (MrvlIEtypes_SnrThreshold_t *) (buf +
+                                                                    len);
+                                printf("Low SNR\t\t%d\t%d\t%s\n",
+                                       LowSnr->SNRValue, LowSnr->SNRFreq,
+                                       (se->Events & 0x0002) ? "yes" : "no");
+                                len += sizeof(MrvlIEtypes_SnrThreshold_t);
+                                break;
+                            }
+                        case TLV_TYPE_FAILCOUNT:
+                            {
+                                MrvlIEtypes_FailureCount_t *FailureCount =
+                                    (MrvlIEtypes_FailureCount_t *) (buf +
+                                                                    len);
+                                printf("Failure Count\t%d\t%d\t%s\n",
+                                       FailureCount->FailValue,
+                                       FailureCount->FailFreq,
+                                       (se->Events & 0x0004) ? "yes" : "no");
+                                len += sizeof(MrvlIEtypes_FailureCount_t);
+                                break;
+                            }
+                        case TLV_TYPE_BCNMISS:
+                            {
+                                MrvlIEtypes_BeaconsMissed_t *BcnMissed =
+                                    (MrvlIEtypes_BeaconsMissed_t *) (buf +
+                                                                     len);
+                                printf("Beacon Missed\t%d\tN/A\t%s\n",
+                                       BcnMissed->BeaconMissed,
+                                       (se->Events & 0x0008) ? "yes" : "no");
+                                len += sizeof(MrvlIEtypes_BeaconsMissed_t);
+                                break;
+                            }
+                        case TLV_TYPE_RSSI_HIGH:
+                            {
+                                MrvlIEtypes_RssiParamSet_t *HighRssi =
+                                    (MrvlIEtypes_RssiParamSet_t *) (buf +
+                                                                    len);
+                                printf("High RSSI\t%d\t%d\t%s\n",
+                                       HighRssi->RSSIValue,
+                                       HighRssi->RSSIFreq,
+                                       (se->Events & 0x0010) ? "yes" : "no");
+                                len += sizeof(MrvlIEtypes_RssiParamSet_t);
+                                break;
+                            }
+                        case TLV_TYPE_SNR_HIGH:
+                            {
+                                MrvlIEtypes_SnrThreshold_t *HighSnr =
+                                    (MrvlIEtypes_SnrThreshold_t *) (buf +
+                                                                    len);
+                                printf("High SNR\t%d\t%d\t%s\n",
+                                       HighSnr->SNRValue, HighSnr->SNRFreq,
+                                       (se->Events & 0x0020) ? "yes" : "no");
+                                len += sizeof(MrvlIEtypes_SnrThreshold_t);
+                                break;
+                            }
+                        default:
+                            printf
+                                ("unknown subscribed event TLV Type=%#x, Len=%d\n",
+                                 header->Type, header->Len);
+                            len += sizeof(MrvlIEtypesHeader_t) + header->Len;
+                            break;
+                        }
+                    }
+                }
+                break;
+            }
+        case HostCmd_RET_802_11_AUTO_TX:
+            {
+                PHostCmd_DS_802_11_AUTO_TX at =
+                    (PHostCmd_DS_802_11_AUTO_TX) (buf + S_DS_GEN);
+                if (at->Action == HostCmd_ACT_GET) {
+                    if (S_DS_GEN + sizeof(at->Action) == hostcmd->Size) {
+                        printf("auto_tx not configured\n");
+                    } else {
+                        MrvlIEtypesHeader_t *header = &at->AutoTx.Header;
+                        if ((S_DS_GEN + sizeof(at->Action) +
+                             sizeof(MrvlIEtypesHeader_t) + header->Len ==
+                             hostcmd->Size) &&
+                            (header->Type == TLV_TYPE_AUTO_TX)) {
+                            AutoTx_MacFrame_t *atmf =
+                                &at->AutoTx.AutoTx_MacFrame;
+
+                            printf("Interval: %d second(s)\n",
+                                   atmf->Interval);
+                            printf("Priority: %#x\n", atmf->Priority);
+
+                            printf("Frame Length: %d\n", atmf->FrameLen);
+                            printf
+                                ("Dest Mac Address: %02x:%02x:%02x:%02x:%02x:%02x\n",
+                                 atmf->DestMacAddr[0], atmf->DestMacAddr[1],
+                                 atmf->DestMacAddr[2], atmf->DestMacAddr[3],
+                                 atmf->DestMacAddr[4], atmf->DestMacAddr[5]);
+                            printf
+                                ("Src Mac Address: %02x:%02x:%02x:%02x:%02x:%02x\n",
+                                 atmf->SrcMacAddr[0], atmf->SrcMacAddr[1],
+                                 atmf->SrcMacAddr[2], atmf->SrcMacAddr[3],
+                                 atmf->SrcMacAddr[4], atmf->SrcMacAddr[5]);
+
+                            hexdump("Frame Payload", atmf->Payload,
+                                    atmf->FrameLen - ETH_ALEN * 2, ' ');
+                        } else {
+                            printf("incorrect auto_tx command response\n");
+                        }
+                    }
+                }
+                break;
+            }
+        default:
+            printf("HOSTCMD_RESP: ReturnCode=%#04x, Result=%#04x\n",
+                   hostcmd->Command, hostcmd->Result);
+            break;
+        }
+    } else {
+        printf("HOSTCMD failed: ReturnCode=%#04x, Result=%#04x\n",
+               hostcmd->Command, hostcmd->Result);
+    }
+
+  _exit_:
+    if (buf)
+        free(buf);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Rate
+ *   
+ *  @return      WLAN_STATUS_SUCCESS--success, otherwise --fail
+ */
+static int
+process_get_rate(void)
+{
+    u32 bitrate[WLAN_MAX_RATES];
+    struct iwreq iwr;
+    s32 i = 0;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("getrate",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    memset(&iwr, 0, sizeof(iwr));
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = (caddr_t) bitrate;
+    iwr.u.data.length = sizeof(bitrate);
+    iwr.u.data.flags = subioctl_val;
+
+    if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+        perror("wlanconfig");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    printf("%-8.16s  %d available bit-rates :\n",
+           dev_name, iwr.u.data.length);
+
+    for (i = 0; i < iwr.u.data.length; i++) {
+        print_bitrate(bitrate[i], 0, 0);
+    }
+
+    if (ioctl(sockfd, SIOCGIWRATE, &iwr)) {
+        perror("wlanconfig");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    print_bitrate(iwr.u.bitrate.value, 1, iwr.u.bitrate.fixed);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Check the Hex String
+ *  @param s		A pointer to the string      
+ *  @return      	0--HexString, -1--not HexString
+ */
+static int
+ishexstring(s8 * s)
+{
+    int ret = -1;
+    s32 tmp;
+
+    while (*s) {
+        tmp = toupper(*s);
+        if (tmp >= 'A' && tmp <= 'F') {
+            ret = 0;
+            break;
+        }
+        s++;
+    }
+
+    return ret;
+}
+
+/** 
+ *  @brief Convert String to Integer
+ *  @param buf		A pointer to the string      
+ *  @return      	Integer
+ */
+static int
+atoval(s8 * buf)
+{
+    if (!strncasecmp(buf, "0x", 2))
+        return a2hex(buf + 2);
+    else if (!ishexstring(buf))
+        return a2hex(buf);
+    else
+        return atoi(buf);
+}
+
+/** 
+ *  @brief Display sleep params
+ *  @param sp		A pointer to wlan_ioctl_sleep_params_config structure    
+ *  @return      	NA
+ */
+void
+display_sleep_params(wlan_ioctl_sleep_params_config * sp)
+{
+    printf("Sleep Params for %s:\n", sp->Action ? "set" : "get");
+    printf("----------------------------------------\n");
+    printf("Error		: %u\n", sp->Error);
+    printf("Offset		: %u\n", sp->Offset);
+    printf("StableTime	: %u\n", sp->StableTime);
+    printf("CalControl	: %u\n", sp->CalControl);
+    printf("ExtSleepClk	: %u\n", sp->ExtSleepClk);
+    printf("Reserved	: %u\n", sp->Reserved);
+}
+
+/** 
+ *  @brief Process sleep params
+ *  @param argc		number of arguments
+ *  @param argv         A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_sleep_params(int argc, char *argv[])
+{
+    struct iwreq iwr;
+    int ret;
+    wlan_ioctl_sleep_params_config sp;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("sleepparams",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    if (argc < 4) {
+        printf("Error: invalid no of arguments\n");
+        printf("Syntax: ./wlanconfig eth1 sleepparams get/set <p1>"
+               " <p2> <p3> <p4> <p5> <p6>\n");
+        exit(1);
+    }
+
+    memset(&sp, 0, sizeof(wlan_ioctl_sleep_params_config));
+    if (!strcmp(argv[3], "get")) {
+        sp.Action = 0;
+    } else if (!strncmp(argv[3], "set", 3)) {
+        if (argc != 10) {
+            printf("Error: invalid no of arguments\n");
+            printf("Syntax: ./wlanconfig eth1 sleepparams get/set"
+                   "<p1> <p2> <p3> <p4> <p5> <p6>\n");
+            exit(1);
+        }
+
+        sp.Action = 1;
+        if ((ret = atoval(argv[4])) < 0)
+            return -EINVAL;
+        sp.Error = (u16) ret;
+        if ((ret = atoval(argv[5])) < 0)
+            return -EINVAL;
+        sp.Offset = (u16) ret;
+        if ((ret = atoval(argv[6])) < 0)
+            return -EINVAL;
+        sp.StableTime = (u16) ret;
+        if ((ret = atoval(argv[7])) < 0)
+            return -EINVAL;
+        sp.CalControl = (u8) ret;
+        if ((ret = atoval(argv[8])) < 0)
+            return -EINVAL;
+        sp.ExtSleepClk = (u8) ret;
+        if ((ret = atoval(argv[9])) < 0)
+            return -EINVAL;
+        sp.Reserved = (u16) ret;
+    } else {
+        return -EINVAL;
+    }
+
+    memset(&iwr, 0, sizeof(iwr));
+
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = (caddr_t) & sp;
+    iwr.u.data.length = sizeof(wlan_ioctl_sleep_params_config);
+    iwr.u.data.flags = subioctl_val;
+
+    if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+        perror("wlanconfig");
+        return -1;
+    }
+
+    display_sleep_params(&sp);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Display BCA Time Share Params
+ *  @param sp		A point to wlan_ioctl_bca_timeshare_config structure    
+ *  @return      	NA
+ */
+static void
+display_bca_ts_params(wlan_ioctl_bca_timeshare_config * bca_ts)
+{
+    printf("BCA Time Share Params for %s:\n", bca_ts->Action ? "set" : "get");
+    printf("----------------------------------------\n");
+    printf("TrafficType		: %u\n", bca_ts->TrafficType);
+    printf("TimeShareInterval	: %lu\n", bca_ts->TimeShareInterval);
+    printf("BTTime			: %lu\n", bca_ts->BTTime);
+}
+
+/** 
+ *  @brief Process BCA Time Share Params
+ *  @param argc		number of arguments
+ *  @param argv         A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_bca_ts(int argc, char *argv[])
+{
+    int ret, i;
+    struct iwreq iwr;
+    wlan_ioctl_bca_timeshare_config bca_ts;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("bca-ts",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    if (argc < 5) {
+        printf("Error: invalid no of arguments\n");
+        printf("Syntax: ./wlanconfig eth1 bca_ts get/set <p1>"
+               " <p2> <p3>\n");
+        exit(1);
+    }
+
+    memset(&bca_ts, 0, sizeof(wlan_ioctl_bca_timeshare_config));
+
+    if ((ret = atoval(argv[4])) < 0)
+        return -EINVAL;
+    if (ret > 1)
+        return -EINVAL;
+    bca_ts.TrafficType = (u16) ret;     // 0 or 1
+
+    if (!strcmp(argv[3], "get")) {
+        bca_ts.Action = 0;
+    } else if (!strncmp(argv[3], "set", 3)) {
+        if (argc != 7) {
+            printf("Error: invalid no of arguments\n");
+            printf("Syntax: ./wlanconfig eth1 bca_ts get/set"
+                   " <p1> <p2> <p3>\n");
+            exit(1);
+        }
+
+        bca_ts.Action = 1;
+
+        if ((ret = atoval(argv[5])) < 0)
+            return -EINVAL;
+        /* If value is not multiple of 10 then take the floor value */
+        i = ret % 10;
+        ret -= i;
+        /* Valid Range for TimeShareInterval: < 20 ... 60_000 > ms */
+        if (ret < 20 || ret > 60000) {
+            printf("Invalid TimeShareInterval Range:"
+                   " < 20 ... 60000 > ms\n");
+            return -EINVAL;
+        }
+        bca_ts.TimeShareInterval = (u32) ret;
+
+        if ((ret = atoval(argv[6])) < 0)
+            return -EINVAL;
+        /* If value is not multiple of 10 then take the floor value */
+        i = ret % 10;
+        ret -= i;
+
+        if (ret > bca_ts.TimeShareInterval) {
+            printf("Invalid BTTime"
+                   "  Range: < 0 .. TimeShareInterval > ms\n");
+            return -EINVAL;
+        }
+        bca_ts.BTTime = (u32) ret;
+    } else {
+        return -EINVAL;
+    }
+
+    memset(&iwr, 0, sizeof(iwr));
+
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = (caddr_t) & bca_ts;
+    iwr.u.data.length = sizeof(wlan_ioctl_bca_timeshare_config);
+    iwr.u.data.flags = subioctl_val;
+
+    if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+        perror("wlanconfig");
+        return -1;
+    }
+
+    display_bca_ts_params(&bca_ts);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Process reassoication
+ *
+ *  @param argc     number of arguments
+ *  @param argv     A pointer to arguments array    
+ *
+ *  @return         WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_reassociation(int argc, char *argv[])
+{
+    wlan_ioctl_reassociation_info reassocInfo;
+    struct iwreq iwr;
+    unsigned int mac[MRVDRV_ETH_ADDR_LEN];
+    u32 idx;
+    s32 numToks;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("reassociate",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    /*
+     * Reassociation request is expected to be in the following format:
+     *
+     *      <xx:xx:xx:xx:xx:xx>      <yy:yy:yy:yy:yy:yy>  <ssid string>
+     *
+     *      where xx..xx is the current AP BSSID to be included in the reassoc req
+     *                yy..yy is the desired AP to send the reassoc req to
+     *                <ssid string> is the desired AP SSID to send the reassoc req to.
+     *
+     *      The current and desired AP BSSIDs are required.  
+     *      The SSID string can be omitted if the desired BSSID is provided.
+     *
+     *      If we fail to find the desired BSSID, we attempt the SSID.
+     *      If the desired BSSID is set to all 0's, the ssid string is used.
+     *      
+     */
+
+    /* Verify the number of arguments is either 5 or 6 */
+    if (argc != 5 && argc != 6) {
+        fprintf(stderr, "Invalid number of parameters!\n");
+        return -EINVAL;
+    }
+
+    memset(&iwr, 0, sizeof(iwr));
+    memset(&reassocInfo, 0x00, sizeof(reassocInfo));
+
+    /*
+     *      Scan in and set the current AP BSSID
+     */
+    numToks = sscanf(argv[3], "%2x:%2x:%2x:%2x:%2x:%2x",
+                     mac + 0, mac + 1, mac + 2, mac + 3, mac + 4, mac + 5);
+
+    if (numToks != 6) {
+        fprintf(stderr, "Invalid number of parameters!\n");
+        return -EINVAL;
+    }
+
+    for (idx = 0; idx < NELEMENTS(mac); idx++) {
+        reassocInfo.CurrentBSSID[idx] = (u8) mac[idx];
+    }
+
+    /*
+     *      Scan in and set the desired AP BSSID
+     */
+    numToks = sscanf(argv[4], "%2x:%2x:%2x:%2x:%2x:%2x",
+                     mac + 0, mac + 1, mac + 2, mac + 3, mac + 4, mac + 5);
+
+    if (numToks != 6) {
+        fprintf(stderr, "Invalid number of parameters!\n");
+        return -EINVAL;
+    }
+
+    for (idx = 0; idx < NELEMENTS(mac); idx++) {
+        reassocInfo.DesiredBSSID[idx] = (u8) mac[idx];
+    }
+
+    /*
+     * If the ssid string is provided, save it; otherwise it is an empty string
+     */
+    if (argc == 6) {
+        strcpy(reassocInfo.DesiredSSID, argv[5]);
+    }
+
+    /* 
+     * Set up and execute the ioctl call
+     */
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = (caddr_t) & reassocInfo;
+    iwr.u.data.length = sizeof(reassocInfo);
+    iwr.u.data.flags = subioctl_val;
+
+    if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+        perror("wlanconfig: reassociate ioctl");
+        return -EFAULT;
+    }
+
+    /* No error return */
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Provision the driver with a IEEE IE for use in the next join cmd
+ *
+ *    Test function used to check the ioctl and driver funcionality 
+ *  
+ *  @return WLAN_STATUS_SUCCESS or ioctl error code
+ */
+static int
+process_setgenie(void)
+{
+    int ioctl_val, subioctl_val;
+    struct iwreq iwr;
+
+    u8 testIE[] = { 0xdd, 0x09,
+        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99
+    };
+
+    if (get_priv_ioctl("setgenie",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = (caddr_t) testIE;
+    iwr.u.data.length = sizeof(testIE);
+    iwr.u.data.flags = subioctl_val;
+
+    if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+        perror("wlanconfig: setgenie ioctl");
+        return -EFAULT;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Retrieve and display the contents of the driver scan table.
+ *
+ *  The ioctl to retrieve the scan table contents will be invoked, and portions
+ *   of the scan data will be displayed on stdout.  The entire beacon or 
+ *   probe response is also retrieved (if available in the driver).  This 
+ *   data would be needed in case the application was explicitly controlling
+ *   the association (inserting IEs, TLVs, etc).
+ *
+ *  @param argc     number of arguments
+ *  @param argv     A pointer to arguments array    
+ *
+ *  @return         WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_getscantable(int argc, char *argv[])
+{
+    int ioctl_val, subioctl_val;
+    struct iwreq iwr;
+    u8 scanRspBuffer[500];      /* Stack buffer can be as large as ioctl allows */
+
+    uint scanStart;
+    uint idx;
+
+    u8 *pCurrent;
+    u8 *pNext;
+    IEEEtypes_ElementId_e *pElementId;
+    u8 *pElementLen;
+    int bssInfoLen;
+    int ssidIdx;
+    u16 tmpCap;
+    u8 *pByte;
+
+    IEEEtypes_CapInfo_t capInfo;
+    u8 tsf[8];
+    u16 beaconInterval;
+
+    wlan_ioctl_get_scan_table_info *pRspInfo;
+    wlan_ioctl_get_scan_table_entry *pRspEntry;
+
+    pRspInfo = (wlan_ioctl_get_scan_table_info *) scanRspBuffer;
+
+    if (get_priv_ioctl("getscantable",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    scanStart = 0;
+
+    printf("---------------------------------------");
+    printf("---------------------------------------\n");
+    printf("# | ch  | ss  |       bssid       |   cap    |   SSID \n");
+    printf("---------------------------------------");
+    printf("---------------------------------------\n");
+
+    do {
+        pRspInfo->scanNumber = scanStart;
+
+        /* 
+         * Set up and execute the ioctl call
+         */
+        strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+        iwr.u.data.pointer = (caddr_t) pRspInfo;
+        iwr.u.data.length = sizeof(scanRspBuffer);
+        iwr.u.data.flags = subioctl_val;
+
+        if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+            perror("wlanconfig: getscantable ioctl");
+            return -EFAULT;
+        }
+
+        pCurrent = 0;
+        pNext = pRspInfo->scan_table_entry_buffer;
+
+        for (idx = 0; idx < pRspInfo->scanNumber; idx++) {
+
+            /* 
+             * Set pCurrent to pNext in case pad bytes are at the end
+             *   of the last IE we processed.
+             */
+            pCurrent = pNext;
+
+            pRspEntry = (wlan_ioctl_get_scan_table_entry *) pCurrent;
+
+            printf("%02u| %03d | %03d | %02x:%02x:%02x:%02x:%02x:%02x |",
+                   scanStart + idx,
+                   pRspEntry->fixedFields.channel,
+                   pRspEntry->fixedFields.rssi,
+                   pRspEntry->fixedFields.bssid[0],
+                   pRspEntry->fixedFields.bssid[1],
+                   pRspEntry->fixedFields.bssid[2],
+                   pRspEntry->fixedFields.bssid[3],
+                   pRspEntry->fixedFields.bssid[4],
+                   pRspEntry->fixedFields.bssid[5]);
+
+#if 0
+            printf("fixed = %u, bssInfo = %u\n",
+                   (unsigned int) pRspEntry->fixedFieldLength,
+                   (unsigned int) pRspEntry->bssInfoLength);
+#endif
+
+            pCurrent += (sizeof(pRspEntry->fixedFieldLength) +
+                         pRspEntry->fixedFieldLength);
+
+            bssInfoLen = pRspEntry->bssInfoLength;
+            pCurrent += sizeof(pRspEntry->bssInfoLength);
+            pNext = pCurrent + pRspEntry->bssInfoLength;
+
+            if (bssInfoLen >= (sizeof(tsf)
+                               + sizeof(beaconInterval) + sizeof(capInfo))) {
+                /* time stamp is 8 byte long */
+                memcpy(tsf, pCurrent, sizeof(tsf));
+                pCurrent += sizeof(tsf);
+                bssInfoLen -= sizeof(tsf);
+
+                /* beacon interval is 2 byte long */
+                memcpy(&beaconInterval, pCurrent, sizeof(beaconInterval));
+                pCurrent += sizeof(beaconInterval);
+                bssInfoLen -= sizeof(beaconInterval);
+
+                /* capability information is 2 byte long */
+                memcpy(&capInfo, pCurrent, sizeof(capInfo));
+                memcpy(&tmpCap, pCurrent, sizeof(tmpCap));
+                pCurrent += sizeof(capInfo);
+                bssInfoLen -= sizeof(capInfo);
+
+                printf(" %04x-", tmpCap);
+
+                printf("%c%c%c | ",
+                       capInfo.Ibss ? 'A' : 'I',
+                       capInfo.Privacy ? 'P' : ' ',
+                       capInfo.SpectrumMgmt ? 'S' : ' ');
+            } else {
+                printf("          | ");
+            }
+
+            while (bssInfoLen >= 2) {
+                pElementId = (IEEEtypes_ElementId_e *) pCurrent;
+                pElementLen = pCurrent + 1;
+                pCurrent += 2;
+
+                switch (*pElementId) {
+
+                case SSID:
+                    if (*pElementLen &&
+                        *pElementLen <= MRVDRV_MAX_SSID_LENGTH) {
+                        for (ssidIdx = 0; ssidIdx < *pElementLen; ssidIdx++) {
+                            if (isprint(*(pCurrent + ssidIdx))) {
+                                printf("%c", *(pCurrent + ssidIdx));
+                            } else {
+                                printf("\\%02x", *(pCurrent + ssidIdx));
+                            }
+                        }
+                    }
+                    break;
+
+                default:
+#if 0
+                    printf("% d(%d), bil=%d\n",
+                           *pElementId, *pElementLen, bssInfoLen);
+#endif
+                    break;
+                }
+
+                pCurrent += *pElementLen;
+                bssInfoLen -= (2 + *pElementLen);
+            }
+
+            printf("\n");
+
+            if (argc > 3) {
+                /* TSF is a u64, some formatted printing libs have
+                 *   trouble printing long longs, so cast and dump as bytes
+                 */
+                pByte = (u8 *) & pRspEntry->fixedFields.networkTSF;
+                printf("    TSF=%02x%02x%02x%02x%02x%02x%02x%02x\n",
+                       pByte[7], pByte[6], pByte[5], pByte[4],
+                       pByte[3], pByte[2], pByte[1], pByte[0]);
+            }
+        }
+
+        scanStart += pRspInfo->scanNumber;
+
+    } while (pRspInfo->scanNumber);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Request a scan from the driver and display the scan table afterwards
+ *
+ *  Command line interface for performing a specific immediate scan based
+ *    on the following keyword parsing:
+ *
+ *     chan=[chan#][band][mode] where band is [a,b,g] and mode is 
+ *                              blank for active or 'p' for passive
+ *     bssid=xx:xx:xx:xx:xx:xx  specify a BSSID filter for the scan
+ *     ssid="[SSID]"            specify a SSID filter for the scan
+ *     keep=[0 or 1]            keep the previous scan results (1), discard (0)
+ *     dur=[scan time]          time to scan for each channel in milliseconds
+ *     probes=[#]               number of probe requests to send on each chan
+ *     type=[1,2,3]             BSS type: 1 (Infra), 2(Adhoc), 3(Any)
+ *
+ *  Any combination of the above arguments can be supplied on the command line.
+ *    If the chan token is absent, a full channel scan will be completed by 
+ *    the driver.  If the dur or probes tokens are absent, the driver default
+ *    setting will be used.  The bssid and ssid fields, if blank, 
+ *    will produce an unfiltered scan. The type field will default to 3 (Any)
+ *    and the keep field will default to 0 (Discard).  
+ *
+ *  @param argc     number of arguments
+ *  @param argv     A pointer to arguments array    
+ *
+ *  @return         WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_setuserscan(int argc, char *argv[])
+{
+    wlan_ioctl_user_scan_cfg scanReq;
+    int ioctl_val, subioctl_val;
+    struct iwreq iwr;
+    char *pArgTok;
+    char *pChanTok;
+    char *pArgCookie;
+    char *pChanCookie;
+    int argIdx;
+    int chanParseIdx;
+    int chanCmdIdx;
+    char chanScratch[10];
+    char *pScratch;
+    int tmpIdx;
+    unsigned int mac[MRVDRV_ETH_ADDR_LEN];
+    int scanTime;
+
+    memset(&scanReq, 0x00, sizeof(scanReq));
+    chanCmdIdx = 0;
+    scanTime = 0;
+
+    if (get_priv_ioctl("setuserscan",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    for (argIdx = 0; argIdx < argc; argIdx++) {
+        if (strncmp(argv[argIdx], "chan=", strlen("chan=")) == 0) {
+            /* 
+             *  "chan" token string handler
+             */
+            pArgTok = argv[argIdx] + strlen("chan=");
+
+            while ((pArgTok = strtok_r(pArgTok, ",", &pArgCookie)) != NULL) {
+
+                memset(chanScratch, 0x00, sizeof(chanScratch));
+                pScratch = chanScratch;
+
+                for (chanParseIdx = 0;
+                     chanParseIdx < strlen(pArgTok); chanParseIdx++) {
+                    if (isalpha(*(pArgTok + chanParseIdx))) {
+                        *pScratch++ = ' ';
+                    }
+
+                    *pScratch++ = *(pArgTok + chanParseIdx);
+                }
+                *pScratch = 0;
+                pArgTok = NULL;
+
+                pChanTok = chanScratch;
+
+                while ((pChanTok = strtok_r(pChanTok, " ",
+                                            &pChanCookie)) != NULL) {
+                    if (isdigit(*pChanTok)) {
+                        scanReq.chanList[chanCmdIdx].chanNumber
+                            = atoi(pChanTok);
+                    } else {
+                        switch (toupper(*pChanTok)) {
+                        case 'A':
+                            scanReq.chanList[chanCmdIdx].radioType = 1;
+                            break;
+                        case 'B':
+                        case 'G':
+                            scanReq.chanList[chanCmdIdx].radioType = 0;
+                            break;
+                        case 'P':
+                            scanReq.chanList[chanCmdIdx].scanType = 1;
+                            break;
+                        }
+                    }
+                    pChanTok = NULL;
+                }
+                chanCmdIdx++;
+            }
+        } else if (strncmp(argv[argIdx], "bssid=", strlen("bssid=")) == 0) {
+            /* 
+             *  "bssid" token string handler
+             */
+            sscanf(argv[argIdx] + strlen("bssid="), "%2x:%2x:%2x:%2x:%2x:%2x",
+                   mac + 0, mac + 1, mac + 2, mac + 3, mac + 4, mac + 5);
+
+            for (tmpIdx = 0; tmpIdx < NELEMENTS(mac); tmpIdx++) {
+                scanReq.specificBSSID[tmpIdx] = (u8) mac[tmpIdx];
+            }
+        } else if (strncmp(argv[argIdx], "keep=", strlen("keep=")) == 0) {
+            /* 
+             *  "keep" token string handler
+             */
+            scanReq.keepPreviousScan = atoi(argv[argIdx] + strlen("keep="));
+        } else if (strncmp(argv[argIdx], "dur=", strlen("dur=")) == 0) {
+            /* 
+             *  "dur" token string handler
+             */
+            scanTime = atoi(argv[argIdx] + strlen("dur="));
+        } else if (strncmp(argv[argIdx], "ssid=", strlen("ssid=")) == 0) {
+            /* 
+             *  "ssid" token string handler
+             */
+            strncpy(scanReq.specificSSID, argv[argIdx] + strlen("ssid="),
+                    sizeof(scanReq.specificSSID));
+        } else if (strncmp(argv[argIdx], "probes=", strlen("probes=")) == 0) {
+            /* 
+             *  "probes" token string handler
+             */
+            scanReq.numProbes = atoi(argv[argIdx] + strlen("probes="));
+        } else if (strncmp(argv[argIdx], "type=", strlen("type=")) == 0) {
+            /* 
+             *  "type" token string handler
+             */
+            scanReq.bssType = atoi(argv[argIdx] + strlen("type="));
+            switch (scanReq.bssType) {
+            case WLAN_SCAN_BSS_TYPE_BSS:
+            case WLAN_SCAN_BSS_TYPE_IBSS:
+                break;
+
+            default:
+            case WLAN_SCAN_BSS_TYPE_ANY:
+                /* Set any unknown types to ANY */
+                scanReq.bssType = WLAN_SCAN_BSS_TYPE_ANY;
+            }
+        }
+    }
+
+    /*
+     * Update all the channels to have the same scan time
+     */
+    for (tmpIdx = 0; tmpIdx < chanCmdIdx; tmpIdx++) {
+        scanReq.chanList[tmpIdx].scanTime = scanTime;
+    }
+
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = (caddr_t) & scanReq;
+    iwr.u.data.length = sizeof(scanReq);
+    iwr.u.data.flags = subioctl_val;
+
+    if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+        perror("wlanconfig: setuserscan ioctl");
+        return -EFAULT;
+    }
+
+    process_getscantable(0, 0);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Provision the driver with a Marvell TLV for use in the next join cmd
+ *
+ *    Test function used to check the ioctl and driver funcionality 
+ *  
+ *  @return WLAN_STATUS_SUCCESS or ioctl error code
+ */
+static int
+process_setmrvltlv(void)
+{
+    int ioctl_val, subioctl_val;
+    struct iwreq iwr;
+
+    u8 testTlv[] = { 0x0A, 0x01, 0x0C, 0x00,
+        0xdd, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
+    };
+
+    if (get_priv_ioctl("setmrvltlv",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = (caddr_t) testTlv;
+    iwr.u.data.length = sizeof(testTlv);
+    iwr.u.data.flags = subioctl_val;
+
+    if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+        perror("wlanconfig: setmrvltlv ioctl");
+        return -EFAULT;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Retrieve the association response from the driver
+ *
+ *  Retrieve the buffered (re)association management frame from the driver.
+ *    The response is identical to the one received from the AP and conforms
+ *    to the IEEE specification.
+ *
+ *  @return WLAN_STATUS_SUCCESS or ioctl error code
+ */
+static int
+process_getassocrsp(void)
+{
+    int ioctl_val, subioctl_val;
+    struct iwreq iwr;
+    u8 assocRspBuffer[500];     /* Stack buffer can be as large as ioctl allows */
+    IEEEtypes_AssocRsp_t *pAssocRsp;
+
+    pAssocRsp = (IEEEtypes_AssocRsp_t *) assocRspBuffer;
+
+    if (get_priv_ioctl("getassocrsp",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = (caddr_t) assocRspBuffer;
+    iwr.u.data.length = sizeof(assocRspBuffer);
+    iwr.u.data.flags = subioctl_val;
+
+    if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+        perror("wlanconfig: getassocrsp ioctl");
+        return -EFAULT;
+    }
+
+    if (iwr.u.data.length) {
+        printf("getassocrsp: Status[%d], Cap[0x%04x]: ",
+               pAssocRsp->StatusCode, *(u16 *) & pAssocRsp->Capability);
+        hexdump(NULL, assocRspBuffer, iwr.u.data.length, ' ');
+    } else {
+        printf("getassocrsp: <empty>\n");
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief scan network with specific ssid
+ *  @param argc		number of arguments
+ *  @param argv         A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_extscan(int argc, char *argv[])
+{
+    struct iwreq iwr;
+    WCON_SSID Ssid;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("extscan",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    if (argc != 4) {
+        printf("Error: invalid no of arguments\n");
+        printf("Syntax: ./wlanconfig eth1 extscan <SSID>\n");
+        exit(1);
+    }
+
+    printf("Ssid: %s\n", argv[3]);
+
+    memset(&Ssid, 0, sizeof(Ssid));
+    memset(&iwr, 0, sizeof(iwr));
+
+    Ssid.ssid_len = strlen(argv[3]);
+    memcpy(Ssid.ssid, argv[3], Ssid.ssid_len);
+
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = (caddr_t) & Ssid;
+    iwr.u.data.length = sizeof(Ssid);
+    iwr.u.data.flags = subioctl_val;
+
+    if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+        perror("wlanconfig");
+        return -1;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+#if WIRELESS_EXT > 14
+/** 
+ *  @brief parse custom info
+ *  @param pHandle	A pointer to WCON_HANDLE
+ *  @param data         A pointer to iw_point structure
+ *  @param idx          AP index
+ *  @return      	NA
+ */
+static void
+parse_custom_info(WCON_HANDLE * pHandle, struct iw_point *data, s32 idx)
+{
+    s32 i = 0;
+    s8 *custom_cmd[] = { "wpa_ie", "rsn_ie", NULL };
+
+    if (!data->pointer || !data->length) {
+        printf("iw_point: Invalid Pointer/Length\n");
+        return;
+    }
+
+    if (!strncmp(data->pointer, "wmm_ie", strlen("wmm_ie"))) {
+        pHandle->ScanList[idx].Wmm = WCON_WMM_ENABLED;
+    }
+
+    while (custom_cmd[i]) {
+        if (!strncmp(data->pointer, custom_cmd[i], strlen(custom_cmd[i]))) {
+            pHandle->ScanList[idx].WpaAP = WCON_WPA_ENABLED;
+            break;
+        }
+        i++;
+    }
+
+    printf("Wpa:\t %s\n", pHandle->ScanList[idx].WpaAP ?
+           "enabled" : "disabled");
+    printf("Wmm:\t %s\n", pHandle->ScanList[idx].Wmm ?
+           "enabled" : "disabled");
+}
+#endif
+
+/** 
+ *  @brief parse scan info
+ *  @param pHandle	A pointer to WCON_HANDLE
+ *  @param buffer       A pointer to scan result buffer
+ *  @param length       length of scan result buffer
+ *  @return      	NA
+ */
+static void
+parse_scan_info(WCON_HANDLE * pHandle, u8 buffer[], s32 length)
+{
+    s32 len = 0;
+    u32 ap_index = 0;
+    int new_index = FALSE;
+    s8 *mode[3] = { "auto", "ad-hoc", "infra" };
+    struct iw_event iwe;
+    struct iw_point iwp;
+
+    memset(pHandle->ScanList, 0, sizeof(pHandle->ScanList));
+    pHandle->ApNum = 0;
+
+    while (len + IW_EV_LCP_LEN < length) {
+        memcpy((s8 *) & iwe, buffer + len, sizeof(struct iw_event));
+        if ((iwe.cmd == SIOCGIWESSID) || (iwe.cmd == SIOCGIWENCODE) ||
+            (iwe.cmd == IWEVCUSTOM)) {
+            if (we_version_compiled > 18)
+                memcpy((s8 *) & iwp,
+                       buffer + len + IW_EV_LCP_LEN - MRV_EV_POINT_OFF,
+                       sizeof(struct iw_point));
+            else
+                memcpy((s8 *) & iwp, buffer + len + IW_EV_LCP_LEN,
+                       sizeof(struct iw_point));
+            iwp.pointer = buffer + len + IW_EV_POINT_LEN;
+        }
+        switch (iwe.cmd) {
+        case SIOCGIWAP:
+            if (new_index && ap_index < IW_MAX_AP - 1)
+                ap_index++;
+            memcpy(pHandle->ScanList[ap_index].Bssid,
+                   iwe.u.ap_addr.sa_data, ETH_ALEN);
+            printf("\nBSSID:\t %02X:%02X:%02X:%02X:%02X:%02X\n",
+                   HWA_ARG(pHandle->ScanList[ap_index].Bssid));
+            new_index = TRUE;
+            break;
+
+        case SIOCGIWESSID:
+            if ((iwp.pointer) && (iwp.length)) {
+                memcpy(pHandle->ScanList[ap_index].Ssid.ssid,
+                       (s8 *) iwp.pointer, iwp.length);
+                pHandle->ScanList[ap_index].Ssid.ssid_len = iwp.length;
+            }
+            printf("SSID:\t %s\n", pHandle->ScanList[ap_index].Ssid.ssid);
+            break;
+
+        case SIOCGIWENCODE:
+            if (!(iwp.flags & IW_ENCODE_DISABLED)) {
+                pHandle->ScanList[ap_index].Privacy = WCON_ENC_ENABLED;
+            }
+            printf("Privacy: %s\n",
+                   pHandle->ScanList[ap_index].Privacy ?
+                   "enabled" : "disabled");
+            break;
+
+        case SIOCGIWMODE:
+            pHandle->ScanList[ap_index].NetMode = iwe.u.mode;
+            printf("NetMode: %s\n",
+                   mode[pHandle->ScanList[ap_index].NetMode]);
+            break;
+
+#if WIRELESS_EXT > 14
+        case IWEVCUSTOM:
+            parse_custom_info(pHandle, &iwp, ap_index);
+            break;
+#endif
+
+        case IWEVQUAL:
+            pHandle->ScanList[ap_index].Rssi = iwe.u.qual.level;
+            printf("Quality: %d\n", pHandle->ScanList[ap_index].Rssi);
+            break;
+        }
+
+        len += iwe.len;
+    }
+    if (new_index)
+        pHandle->ApNum = ap_index + 1;
+    printf("\nNo of AP's = %d\n", pHandle->ApNum);
+
+    return;
+}
+
+/* 
+ *  @brief Process scan results
+ *  @param argc		number of arguments
+ *  @param argv         A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_scan_results(int argc, char *argv[])
+{
+    u8 buffer[IW_SCAN_MAX_DATA];
+    struct iwreq iwr;
+    WCON_HANDLE mhandle, *pHandle = &mhandle;
+
+    memset(pHandle, 0, sizeof(WCON_HANDLE));
+    memset(&iwr, 0, sizeof(struct iwreq));
+
+    iwr.u.data.pointer = buffer;
+    iwr.u.data.length = sizeof(buffer);
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+
+    if ((ioctl(sockfd, SIOCGIWSCAN, &iwr)) < 0) {
+        printf("Get Scan Results Failed\n");
+        return -1;
+    }
+
+    parse_scan_info(pHandle, buffer, iwr.u.data.length);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Process read eeprom
+ *
+ *  @param stroffset	A pointer to the offset string
+ *  @param strnob	A pointer to NOB string
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_read_eeprom(s8 * stroffset, s8 * strnob)
+{
+    s8 buffer[MAX_EEPROM_DATA];
+    struct ifreq userdata;
+    wlan_ioctl_regrdwr *reg = (wlan_ioctl_regrdwr *) buffer;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("regrdwr",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    memset(buffer, 0, sizeof(buffer));
+    reg->WhichReg = REG_EEPROM;
+    reg->Action = 0;
+
+    if (!strncasecmp(stroffset, "0x", 2))
+        reg->Offset = a2hex((stroffset + 2));
+    else
+        reg->Offset = atoi(stroffset);
+
+    if (!strncasecmp(strnob, "0x", 2))
+        reg->NOB = a2hex((strnob + 2));
+    else
+        reg->NOB = atoi(strnob);
+
+    if ((reg->NOB + sizeof(wlan_ioctl_regrdwr)) > MAX_EEPROM_DATA) {
+        fprintf(stderr, "Number of bytes exceeds MAX EEPROM Read size\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    strncpy(userdata.ifr_name, dev_name, IFNAMSIZ);
+    userdata.ifr_data = buffer;
+
+    if (ioctl(sockfd, ioctl_val, &userdata)) {
+        perror("wlanconfig");
+        fprintf(stderr,
+                "wlanconfig: EEPROM read not possible "
+                "by interface %s\n", dev_name);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    hexdump("RD EEPROM", &reg->Value, reg->NOB, ' ');
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief Display usage
+ *  
+ *  @return       NA
+ */
+static void
+display_usage(void)
+{
+    s32 i;
+
+    for (i = 0; i < NELEMENTS(usage); i++)
+        fprintf(stderr, "%s\n", usage[i]);
+}
+
+/* 
+ *  @brief Find command
+ *  
+ *  @param maxcmds	max command number
+ *  @param cmds		A pointer to commands buffer
+ *  @param cmd		A pointer to command buffer
+ *  @return      	index of command or WLAN_STATUS_FAILURE
+ */
+static int
+findcommand(s32 maxcmds, s8 * cmds[], s8 * cmd)
+{
+    s32 i;
+
+    for (i = 0; i < maxcmds; i++) {
+        if (!strcasecmp(cmds[i], cmd)) {
+            return i;
+        }
+    }
+
+    return WLAN_STATUS_FAILURE;
+}
+
+/* 
+ *  @brief SD comand52 read
+ *  @param argc		number of arguments
+ *  @param argv         A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_sdcmd52r(int argc, char *argv[])
+{
+    struct ifreq userdata;
+    u8 buf[6];
+    u32 tmp;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("sdcmd52rw",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    buf[0] = 0;                 //CMD52 read
+    if (argc == 5) {
+        buf[1] = atoval(argv[3]);       //func
+        tmp = atoval(argv[4]);  //reg
+        buf[2] = tmp & 0xff;
+        buf[3] = (tmp >> 8) & 0xff;
+        buf[4] = (tmp >> 16) & 0xff;
+        buf[5] = (tmp >> 24) & 0xff;
+    } else {
+        fprintf(stderr, "Invalid number of parameters!\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    strncpy(userdata.ifr_name, dev_name, IFNAMSIZ);
+    userdata.ifr_data = buf;
+
+    if (ioctl(sockfd, ioctl_val, &userdata)) {
+        perror("wlanconfig");
+        fprintf(stderr,
+                "wlanconfig: CMD52 R/W not supported by "
+                "interface %s\n", dev_name);
+        return WLAN_STATUS_FAILURE;
+    }
+    printf("sdcmd52r returns 0x%02X\n", buf[0]);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief SD comand52 write
+ *  @param argc		number of arguments
+ *  @param argv         A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_sdcmd52w(int argc, char *argv[])
+{
+    struct ifreq userdata;
+    u8 buf[7];
+    u32 tmp;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("sdcmd52rw",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    buf[0] = 1;                 //CMD52 write
+    if (argc == 6) {
+        buf[1] = atoval(argv[3]);       //func
+        tmp = atoval(argv[4]);  //reg
+        buf[2] = tmp & 0xff;
+        buf[3] = (tmp >> 8) & 0xff;
+        buf[4] = (tmp >> 16) & 0xff;
+        buf[5] = (tmp >> 24) & 0xff;
+        buf[6] = atoval(argv[5]);       //dat
+    } else {
+        fprintf(stderr, "Invalid number of parameters!\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    strncpy(userdata.ifr_name, dev_name, IFNAMSIZ);
+    userdata.ifr_data = buf;
+
+    if (ioctl(sockfd, ioctl_val, &userdata)) {
+        perror("wlanconfig");
+        fprintf(stderr,
+                "wlanconfig: CMD52 R/W not supported by "
+                "interface %s\n", dev_name);
+        return WLAN_STATUS_FAILURE;
+    }
+    printf("sdcmd52w returns 0x%02X\n", buf[0]);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief SD comand53 read
+ *  
+ *  @param argc		number of arguments
+ *  @param argv         A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_sdcmd53r(void)
+{
+    struct ifreq userdata;
+    s8 buf[CMD53BUFLEN];
+    int i;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("sdcmd53rw",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+    strncpy(userdata.ifr_name, dev_name, IFNAMSIZ);
+    userdata.ifr_data = buf;
+
+    for (i = 0; i < NELEMENTS(buf); i++)
+        buf[i] = i & 0xff;
+
+    if (ioctl(sockfd, ioctl_val, &userdata)) {
+        perror("wlanconfig");
+        fprintf(stderr,
+                "wlanconfig: CMD53 R/W not supported by "
+                "interface %s\n", dev_name);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    for (i = 0; i < NELEMENTS(buf); i++) {
+        if (buf[i] != (i ^ 0xff))
+            printf("i=%02X  %02X\n", i, buf[i]);
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief Get the current status of the WMM Queues
+ *  
+ *  Command: wlanconfig eth1 qstatus
+ *
+ *  Retrieve the following information for each AC if wmm is enabled:
+ *        - WMM IE ACM Required
+ *        - Firmware Flow Required 
+ *        - Firmware Flow Established
+ *        - Firmware Queue Enabled
+ *  
+ *  @param argc     number of arguments
+ *  @param argv     A pointer to arguments array    
+ *
+ *  @return         WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_wmm_qstatus(int argc, char *argv[])
+{
+    int ioctl_val, subioctl_val;
+    struct iwreq iwr;
+    wlan_ioctl_wmm_queue_status_t qstatus;
+    wlan_wmm_ac_e acVal;
+
+    if (get_priv_ioctl("qstatus",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    memset(&qstatus, 0x00, sizeof(qstatus));
+
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.flags = subioctl_val;
+    iwr.u.data.pointer = (caddr_t) & qstatus;
+    iwr.u.data.length = (sizeof(qstatus));
+
+    if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+        perror("wlanconfig: qstatus ioctl");
+        return -EFAULT;
+    }
+
+    for (acVal = AC_PRIO_BK; acVal <= AC_PRIO_VO; acVal++) {
+        switch (acVal) {
+        case AC_PRIO_BK:
+            printf("BK: ");
+            break;
+        case AC_PRIO_BE:
+            printf("BE: ");
+            break;
+        case AC_PRIO_VI:
+            printf("VI: ");
+            break;
+        case AC_PRIO_VO:
+            printf("VO: ");
+            break;
+        default:
+            printf("??: ");
+        }
+
+        printf("ACM[%c], FlowReq[%c], FlowCreated[%c], Enabled[%c]\n",
+               (qstatus.acStatus[acVal].wmmACM ? 'X' : ' '),
+               (qstatus.acStatus[acVal].flowRequired ? 'X' : ' '),
+               (qstatus.acStatus[acVal].flowCreated ? 'X' : ' '),
+               (qstatus.acStatus[acVal].disabled ? ' ' : 'X'));
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief Get/Set WMM ack policy
+ *  
+ *  @param argc		number of arguments
+ *  @param argv         A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_wmm_ack_policy(int argc, char *argv[])
+{
+    u8 buf[(WMM_ACK_POLICY_PRIO * 2) + 3];
+    s32 count, i;
+    struct ifreq userdata;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("setgetconf",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    if ((argc != 3) && (argc != 5)) {
+        printf("Error: invalid no of arguments\n");
+        printf("Syntax: ./wlanconfig eth1 wmm_ack_policy\n");
+        printf("Syntax: ./wlanconfig eth1 wmm_ack_policy <AC> <POLICY>\n");
+        exit(1);
+    }
+
+    memset(buf, 0, (WMM_ACK_POLICY_PRIO * 2) + 3);
+
+    buf[0] = WMM_ACK_POLICY;
+
+    if (argc == 5) {
+        buf[1] = HostCmd_ACT_SET;
+        buf[2] = 0;
+
+        buf[3] = atoi(argv[3]);
+        if (buf[3] > WMM_ACK_POLICY_PRIO - 1) {
+            printf("Invalid Priority. Should be between 0 and %d\n",
+                   WMM_ACK_POLICY_PRIO - 1);
+            exit(1);
+        }
+
+        buf[4] = atoi(argv[4]);
+        if (buf[4] > 1) {
+            printf("Invalid Ack Policy. Should be 1 or 0\n");
+            exit(1);
+        }
+
+        count = 5;
+    } else {
+        count = 2;
+        buf[1] = HostCmd_ACT_GET;
+    }
+
+    strncpy(userdata.ifr_name, dev_name, IFNAMSIZ);
+    userdata.ifr_data = buf;
+
+    if (ioctl(sockfd, ioctl_val, &userdata)) {
+        fprintf(stderr, "wlanconfig: %s not supported by %s\n",
+                argv[2], dev_name);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    if (buf[1] == HostCmd_ACT_GET) {
+        printf("AC Value    Priority\n");
+        for (i = 0; i < WMM_ACK_POLICY_PRIO; ++i) {
+            count = SKIP_TYPE_ACTION + (i * 2);
+            printf("%4x       %5x\n", buf[count], buf[count + 1]);
+        }
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief read current command
+ *  @param ptr		A pointer to data
+ *  @param curCmd       A pointer to the buf which will hold current command    
+ *  @return      	NULL or the pointer to the left command buf
+ */
+static s8 *
+readCurCmd(s8 * ptr, s8 * curCmd)
+{
+    s32 i = 0;
+#define MAX_CMD_SIZE 64
+
+    while (*ptr != ']' && i < (MAX_CMD_SIZE - 1))
+        curCmd[i++] = *(++ptr);
+
+    if (*ptr != ']')
+        return NULL;
+
+    curCmd[i - 1] = '\0';
+
+    return ++ptr;
+}
+
+/** 
+ *  @brief parse command and hex data
+ *  @param fp 		A pointer to FILE stream
+ *  @param dst       	A pointer to the dest buf
+ *  @param cmd		A pointer to command buf for search
+ *  @return            	length of hex data or WLAN_STATUS_FAILURE  		
+ */
+static int
+fparse_for_cmd_and_hex(FILE * fp, u8 * dst, u8 * cmd)
+{
+    s8 *ptr;
+    u8 *dptr;
+    s8 buf[256], curCmd[64];
+    s32 isCurCmd = 0;
+
+    dptr = dst;
+    while (fgets(buf, sizeof(buf), fp)) {
+        ptr = buf;
+
+        while (*ptr) {
+            // skip leading spaces
+            while (*ptr && isspace(*ptr))
+                ptr++;
+
+            // skip blank lines and lines beginning with '#'
+            if (*ptr == '\0' || *ptr == '#')
+                break;
+
+            if (*ptr == '[' && *(ptr + 1) != '/') {
+                if (!(ptr = readCurCmd(ptr, curCmd)))
+                    return WLAN_STATUS_FAILURE;
+
+                if (strcasecmp(curCmd, cmd))    /* Not equal */
+                    isCurCmd = 0;
+                else
+                    isCurCmd = 1;
+            }
+
+            /* Ignore the rest if it is not correct cmd */
+            if (!isCurCmd)
+                break;
+
+            if (*ptr == '[' && *(ptr + 1) == '/')
+                return (dptr - dst);
+
+            if (isxdigit(*ptr)) {
+                ptr = convert2hex(ptr, dptr++);
+            } else {
+                /* Invalid character on data line */
+                ptr++;
+            }
+
+        }
+    }
+
+    return WLAN_STATUS_FAILURE;
+}
+
+/* 
+ *  @brief Config WMM parameters
+ *  
+ *  @param argc		number of arguments
+ *  @param argv         A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_wmm_para_conf(int argc, char *argv[], s32 cmd)
+{
+    s32 count;
+    FILE *fp;
+    s8 buf[256];
+    s8 filename[48] = "";
+    struct ifreq userdata;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("setgetconf",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    if (argc != 4) {
+        printf("Error: invalid no of arguments\n");
+        printf("Syntax: ./wlanconfig eth1 %s <filename>\n", argv[2]);
+        exit(1);
+    }
+
+    strncpy(filename, argv[3], MIN(sizeof(filename) - 1, strlen(argv[3])));
+    if ((fp = fopen(filename, "r")) == NULL) {
+        fprintf(stderr, "Cannot open file %s\n", argv[3]);
+        exit(1);
+    }
+
+    count = fparse_for_cmd_and_hex(fp, buf + SKIP_TYPE, argv[2]);
+    if (count < 0) {
+        printf("Invalid command parsing failed !!!\n");
+        return -EINVAL;
+    }
+
+    /* This will set the type of command sent */
+    buf[0] = (cmd - CMD_WMM_ACK_POLICY) + WMM_ACK_POLICY;
+
+    hexdump(argv[2], buf, count + SKIP_TYPE, ' ');
+    strncpy(userdata.ifr_name, dev_name, IFNAMSIZ);
+    userdata.ifr_data = buf;
+
+    if (ioctl(sockfd, ioctl_val, &userdata)) {
+        fprintf(stderr, "wlanconfig: %s not supported by %s\n",
+                argv[2], dev_name);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    hexdump(argv[2], buf, count + SKIP_TYPE, ' ');
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Send an ADDTS command to the associated AP
+ *
+ *  Process a given conf file for a specific TSPEC data block.  Send the
+ *    TSPEC along with any other IEs to the driver/firmware for transmission
+ *    in an ADDTS request to the associated AP.  
+ *
+ *  Return the execution status of the command as well as the ADDTS response
+ *    from the AP if any.
+ *  
+ *  wlanconfig ethX addts <filename.conf> <section# of tspec> <timeout in ms>
+ *
+ *  @param argc     number of arguments
+ *  @param argv     A pointer to arguments array    
+ *
+ *  @return         WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_addts(int argc, char *argv[])
+{
+    int ioctl_val, subioctl_val;
+    struct iwreq iwr;
+    unsigned int ieBytes;
+    wlan_ioctl_wmm_addts_req_t addtsReq;
+
+    FILE *fp;
+    char filename[48];
+    char config_id[20];
+
+    memset(&addtsReq, 0x00, sizeof(addtsReq));
+    memset(filename, 0x00, sizeof(filename));
+
+    if (get_priv_ioctl("addts",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    if (argc != 6) {
+        fprintf(stderr, "Invalid number of parameters!\n");
+        return -EINVAL;
+    }
+
+    ieBytes = 0;
+
+    strncpy(filename, argv[3], MIN(sizeof(filename) - 1, strlen(argv[3])));
+    if ((fp = fopen(filename, "r")) == NULL) {
+        perror("fopen");
+        fprintf(stderr, "Cannot open file %s\n", argv[3]);
+        exit(1);
+    }
+
+    sprintf(config_id, "tspec%d", atoi(argv[4]));
+
+    ieBytes = fparse_for_cmd_and_hex(fp, addtsReq.tspecData, config_id);
+
+    if (ieBytes > 0) {
+        printf("Found %d bytes in the %s section of conf file %s\n",
+               ieBytes, config_id, filename);
+    } else {
+        fprintf(stderr, "section %s not found in %s\n", config_id, filename);
+        exit(1);
+    }
+
+    addtsReq.timeout_ms = atoi(argv[5]);
+
+    printf("Cmd Input:\n");
+    hexdump(config_id, addtsReq.tspecData, ieBytes, ' ');
+
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.flags = subioctl_val;
+    iwr.u.data.pointer = (caddr_t) & addtsReq;
+    iwr.u.data.length = (sizeof(addtsReq.timeout_ms)
+                         + sizeof(addtsReq.commandResult)
+                         + sizeof(addtsReq.ieeeStatusCode)
+                         + ieBytes);
+
+    if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+        perror("wlanconfig: addts ioctl");
+        return -EFAULT;
+    }
+
+    ieBytes = iwr.u.data.length - (sizeof(addtsReq.timeout_ms)
+                                   + sizeof(addtsReq.commandResult)
+                                   + sizeof(addtsReq.ieeeStatusCode));
+    printf("Cmd Output:\n");
+    printf("ADDTS Command Result = %d\n", addtsReq.commandResult);
+    printf("ADDTS IEEE Status    = %d\n", addtsReq.ieeeStatusCode);
+    hexdump(config_id, addtsReq.tspecData, ieBytes, ' ');
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Send a DELTS command to the associated AP
+ *
+ *  Process a given conf file for a specific TSPEC data block.  Send the
+ *    TSPEC along with any other IEs to the driver/firmware for transmission
+ *    in a DELTS request to the associated AP.  
+ *
+ *  Return the execution status of the command.  There is no response to a
+ *    DELTS from the AP.
+ *  
+ *  wlanconfig ethX delts <filename.conf> <section# of tspec>
+ *
+ *  @param argc     number of arguments
+ *  @param argv     A pointer to arguments array    
+ *
+ *  @return         WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_delts(int argc, char *argv[])
+{
+    int ioctl_val, subioctl_val;
+    struct iwreq iwr;
+    unsigned int ieBytes;
+    wlan_ioctl_wmm_delts_req_t deltsReq;
+
+    FILE *fp;
+    char filename[48];
+    char config_id[20];
+
+    memset(&deltsReq, 0x00, sizeof(deltsReq));
+    memset(filename, 0x00, sizeof(filename));
+
+    if (get_priv_ioctl("delts",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    if (argc != 5) {
+        fprintf(stderr, "Invalid number of parameters!\n");
+        return -EINVAL;
+    }
+
+    ieBytes = 0;
+
+    strncpy(filename, argv[3], MIN(sizeof(filename) - 1, strlen(argv[3])));
+    if ((fp = fopen(filename, "r")) == NULL) {
+        perror("fopen");
+        fprintf(stderr, "Cannot open file %s\n", argv[3]);
+        exit(1);
+    }
+
+    sprintf(config_id, "tspec%d", atoi(argv[4]));
+
+    ieBytes = fparse_for_cmd_and_hex(fp, deltsReq.tspecData, config_id);
+
+    if (ieBytes > 0) {
+        printf("Found %d bytes in the %s section of conf file %s\n",
+               ieBytes, config_id, filename);
+    } else {
+        fprintf(stderr, "section %s not found in %s\n", config_id, filename);
+        exit(1);
+    }
+
+    deltsReq.ieeeReasonCode = 0x20;     /* 32, unspecified QOS reason */
+
+    printf("Cmd Input:\n");
+    hexdump(config_id, deltsReq.tspecData, ieBytes, ' ');
+
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.flags = subioctl_val;
+    iwr.u.data.pointer = (caddr_t) & deltsReq;
+    iwr.u.data.length = (sizeof(deltsReq.commandResult)
+                         + sizeof(deltsReq.ieeeReasonCode)
+                         + ieBytes);
+
+    if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+        perror("wlanconfig: delts ioctl");
+        return -EFAULT;
+    }
+
+    printf("Cmd Output:\n");
+    printf("DELTS Command Result = %d\n", deltsReq.commandResult);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Send a WMM AC Queue configuration command to get/set/default params
+ *
+ *  Configure or get the parameters of a WMM AC queue. The command takes
+ *    an optional Queue Id as a last parameter.  Without the queue id, all
+ *    queues will be acted upon.
+ *  
+ *  wlanconfig ethX qconfig set msdu <lifetime in TUs> [Queue Id: 0-3]
+ *  wlanconfig ethX qconfig get [Queue Id: 0-3]
+ *  wlanconfig ethX qconfig def [Queue Id: 0-3]
+ *
+ *  @param argc     number of arguments
+ *  @param argv     A pointer to arguments array    
+ *
+ *  @return         WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_qconfig(int argc, char *argv[])
+{
+    int ioctl_val, subioctl_val;
+    struct iwreq iwr;
+    wlan_ioctl_wmm_queue_config_t queue_config_cmd;
+    wlan_wmm_ac_e ac_idx;
+    wlan_wmm_ac_e ac_idx_start;
+    wlan_wmm_ac_e ac_idx_stop;
+
+    const char *ac_str_tbl[] = { "BK", "BE", "VI", "VO" };
+
+    if (argc < 4) {
+        fprintf(stderr, "Invalid number of parameters!\n");
+        return -EINVAL;
+    }
+
+    if (get_priv_ioctl("qconfig",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    memset(&queue_config_cmd, 0x00, sizeof(queue_config_cmd));
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = (caddr_t) & queue_config_cmd;
+    iwr.u.data.length = sizeof(queue_config_cmd);
+    iwr.u.data.flags = subioctl_val;
+
+    if (strcmp(argv[3], "get") == 0) {
+        /*    3     4    5   */
+        /* qconfig get [qid] */
+        if (argc == 4) {
+            ac_idx_start = AC_PRIO_BK;
+            ac_idx_stop = AC_PRIO_VO;
+        } else if (argc == 5) {
+            ac_idx_start = atoi(argv[4]);
+            ac_idx_stop = ac_idx_start;
+        } else {
+            fprintf(stderr, "Invalid number of parameters!\n");
+            return -EINVAL;
+        }
+        queue_config_cmd.action = WMM_QUEUE_CONFIG_ACTION_GET;
+
+        for (ac_idx = ac_idx_start; ac_idx <= ac_idx_stop; ac_idx++) {
+            queue_config_cmd.accessCategory = ac_idx;
+            if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+                perror("qconfig ioctl");
+            } else {
+                printf("qconfig %s(%d): MSDU Lifetime GET = 0x%04x (%d)\n",
+                       ac_str_tbl[ac_idx],
+                       ac_idx,
+                       queue_config_cmd.msduLifetimeExpiry,
+                       queue_config_cmd.msduLifetimeExpiry);
+            }
+        }
+    } else if (strcmp(argv[3], "set") == 0) {
+        if (strcmp(argv[4], "msdu") == 0) {
+            /*    3     4    5     6      7   */
+            /* qconfig set msdu <value> [qid] */
+            if (argc == 6) {
+                ac_idx_start = AC_PRIO_BK;
+                ac_idx_stop = AC_PRIO_VO;
+            } else if (argc == 7) {
+                ac_idx_start = atoi(argv[6]);
+                ac_idx_stop = ac_idx_start;
+            } else {
+                fprintf(stderr, "Invalid number of parameters!\n");
+                return -EINVAL;
+            }
+            queue_config_cmd.action = WMM_QUEUE_CONFIG_ACTION_SET;
+            queue_config_cmd.msduLifetimeExpiry = atoi(argv[5]);
+
+            for (ac_idx = ac_idx_start; ac_idx <= ac_idx_stop; ac_idx++) {
+                queue_config_cmd.accessCategory = ac_idx;
+                if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+                    perror("qconfig ioctl");
+                } else {
+                    printf
+                        ("qconfig %s(%d): MSDU Lifetime SET = 0x%04x (%d)\n",
+                         ac_str_tbl[ac_idx], ac_idx,
+                         queue_config_cmd.msduLifetimeExpiry,
+                         queue_config_cmd.msduLifetimeExpiry);
+                }
+            }
+        } else {
+            /* Only MSDU Lifetime provisioning accepted for now */
+            fprintf(stderr, "Invalid set parameter: s/b [msdu]\n");
+            return -EINVAL;
+        }
+    } else if (strncmp(argv[3], "def", strlen("def")) == 0) {
+        /*    3     4    5   */
+        /* qconfig def [qid] */
+        if (argc == 4) {
+            ac_idx_start = AC_PRIO_BK;
+            ac_idx_stop = AC_PRIO_VO;
+        } else if (argc == 5) {
+            ac_idx_start = atoi(argv[4]);
+            ac_idx_stop = ac_idx_start;
+        } else {
+            fprintf(stderr, "Invalid number of parameters!\n");
+            return -EINVAL;
+        }
+        queue_config_cmd.action = WMM_QUEUE_CONFIG_ACTION_DEFAULT;
+
+        for (ac_idx = ac_idx_start; ac_idx <= ac_idx_stop; ac_idx++) {
+            queue_config_cmd.accessCategory = ac_idx;
+            if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+                perror("qconfig ioctl");
+            } else {
+                printf
+                    ("qconfig %s(%d): MSDU Lifetime DEFAULT = 0x%04x (%d)\n",
+                     ac_str_tbl[ac_idx], ac_idx,
+                     queue_config_cmd.msduLifetimeExpiry,
+                     queue_config_cmd.msduLifetimeExpiry);
+            }
+        }
+    } else {
+        fprintf(stderr, "Invalid qconfig command; s/b [set, get, default]\n");
+        return -EINVAL;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Turn on/off or retrieve and clear the queue statistics for an AC
+ *
+ *  Turn the queue statistics collection on/off for a given AC or retrieve the
+ *    current accumulated stats and clear them from the firmware.  The command
+ *    takes an optional Queue Id as a last parameter.  Without the queue id,
+ *    all queues will be acted upon.
+ *
+ *  wlanconfig ethX qstats on [Queue Id: 0-3]
+ *  wlanconfig ethX qstats off [Queue Id: 0-3]
+ *  wlanconfig ethX qstats get [Queue Id: 0-3]
+ *
+ *  @param argc     number of arguments
+ *  @param argv     A pointer to arguments array    
+ *
+ *  @return         WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_qstats(int argc, char *argv[])
+{
+    int ioctl_val, subioctl_val;
+    struct iwreq iwr;
+    wlan_ioctl_wmm_queue_stats_t queue_stats_cmd;
+    wlan_wmm_ac_e ac_idx;
+
+    const char *ac_str_tbl[] = { "BK", "BE", "VI", "VO" };
+
+    if (argc < 3) {
+        fprintf(stderr, "Invalid number of parameters!\n");
+        return -EINVAL;
+    }
+
+    if (get_priv_ioctl("qstats",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    printf("\n");
+
+    memset(&queue_stats_cmd, 0x00, sizeof(queue_stats_cmd));
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = (caddr_t) & queue_stats_cmd;
+    iwr.u.data.length = sizeof(queue_stats_cmd);
+    iwr.u.data.flags = subioctl_val;
+
+    if ((argc > 3) && strcmp(argv[3], "on") == 0) {
+        queue_stats_cmd.action = WMM_STATS_ACTION_START;
+        for (ac_idx = AC_PRIO_BK; ac_idx <= AC_PRIO_VO; ac_idx++) {
+            queue_stats_cmd.accessCategory = ac_idx;
+            if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+                perror("qstats ioctl");
+            } else {
+                printf("qstats %s(%d) turned on\n",
+                       ac_str_tbl[ac_idx], ac_idx);
+            }
+        }
+    } else if ((argc > 3) && strcmp(argv[3], "off") == 0) {
+        queue_stats_cmd.action = WMM_STATS_ACTION_STOP;
+        for (ac_idx = AC_PRIO_BK; ac_idx <= AC_PRIO_VO; ac_idx++) {
+            queue_stats_cmd.accessCategory = ac_idx;
+            if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+                perror("qstats ioctl");
+            } else {
+                printf("qstats %s(%d) turned off\n",
+                       ac_str_tbl[ac_idx], ac_idx);
+            }
+        }
+    } else {
+        printf("AC  Count   Loss  TxDly   QDly"
+               "    <=5   <=10   <=20   <=30   <=40   <=50    >50\n");
+        printf("----------------------------------"
+               "---------------------------------------------\n");
+
+        queue_stats_cmd.action = WMM_STATS_ACTION_GET_CLR;
+
+        if (argc == 3) {
+            for (ac_idx = AC_PRIO_BK; ac_idx <= AC_PRIO_VO; ac_idx++) {
+                queue_stats_cmd.accessCategory = ac_idx;
+                if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+                    perror("qstats ioctl");
+                } else {
+                    printf("%s  %5u  %5u %6u %6u"
+                           "  %5u  %5u  %5u  %5u  %5u  %5u  %5u\n",
+                           ac_str_tbl[ac_idx],
+                           queue_stats_cmd.pktCount,
+                           queue_stats_cmd.pktLoss,
+                           (unsigned int) queue_stats_cmd.avgTxDelay,
+                           (unsigned int) queue_stats_cmd.avgQueueDelay,
+                           queue_stats_cmd.delayHistogram[0],
+                           queue_stats_cmd.delayHistogram[1],
+                           queue_stats_cmd.delayHistogram[2],
+                           queue_stats_cmd.delayHistogram[3],
+                           queue_stats_cmd.delayHistogram[4],
+                           queue_stats_cmd.delayHistogram[5],
+                           queue_stats_cmd.delayHistogram[6]);
+                }
+            }
+        } else {
+            ac_idx = atoi(argv[3]);
+            if (ac_idx > AC_PRIO_VO) {
+                fprintf(stderr, "AC index invalid!\n");
+                return -EINVAL;
+            } else {
+                queue_stats_cmd.accessCategory = ac_idx;
+                if (ioctl(sockfd, ioctl_val, &iwr) < 0) {
+                    perror("qstats ioctl");
+                } else {
+                    printf("%s  %5u  %5u %6u %6u"
+                           "  %5u  %5u  %5u  %5u  %5u  %5u  %5u\n",
+                           ac_str_tbl[ac_idx],
+                           queue_stats_cmd.pktCount,
+                           queue_stats_cmd.pktLoss,
+                           (unsigned int) queue_stats_cmd.avgTxDelay,
+                           (unsigned int) queue_stats_cmd.avgQueueDelay,
+                           queue_stats_cmd.delayHistogram[0],
+                           queue_stats_cmd.delayHistogram[1],
+                           queue_stats_cmd.delayHistogram[2],
+                           queue_stats_cmd.delayHistogram[3],
+                           queue_stats_cmd.delayHistogram[4],
+                           queue_stats_cmd.delayHistogram[5],
+                           queue_stats_cmd.delayHistogram[6]);
+                }
+            }
+        }
+    }
+    printf("\n");
+
+    return 0;
+}
+
+/* 
+ *  @brief Get one line from the File
+ *  
+ *  @param s	        Storage location for data.
+ *  @param size 	Maximum number of characters to read. 
+ *  @param stream 	File stream	  	
+ *  @param line		A pointer to return current line number
+ *  @return             returns string or NULL 
+ */
+static s8 *
+wlan_config_get_line(s8 * s, s32 size, FILE * stream, int *line)
+{
+    s8 *pos, *end, *sstart;
+
+    while (fgets(s, size, stream)) {
+        (*line)++;
+        s[size - 1] = '\0';
+        pos = s;
+
+        while (*pos == ' ' || *pos == '\t')
+            pos++;
+        if (*pos == '#' || (*pos == '\r' && *(pos + 1) == '\n') ||
+            *pos == '\n' || *pos == '\0')
+            continue;
+
+        /* Remove # comments unless they are within a double quoted
+         * string. Remove trailing white space. */
+        sstart = strchr(pos, '"');
+        if (sstart)
+            sstart = strchr(sstart + 1, '"');
+        if (!sstart)
+            sstart = pos;
+        end = strchr(sstart, '#');
+        if (end)
+            *end-- = '\0';
+        else
+            end = pos + strlen(pos) - 1;
+        while (end > pos && (*end == '\r' || *end == '\n' ||
+                             *end == ' ' || *end == '\t')) {
+            *end-- = '\0';
+        }
+        if (*pos == '\0')
+            continue;
+        return pos;
+    }
+
+    return NULL;
+}
+
+/* 
+ *  @brief convert hex char to integer
+ *  
+ *  @param c		char
+ *  @return      	integer or WLAN_STATUS_FAILURE
+ */
+static int
+hex2num(s8 c)
+{
+    if (c >= '0' && c <= '9')
+        return c - '0';
+    if (c >= 'a' && c <= 'f')
+        return c - 'a' + 10;
+    if (c >= 'A' && c <= 'F')
+        return c - 'A' + 10;
+    return WLAN_STATUS_FAILURE;
+}
+
+/* 
+ *  @brief convert hex char to integer
+ *  
+ *  @param c		char
+ *  @return      	integer or WLAN_STATUS_FAILURE
+ */
+static int
+hex2byte(const s8 * hex)
+{
+    s32 a, b;
+    a = hex2num(*hex++);
+    if (a < 0)
+        return -1;
+    b = hex2num(*hex++);
+    if (b < 0)
+        return -1;
+    return (a << 4) | b;
+}
+
+/* 
+ *  @brief convert hex char to integer
+ *  
+ *  @param hex		A pointer to hex string
+ *  @param buf		buffer to storege the data
+ *  @param len		
+ *  @return      	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+hexstr2bin(const s8 * hex, u8 * buf, size_t len)
+{
+    s32 i, a;
+    const s8 *ipos = hex;
+    s8 *opos = buf;
+
+    for (i = 0; i < len; i++) {
+        a = hex2byte(ipos);
+        if (a < 0)
+            return WLAN_STATUS_FAILURE;
+        *opos++ = a;
+        ipos += 2;
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse string
+ *  
+ *  @param value	A pointer to string
+ *  @param buf		buffer to storege the data
+ *  @param str		buffer to hold return string
+ *  @param len 		use to return the length of parsed string
+ *  @param maxlen	use to return the max length of ssid
+ *  @return      	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_config_parse_string(const s8 * value, s8 * str, size_t * len,
+                         size_t * maxlen)
+{
+    s8 *p;
+    p = strchr(value, ',');
+    if (p) {
+        *maxlen = (u16) a2hex_or_atoi(p + 1);
+        *p = '\0';
+    } else {
+#define WILDCARD_CHAR		'*'
+        p = strchr(value, WILDCARD_CHAR);
+        if (p)
+            *maxlen = (size_t) WILDCARD_CHAR;
+        else
+            *maxlen = 0;
+    }
+
+    if (*value == '"') {
+        s8 *pos;
+        value++;
+        pos = strchr(value, '"');
+
+        if (pos == NULL || pos[1] != '\0') {
+            value--;
+            return WLAN_STATUS_FAILURE;
+        }
+        *pos = '\0';
+        *len = strlen(value);
+        strcpy(str, value);
+        return WLAN_STATUS_SUCCESS;
+    } else {
+        s32 hlen = strlen(value);
+
+        if (hlen % 1)
+            return WLAN_STATUS_FAILURE;
+        *len = hlen / 2;
+        if (str == NULL)
+            return WLAN_STATUS_FAILURE;
+        if (hexstr2bin(value, str, *len)) {
+            return WLAN_STATUS_FAILURE;
+        }
+
+        return WLAN_STATUS_SUCCESS;
+    }
+}
+
+/* 
+ *  @brief parse bgscan action
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to Action buffer
+ *  @return      	WLAN_STATUS_SUCCESS
+ */
+static int
+bgscan_parse_action(u8 * CmdBuf, s32 line, s8 * value)
+{
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgscan_config =
+        (HostCmd_DS_802_11_BG_SCAN_CONFIG *) CmdBuf;
+
+    bgscan_config->Action = (u16) a2hex_or_atoi(value);
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan enable parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to Enable buffer
+ *  @return      	WLAN_STATUS_SUCCESS
+ */
+static int
+bgscan_parse_enable(u8 * CmdBuf, s32 line, s8 * value)
+{
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgscan_config =
+        (HostCmd_DS_802_11_BG_SCAN_CONFIG *) CmdBuf;
+
+    bgscan_config->Enable = (u8) a2hex_or_atoi(value);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan BssType
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to BssType buffer
+ *  @return      	WLAN_STATUS_SUCCESS
+ */
+static int
+bgscan_parse_bsstype(u8 * CmdBuf, s32 line, s8 * value)
+{
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgscan_config =
+        (HostCmd_DS_802_11_BG_SCAN_CONFIG *) CmdBuf;
+
+    bgscan_config->BssType = (u8) a2hex_or_atoi(value);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan channels per scan parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to channels per scan buffer
+ *  @return      	WLAN_STATUS_SUCCESS
+ */
+static int
+bgscan_parse_channelsperscan(u8 * CmdBuf, s32 line, s8 * value)
+{
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgscan_config =
+        (HostCmd_DS_802_11_BG_SCAN_CONFIG *) CmdBuf;
+
+    bgscan_config->ChannelsPerScan = (u8) a2hex_or_atoi(value);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan discardwhenfull parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to channels per scan buffer
+ *  @return      	WLAN_STATUS_SUCCESS
+ */
+static int
+bgscan_parse_discardwhenfull(u8 * CmdBuf, s32 line, s8 * value)
+{
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgscan_config =
+        (HostCmd_DS_802_11_BG_SCAN_CONFIG *) CmdBuf;
+
+    bgscan_config->DiscardWhenFull = (u8) a2hex_or_atoi(value);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan scan interval parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to scan interval buffer
+ *  @return      	WLAN_STATUS_SUCCESS
+ */
+static int
+bgscan_parse_scaninterval(u8 * CmdBuf, s32 line, s8 * value)
+{
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgscan_config =
+        (HostCmd_DS_802_11_BG_SCAN_CONFIG *) CmdBuf;
+
+    bgscan_config->ScanInterval = (u32) a2hex_or_atoi(value);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan store condition parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to store condition buffer
+ *  @return      	WLAN_STATUS_SUCCESS
+ */
+static int
+bgscan_parse_storecondition(u8 * CmdBuf, s32 line, s8 * value)
+{
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgscan_config =
+        (HostCmd_DS_802_11_BG_SCAN_CONFIG *) CmdBuf;
+
+    bgscan_config->StoreCondition = a2hex_or_atoi(value);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan report conditions parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to report conditionsn buffer
+ *  @return      	WLAN_STATUS_SUCCESS
+ */
+static int
+bgscan_parse_reportconditions(u8 * CmdBuf, s32 line, s8 * value)
+{
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgscan_config =
+        (HostCmd_DS_802_11_BG_SCAN_CONFIG *) CmdBuf;
+
+    bgscan_config->ReportConditions = a2hex_or_atoi(value);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan max scan results parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to max scan results buffer
+ *  @return      	WLAN_STATUS_SUCCESS
+ */
+static int
+bgscan_parse_maxscanresults(u8 * CmdBuf, s32 line, s8 * value)
+{
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgscan_config =
+        (HostCmd_DS_802_11_BG_SCAN_CONFIG *) CmdBuf;
+
+    bgscan_config->MaxScanResults = (u16) a2hex_or_atoi(value);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan ssid parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to ssid buffer
+ *  @return      	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+bgscan_parse_ssid(u8 * CmdBuf, s32 line, s8 * value)
+{
+    static int ssidCnt;
+    MrvlIEtypes_SsIdParamSet_t *SsIdParamSet = NULL;
+    MrvlIEtypes_WildCardSsIdParamSet_t *WildcardSsIdParamSet = NULL;
+    s8 *buf = NULL;
+    size_t len = 0;
+    size_t maxlen = 0;
+
+    SsIdParamSet = (MrvlIEtypes_SsIdParamSet_t *) (CmdBuf + ActualPos);
+    WildcardSsIdParamSet =
+        (MrvlIEtypes_WildCardSsIdParamSet_t *) (CmdBuf + ActualPos);
+
+    buf = (s8 *) malloc(strlen(value));
+    if (buf == NULL)
+        return WLAN_STATUS_FAILURE;
+    memset(buf, 0, strlen(value));
+
+    if (wlan_config_parse_string(value, buf, &len, &maxlen)) {
+        printf("Invalid SSID\n");
+        free(buf);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    ssidCnt++;
+
+    if (!strlen(buf)) {
+        printf("The %dth SSID is NULL.\n", ssidCnt);
+    }
+
+    if (maxlen > len) {
+        WildcardSsIdParamSet->Header.Type =
+            cpu_to_le16(TLV_TYPE_WILDCARDSSID);
+        WildcardSsIdParamSet->Header.Len =
+            strlen(buf) + sizeof(WildcardSsIdParamSet->MaxSsidLength);
+        WildcardSsIdParamSet->MaxSsidLength = maxlen;
+        TLVSsidSize +=
+            WildcardSsIdParamSet->Header.Len + sizeof(MrvlIEtypesHeader_t);
+        ActualPos +=
+            WildcardSsIdParamSet->Header.Len + sizeof(MrvlIEtypesHeader_t);
+        WildcardSsIdParamSet->Header.Len =
+            cpu_to_le16(WildcardSsIdParamSet->Header.Len);
+        memcpy(WildcardSsIdParamSet->SsId, buf, strlen(buf));
+    } else {
+        SsIdParamSet->Header.Type = cpu_to_le16(TLV_TYPE_SSID); /*0x0000; */
+        SsIdParamSet->Header.Len = strlen(buf);
+        TLVSsidSize += SsIdParamSet->Header.Len + sizeof(MrvlIEtypesHeader_t);
+
+        ActualPos += SsIdParamSet->Header.Len + sizeof(MrvlIEtypesHeader_t);
+
+        SsIdParamSet->Header.Len = cpu_to_le16(SsIdParamSet->Header.Len);
+
+        memcpy(SsIdParamSet->SsId, buf, strlen(buf));
+    }
+    free(buf);
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan probes parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to probes buffer
+ *  @return      	WLAN_STATUS_SUCCESS 
+ */
+static int
+bgscan_parse_probes(u8 * CmdBuf, s32 line, s8 * value)
+{
+    MrvlIEtypes_NumProbes_t *Probes = NULL;
+
+#define PROBES_PAYLOAD_SIZE	2
+
+    Probes = (MrvlIEtypes_NumProbes_t *) (CmdBuf + ActualPos);
+
+    Probes->Header.Type = TLV_TYPE_NUMPROBES;
+    Probes->Header.Len = PROBES_PAYLOAD_SIZE;
+
+    Probes->NumProbes = (u16) a2hex_or_atoi(value);
+
+    if (Probes->NumProbes) {
+        TLVProbeSize += sizeof(MrvlIEtypesHeader_t) + Probes->Header.Len;
+    } else {
+        TLVProbeSize = 0;
+    }
+
+    ActualPos += TLVProbeSize;
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan channel list parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to channel list buffer
+ *  @return      	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+bgscan_parse_channellist(u8 * CmdBuf, s32 line, s8 * value)
+{
+    MrvlIEtypes_ChanListParamSet_t *chan;
+    char *buf, *grp0, *grp1;
+    s32 len, idx;
+
+    chan = (MrvlIEtypes_ChanListParamSet_t *) (CmdBuf + ActualPos);
+
+    len = strlen(value) + 1;
+    buf = malloc(len);
+
+    if (buf == NULL)
+        return WLAN_STATUS_FAILURE;
+
+    memset(buf, 0, len);
+    strcpy(buf, value);
+
+    chan->Header.Type = cpu_to_le16(TLV_TYPE_CHANLIST);
+    grp1 = buf;
+    idx = 0;
+    while ((grp1 != NULL) && (*grp1 != 0)) {
+        grp0 = strsep(&grp1, "\";");
+
+        if ((grp0 != NULL) && (*grp0 != 0)) {
+            chan->ChanScanParam[idx].RadioType = atoi(strtok(grp0, ","));
+            chan->ChanScanParam[idx].ChanNumber = atoi(strtok(NULL, ","));
+            chan->ChanScanParam[idx].ChanScanMode.PassiveScan
+                = atoi(strtok(NULL, ","));
+            chan->ChanScanParam[idx].ChanScanMode.DisableChanFilt = 1;
+            chan->ChanScanParam[idx].MinScanTime = atoi(strtok(NULL, ","));
+            chan->ChanScanParam[idx].MaxScanTime = atoi(strtok(NULL, ","));
+            idx++;
+        }
+    }
+
+    chan->Header.Len = (idx * sizeof(ChanScanParamSet_t));
+    TLVChanSize += (chan->Header.Len + sizeof(MrvlIEtypesHeader_t));
+    chan->Header.Len = cpu_to_le16(chan->Header.Len);
+    ActualPos += TLVChanSize;
+
+    free(buf);
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan snr threshold parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to bgscan snr threshold buffer
+ *  @return      	WLAN_STATUS_SUCCESS
+ */
+static int
+bgscan_parse_snrthreshold(u8 * CmdBuf, s32 line, s8 * value)
+{
+    MrvlIEtypes_SnrThreshold_t *SnrThreshold = NULL;
+    u32 tmp;
+
+    SnrThreshold = (MrvlIEtypes_SnrThreshold_t *) (CmdBuf + ActualPos);
+
+    SnrThreshold->Header.Type = TLV_TYPE_SNR_LOW;
+    SnrThreshold->Header.Len = PROBES_PAYLOAD_SIZE;
+
+    tmp = (u16) a2hex_or_atoi(value);
+    SnrThreshold->SNRValue = tmp & 0xff;
+    SnrThreshold->SNRFreq = (tmp >> 8) & 0xff;
+
+    TLVSnrSize += sizeof(MrvlIEtypesHeader_t) + SnrThreshold->Header.Len;
+    ActualPos += TLVSnrSize;
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse bgscan broadcast probe parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to broadcast probe buffer
+ *  @return      	WLAN_STATUS_SUCCESS
+ */
+static int
+bgscan_parse_bcastprobe(u8 * CmdBuf, s32 line, s8 * value)
+{
+    MrvlIEtypes_BcastProbe_t *BcastProbe = NULL;
+
+    BcastProbe = (MrvlIEtypes_BcastProbe_t *) (CmdBuf + ActualPos);
+
+    BcastProbe->Header.Type = TLV_TYPE_BCASTPROBE;
+    BcastProbe->Header.Len = PROBES_PAYLOAD_SIZE;
+
+    BcastProbe->BcastProbe = (u16) a2hex_or_atoi(value);
+
+    TLVBcProbeSize = sizeof(MrvlIEtypesHeader_t) + BcastProbe->Header.Len;
+    ActualPos += TLVBcProbeSize;
+    return WLAN_STATUS_SUCCESS;
+}
+
+/* 
+ *  @brief parse number ssid probe parameter
+ *  
+ *  @param CmdBuf	A pointer to command buffer
+ *  @param line	        line number
+ *  @param value	A pointer to number ssid probe buffer
+ *  @return      	WLAN_STATUS_SUCCESS
+ */
+static int
+bgscan_parse_numssidprobe(u8 * CmdBuf, s32 line, s8 * value)
+{
+    MrvlIEtypes_NumSSIDProbe_t *NumSSIDProbe = NULL;
+
+    NumSSIDProbe = (MrvlIEtypes_NumSSIDProbe_t *) (CmdBuf + ActualPos);
+
+    NumSSIDProbe->Header.Type = TLV_TYPE_NUMSSID_PROBE;
+    NumSSIDProbe->Header.Len = PROBES_PAYLOAD_SIZE;
+
+    NumSSIDProbe->NumSSIDProbe = (u16) a2hex_or_atoi(value);
+
+    TLVNumSsidProbeSize =
+        sizeof(MrvlIEtypesHeader_t) + NumSSIDProbe->Header.Len;
+    ActualPos += TLVNumSsidProbeSize;
+    return WLAN_STATUS_SUCCESS;
+}
+
+static struct bgscan_fields
+{
+    s8 *name;
+    int (*parser) (u8 * CmdBuf, s32 line, s8 * value);
+} bgscan_fields[] = {
+    {
+    "Action", bgscan_parse_action}, {
+    "Enable", bgscan_parse_enable}, {
+    "BssType", bgscan_parse_bsstype}, {
+    "ChannelsPerScan", bgscan_parse_channelsperscan}, {
+    "DiscardWhenFull", bgscan_parse_discardwhenfull}, {
+    "ScanInterval", bgscan_parse_scaninterval}, {
+    "StoreCondition", bgscan_parse_storecondition}, {
+    "ReportConditions", bgscan_parse_reportconditions}, {
+    "MaxScanResults", bgscan_parse_maxscanresults}, {
+    "SSID1", bgscan_parse_ssid}, {
+    "SSID2", bgscan_parse_ssid}, {
+    "SSID3", bgscan_parse_ssid}, {
+    "SSID4", bgscan_parse_ssid}, {
+    "SSID5", bgscan_parse_ssid}, {
+    "SSID6", bgscan_parse_ssid}, {
+    "SSID7", bgscan_parse_ssid}, {
+    "SSID8", bgscan_parse_ssid}, {
+    "SSID9", bgscan_parse_ssid}, {
+    "SSID10", bgscan_parse_ssid}, {
+    "Probes", bgscan_parse_probes}, {
+    "ChannelList", bgscan_parse_channellist}, {
+    "SnrThreshold", bgscan_parse_snrthreshold}, {
+    "BcastProbe", bgscan_parse_bcastprobe}, {
+"NumSSIDProbe", bgscan_parse_numssidprobe},};
+
+/* 
+ *  @brief get bgscan data
+ *  
+ *  @param fp			A pointer to file stream
+ *  @param line	        	A pointer to line number
+ *  @param bgscan_config	A pointer to HostCmd_DS_802_11_BG_SCAN_CONFIG structure
+ *  @return      		WLAN_STATUS_SUCCESS
+ */
+static int
+wlan_get_bgscan_data(FILE * fp, int *line,
+                     HostCmd_DS_802_11_BG_SCAN_CONFIG * bgscan_config)
+{
+    s32 errors = 0, i, end = 0;
+    s8 buf[256], *pos, *pos2;
+
+    while ((pos = wlan_config_get_line(buf, sizeof(buf), fp, line))) {
+        if (strcmp(pos, "}") == 0) {
+            end = 1;
+            break;
+        }
+
+        pos2 = strchr(pos, '=');
+        if (pos2 == NULL) {
+            printf("Line %d: Invalid bgscan line '%s'.", *line, pos);
+            errors++;
+            continue;
+        }
+
+        *pos2++ = '\0';
+        if (*pos2 == '"') {
+            if (strchr(pos2 + 1, '"') == NULL) {
+                printf("Line %d: invalid quotation '%s'.", *line, pos2);
+                errors++;
+                continue;
+            }
+        }
+
+        for (i = 0; i < NELEMENTS(bgscan_fields); i++) {
+            if (strcmp(pos, bgscan_fields[i].name) == 0) {
+                if (bgscan_fields[i].parser((u8 *) bgscan_config,
+                                            *line, pos2)) {
+                    printf("Line %d: failed to parse %s"
+                           "'%s'.", *line, pos, pos2);
+                    errors++;
+                }
+                break;
+            }
+        }
+        if (i == NELEMENTS(bgscan_fields)) {
+            printf("Line %d: unknown bgscan field '%s'.\n", *line, pos);
+            errors++;
+        }
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Process bgscan config 
+ *  @param argc		number of arguments
+ *  @param argv         A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_bg_scan_config(int argc, char *argv[])
+{
+    u8 scanCfg[256], *pos, *buf = NULL;
+    s8 filename[48] = "";
+    FILE *fp;
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgscan_config;
+    struct ifreq userdata;
+    int line = 0;
+    s32 CmdNum = BG_SCAN_CONFIG;
+    s32 Action;
+    u16 Size;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("setgetconf",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    if (argc != 4) {
+        printf("Error: invalid no of arguments\n");
+        printf("Syntax: ./wlanconfig eth1 bgscanconfig <filename>\n");
+        exit(1);
+    }
+
+    strncpy(filename, argv[3], MIN(sizeof(filename) - 1, strlen(argv[3])));
+    if ((fp = fopen(filename, "r")) == NULL) {
+        fprintf(stderr, "Cannot open file %s\n", filename);
+        exit(1);
+    }
+#define BGSCANCFG_BUF_LEN	1024
+    buf = (u8 *) malloc(BGSCANCFG_BUF_LEN);
+    if (buf == NULL) {
+        printf("Error: allocate memory for bgscan fail\n");
+        fclose(fp);
+        return -ENOMEM;
+    }
+    memset(buf, 0, BGSCANCFG_BUF_LEN);
+
+    bgscan_config = (HostCmd_DS_802_11_BG_SCAN_CONFIG *)
+        (buf + sizeof(s32) + sizeof(u16));
+
+    while ((pos =
+            (u8 *) wlan_config_get_line((s8 *) scanCfg, sizeof(scanCfg), fp,
+                                        &line))) {
+        if (strcmp((char *) pos, "bgscan={") == 0) {
+            wlan_get_bgscan_data(fp, &line, bgscan_config);
+        }
+    }
+
+    fclose(fp);
+
+    Action = bgscan_config->Action;
+
+    Size = sizeof(HostCmd_DS_802_11_BG_SCAN_CONFIG) +
+        TLVSsidSize + TLVProbeSize + TLVChanSize + TLVSnrSize +
+        TLVBcProbeSize + TLVNumSsidProbeSize;
+
+    memcpy(buf, &CmdNum, sizeof(s32));
+    memcpy(buf + sizeof(s32), &Size, sizeof(u16));
+
+    strncpy(userdata.ifr_name, dev_name, IFNAMSIZ);
+    userdata.ifr_data = buf;
+
+    if (ioctl(sockfd, ioctl_val, &userdata)) {
+        fprintf(stderr, "wlanconfig: BG_SCAN is not supported by %s\n",
+                dev_name);
+        return -1;
+    }
+
+    if (Action == HostCmd_ACT_GEN_GET) {
+        s32 i;
+        printf("BGSCAN Configuration setup:\n");
+        for (i = 0; i < Size; i++) {
+            if (!(i % 10)) {
+                printf("\n");
+            }
+            printf(" 0x%x ", buf[i + 3]);
+        }
+        printf("\n");
+    }
+
+    free(buf);
+
+    return WLAN_STATUS_SUCCESS;
+
+}
+
+/** 
+ *  @brief parse hex data
+ *  @param fp 		A pointer to FILE stream
+ *  @param dst		A pointer to receive hex data
+ *  @return            	length of hex data
+ */
+static int
+fparse_for_hex(FILE * fp, u8 * dst)
+{
+    s8 *ptr;
+    u8 *dptr;
+    s8 buf[256];
+
+    dptr = dst;
+    while (fgets(buf, sizeof(buf), fp)) {
+        ptr = buf;
+
+        while (*ptr) {
+            // skip leading spaces
+            while (*ptr && isspace(*ptr))
+                ptr++;
+
+            // skip blank lines and lines beginning with '#'
+            if (*ptr == '\0' || *ptr == '#')
+                break;
+
+            if (isxdigit(*ptr)) {
+                ptr = convert2hex(ptr, dptr++);
+            } else {
+                /* Invalid character on data line */
+                ptr++;
+            }
+        }
+    }
+
+    return (dptr - dst);
+}
+
+/** 
+ *  @brief Process calibration data
+ *  @param argc		number of arguments
+ *  @param argv         A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int
+process_cal_data_ext(int argc, char *argv[])
+{
+    s32 count;
+    u8 *buf = NULL;
+    FILE *fp;
+    s8 filename[48] = "";
+    HostCmd_DS_802_11_CAL_DATA_EXT *pcal_data;
+    struct ifreq userdata;
+    s32 CmdNum = CAL_DATA_EXT_CONFIG;
+    int ioctl_val, subioctl_val;
+    u16 action;
+
+    if (get_priv_ioctl("setgetconf",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    if (argc != 4) {
+        printf("Error: invalid no of arguments\n");
+        printf("Syntax: ./wlanconfig eth1 caldataext <filename>\n");
+        exit(1);
+    }
+
+    strncpy(filename, argv[3], MIN(sizeof(filename) - 1, strlen(argv[3])));
+    if ((fp = fopen(filename, "r")) == NULL) {
+        fprintf(stderr, "Cannot open file %s\n", argv[1]);
+        exit(1);
+    }
+
+    buf = malloc(sizeof(HostCmd_DS_802_11_CAL_DATA_EXT) + sizeof(s32));
+    if (buf == NULL)
+        return WLAN_STATUS_FAILURE;
+    pcal_data = (HostCmd_DS_802_11_CAL_DATA_EXT *) (buf + sizeof(s32));
+    memset(pcal_data, 0, sizeof(HostCmd_DS_802_11_CAL_DATA_EXT));
+
+    count = fparse_for_hex(fp, (u8 *) pcal_data);
+    fclose(fp);
+
+    action = pcal_data->Action;
+    memcpy(buf, &CmdNum, sizeof(s32));
+    strncpy(userdata.ifr_name, dev_name, IFNAMSIZ);
+    userdata.ifr_data = buf;
+
+    if (ioctl(sockfd, ioctl_val, &userdata)) {
+        fprintf(stderr, "wlanconfig: CAL DATA not supported by %s\n",
+                dev_name);
+        free(buf);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    if (action == HostCmd_ACT_GET) {
+        printf("Cal Data revision: %04x\n", pcal_data->Revision);
+        printf("Cal Data length: %0d", pcal_data->CalDataLen);
+        for (count = 0; count < pcal_data->CalDataLen; count++) {
+            if ((count % 16) == 0) {
+                printf("\n");
+            }
+            printf("%02x ", pcal_data->CalData[count]);
+        }
+        printf("\n");
+    }
+
+    free(buf);
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief read register
+ *  @param cmd 		the type of register
+ *  @param stroffset	A pointer to register index string
+ *  @return            	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+process_read_register(s32 cmd, s8 * stroffset)
+{
+    struct ifreq userdata;
+    wlan_ioctl_regrdwr reg;
+    s8 *whichreg;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("regrdwr",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+    memset(&reg, 0, sizeof(reg));
+    switch (cmd) {
+    case CMD_RDMAC:
+        /*
+         * HostCmd_CMD_MAC_REG_ACCESS 
+         */
+        reg.WhichReg = REG_MAC;
+        whichreg = "MAC";
+        break;
+    case CMD_RDBBP:
+        /*
+         * HostCmd_CMD_BBP_REG_ACCESS 
+         */
+        reg.WhichReg = REG_BBP;
+        whichreg = "BBP";
+        break;
+    case CMD_RDRF:
+        /*
+         * HostCmd_CMD_RF_REG_ACCESS 
+         */
+        reg.WhichReg = REG_RF;
+        whichreg = "RF";
+        break;
+    default:
+        fprintf(stderr, "Invalid Register set specified.\n");
+        return -1;
+    }
+
+    reg.Action = 0;             /* READ */
+
+    if (!strncasecmp(stroffset, "0x", 2))
+        reg.Offset = a2hex((stroffset + 2));
+    else
+        reg.Offset = atoi(stroffset);
+
+    strncpy(userdata.ifr_name, dev_name, IFNAMSIZ);
+    userdata.ifr_data = (s8 *) & reg;
+
+    if (ioctl(sockfd, ioctl_val, &userdata)) {
+        perror("wlanconfig");
+        fprintf(stderr,
+                "wlanconfig: Register Reading not supported by"
+                "interface %s\n", dev_name);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    printf("%s[0x%04lx] = 0x%08lx\n", whichreg, reg.Offset, reg.Value);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief write register
+ *  @param cmd 		the type of register
+ *  @param stroffset	A pointer to register index string
+ *  @param strvalue	A pointer to the register value
+ *  @return            	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+process_write_register(s32 cmd, s8 * stroffset, s8 * strvalue)
+{
+    struct ifreq userdata;
+    wlan_ioctl_regrdwr reg;
+    s8 *whichreg;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("regrdwr",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    switch (cmd) {
+    case CMD_WRMAC:
+        /*
+         * HostCmd_CMD_MAC_REG_ACCESS 
+         */
+        reg.WhichReg = REG_MAC;
+        whichreg = "MAC";
+        break;
+    case CMD_WRBBP:
+        /*
+         * HostCmd_CMD_BBP_REG_ACCESS 
+         */
+        reg.WhichReg = REG_BBP;
+        whichreg = "BBP";
+        break;
+    case CMD_WRRF:
+        /*
+         * HostCmd_CMD_RF_REG_ACCESS 
+         */
+        reg.WhichReg = REG_RF;
+        whichreg = "RF";
+        break;
+    default:
+        fprintf(stderr, "Invalid register set specified.\n");
+        return -1;
+    }
+
+    reg.Action = 1;             /* WRITE */
+
+    if (!strncasecmp(stroffset, "0x", 2))
+        reg.Offset = a2hex((stroffset + 2));
+    else
+        reg.Offset = atoi(stroffset);
+
+    if (!strncasecmp(strvalue, "0x", 2))
+        reg.Value = a2hex((strvalue + 2));
+    else
+        reg.Value = atoi(strvalue);
+
+    printf("Writing %s Register 0x%04lx with 0x%08lx\n", whichreg,
+           reg.Offset, reg.Value);
+
+    strncpy(userdata.ifr_name, dev_name, IFNAMSIZ);
+    userdata.ifr_data = (s8 *) & reg;
+
+    if (ioctl(sockfd, ioctl_val, &userdata)) {
+        perror("wlanconfig");
+        fprintf(stderr,
+                "wlanconfig: Register Writing not supported "
+                "by interface %s\n", dev_name);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    printf("%s[0x%04lx] = 0x%08lx\n", whichreg, reg.Offset, reg.Value);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Process arpfilter
+ *  @param argc     number of arguments
+ *  @param argv     A pointer to arguments array    
+ *  @return	    WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+process_arpfilter(int argc, char *argv[])
+{
+    s8 line[256], *pos;
+    u8 *buf;
+    FILE *fp;
+    struct iwreq iwr;
+    int ln = 0;
+    int arpfilter_found = 0;
+    u16 length = 0;
+    int ret = WLAN_STATUS_SUCCESS;
+    int ioctl_val, subioctl_val;
+
+    if (get_priv_ioctl("arpfilter",
+                       &ioctl_val, &subioctl_val) == WLAN_STATUS_FAILURE) {
+        return -EOPNOTSUPP;
+    }
+
+    if (argc < 4) {
+        printf("Error: invalid no of arguments\n");
+        printf("Syntax: ./wlanconfig eth1 arpfilter <arpfilter.conf>\n");
+        exit(1);
+    }
+
+    if ((fp = fopen(argv[3], "r")) == NULL) {
+        fprintf(stderr, "Cannot open file %s\n", argv[3]);
+        exit(1);
+    }
+
+    buf = (u8 *) malloc(MRVDRV_SIZE_OF_CMD_BUFFER);
+    if (buf == NULL) {
+        printf("Error: allocate memory for arpfilter failed\n");
+        return -ENOMEM;
+    }
+    memset(buf, 0, MRVDRV_SIZE_OF_CMD_BUFFER);
+
+    arpfilter_found = 0;
+    while ((pos = wlan_config_get_line(line, sizeof(line), fp, &ln))) {
+        if (strcmp(pos, "arpfilter={") == 0) {
+            arpfilter_found = 1;
+            wlan_get_hostcmd_data(fp, &ln, buf + length, &length);
+            break;
+        }
+    }
+
+    fclose(fp);
+
+    if (!arpfilter_found) {
+        fprintf(stderr, "wlanconfig: 'arpfilter' not found in file '%s'\n",
+                argv[3]);
+        ret = -1;
+        goto _exit_;
+    }
+
+    memset(&iwr, 0, sizeof(iwr));
+    strncpy(iwr.ifr_name, dev_name, IFNAMSIZ);
+    iwr.u.data.pointer = buf;
+    iwr.u.data.length = length;
+
+    iwr.u.data.flags = 0;
+    if (ioctl(sockfd, ioctl_val, &iwr)) {
+        fprintf(stderr, "wlanconfig: WLANARPFILTER failed\n");
+        ret = -1;
+        goto _exit_;
+    }
+
+  _exit_:
+    if (buf)
+        free(buf);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+/* 
+ *  @brief Entry function for wlanconfig
+ *  @param argc		number of arguments
+ *  @param argv         A pointer to arguments array    
+ *  @return      	WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int
+main(int argc, char *argv[])
+{
+    s32 cmd;
+
+    if ((argc == 2) && (strcmp(argv[1], "-v") == 0)) {
+        fprintf(stdout, "Marvell wlanconfig version %s\n", WLANCONFIG_VER);
+        exit(0);
+    }
+    if (argc < 3) {
+        fprintf(stderr, "Invalid number of parameters!\n");
+        display_usage();
+        exit(1);
+    }
+
+    strncpy(dev_name, argv[1], IFNAMSIZ);
+
+    /*
+     * create a socket 
+     */
+    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+        fprintf(stderr, "wlanconfig: Cannot open socket.\n");
+        exit(1);
+    }
+    if (get_range() < 0) {
+        fprintf(stderr, "wlanconfig: Cannot get range.\n");
+        exit(1);
+    }
+    switch ((cmd = findcommand(NELEMENTS(commands), commands, argv[2]))) {
+    case CMD_HOSTCMD:
+        process_host_cmd(argc, argv);
+        break;
+    case CMD_RDMAC:
+    case CMD_RDBBP:
+    case CMD_RDRF:
+        if (argc < 4) {
+            fprintf(stderr, "Register offset required!\n");
+            display_usage();
+            exit(1);
+        }
+
+        if (process_read_register(cmd, argv[3])) {
+            fprintf(stderr, "Read command failed!\n");
+            exit(1);
+        }
+        break;
+    case CMD_WRMAC:
+    case CMD_WRBBP:
+    case CMD_WRRF:
+        if (argc < 5) {
+            fprintf(stderr, "Register offset required & value!\n");
+            display_usage();
+            exit(1);
+        }
+        if (process_write_register(cmd, argv[3], argv[4])) {
+            fprintf(stderr, "Write command failed!\n");
+            exit(1);
+        }
+        break;
+    case CMD_CMD52R:
+        process_sdcmd52r(argc, argv);
+        break;
+    case CMD_CMD52W:
+        process_sdcmd52w(argc, argv);
+        break;
+    case CMD_CMD53R:
+        process_sdcmd53r();
+        break;
+    case CMD_BG_SCAN_CONFIG:
+        process_bg_scan_config(argc, argv);
+        break;
+    case CMD_WMM_QSTATUS:
+        process_wmm_qstatus(argc, argv);
+        break;
+    case CMD_WMM_ACK_POLICY:
+        process_wmm_ack_policy(argc, argv);
+        break;
+    case CMD_WMM_AC_WPAIE:
+        process_wmm_para_conf(argc, argv, cmd);
+        break;
+    case CMD_ADDTS:
+        if (process_addts(argc, argv)) {
+            exit(1);
+        }
+        break;
+    case CMD_DELTS:
+        if (process_delts(argc, argv)) {
+            exit(1);
+        }
+        break;
+    case CMD_QCONFIG:
+        if (process_qconfig(argc, argv)) {
+            exit(1);
+        }
+        break;
+    case CMD_QSTATS:
+        if (process_qstats(argc, argv)) {
+            exit(1);
+        }
+        break;
+    case CMD_CAL_DATA_EXT:
+        process_cal_data_ext(argc, argv);
+        break;
+    case CMD_RDEEPROM:
+        printf("proces read eeprom\n");
+
+        if (argc < 5) {
+            fprintf(stderr, "Register offset, number of bytes required\n");
+            display_usage();
+            exit(1);
+        }
+
+        if (process_read_eeprom(argv[3], argv[4])) {
+            fprintf(stderr, "EEPROM Read failed\n");
+            display_usage();
+            exit(1);
+        }
+        break;
+    case CMD_GETRATE:
+        if (process_get_rate()) {
+            fprintf(stderr, "Get Rate Failed\n");
+            display_usage();
+            exit(1);
+        }
+        break;
+    case CMD_SLEEPPARAMS:
+        if (process_sleep_params(argc, argv)) {
+            fprintf(stderr, "Sleep Params Failed\n");
+            display_usage();
+            exit(1);
+        }
+        break;
+    case CMD_BCA_TS:
+        if (process_bca_ts(argc, argv)) {
+            fprintf(stderr, "SetBcaTs Failed\n");
+            display_usage();
+            exit(1);
+        }
+        break;
+    case CMD_REASSOCIATE:
+        if (process_reassociation(argc, argv)) {
+            exit(1);
+        }
+        break;
+    case CMD_EXTSCAN:
+        if (process_extscan(argc, argv)) {
+            fprintf(stderr, "ExtScan Failed\n");
+            display_usage();
+            exit(1);
+        }
+        break;
+    case CMD_SCAN_LIST:
+        if (process_scan_results(argc, argv)) {
+            fprintf(stderr, "getscanlist Failed\n");
+            display_usage();
+            exit(1);
+        }
+        break;
+    case CMD_SET_GEN_IE:
+        if (process_setgenie()) {
+            exit(1);
+        }
+        break;
+    case CMD_GET_SCAN_RSP:
+        if (process_getscantable(argc, argv)) {
+            exit(1);
+        }
+        break;
+
+    case CMD_SET_USER_SCAN:
+        if (process_setuserscan(argc, argv)) {
+            exit(1);
+        }
+        break;
+
+    case CMD_SET_MRVL_TLV:
+        if (process_setmrvltlv()) {
+            exit(1);
+        }
+        break;
+
+    case CMD_GET_ASSOC_RSP:
+        if (process_getassocrsp()) {
+            exit(1);
+        }
+        break;
+    case CMD_ARPFILTER:
+        process_arpfilter(argc, argv);
+        break;
+    default:
+        fprintf(stderr, "Invalid command specified!\n");
+        display_usage();
+        exit(1);
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
diff --git a/drivers/net/wireless/8686_wlan/app/wlanconfig/wlanconfig.h b/drivers/net/wireless/8686_wlan/app/wlanconfig/wlanconfig.h
new file mode 100644
index 0000000..b9d6369
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/app/wlanconfig/wlanconfig.h
@@ -0,0 +1,83 @@
+/** @file wlan_config.h
+ * 
+ * @brief This file contains definitions for application
+ * 
+ * (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/****************************************************************
+Change log:
+	09/26/05: add Doxygen format comments
+****************************************************************/
+
+#ifndef _WLANCONFIG_H_
+#define _WLANCONFIG_H_
+
+#define NULLBSSID		"\x00\x00\x00\x00\x00\x00"
+
+/* to create pointers to 6-byte hardware address */
+#define HWA_ARG(x)		*(((u8 *)x + 0)), *(((u8 *)x + 1)), \
+				*(((u8 *)x + 2)), *(((u8 *)x + 3)), \
+				*(((u8 *)x + 4)), *(((u8 *)x + 5))
+
+#define WCON_ENC_DISABLED	0
+#define WCON_ENC_ENABLED	1
+
+#define WCON_WPA_DISABLED	0
+#define WCON_WPA_ENABLED	1
+
+#define WCON_WMM_DISABLED	0
+#define WCON_WMM_ENABLED	1
+
+/** struct of SSID network name */
+typedef struct _WCON_SSID
+{
+        /** SSID name length */
+    u32 ssid_len;
+        /** SSID name string */
+    u8 ssid[IW_ESSID_MAX_SIZE + 1];
+} WCON_SSID;
+
+typedef u8 WCON_BSSID[ETH_ALEN];
+
+/** struct of SSID network information */
+typedef struct _WCON_NET_INFO
+{
+        /** SSID network name struct */
+    WCON_SSID Ssid;
+        /** hardware address of the SSID network */
+    WCON_BSSID Bssid;
+        /** rssi value */
+    unsigned int Rssi;
+        /**  network operating mode */
+    int NetMode;
+        /** network privacy mode */
+    int Privacy;
+        /** WPA enable */
+    int WpaAP;
+        /** WMM enable */
+    int Wmm;
+} WCON_NET_INFO;
+
+/** struct of SSID list from scan */
+typedef struct _WCON_HANDLE
+{
+        /** list of scan result */
+    WCON_NET_INFO ScanList[IW_MAX_AP];
+    int ApNum;
+} WCON_HANDLE;
+
+#endif /* _WLANCONFIG_H_ */
diff --git a/drivers/net/wireless/8686_wlan/config/arpfilter.conf b/drivers/net/wireless/8686_wlan/config/arpfilter.conf
new file mode 100644
index 0000000..dca086d
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/config/arpfilter.conf
@@ -0,0 +1,40 @@
+#	File : arpfilter.conf
+#
+# (c) Copyright © 2003-2007, Marvell International Ltd. 
+#
+# This software file (the "File") is distributed by Marvell International 
+# Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+# (the "License").  You may use, redistribute and/or modify this File in 
+# accordance with the terms and conditions of the License, a copy of which 
+# is available along with the File in the gpl.txt file or by writing to 
+# the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+# 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+#
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+# IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+# ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+# this warranty disclaimer.
+#
+
+######################### Host Sleep ARP/IP filtering command ##################
+# add arp filter
+# must not exceed 20 bytes
+arpfilter={
+	TlvType:2=0x0115
+	TlvLength:2={
+		AddrType:2=3		# multicast		
+		EthType:2=0x0008	# IPv4: 0x0800
+		Ipv4Addr:4=0xffffffff	# not used
+		AddrType:2=1		# broadcast		
+		EthType:2=0x0608	# ARP: 0x0806
+		Ipv4Addr:4=0x5800a8c0	# 192.168.0.88
+	}
+}
+
+# remove arp filter
+#arpfilter={
+#	TlvType:2=0x0115
+#	TlvLength:2={
+#	}
+#}
+######################### Host Sleep ARP/IP filtering command ##################
diff --git a/drivers/net/wireless/8686_wlan/config/bg_scan.conf b/drivers/net/wireless/8686_wlan/config/bg_scan.conf
new file mode 100644
index 0000000..d3e940a
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/config/bg_scan.conf
@@ -0,0 +1,66 @@
+#	File : bg_scan_config.conf
+#
+# (c) Copyright © 2003-2006, Marvell International Ltd. 
+#
+# This software file (the "File") is distributed by Marvell International 
+# Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+# (the "License").  You may use, redistribute and/or modify this File in 
+# accordance with the terms and conditions of the License, a copy of which 
+# is available along with the File in the gpl.txt file or by writing to 
+# the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+# 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+#
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+# IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+# ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+# this warranty disclaimer.
+#
+
+bgscan={
+	Action=1		# 1 - set configuration 0 - get previous configuration
+	BssType=3		# 1 - Infrastructure
+				# 2 - IBSS
+				# 3 - Any
+	ChannelsPerScan=14	# Number of Channel to scan at one scan; maxinum 14
+	DiscardWhenFull=0	# 0 - Discard old scan result
+				# 1 - Discard new scan result
+	ScanInterval=1000	# Interval between consecutive scan (in milliseconds)
+	StoreCondition=1	# 1 - SSID match (bit 0) 
+	                        # 2 - SSID match AND SNR above SNR threshold (bit 1)
+	ReportConditions=1	# 1 - SSID match (bit 0)
+				# 2 - SSID match AND SNR above SNR threshold (bit 1)	
+	MaxScanResults=14	# - Max scan results that will trigger a
+				#   scan completion event
+
+# SSID entries, 
+# 1. Comment the SSIDX field with '#' to denote SSIDX is not present.
+# 2. SSIDX="", to denote NULL SSID, which is considered as SSID with length 0.
+# 3. SSIDX="AP_NAME", to mention a specific SSID to match.
+# 4. SSIDX="AP_NAME",max length, wildcard AP_NAME will be use to match the SSID, and SSID's max length is max length.
+# 5. SSIDX="AP*NAME", wildcard AP*NAME will be use to match the SSID. 
+
+	SSID1="AP_NAME"		# SSID to match	
+#	SSID2="AP_NAME",9	# SSID to match	"AP_NAME*" and SSID's max length is 9
+#	SSID3="AP*NAME"		# SSID to match	"AP*NAME"
+#	SSID4=""		# SSID to match	
+#	SSID5=""		# SSID to match	
+#	SSID6=""		# SSID to match
+#	SSID7=""
+#	SSID8=""
+#	SSID9=""
+#	SSID10=""
+	Probes=0		# Number Probe requests to be sent, 0 mean use firmware default settings.	
+
+	ChannelList="0,1,0,6,100;0,6,1,6,100" #ChannelList contains the channels to scan
+				# The ChannelList should be specified in the form of
+				# RadioType, ChanNumber, ScanType, MinScanTime, ScanTime
+				# The next channel description should be separated by semicolon
+				# operator
+				# RadioType - 0 [B/G Band], 1 [A Band]
+				# ScanType - 0 [Active], 1 [Passive]
+        SnrThreshold=40		# the SNR threshold to match, when StoreCondition or ReportConditions been set to 2		
+        BcastProbe=0            # 0 - broadcast SSID probe is not generate  
+				# 1 - broadcast SSID is generate
+	NumSSIDProbe=1          # 0-10 - probe request are generated corresponding to the first N SSIDs
+}
+
diff --git a/drivers/net/wireless/8686_wlan/config/cal_data_ext_set_v5.conf b/drivers/net/wireless/8686_wlan/config/cal_data_ext_set_v5.conf
new file mode 100644
index 0000000..6419701
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/config/cal_data_ext_set_v5.conf
@@ -0,0 +1,7 @@
+01 00
+05 00 40 00
+#from CF8385 EEPROM 0x80
+43 46 2d 32 35 70 00 ab 05 02 00 09 06 00 06 00
+06 00 06 00 06 00 06 00 06 00 06 00 06 00 06 00
+06 00 06 00 06 00 04 00 8f ce 18 5d 10 00 00 00
+10 40 00 80 12 11 08 00 01 00 01 01 04 78 05 f6
diff --git a/drivers/net/wireless/8686_wlan/config/cal_data_ext_set_v7.conf b/drivers/net/wireless/8686_wlan/config/cal_data_ext_set_v7.conf
new file mode 100644
index 0000000..89ddd6e
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/config/cal_data_ext_set_v7.conf
@@ -0,0 +1,19 @@
+01 00
+07 00 00 01
+#from CF8385H EEPROM 0x80, set v7
+07 24 44 98 01 01 00 00 00 03 e2 3b 00 00 10 03
+20 00 20 01 88 20 03 10 01 01 02 02 10 01 00 00
+00 00 03 4f 0c 8f ce 18 08 00 00 00 08 00 00 00
+08 00 00 00 08 00 00 00 07 00 00 00 07 00 00 00
+06 00 00 00 05 00 00 00 04 00 00 00 04 00 00 00
+03 00 00 00 03 00 00 00 02 00 00 00 02 00 00 00
+dd 22 40 06 00 00 03 11 04 95 00 00 fb 08 00 00
+fa 08 00 00 f9 08 00 00 f8 08 00 00 f8 08 00 00
+f7 08 00 00 f6 08 00 00 f6 08 00 00 f8 08 00 00
+f8 08 00 00 f8 08 00 00 f9 08 00 00 f9 08 00 00
+f9 08 00 00 f9 08 00 00 fa 08 00 00 f9 08 00 00
+f9 08 00 00 f9 08 00 00 fc 0c 00 00 fc 0c 00 00
+fc 0c 00 00 fc 0c 00 00 fd 0c 00 00 03 09 00 00
+02 09 00 00 01 09 00 00 fd 09 00 00 fc 09 00 00
+fa 09 00 00 f9 09 00 00 04 09 00 00 04 09 00 00
+04 09 00 00 04 09 00 00 00 22 40 06 0d 2b 1d d1
diff --git a/drivers/net/wireless/8686_wlan/config/cal_data_ext_set_vA.conf b/drivers/net/wireless/8686_wlan/config/cal_data_ext_set_vA.conf
new file mode 100644
index 0000000..39da1e9
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/config/cal_data_ext_set_vA.conf
@@ -0,0 +1,31 @@
+01 00
+0a 00 b0 01
+#from GSPI8385 EEPROM Rev A 
+00 00 00 00 01 01 01 01 0a 00 00 a0 00 00 00 40 
+04 71 ed 00 00 fe 00 00 ff f9 00 00 00 00 00 00 
+14 0f 14 0f 8f ce 18 14 8f ce 18 14 10 00 00 00 
+10 1f 00 00 10 11 10 00 01 00 01 01 04 48 00 1f 
+01 98 00 50 00 00 00 90 00 fe 00 00 ff f9 00 00 
+00 00 00 00 0e 0b 0e 0b 8f ce 18 0e 8f ce 18 0e 
+00 fe 00 00 ff f9 00 00 00 00 00 00 0a 06 0a 06 
+8f ca 0a 0a 8f ce 18 0a 00 fe 00 00 ff f9 00 00 
+00 00 00 00 05 00 05 00 86 ca 10 05 86 ca 18 05 
+02 b1 00 1c 00 00 00 ac 00 00 00 00 00 00 00 00 
+00 00 00 00 00 00 00 00 00 00 00 00 03 94 00 1c 
+00 00 00 c8 00 00 00 00 00 00 00 00 00 00 00 00 
+00 00 00 00 00 00 00 00 04 6f 00 20 00 00 00 e8 
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
+00 00 00 00 00 00 00 00 05 71 00 10 00 00 00 f8 
+00 ff ff ff 00 00 00 00 07 74 00 5c 00 00 01 54 
+00 0c 0a 54 01 0f 0d 5c 02 12 10 64 03 14 12 68 
+04 17 15 70 05 1a 18 78 06 1f 1d 6c 07 27 25 74 
+08 2f 2d 7c 09 37 35 84 0a 3f 3d 8c 0b 26 24 61 
+0c 2b 29 69 0d 31 2f 71 0e 36 34 79 0f 39 37 81 
+10 3c 3a 89 11 3f 3d 91 12 ff ff fd 13 ff ff fd 
+14 ff ff fd 08 43 00 5c ff ff ff ff 00 0a 08 70 
+01 0d 0b 78 02 10 0e 80 03 12 10 88 04 15 13 90 
+05 18 16 98 06 1c 1a 68 07 22 20 70 08 29 27 78 
+09 2f 2d 80 0a 36 34 88 0b ff ff fd 0c ff ff fd 
+0d ff ff fd 0e ff ff fd 0f ff ff fd 10 ff ff fd 
+11 ff ff fd 12 ff ff fd 13 ff ff fd 14 ff ff fd
+   	     	   	     	   	     	   	     
diff --git a/drivers/net/wireless/8686_wlan/config/hostcmd.conf b/drivers/net/wireless/8686_wlan/config/hostcmd.conf
new file mode 100644
index 0000000..63c6492
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/config/hostcmd.conf
@@ -0,0 +1,240 @@
+#	File : hostcmd.conf
+#
+# (c) Copyright © 2003-2006, Marvell International Ltd. 
+#
+# This software file (the "File") is distributed by Marvell International 
+# Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+# (the "License").  You may use, redistribute and/or modify this File in 
+# accordance with the terms and conditions of the License, a copy of which 
+# is available along with the File in the gpl.txt file or by writing to 
+# the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+# 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+#
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+# IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+# ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+# this warranty disclaimer.
+#
+
+######################### Power Adaptation Config Ext command ##################
+pa_cfg_ext_get={
+	CmdCode=0x007e		# do NOT change this line
+
+				# The following table shows the bitmap of the rates:
+				# (bit 0 is the least significant bit)
+		       		#	Bit	Data rate
+				#	0	1 Mbps
+				#	1	2 Mbps
+				#	2	5.5 Mbps
+				#	3	11 Mbps
+				#	4	Reserved
+				#	5	6 Mbps
+				#	6	9 Mbps
+				#	7	12 Mbps
+				#	8	18 Mbps
+				#	9	24 Mbps
+				#	10	36 Mbps
+				#	11	48 Mbps
+				#	12	54 Mbps
+				#	13-15	Reserved
+
+	Action:2=0		# 0 - GET
+	EnablePA:2=0
+	TlvType:2=0x0114
+	TlvLength:2={
+	}
+}
+
+pa_cfg_ext_set={
+	CmdCode=0x007e		# do NOT change this line
+
+	Action:2=1		# 1 - SET
+	EnablePA:2=1		# 1 - enable power adaptation
+	TlvType:2=0x0114
+	TlvLength:2={
+							# Up to 5 power level groups are supported
+							# Power Level	Rate Bitmap (Mbps)
+
+							# 13 dbm	0x1800 (54, 48)
+		PowerAdaptGroup1.PowerLevel:2=13
+		PowerAdaptGroup1.RateBitmap:2=0x1800
+		PowerAdaptGroup1.Reserved:4=0
+
+							# 15 dbm	0x07e0 (36, 24, 18, 12, 9, 6)
+		PowerAdaptGroup2.PowerLevel:2=15
+		PowerAdaptGroup2.RateBitmap:2=0x07e0
+		PowerAdaptGroup2.Reserved:4=0
+
+							# 18 dbm	0x000f (11, 5.5, 2, 1)
+		PowerAdaptGroup3.PowerLevel:2=18
+		PowerAdaptGroup3.RateBitmap:2=0x000f
+		PowerAdaptGroup3.Reserved:4=0
+
+#		PowerAdaptGroup4.PowerLevel:2=0
+#		PowerAdaptGroup4.RateBitmap:2=0
+#		PowerAdaptGroup4.Reserved:4=0
+
+#		PowerAdaptGroup5.PowerLevel:2=0
+#		PowerAdaptGroup5.RateBitmap:2=0
+#		PowerAdaptGroup5.Reserved:4=0
+	}
+}
+######################### Power Adaptation Config Ext command ##################
+
+######################### Subscribe Events command ##################
+subevent_get={
+	CmdCode=0x0075		# do NOT change this line
+
+	Action:2=0		# GET
+	Events:2=0
+}
+
+subevent_set={
+	CmdCode=0x0075		# do NOT change this line
+
+	Action:2=1		# SET
+	Events:2=0x3f		# bit0 - RSSI_LOW; bit1 - SNR_LOW
+				# bit2 - FAILED_COUNT; bit3 - Beacon Missed
+				# bit4 - RSSI_HIGH; bit5 - SNR_HIGH
+				# bit6-15 reserved
+
+	LowRssiTlvType:2=0x0104
+	LowRssiTlvLength:2={
+		Threshold:1=70
+		ReportingFreq:1=0
+	}
+
+	LowSnrTlvType:2=0x0105
+	LowSnrTlvLength:2={
+		Threshold:1=56
+		ReportingFreq:1=0
+	}
+
+	FailedCountTlvType:2=0x0106
+	FailedCountTlvLength:2={
+		Threshold:1=5
+		ReportingFreq:1=0
+	}
+
+	BeaconMissTlvType:2=0x0107
+	BeaconMissTlvLength:2={
+		BeaconMissed:1=60
+		Reserved:1=0
+	}
+
+	HighRssiTlvType:2=0x0116
+	HighRssiTlvLength:2={
+		Threshold:1=40
+		ReportingFreq:1=0
+	}
+
+	HighSnrTlvType:2=0x0117
+	HighSnrTlvLength:2={
+		Threshold:1=86
+		ReportingFreq:1=0
+	}
+}
+######################### Subscribe Events command ##################
+
+######################### Host Sleep ARP/IP filtering command ##################
+arp_filter={
+	CmdCode=0x0043		# do NOT change this line
+
+	Condition:4=0x09	# bit0 - broadcast; bit1 - unicast; bit2 - MAC event; bit3 - multicast
+				# 0xffffffff - cancel host_sleep_cfg
+	Gpio:1=0xff		# 0xff - GPIO wakeup not required
+				# 0-7: GPIO 0-7
+	Gap:1=0x80		# 128 ms
+	TlvType:2=0x0115
+	TlvLength:2={
+		AddrType:2=3		# multicast		
+		EthType:2=0x0008	# IPv4: 0x0800
+		Ipv4Addr:4=0xffffffff	# not used
+		AddrType:2=1		# broadcast		
+		EthType:2=0x0608	# ARP: 0x0806
+		Ipv4Addr:4=0x5800a8c0	# 192.168.0.88
+	}
+}
+######################### Host Sleep ARP/IP filtering command ##################
+
+######################### Auto-TX command ##################
+auto_tx_get={
+	CmdCode=0x0082		# do NOT change this line
+
+	Action:2=0		# GET
+}
+
+auto_tx_unreg={
+	CmdCode=0x0082		# do NOT change this line
+
+	Action:2=1		# SET
+}
+
+NatKeepAlive={
+	CmdCode=0x0082		# do NOT change this line
+
+	Action:2=1		# SET
+
+	AutoTxTlvType:2=0x0118
+	AutoTxTlvLength:2={				# 58 = 6 + 52 (FrameLen)
+		Interval:2=2				# 1 - 3600 seconds
+		Priority:1=7				# Priority, ignored if non-WMM
+		Reserved:1=0
+		FrameLength:2={				# 52 = 6 (DA) + 6 (SA) + 2 + 38 (Length)
+			DestMacAddr:6='0x00,0x40,0xf4,0xbf,0x24,0xee'
+			SrcMacAddr:6='0x00,0x00,0x00,0x00,0x00,0x00'
+			Length:2='0x00,38'		# 38 = 8 (SNAP hdr) + 29 (IP) + 1 (padding)
+			DSAP:1=0xaa			# SNAP header
+			SSAP:1=0xaa
+			Ctrl:1=0x03
+			SNAP_OUI:3='0x00,0x00,0x00'
+			SNAP_PID:2='0x08,0x00'		# IP Packet
+			IPv4:1=0x45
+			IP_TOS:1=0x00
+			IP_LEN:2='0x00,29'		# IP hdr 20 + payload 9 = 29
+			IP_ID:2=0xefbe
+			IP_Flag_FragOffset:2=0x0000
+			IP_TTL:1=128
+			IP_Prot:1=17			# UDP protocol
+			IPhdr_cksum:2=0xc5f9		# may need re-calculation if changed
+			IPsrcAddr:4='192,168,0,201'	# 192.168.0.201
+			IPdstAddr:4='192,168,0,1'	# 192.168.0.1
+			UDPsrcPort:2='0x11,0x94'	# 4500
+			UDPdstPort:2='0x11,0x94'	# 4500
+			UDPlength:2='0x00,9'		# UDP hdr 8 + payload 1 = 9
+			UDPcksum:2=0x985b		# may need re-calculation if changed
+			UDPpayload:1=0xff
+			padding:1=0			# MAC Padding for 32bit alignment, set to 0
+		}
+	}
+}
+######################### Auto-TX command ##################
+
+######################### MEM_ACCESS ##################
+mr_c00153e4={
+	CmdCode=0x0086		# do NOT change this line
+
+	Action:2=0		# GET
+	Reserved:2=0
+	Address:4=0xc00153e4
+	Value:4=0
+}
+
+mw_c00153e4_0={
+	CmdCode=0x0086		# do NOT change this line
+
+	Action:2=1		# SET
+	Reserved:2=0
+	Address:4=0xc00153e4
+	Value:4=0
+}
+
+mw_c00153e4_aabbccdd={
+	CmdCode=0x0086		# do NOT change this line
+
+	Action:2=1		# SET
+	Reserved:2=0
+	Address:4=0xc00153e4
+	Value:4=0xaabbccdd
+}
+######################### MEM_ACCESS ##################
diff --git a/drivers/net/wireless/8686_wlan/config/tspecs.conf b/drivers/net/wireless/8686_wlan/config/tspecs.conf
new file mode 100644
index 0000000..fa4f128
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/config/tspecs.conf
@@ -0,0 +1,99 @@
+# TSPEC contents for TID=0, UserPriority = 6
+[tspec0]
+# Element ID
+dd 
+# Length
+3d 
+# OUI
+00 50 f2 
+# OUI Type
+02 
+# OUI SubType
+02 
+# Version
+01 
+# TSInfo
+e0 34 00 
+# Nominal MSDU Size
+d0 80 
+# Maximum MSDU Size
+d0 00 
+# Min Service Interval
+20 4e 00 00 
+# Max Service Interval
+20 4e 00 00 
+# Inactivity Interval
+80 96 98 00 
+# Suspension Interval
+ff ff ff ff 
+# Service Start Time
+00 00 00 00 
+# Minimum Data Rate
+00 45 01 00 
+# Mean Data Rate
+00 45 01 00 
+# Peak Data Rate
+00 45 01 00 
+# Max Burst Size
+00 00 00 00 
+# Delay Bound
+00 00 00 00 
+# Min PHY Rate
+00 1b b7 00 
+# Surplus Bandwidth Allowance
+04 20 
+# Medium Time
+00 00 
+# Extra Data Bytes
+[/tspec0]
+
+
+# TSPEC contents for TID=1, UserPriority = 4
+[tspec1]
+# Element ID
+dd 
+# Length
+3d 
+# OUI
+00 50 f2 
+# OUI Type
+02 
+# OUI SubType
+02 
+# Version
+01 
+# TSInfo
+e3 20 00 
+# Nominal MSDU Size
+96 00 
+# Maximum MSDU Size
+dc 05 
+# Min Service Interval
+00 00 00 00 
+# Max Service Interval
+00 00 00 00 
+# Inactivity Interval
+00 00 00 00 
+# Suspension Interval
+ff ff ff ff 
+# Service Start Time
+00 00 00 00 
+# Minimum Data Rate
+a0 00 00 00 
+# Mean Data Rate
+a0 00 00 00 
+# Peak Data Rate
+a0 00 00 00 
+# Max Burst Size
+00 00 00 00 
+# Delay Bound
+00 00 00 00 
+# Min PHY Rate
+80 8d 5b 00 
+# Surplus Bandwidth Allowance
+00 20 
+# Medium Time
+00 00 
+# Extra Data Bytes
+[/tspec1]
+
diff --git a/drivers/net/wireless/8686_wlan/config/wmm_para.conf b/drivers/net/wireless/8686_wlan/config/wmm_para.conf
new file mode 100644
index 0000000..4301755
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/config/wmm_para.conf
@@ -0,0 +1,30 @@
+#	File : wmm_para.conf
+#
+# (c) Copyright © 2003-2006, Marvell International Ltd. 
+#
+# This software file (the "File") is distributed by Marvell International 
+# Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+# (the "License").  You may use, redistribute and/or modify this File in 
+# accordance with the terms and conditions of the License, a copy of which 
+# is available along with the File in the gpl.txt file or by writing to 
+# the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+# 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+#
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+# IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+# ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+# this warranty disclaimer.
+#
+#	
+#	Configuration file
+#	Para IE command
+#	short	Action; 		/* 0 - ACT_GET
+#					   1 - ACT_SET
+#					  -1 - Command not sent to firmware */
+#	u8	Para_IE[26];	
+[wmmparaie]
+# short Action
+01 00
+# u8 Para_IE[26]
+dd 18 00 50 f2 02 01 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+[/wmmparaie]
diff --git a/drivers/net/wireless/8686_wlan/gpl.txt b/drivers/net/wireless/8686_wlan/gpl.txt
new file mode 100644
index 0000000..f90922e
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/gpl.txt
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+ 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/drivers/net/wireless/8686_wlan/if/if_sdio_fb/if_sdio.c b/drivers/net/wireless/8686_wlan/if/if_sdio_fb/if_sdio.c
new file mode 100644
index 0000000..5e1393e
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/if/if_sdio_fb/if_sdio.c
@@ -0,0 +1,1422 @@
+/** @file if_sdio.c
+ *  @brief This file contains SDIO IF (interface) module
+ *  related functions.
+ *  
+ * Copyright 2007 Intel Corporation and its suppliers. All rights reserved
+ * 
+ * (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+
+#include "if_sdio.h"
+#include <asm/scatterlist.h>
+
+#include <linux/firmware.h>
+
+#define DEFAULT_HELPER_NAME "mrvl/helper_sd.bin"
+#define DEFAULT_FW_NAME "mrvl/sd8686.bin"
+
+extern u8 *helper_name;
+extern u8 *fw_name;
+
+/* 
+ * Define the SD Block Size
+ * for SD8381-B0/B1, SD8385/B0 chip, it could be 32,64,128,256,512
+ * for all other chips including SD8381-A0, it must be 32
+ */
+
+/* define SD block size for firmware download */
+#define SD_BLOCK_SIZE_FW_DL     32
+#define SDIO_HEADER_LEN		4
+
+/* define SD block size for data Tx/Rx */
+#define SD_BLOCK_SIZE           256
+
+/* manually set the CIS addr for 8686 */
+#define CIS_8686_PTR 0x8000
+
+#define ALLOC_BUF_SIZE          (((MAX(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE, \
+                                        MRVDRV_SIZE_OF_CMD_BUFFER) + SDIO_HEADER_LEN \
+                                        + SD_BLOCK_SIZE - 1) / SD_BLOCK_SIZE) * SD_BLOCK_SIZE)
+
+#define GPIO_PORT_NUM
+#define GPIO_PORT_INIT()
+#define GPIO_PORT_TO_HIGH()
+#define GPIO_PORT_TO_LOW()
+
+/*
+ * Poll the Card Status register until the bits specified in the argument
+ * are turned on.
+ */
+
+#define BLOCK_MODE 1
+#define FIXED_ADDRESS 0
+
+// feng: temply add some notes here
+#define BUS_IF_CTRL 0x0
+
+struct net_device *the_netdev = NULL;
+
+
+int sbi_mmc_disable_host_int(wlan_private *priv); 
+
+/* some sdio wrapper API */
+static int sdio_read_byte(struct sdio_func *func, u32 addr, u8 *pdata)
+{
+	int ret;
+	sdio_claim_host(func);
+	*pdata = sdio_readb(func, addr, &ret);
+	sdio_release_host(func);
+	return ret;
+}
+
+static int sdio_write_byte(struct sdio_func *func, u32 addr, u8 data)
+{
+	int ret;
+	sdio_claim_host(func);
+	sdio_writeb(func, data, addr, &ret);
+	sdio_release_host(func);
+	return ret;
+}
+
+static int sdio_card_readb(struct sdio_func *func, u32 addr, u8 *data)
+{
+	int ret;
+
+	sdio_claim_host(func);
+	*data = sdio_f0_readb(func, addr, &ret);
+	sdio_release_host(func);
+
+	return ret;
+}
+
+static int sdio_card_writeb(struct sdio_func *func, u32 addr, u8 data)
+{
+	int ret;
+
+	sdio_claim_host(func);
+	sdio_f0_writeb(func, data, addr, &ret);
+	sdio_release_host(func);
+
+	return ret;
+}
+
+
+static wlan_private *pwlanpriv;
+static wlan_private *(*wlan_add_callback) (void *dev_id);
+static int (*wlan_remove_callback) (void *dev_id);
+static int cmd_result = 0;
+
+int mv_sdio_read_event_cause(wlan_private * priv);
+
+void sbi_interrupt(struct sdio_func  *func)
+{
+	wlan_interrupt(the_netdev);
+}
+
+int sbi_probe_card(void *val)
+{
+	return WLAN_STATUS_SUCCESS;
+}
+
+static void sbi_io_request_done(struct mmc_request *req)
+{
+    ENTER();
+    LEAVE();
+}
+
+
+
+static int sbi_dev_probe_func(struct sdio_func *func, const struct sdio_device_id *id)
+{
+	int result, ret = WLAN_STATUS_SUCCESS;
+    	u8 chiprev, bic;   
+
+	umd_dbg("enter, func = 0x%08x", func);
+    
+	result = sdio_read_byte(func, CARD_REVISION_REG, &chiprev);
+
+	/* read Revision Register to get the hw revision number */
+	if (result) {
+		printk("cannot read CARD_REVISION_REG\n");
+	} else {
+		umd_dbg("revision=0x%x\n", chiprev);
+		switch (chiprev) {
+			default:
+
+			/* enable async interrupt mode */
+			sdio_card_readb(func, BUS_IF_CTRL, &bic);
+			bic |= ASYNC_INT_MODE;
+			sdio_card_writeb(func, BUS_IF_CTRL, bic);
+			break;
+		}
+    	}
+
+	if (!wlan_add_callback)
+		goto done;
+
+	umd_dbg("will call sdio_enable_func");
+	sdio_claim_host(func);
+	ret = sdio_enable_func(func);
+	sdio_release_host(func);
+	if (ret) {
+		printk(KERN_ALERT "Fail to enable func\n");
+		ret = WLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* feng: here we need add the irq hook */
+	sdio_claim_host(func);
+	ret =  sdio_claim_irq(func, sbi_interrupt);
+	sdio_release_host(func);
+        
+	umd_dbg("Will call the wlan_add_callback");
+	pwlanpriv = wlan_add_callback(func);
+
+	if (pwlanpriv)
+		ret = WLAN_STATUS_SUCCESS;
+	else
+		ret = WLAN_STATUS_FAILURE;
+
+	//sdio_claim_host(func);
+       //sdio_dump_cccr(func);
+	//sdio_release_host(func);
+	umd_dbg("exit, ret = %d", ret);
+done:
+	LEAVE();
+	return ret;
+}
+
+static void sbi_dev_remove_func(struct sdio_func *func)
+{
+	if (!wlan_remove_callback)
+		return WLAN_STATUS_FAILURE;
+	pwlanpriv = NULL;
+
+	wlan_remove_callback(func);
+
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+	sdio_disable_func(func);
+	sdio_release_host(func);
+}
+
+static const struct sdio_device_id sdio_8686_ids[] = {
+	{ SDIO_DEVICE_CLASS(SDIO_CLASS_WLAN)		},
+	{ /* end: all zeroes */				},
+};
+
+//MODULE_DEVICE_TABLE(sdio, sdio_8686_ids);
+
+static struct sdio_driver sdio8686_driver = {
+	.probe		= sbi_dev_probe_func,
+	.remove		= sbi_dev_remove_func,
+	.name 		= "sdio_8686",
+	.id_table	= sdio_8686_ids,
+};
+
+int *sbi_register(wlan_notifier_fn_add add, wlan_notifier_fn_remove remove,
+             void *arg)
+{
+	umd_enter();
+	wlan_add_callback = add;
+	wlan_remove_callback = remove;
+
+	sdio_register_driver(&sdio8686_driver);
+	umd_exit();
+	return (int *) wlan_add_callback;
+}
+
+void sbi_unregister(void)
+{
+	sdio_unregister_driver(&sdio8686_driver);
+
+	wlan_add_callback = NULL;
+	wlan_remove_callback = NULL;	
+}
+
+int sbi_read_ioreg(wlan_private * priv, u32 reg, u8 *pdata)
+{
+	struct sdio_func *func = (struct sdio_func*)(priv->wlan_dev.card);
+	int ret;
+
+	ret = sdio_read_byte(func, reg, pdata);
+	return ret;
+}
+
+int sbi_write_ioreg(wlan_private * priv, u32 reg, u8 data)
+{
+    	struct sdio_func *func = (struct sdio_func*)(priv->wlan_dev.card);
+	int ret;
+
+	ret = sdio_write_byte(func, reg, data);
+	return ret;
+}
+
+int sbi_write_iomem(wlan_private * priv, u32 reg, u8 blockmode,
+                u8 opcode, ssize_t cnt, ssize_t blksz, u8 * dat)
+{
+	struct sdio_func *func = (struct sdio_func*)(priv->wlan_dev.card);
+	int ret;
+	
+	/* feng: need set the block size here */
+	sdio_claim_host(func);
+        ret = sdio_writesb(func, reg, dat, cnt * blksz);
+	sdio_release_host(func);
+	return ret;
+}
+
+int sbi_read_iomem(wlan_private * priv, u32 reg, u8 blockmode, u8 opcode,
+               ssize_t cnt, ssize_t blksz, u8 * dat)
+{
+	struct sdio_func *func = (struct sdio_func*)(priv->wlan_dev.card);
+	int ret;
+
+	sdio_claim_host(func);
+        ret = sdio_readsb(func, dat, reg, cnt * blksz); 
+	sdio_release_host(func);
+	return ret;
+}
+
+int sbi_read_intr_reg(wlan_private * priv, u8 *ireg)
+{
+    return sbi_read_ioreg(priv, HOST_INTSTATUS_REG, ireg);
+}
+
+int sbi_read_card_reg(wlan_private * priv, u8 *cs)
+{
+    return sbi_read_ioreg(priv, CARD_STATUS_REG, cs);
+}
+
+int sbi_clear_int_status(wlan_private * priv, u8 mask)
+{
+	return sbi_write_ioreg(priv, HOST_INTSTATUS_REG, 0x0);
+}
+
+int
+sbi_get_int_status(wlan_private * priv, u8 * ireg)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+	u8 cs, *cmdBuf;
+	wlan_dev_t *wlan_dev = &priv->wlan_dev;
+	struct sk_buff *skb;
+	struct sdio_func *func = (struct sdio_func *) (priv->wlan_dev.card);
+
+	//umd_enter();
+
+	// feng: we mask it here, but this may be an issue
+	//mss_set_sdio_int(slot->host, MSS_SDIO_INT_DIS);
+	sbi_mmc_disable_host_int(priv);
+
+	if ((ret = sbi_read_ioreg(priv, HOST_INTSTATUS_REG, ireg)) < 0) {
+		PRINTM(WARN, "Reading interrupt status register failed\n");
+		umd_dbg("Reading interrupt status register failed\n");
+		ret = WLAN_STATUS_FAILURE;
+		goto end;
+	}
+
+	//umd_dbg("int status ireg = 0x%08x", *ireg);
+
+	if (*ireg != 0) {           /* DN_LD_HOST_INT_STATUS and/or UP_LD_HOST_INT_STATUS */
+		/* Clear the interrupt status register */
+		if ((ret = sbi_write_ioreg(priv, HOST_INTSTATUS_REG,
+		                           ~(*ireg) & (DN_LD_HOST_INT_STATUS |
+		                                       UP_LD_HOST_INT_STATUS))) < 0) {
+		    PRINTM(WARN, "sdio_write_ioreg: clear interrupt status"
+		           " register failed\n");
+		    ret = WLAN_STATUS_FAILURE;
+		    goto end;
+		}
+	}
+
+	if (*ireg & DN_LD_HOST_INT_STATUS) {
+		*ireg |= HIS_TxDnLdRdy;
+		if (!priv->wlan_dev.dnld_sent) {        // tx_done already received
+			umd_dbg("warning: tx_done already received:"
+			   " dnld_sent=0x%x ireg=0x%x cs=0x%x",
+			   priv->wlan_dev.dnld_sent, *ireg, cs);
+		} else {
+			//umd_dbg("tx_done received: dnld_sent=0x%x ireg=0x%x"
+			 //  " cs=0x%x", priv->wlan_dev.dnld_sent, *ireg, cs);
+			if (priv->wlan_dev.dnld_sent == DNLD_DATA_SENT)
+			os_start_queue(priv);
+			priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+		}
+	}
+
+	if (*ireg & UP_LD_HOST_INT_STATUS) {
+		/*
+		 * DMA read data is by block alignment,so we need alloc extra block
+		 * to avoid wrong memory access.
+		 */
+		if (!(skb = dev_alloc_skb(ALLOC_BUF_SIZE))) {
+		    PRINTM(WARN, "No free skb\n");
+		    priv->stats.rx_dropped++;
+		    return WLAN_STATUS_FAILURE;
+		}
+
+		/* Transfer data from card */
+		/* TODO: Check for error return on the read */
+		/* skb->tail is passed as we are calling skb_put after we
+		 * are reading the data */
+		if (mv_sdio_card_to_host(priv, &wlan_dev->upld_typ,
+		                         (int *) &wlan_dev->upld_len, skb->tail,
+		                         ALLOC_BUF_SIZE) < 0) {
+		    PRINTM(WARN, "Card to host failed: ireg=0x%x cs=0x%x\n",
+		           *ireg, cs);
+		    if (sbi_read_ioreg(priv, CONFIGURATION_REG, &cs) < 0)
+		        PRINTM(WARN, "sdio_read_ioreg failed\n");
+
+		    //umd_dbg("Config Reg val = %d", cs);
+		    if (sbi_write_ioreg(priv, CONFIGURATION_REG, (cs | 0x04)) <
+		        0)
+		        PRINTM(WARN, "write ioreg failed\n");
+
+		    //umd_dbg("write success");
+		    if (sbi_read_ioreg(priv, CONFIGURATION_REG, &cs) < 0)
+		        PRINTM(WARN, "sdio_read_ioreg failed\n");
+
+		    //umd_dbg("Config reg val =%x", cs);
+		    ret = WLAN_STATUS_FAILURE;
+		    kfree_skb(skb);
+		    goto end;
+		}
+
+		//umd_dbg("Reading data in to skb size=%d upld_type=%d",
+		//	wlan_dev->upld_len, wlan_dev->upld_typ);
+		if (wlan_dev->upld_typ == MVSD_DAT) {
+		    //umd_dbg("Up load type is Data");
+		    *ireg |= HIS_RxUpLdRdy;
+		    skb_put(skb, priv->wlan_dev.upld_len);
+		    skb_pull(skb, SDIO_HEADER_LEN);
+		    list_add_tail((struct list_head *) skb,
+		                  (struct list_head *) &priv->adapter->RxSkbQ);
+		} else if (wlan_dev->upld_typ == MVSD_CMD) {
+		    *ireg &= ~(HIS_RxUpLdRdy);
+		    *ireg |= HIS_CmdUpLdRdy;
+
+		    //umd_dbg("Up load type is Cmd Response");
+		    /* take care of CurCmd = NULL case by reading the 
+		     * data to clear the interrupt */
+		    if (!priv->adapter->CurCmd) {
+		        cmdBuf = priv->wlan_dev.upld_buf;
+		        priv->adapter->HisRegCpy &= ~HIS_CmdUpLdRdy;
+			//                              *ireg &= ~HIS_RxUpLdRdy;
+		    } else {
+		        cmdBuf = priv->adapter->CurCmd->BufVirtualAddr;
+		    }
+
+		    priv->wlan_dev.upld_len -= SDIO_HEADER_LEN;
+		    memcpy(cmdBuf, skb->data + SDIO_HEADER_LEN,
+		           MIN(MRVDRV_SIZE_OF_CMD_BUFFER, priv->wlan_dev.upld_len));
+		    kfree_skb(skb);
+		} else if (wlan_dev->upld_typ == MVSD_EVENT) {
+		    *ireg |= HIS_CardEvent;
+		    kfree_skb(skb);
+		}
+
+		*ireg |= HIS_CmdDnLdRdy;
+	}
+
+	ret = WLAN_STATUS_SUCCESS;
+end:
+	//umd_exit();
+	// feng: mask here, may cause some issue	
+	sbi_reenable_host_interrupt(priv, 0x00);
+	return ret;
+}
+
+int
+sbi_poll_cmd_dnld_rdy(wlan_private * priv)
+{
+	return mv_sdio_poll_card_status(priv, CARD_IO_READY | UP_LD_CARD_RDY);
+}
+
+int sbi_card_to_host(wlan_private * priv, u32 type, u32 * nb, u8 * payload,
+                 u16 npayload)
+{
+	return WLAN_STATUS_SUCCESS;
+}
+
+int sbi_read_event_cause(wlan_private * priv)
+{
+	return WLAN_STATUS_SUCCESS;
+}
+
+int mv_sdio_read_event_cause(wlan_private * priv)
+{
+	struct sdio_func *func = (struct sdio_func*)(priv->wlan_dev.card);
+	int ret;
+	u8 scr2;
+
+	ENTER();
+	/* the SCRATCH_REG @ 0x8fc tells the cause for the Mac Event */
+	if ((ret = sdio_card_readb(func, 0x80fc, &scr2)) < 0) {
+		umd_dbg("Unable to read Event cause\n");
+		return ret;
+	}
+	priv->adapter->EventCause = scr2;
+
+	LEAVE();
+	return 0;
+}
+
+int sbi_retrigger(wlan_private * priv)
+{
+
+    ENTER();
+    if (sbi_write_ioreg(priv, CONFIGURATION_REG, 0x4) < 0) {
+        return -1;
+    }
+    LEAVE();
+    return 0;
+}
+
+int if_dnld_ready(wlan_private * priv)
+{
+    int rval;
+    u8 cs;
+    ENTER();
+    rval = sbi_read_ioreg(priv, CARD_STATUS_REG, &cs);
+    if (rval < 0)
+        return -EBUSY;
+    LEAVE();
+    return (cs & DN_LD_CARD_RDY) && (cs & CARD_IO_READY);
+}
+
+int sbi_is_tx_download_ready(wlan_private * priv)
+{
+	int rval;
+	ENTER();
+	rval = if_dnld_ready(priv);
+	LEAVE();
+	return (rval < 0) ? -1 : (rval == 1) ? 0 : -EBUSY;  //Check again
+}
+
+int sbi_reenable_host_interrupt(wlan_private *priv, u8 bits)
+{
+	struct sdio_func *func = (struct sdio_func*)(priv->wlan_dev.card);
+	struct mmc_host	*host;
+
+	host = func->card->host;
+	host->ops->enable_sdio_irq(host, 1);
+#if 0
+    struct mss_slot *slot = (struct mss_slot *) (priv->wlan_dev.card);
+    ENTER();
+    //mss_set_sdio_int(slot->host, MSS_SDIO_INT_EN);
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+#endif
+}
+
+int sbi_mmc_disable_host_int(wlan_private *priv) 
+{
+	struct sdio_func *func = (struct sdio_func*)(priv->wlan_dev.card);
+	struct mmc_host	*host;
+
+	host = func->card->host;
+	host->ops->enable_sdio_irq(host, 0);
+}
+
+
+/**  @brief This function disables the host interrupts mask.
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param mask    the interrupt mask
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int disable_host_int_mask(wlan_private * priv, u8 mask)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+	u8 host_int_mask;
+
+	ENTER();
+	/* Read back the host_int_mask register */
+	ret = sbi_read_ioreg(priv, HOST_INT_MASK_REG, &host_int_mask);
+	if (ret < 0) {
+		ret = WLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Update with the mask and write back to the register */
+	host_int_mask &= ~mask;
+	ret = sbi_write_ioreg(priv, HOST_INT_MASK_REG, host_int_mask);
+	if (ret < 0) {
+		PRINTM(WARN, "Unable to diable the host interrupt!\n");
+		ret = WLAN_STATUS_FAILURE;
+    	}
+  done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function disables the host interrupts.
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int sbi_disable_host_int(wlan_private * priv)
+{
+	return disable_host_int_mask(priv, HIM_DISABLE);
+}
+
+/**
+ *  @brief This function enables the host interrupts mask
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param mask    the interrupt mask
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+static int enable_host_int_mask(wlan_private * priv, u8 mask)
+{
+	int ret = WLAN_STATUS_SUCCESS;
+
+	ENTER();
+	/* Simply write the mask to the register */
+	ret = sbi_write_ioreg(priv, HOST_INT_MASK_REG, mask);
+
+	if (ret < 0) {
+		PRINTM(WARN, "ret = %d\n", ret);
+		ret = WLAN_STATUS_FAILURE;
+	}
+	priv->adapter->HisRegCpy = 1;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function enables the host interrupts.
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+int sbi_enable_host_int(wlan_private * priv)
+{
+	return enable_host_int_mask(priv, HIM_ENABLE);
+}
+
+int sbi_unregister_dev(wlan_private * priv)
+{
+	ENTER();
+
+	if (priv->wlan_dev.card != NULL) {
+		/* Release the SDIO IRQ */
+		//sdio_free_irq(priv->wlan_dev.card, priv->wlan_dev.netdev);
+		PRINTM(WARN, "Making the sdio dev card as NULL\n");
+	}
+	LEAVE();
+	return WLAN_STATUS_SUCCESS;
+}
+
+int mv_sdio_poll_card_status(wlan_private * priv, u8 bits)
+{
+    int tries;
+    int rval;
+    u8 cs;
+
+    ENTER();
+    for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
+        rval = sbi_read_ioreg(priv, CARD_STATUS_REG, &cs);
+        //PRINTM(INFO, "rval = %x\n cs&bits =%x\n", rval, (cs & bits));
+        if (rval == 0 && (cs & bits) == bits) {
+            return 0;
+        }
+
+        udelay(100);
+    }
+
+    umd_dbg("mv_sdio_poll_card_status: FAILED!\n");
+    LEAVE();
+    return -EBUSY;
+}
+
+int sbi_register_dev(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 reg;
+    ENTER();
+
+    the_netdev = priv->wlan_dev.netdev;
+
+    /* Initialize the private structure */
+    strncpy(priv->wlan_dev.name, "sdio0", sizeof(priv->wlan_dev.name));
+    priv->wlan_dev.ioport = 0;
+    priv->wlan_dev.upld_rcv = 0;
+    priv->wlan_dev.upld_typ = 0;
+    priv->wlan_dev.upld_len = 0;
+
+    /* Read the IO port */
+    ret = sbi_read_ioreg(priv, IO_PORT_0_REG, &reg);
+    if (ret)
+        goto failed;
+    else
+        priv->wlan_dev.ioport |= reg;
+
+    ret = sbi_read_ioreg(priv, IO_PORT_1_REG, &reg);
+    if (ret)
+        goto failed;
+    else
+        priv->wlan_dev.ioport |= (reg << 8);
+
+    ret = sbi_read_ioreg(priv, IO_PORT_2_REG, &reg);
+    if (ret)
+        goto failed;
+    else
+        priv->wlan_dev.ioport |= (reg << 16);
+
+    umd_dbg("SDIO FUNC1 IO port: 0x%x\n", priv->wlan_dev.ioport);
+
+    /* Disable host interrupt first. */
+    if ((ret = disable_host_int_mask(priv, 0xff)) < 0) {
+        PRINTM(WARN, "Warning: unable to disable host interrupt!\n");
+    }
+#if 0                           //marked by xc, we have init it
+    /* Request the SDIO IRQ */
+    umd_dbg("Before request_irq Address is if==>%p\n", isr_function);
+    ret = sdio_request_irq(priv->wlan_dev.card,
+                           (handler_fn_t) isr_function, 0,
+                           "sdio_irq", priv->wlan_dev.netdev);
+
+    umd_dbg("IrqLine: %d\n", card->ctrlr->tmpl->irq_line);
+
+    if (ret < 0) {
+        umd_dbg("Failed to request IRQ on SDIO bus (%d)\n", ret);
+        goto failed;
+    }
+#endif
+    //mod by xc
+#if 0
+    priv->wlan_dev.netdev->irq = card->ctrlr->tmpl->irq_line;
+    priv->adapter->irq = priv->wlan_dev.netdev->irq;
+    priv->adapter->chip_rev = card->chiprev;
+#endif
+
+    priv->hotplug_device =
+        &((struct sdio_func *) (priv->wlan_dev.card))->card->dev;
+    if (helper_name == NULL) {
+        helper_name = DEFAULT_HELPER_NAME;
+    }
+    if (fw_name == NULL) {
+        fw_name = DEFAULT_FW_NAME;
+    }
+    pwlanpriv = priv;
+    return WLAN_STATUS_SUCCESS; /* success */
+
+  failed:
+    umd_dbg("register device fail\n");
+    priv->wlan_dev.card = NULL;
+
+    LEAVE();
+    return WLAN_STATUS_FAILURE;
+}
+
+/*
+ * This fuction is used for sending data to the SDIO card.
+ */
+
+int sbi_host_to_card(wlan_private * priv, u8 type, u8 * payload, u16 nb)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    int buf_block_len;
+    int blksz;
+
+    ENTER();
+
+    priv->adapter->HisRegCpy = 0;
+
+    blksz = SD_BLOCK_SIZE;
+    buf_block_len = (nb + SDIO_HEADER_LEN + blksz - 1) / blksz;
+
+    priv->adapter->TmpTxBuf[0] = (nb + SDIO_HEADER_LEN) & 0xff;
+    priv->adapter->TmpTxBuf[1] = ((nb + SDIO_HEADER_LEN) >> 8) & 0xff;
+    priv->adapter->TmpTxBuf[2] = type;
+    priv->adapter->TmpTxBuf[3] = 0x0;
+
+    if (payload != NULL && nb > 0) {
+        if (type == MVMS_CMD)
+            memcpy(&priv->adapter->TmpTxBuf[SDIO_HEADER_LEN], payload, nb);
+    } else {
+        umd_dbg("Error: payload=%p, nb=%d\n", payload, nb);
+    }
+
+    /* The host polls for the IO_READY bit */
+    ret = mv_sdio_poll_card_status(priv, CARD_IO_READY);
+    if (ret < 0) {
+        umd_dbg("<1> Poll failed in host_to_card : %d\n", ret);
+        ret = WLAN_STATUS_FAILURE;
+        goto exit;
+    }
+
+    /* Transfer data to card */
+    ret = sbi_write_iomem(priv, priv->wlan_dev.ioport,
+                          BLOCK_MODE, FIXED_ADDRESS, buf_block_len,
+                          blksz, priv->adapter->TmpTxBuf);
+
+    if (ret < 0) {
+        PRINTM(WARN, "sdio_write_iomem failed: ret=%d\n", ret);
+        umd_dbg("sdio_write_iomem failed: ret=%d !!!!!!!\n", ret);
+        ret = WLAN_STATUS_FAILURE;
+        goto exit;
+    } else {
+        //umd_dbg("sdio write -dnld val =>%d\n", ret);
+    }
+
+    if (type == MVSD_DAT)
+        priv->wlan_dev.dnld_sent = DNLD_DATA_SENT;
+    else
+        priv->wlan_dev.dnld_sent = DNLD_CMD_SENT;
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/*
+ * This function is used to read data from the card.
+ */
+
+int
+mv_sdio_card_to_host(wlan_private * priv,
+                     u32 * type, int *nb, u8 * payload, int npayload)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 buf_len = 0;
+    int buf_block_len;
+    int blksz;
+    u32 *pevent;
+
+    ENTER();
+    if (!payload) {
+        PRINTM(WARN, "payload NULL pointer received!\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto exit;
+    }
+
+    /* Read the length of data to be transferred */
+    ret = mv_sdio_read_scratch(priv, &buf_len);
+    if (ret < 0) {
+        PRINTM(WARN, "Failed to read the scratch reg\n");
+        umd_dbg("Failed to read the scratch reg\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto exit;
+    }
+
+    PRINTM(INFO, "Receiving %d bytes from card at scratch reg value\n",
+           buf_len);
+    if (buf_len - SDIO_HEADER_LEN <= 0 || buf_len > npayload) {
+        PRINTM(WARN, "Invalid packet size from firmware, size = %d\n",
+               buf_len);
+        ret = WLAN_STATUS_FAILURE;
+        goto exit;
+//              if (buf_len > npayload + 4)
+//                      buf_len = npayload + 4;
+    }
+
+    /* Allocate buffer */
+    blksz = SD_BLOCK_SIZE;
+    buf_block_len = (buf_len + blksz - 1) / blksz;
+
+    /* The host polls for the IO_READY bit */
+    ret = mv_sdio_poll_card_status(priv, CARD_IO_READY);
+    if (ret < 0) {
+        PRINTM(WARN, "<1> Poll failed in card_to_host : %d\n", ret);
+        umd_dbg("Error!! Poll failed in card_to_host : %d\n", ret);
+        ret = WLAN_STATUS_FAILURE;
+        goto exit;
+    }
+
+    ret = sbi_read_iomem(priv, priv->wlan_dev.ioport,
+                         BLOCK_MODE, FIXED_ADDRESS, buf_block_len,
+                         blksz, payload);
+
+    if (ret < 0) {
+        umd_dbg("Error!! sdio_read_iomem failed - mv_sdio_card_to_host\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto exit;
+    }
+    *nb = buf_len;
+
+    if (*nb <= 0) {
+        PRINTM(INFO, "Null packet recieved \n");
+        umd_dbg("Null packet recieved \n");
+        ret = WLAN_STATUS_FAILURE;
+        goto exit;
+    }
+
+    *type = (payload[2] | (payload[3] << 8));
+    if (*type == MVSD_EVENT) {
+        pevent = (u32 *) & payload[4];
+        priv->adapter->EventCause = MVSD_EVENT | (((u16) (*pevent)) << 3);
+    }
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/*
+ * Read from the special scratch 'port'.
+ */
+
+int
+mv_sdio_read_scratch(wlan_private * priv, u16 * dat)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 scr0;
+    u8 scr1;
+
+    ENTER();
+    ret = sbi_read_ioreg(priv, CARD_OCR_0_REG, &scr0);
+    if (ret < 0)
+        return WLAN_STATUS_FAILURE;
+    PRINTM(INFO, "SCRATCH_0_REG = %x\n", scr0);
+
+    ret = sbi_read_ioreg(priv, CARD_OCR_1_REG, &scr1);
+    if (ret < 0)
+        return WLAN_STATUS_FAILURE;
+    PRINTM(INFO, "SCRATCH_1_REG = %x\n", scr1);
+
+    *dat = (((u16) scr1) << 8) | scr0;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/*
+ * 	Get the CIS Table 
+ */
+int
+sbi_get_cis_info(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u8 tupledata[255];
+    char cisbuf[512];
+    int ofs = 0, i;
+    u32 ret = WLAN_STATUS_SUCCESS;
+	u32 cis_addr = CIS_8686_PTR;
+    struct sdio_func *func = (struct sdio_func*)(priv->wlan_dev.card);
+
+    //card_info = (struct sdio_card *) slot->card->prot_card;
+    //ret = card_info->ccis.manufacturer;
+	// feng: need figure out how to get the basic card info for SDIO card
+
+    /* Read the Tuple Data */
+    for (i = 0; i < sizeof(tupledata); i++) {
+        ret = sdio_card_readb(func, cis_addr + i, &tupledata[i]);
+        if (ret < 0) {
+            PRINTM(WARN, "sbi_get_cis_info failed!!!\n");
+            return WLAN_STATUS_FAILURE;
+        }
+    }
+
+    memset(cisbuf, 0x0, sizeof(cisbuf));
+    memcpy(cisbuf + ofs, tupledata, sizeof(cisbuf));
+
+    /* Copy the CIS Table to Adapter */
+    memset(Adapter->CisInfoBuf, 0x0, sizeof(cisbuf));
+    memcpy(Adapter->CisInfoBuf, &cisbuf, sizeof(cisbuf));
+    Adapter->CisInfoLen = sizeof(cisbuf);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function downloads firmware image to the card.
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param firmware     A pointer to firmware image buffer
+ *  @param firmwarelen  the length of firmware image
+ *  @return             WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+sbi_download_wlan_fw_image(wlan_private * priv,
+                           const u8 * firmware, int firmwarelen)
+{
+    u8 base0;
+    u8 base1;
+    int ret = WLAN_STATUS_SUCCESS;
+    int offset;
+    u8 *fwbuf = priv->adapter->TmpTxBuf;
+    int timeout = 5000;
+    u16 len;
+    int txlen = 0;
+    int tx_blocks = 0;
+#ifdef FW_DOWNLOAD_SPEED
+    u32 tv1, tv2;
+#endif
+
+    ENTER();
+
+    PRINTM(INFO, "WLAN_FW: Downloading firmware of size %d bytes\n",
+           firmwarelen);
+#ifdef FW_DOWNLOAD_SPEED
+    tv1 = get_utimeofday();
+#endif
+
+    /* Wait initially for the first non-zero value */
+    do {
+        if ((ret = sbi_read_ioreg(priv, HOST_F1_RD_BASE_0, &base0)) < 0) {
+            PRINTM(WARN, "Dev BASE0 register read failed:"
+                   " base0=0x%04X(%d)\n", base0, base0);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+        if ((ret = sbi_read_ioreg(priv, HOST_F1_RD_BASE_1, &base1)) < 0) {
+            PRINTM(WARN, "Dev BASE1 register read failed:"
+                   " base1=0x%04X(%d)\n", base1, base1);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+        len = (((u16) base1) << 8) | base0;
+        mdelay(1);
+    } while (!len && --timeout);
+
+    if (!timeout) {
+        PRINTM(MSG, "Helper downloading finished.\n");
+        PRINTM(MSG, "Timeout for firmware downloading!\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* The host polls for the DN_LD_CARD_RDY and IO_READY bits */
+    ret = mv_sdio_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+    if (ret < 0) {
+        PRINTM(FATAL, "Firmware download died @ the end\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    PRINTM(INFO, "WLAN_FW: Len got from firmware = 0x%04X(%d)\n", len, len);
+    len &= ~B_BIT_0;
+
+    /* Perform firmware data transfer */
+    for (offset = 0; offset < firmwarelen; offset += txlen) {
+        txlen = len;
+
+        /* Set blocksize to transfer - checking for last block */
+        if (firmwarelen - offset < txlen) {
+            txlen = firmwarelen - offset;
+        }
+        PRINTM(INFO, "WLAN_FW: offset=%d, txlen = 0x%04X(%d)\n",
+               offset, txlen, txlen);
+
+        /* The host polls for the DN_LD_CARD_RDY and IO_READY bits */
+        ret = mv_sdio_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+        if (ret < 0) {
+            PRINTM(FATAL, "Firmware download died @ %d\n", offset);
+            goto done;
+        }
+
+        tx_blocks = (txlen + SD_BLOCK_SIZE_FW_DL - 1) / SD_BLOCK_SIZE_FW_DL;
+        PRINTM(INFO, "WLAN_FW:     tx_blocks = 0x%04X(%d)\n",
+               tx_blocks, tx_blocks);
+
+        /* Copy payload to buffer */
+        memcpy(fwbuf, &firmware[offset], txlen);
+
+        /* Send data */
+        ret = sbi_write_iomem(priv, priv->wlan_dev.ioport, BLOCK_MODE,
+                              FIXED_ADDRESS, tx_blocks, SD_BLOCK_SIZE_FW_DL,
+                              fwbuf);
+
+        if (ret < 0) {
+            PRINTM(FATAL, "IO error:transferring @ %d\n", offset);
+            goto done;
+        }
+
+        do {
+            udelay(10);
+            if ((ret = sbi_read_ioreg(priv, HOST_F1_CARD_RDY, &base0)) < 0) {
+                PRINTM(WARN, "Dev CARD_RDY register read failed:"
+                       " base0=0x%04X(%d)\n", base0, base0);
+                ret = WLAN_STATUS_FAILURE;
+                goto done;
+            }
+            PRINTM(INFO, "offset=0x%08X len=0x%04X: "
+                   "HOST_F1_CARD_RDY: 0x%04X\n", offset, txlen, base0);
+        } while (!(base0 & 0x08) || !(base0 & 0x01));
+
+        if ((ret = sbi_read_ioreg(priv, HOST_F1_RD_BASE_0, &base0)) < 0) {
+            PRINTM(WARN, "Dev BASE0 register read failed:"
+                   " base0=0x%04X(%d)\n", base0, base0);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+        if ((ret = sbi_read_ioreg(priv, HOST_F1_RD_BASE_1, &base1)) < 0) {
+            PRINTM(WARN, "Dev BASE1 register read failed:"
+                   " base1=0x%04X(%d)\n", base1, base1);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+        len = (((u16) base1) << 8) | base0;
+
+        if (!len) {
+            PRINTM(INFO, "WLAN Firmware Download Over\n");
+            break;
+        }
+
+        if (len & B_BIT_0) {
+            PRINTM(INFO, "CRC32 Error indicated by the helper:"
+                   " len=0x%04X(%d)\n", len, len);
+            len &= ~B_BIT_0;
+            /* Setting this to 0 to resend from same offset */
+            txlen = 0;
+        } else {
+            PRINTM(INFO, "%d,%d bytes block of firmware downloaded\n",
+                   offset, txlen);
+        }
+    }
+
+    PRINTM(INFO, "Firmware Image of Size %d bytes downloaded\n", firmwarelen);
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+#ifdef FW_DOWNLOAD_SPEED
+    tv2 = get_utimeofday();
+    PRINTM(INFO, "firmware: %ld.%03ld.%03ld ", tv1 / 1000000,
+           (tv1 % 1000000) / 1000, tv1 % 1000);
+    PRINTM(INFO, " -> %ld.%03ld.%03ld ", tv2 / 1000000,
+           (tv2 % 1000000) / 1000, tv2 % 1000);
+    tv2 -= tv1;
+    PRINTM(INFO, " == %ld.%03ld.%03ld\n", tv2 / 1000000,
+           (tv2 % 1000000) / 1000, tv2 % 1000);
+#endif
+    LEAVE();
+    return ret;
+}
+
+static int
+sbi_prog_firmware_image(wlan_private * priv, const u8 * firmware,
+                        int firmwarelen)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 firmwarestat;
+    u8 *fwbuf = priv->adapter->TmpTxBuf;
+    int fwblknow;
+    u32 tx_len;
+#ifdef FW_DOWNLOAD_SPEED
+    unsigned long tv1, tv2;
+#endif
+
+        struct sdio_func *func = (struct sdio_func*)(priv->wlan_dev.card);
+        u8 bic;
+
+	//sdio_claim_host(func);
+       //sdio_dump_cccr(func);
+	//sdio_release_host(func);
+
+        /* feng: here we need add the irq hook */
+
+    /* Check if the firmware is already downloaded */
+    if ((ret = mv_sdio_read_scratch(priv, &firmwarestat)) < 0) {
+        PRINTM(INFO, "read scratch returned <0\n");
+        goto done;
+    }
+
+    if (firmwarestat == FIRMWARE_READY) {
+        PRINTM(INFO, "Firmware already downloaded!\n");
+        /* TODO: We should be returning success over here */
+        ret = WLAN_STATUS_SUCCESS;
+        goto done;
+    }
+
+    PRINTM(INFO, "Downloading helper image (%d bytes), block size %d bytes ",
+           firmwarelen, SD_BLOCK_SIZE_FW_DL);
+
+    umd_dbg("Downloading helper image (%d bytes), block size %d bytes ",
+           firmwarelen, SD_BLOCK_SIZE_FW_DL);
+
+#ifdef FW_DOWNLOAD_SPEED
+    tv1 = get_utimeofday();
+#endif
+    /* Perform firmware data transfer */
+    tx_len =
+        (FIRMWARE_TRANSFER_NBLOCK * SD_BLOCK_SIZE_FW_DL) - SDIO_HEADER_LEN;
+    for (fwblknow = 0; fwblknow < firmwarelen; fwblknow += tx_len) {
+
+        /* The host polls for the DN_LD_CARD_RDY and IO_READY bits */
+        ret = mv_sdio_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+        if (ret < 0) {
+            PRINTM(INFO, "Firmware download died @ %d\n", fwblknow);
+            goto done;
+        }
+
+        /* Set blocksize to transfer - checking for last block */
+        if (firmwarelen - fwblknow < tx_len)
+            tx_len = firmwarelen - fwblknow;
+
+        fwbuf[0] = ((tx_len & 0x000000ff) >> 0);        /* Little-endian */
+        fwbuf[1] = ((tx_len & 0x0000ff00) >> 8);
+        fwbuf[2] = ((tx_len & 0x00ff0000) >> 16);
+        fwbuf[3] = ((tx_len & 0xff000000) >> 24);
+
+        /* Copy payload to buffer */
+        memcpy(&fwbuf[SDIO_HEADER_LEN], &firmware[fwblknow], tx_len);
+
+        PRINTM(INFO, ".");
+
+        /* Send data */
+        ret = sbi_write_iomem(priv, priv->wlan_dev.ioport, BLOCK_MODE,
+                              FIXED_ADDRESS, FIRMWARE_TRANSFER_NBLOCK,
+                              SD_BLOCK_SIZE_FW_DL, fwbuf);
+
+        if (ret) {
+            PRINTM(INFO, "IO error: transferring block @ %d\n", fwblknow);
+            goto done;
+        }
+    }
+
+    PRINTM(INFO, "\ndone (%d/%d bytes)\n", fwblknow, firmwarelen);
+#ifdef FW_DOWNLOAD_SPEED
+    tv2 = get_utimeofday();
+    PRINTM(INFO, "helper: %ld.%03ld.%03ld ", tv1 / 1000000,
+           (tv1 % 1000000) / 1000, tv1 % 1000);
+    PRINTM(INFO, " -> %ld.%03ld.%03ld ", tv2 / 1000000,
+           (tv2 % 1000000) / 1000, tv2 % 1000);
+    tv2 -= tv1;
+    PRINTM(INFO, " == %ld.%03ld.%03ld\n", tv2 / 1000000,
+           (tv2 % 1000000) / 1000, tv2 % 1000);
+#endif
+
+    /* Write last EOF data */
+    PRINTM(INFO, "Transferring EOF block\n");
+    memset(fwbuf, 0x0, SD_BLOCK_SIZE_FW_DL);
+    ret = sbi_write_iomem(priv, priv->wlan_dev.ioport, BLOCK_MODE,
+                          FIXED_ADDRESS, 1, SD_BLOCK_SIZE_FW_DL, fwbuf);
+    if (ret < 0) {
+        PRINTM(INFO, "IO error in writing EOF firmware block\n");
+        goto done;
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+int
+sbi_prog_helper(wlan_private * priv)
+{
+    if (priv->fw_helper) {
+        return sbi_prog_firmware_image(priv,
+                                       priv->fw_helper->data,
+                                       priv->fw_helper->size);
+    } else {
+        PRINTM(MSG, "No hotplug helper image\n");
+        return WLAN_STATUS_FAILURE;
+    }
+}
+
+int
+sbi_prog_firmware_w_helper(wlan_private * priv)
+{
+    if (priv->firmware) {
+        return sbi_download_wlan_fw_image(priv,
+                                          priv->firmware->data,
+                                          priv->firmware->size);
+    } else {
+        PRINTM(MSG, "No hotplug firmware image\n");
+        return WLAN_STATUS_FAILURE;
+    }
+}
+
+int
+sbi_prog_firmware(wlan_private * priv)
+{
+    if (priv->firmware) {
+        return sbi_download_wlan_fw_image(priv,
+                                          priv->firmware->data,
+                                          priv->firmware->size);
+    } else {
+        PRINTM(MSG, "No hotplug firmware image\n");
+        return WLAN_STATUS_FAILURE;
+    }
+}
+
+int
+sbi_set_bus_clock(wlan_private * priv, u8 option)
+{
+    return WLAN_STATUS_SUCCESS;
+}
+
+int
+sbi_exit_deep_sleep(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    PRINTM(INFO,
+           "Trying to wakeup device... Conn=%d IntC=%d PS_Mode=%d PS_State=%d\n",
+           priv->adapter->MediaConnectStatus, priv->adapter->IntCounter,
+           priv->adapter->PSMode, priv->adapter->PSState);
+//      sbi_set_bus_clock(priv, TRUE);
+
+    if (priv->adapter->fwWakeupMethod == WAKEUP_FW_THRU_GPIO) {
+//              GPIO_PORT_TO_LOW();
+    } else
+        ret = sbi_write_ioreg(priv, CONFIGURATION_REG, HOST_POWER_UP);
+
+    return ret;
+}
+
+int
+sbi_reset_deepsleep_wakeup(wlan_private * priv)
+{
+
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (priv->adapter->fwWakeupMethod == WAKEUP_FW_THRU_GPIO) {
+        GPIO_PORT_TO_HIGH();
+    } else
+        ret = sbi_write_ioreg(priv, CONFIGURATION_REG, 0);
+
+    LEAVE();
+
+    return ret;
+}
+
+int
+sbi_verify_fw_download(wlan_private * priv)
+{
+    int ret;
+    u16 firmwarestat;
+    int tries;
+    u8 rsr;
+
+    ENTER();
+    /* Wait for firmware initialization event */
+    for (tries = 0; tries < MAX_FIRMWARE_POLL_TRIES; tries++) {
+        if ((ret = mv_sdio_read_scratch(priv, &firmwarestat)) < 0)
+            continue;
+
+        if (firmwarestat == FIRMWARE_READY) {
+            ret = 0;
+            PRINTM(INFO, "Firmware successfully downloaded\n");
+            break;
+        } else {
+            mdelay(10);
+            ret = -ETIMEDOUT;
+        }
+    }
+
+    if (ret < 0) {
+        PRINTM(INFO, "Timeout waiting for firmware to become active\n");
+        goto done;
+    }
+
+    ret = sbi_read_ioreg(priv, HOST_INT_RSR_REG, &rsr);
+    if (ret < 0) {
+        PRINTM(INFO, "sdio_read_ioreg: reading INT RSR register failed\n");
+        return -1;
+    } else
+        PRINTM(INFO, "sdio_read_ioreg: RSR register 0x%x\n", rsr);
+
+    ret = 0;
+  done:
+    LEAVE();
+    return ret;
+}
+
+#ifdef DEEP_SLEEP_XC
+
+//mod by xc
+
+/*extern int start_bus_clock(mmc_controller_t);
+extern int stop_bus_clock_2(mmc_controller_t);
+*/
+int
+sbi_enter_deep_sleep(wlan_private * priv)
+{
+    int ret;
+
+    sbi_write_ioreg(priv, CONFIGURATION_REG, 0);
+    mdelay(2);
+    ret = sbi_write_ioreg(priv, CONFIGURATION_REG, HOST_POWER_DOWN);
+//mod by xc
+    //stop_bus_clock_2(((mmc_card_t)((priv->wlan_dev).card))->ctrlr);
+    mdelay(2);
+
+    return ret;
+}
+
+int
+sbi_exit_deep_sleep(wlan_private * priv)
+{
+    int ret = 0;
+
+    PRINTM(INFO,
+           "Trying to wakeup device... Conn=%d IntC=%d PS_Mode=%d PS_State=%d\n",
+           priv->adapter->MediaConnectStatus, priv->adapter->IntCounter,
+           priv->adapter->PSMode, priv->adapter->PSState);
+    //mod by xc
+    //start_bus_clock(((mmc_card_t)((priv->wlan_dev).card))->ctrlr);
+
+    if (priv->adapter->fwWakeupMethod == WAKEUP_FW_THRU_GPIO) {
+        GPIO_PORT_TO_LOW();
+    } else                      // SDIO method 
+        ret = sbi_write_ioreg(priv, CONFIGURATION_REG, HOST_POWER_UP);
+
+    return ret;
+}
+
+int
+sbi_reset_deepsleep_wakeup(wlan_private * priv)
+{
+    ENTER();
+
+    int ret = 0;
+
+    if (priv->adapter->fwWakeupMethod == WAKEUP_FW_THRU_GPIO) {
+        GPIO_PORT_TO_HIGH();
+    } else                      // SDIO method 
+        ret = sbi_write_ioreg(priv, CONFIGURATION_REG, 0);
+
+    LEAVE();
+
+    return ret;
+}
+#endif /* DEEP_SLEEP */
+
+#ifdef CONFIG_MARVELL_PM
+inline int
+sbi_suspend(wlan_private * priv)
+{
+    int ret;
+
+    ENTER();
+
+    ret = sdio_suspend(priv->wlan_dev.card);
+
+    LEAVE();
+    return ret;
+}
+
+inline int
+sbi_resume(wlan_private * priv)
+{
+    int ret;
+
+    ENTER();
+
+    ret = sdio_resume(priv->wlan_dev.card);
+
+    LEAVE();
+    return ret;
+}
+#endif
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/wireless/8686_wlan/if/if_sdio_fb/if_sdio.h b/drivers/net/wireless/8686_wlan/if/if_sdio_fb/if_sdio.h
new file mode 100644
index 0000000..d9b8ad9
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/if/if_sdio_fb/if_sdio.h
@@ -0,0 +1,119 @@
+/** @file if_sdio.h
+ *  @brief This file contains SDIO IF (interface) module
+ *  related macros, enum, and structure.
+ *  
+ * Copyright 2005 Intel Corporation and its suppliers. All rights reserved
+ * 
+ * (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+#ifndef	_IF_SDIO_H_
+#define	_IF_SDIO_H_
+
+#include <include.h>
+
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+
+#define FN0	0
+#define FN1	1
+//#include      <sdio_spec.h>
+/* The following defines function 1 registers of SDxx */
+/* Ref.: SDxx SDIO Interface Specification Rev. 2.0.  */
+/*       Marvell Semiconductor, Inc.                  */
+
+/* Host Control Registers */
+
+#define IO_PORT_0_REG			0x00
+#define IO_PORT_1_REG			0x01
+#define IO_PORT_2_REG			0x02
+#define CONFIGURATION_REG		0x03
+#define HOST_WO_CMD53_FINISH_HOST	(0x1U << 2)
+#define HOST_POWER_UP			(0x1U << 1)
+#define HOST_POWER_DOWN			(0x1U << 0)
+#define HOST_INT_MASK_REG		0x04
+#define UP_LD_HOST_INT_MASK		(0x1U)
+#define DN_LD_HOST_INT_MASK		(0x2U)
+#define HOST_INTSTATUS_REG		0x05
+#define UP_LD_HOST_INT_STATUS		(0x1U)
+#define DN_LD_HOST_INT_STATUS		(0x2U)
+#define HOST_INT_RSR_REG		0x06
+#define UP_LD_HOST_INT_RSR		(0x1U)
+#define HOST_INT_STATUS_REG		0x07
+#define UP_LD_CRC_ERR			(0x1U << 2)
+#define UP_LD_RESTART              (0x1U << 1)
+#define DN_LD_RESTART              (0x1U << 0)
+#define ASYNC_INT_MODE			0x20
+
+/* Card Control Registers */
+#define SQ_READ_BASE_ADDRESS_A0_REG  0x10
+#define SQ_READ_BASE_ADDRESS_A1_REG  0x11
+#define SQ_READ_BASE_ADDRESS_A2_REG  0x12
+#define SQ_READ_BASE_ADDRESS_A3_REG  0x13
+#define SQ_READ_BASE_ADDRESS_B0_REG  0x14
+#define SQ_READ_BASE_ADDRESS_B1_REG  0x15
+#define SQ_READ_BASE_ADDRESS_B2_REG  0x16
+#define SQ_READ_BASE_ADDRESS_B3_REG  0x17
+#define CARD_STATUS_REG              0x20
+#define CARD_IO_READY			(0x1U << 3)
+#define CIS_CARD_RDY               (0x1U << 2)
+#define UP_LD_CARD_RDY             (0x1U << 1)
+#define DN_LD_CARD_RDY             (0x1U << 0)
+#define HOST_INTERRUPT_MASK_REG      0x24
+#define HOST_POWER_INT_MASK        (0x1U << 3)
+#define ABORT_CARD_INT_MASK        (0x1U << 2)
+#define UP_LD_CARD_INT_MASK        (0x1U << 1)
+#define DN_LD_CARD_INT_MASK        (0x1U << 0)
+#define CARD_INTERRUPT_STATUS_REG    0x28
+#define POWER_UP_INT               (0x1U << 4)
+#define POWER_DOWN_INT             (0x1U << 3)
+#define CARD_INTERRUPT_RSR_REG       0x2c
+#define POWER_UP_RSR               (0x1U << 4)
+#define POWER_DOWN_RSR             (0x1U << 3)
+#define DEBUG_0_REG                  0x30
+#define SD_TESTBUS0                (0x1U)
+#define DEBUG_1_REG                  0x31
+#define SD_TESTBUS1                (0x1U)
+#define DEBUG_2_REG                  0x32
+#define SD_TESTBUS2                (0x1U)
+#define DEBUG_3_REG                  0x33
+#define SD_TESTBUS3                (0x1U)
+#define CARD_OCR_0_REG               0x34
+#define CARD_OCR_1_REG               0x35
+#define CARD_OCR_3_REG               0x36
+#define CARD_CONFIG_REG              0x38
+#define CARD_REVISION_REG            0x3c
+#define CMD53_FINISH_GBUS          (0x1U << 1)
+#define SD_NEG_EDGE                (0x1U << 0)
+
+/* Special registers in function 0 of the SDxx card */
+#define	SCRATCH_0_REG			0x80fe
+#define	SCRATCH_1_REG			0x80ff
+#define HOST_F1_RD_BASE_0		0x0010
+#define HOST_F1_RD_BASE_1		0x0011
+#define HOST_F1_CARD_RDY		0x0020
+
+int mv_sdio_host_to_card(wlan_private * priv, u8 type, u8 * payload, u16 nb);
+int mv_sdio_card_to_host(wlan_private * priv,
+                         u32 * type, int *nb, u8 * payload, int npayload);
+int mv_sdio_poll_card_status(wlan_private * priv, u8 bits);
+int mv_sdio_read_scratch(wlan_private * priv, u16 * dat);
+//int mv_sdio_probe(struct mmc_slot *slot);
+
+#endif /* _IF_SDIO_H */
diff --git a/drivers/net/wireless/8686_wlan/os/linux/os_defs.h b/drivers/net/wireless/8686_wlan/os/linux/os_defs.h
new file mode 100644
index 0000000..a049f18
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/os/linux/os_defs.h
@@ -0,0 +1,57 @@
+/*
+ *  
+ * (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+
+#ifndef _OS_HEADER1_
+#define _OS_HEADER1_
+
+typedef char CHAR;
+typedef char *PCHAR;
+typedef u8 *PUCHAR;
+typedef u16 *PUSHORT;
+typedef long *PLONG;
+typedef PLONG LONG_PTR;
+typedef u32 *ULONG_PTR;
+typedef u32 *Pu32;
+typedef unsigned int UINT;
+typedef UINT *PUINT;
+typedef void VOID;
+typedef VOID *PVOID;
+typedef int WLAN_STATUS;
+typedef u8 BOOLEAN;
+typedef BOOLEAN *PBOOLEAN;
+typedef PVOID PDRIVER_OBJECT;
+typedef PUCHAR PUNICODE_STRING;
+typedef long long LONGLONG;
+typedef LONGLONG *PLONGLONG;
+typedef unsigned long long *PULONGLONG;
+typedef PUCHAR ANSI_STRING;
+typedef ANSI_STRING *PANSI_STRING;
+typedef unsigned short WCHAR;
+typedef WCHAR *PWCHAR;
+typedef WCHAR *LPWCH, *PWCH;
+typedef WCHAR *NWPSTR;
+typedef WCHAR *LPWSTR, *PWSTR;
+typedef struct semaphore SEMAPHORE;
+
+#ifdef __KERNEL__
+typedef irqreturn_t IRQ_RET_TYPE;
+#define IRQ_RET		return IRQ_HANDLED
+#endif /* __KERNEL__ */
+
+#endif /* _OS_HEADER1 */
diff --git a/drivers/net/wireless/8686_wlan/os/linux/os_headers.h b/drivers/net/wireless/8686_wlan/os/linux/os_headers.h
new file mode 100644
index 0000000..00ec6ee
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/os/linux/os_headers.h
@@ -0,0 +1,81 @@
+/*
+ *  
+ * (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+
+#ifndef _OS_HEADERS_H
+#define _OS_HEADERS_H
+
+#ifndef __ATTRIB_ALIGN__
+#define __ATTRIB_ALIGN__ __attribute__((aligned(4)))
+#endif
+
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__ __attribute__ ((packed))
+#endif
+
+/* Linux header files */
+#include        <linux/kernel.h>
+#include        <linux/module.h>
+#include        <linux/init.h>
+#include        <linux/version.h>
+#include        <linux/param.h>
+#include        <linux/delay.h>
+#include        <linux/slab.h>
+#include        <linux/mm.h>
+#include        <linux/types.h>
+#include        <linux/sched.h>
+#include        <linux/timer.h>
+#include        <linux/types.h>
+#include        <linux/ioport.h>
+#include        <linux/pci.h>
+#include        <linux/ctype.h>
+#include        <linux/proc_fs.h>
+#include	<linux/ptrace.h>
+#include	<linux/string.h>
+
+#include	<linux/ioport.h>
+
+/* New Code to synchronize between IEEE Power save and PM*/
+#ifdef ENABLE_PM
+#include <linux/pm.h>
+#endif
+
+/* ASM files */
+#include        <asm/semaphore.h>
+#include        <asm/byteorder.h>
+#include        <asm/irq.h>
+#include        <asm/uaccess.h>
+#include        <asm/io.h>
+#include	<asm/system.h>
+
+/* Net header files */
+#include        <linux/wireless.h>
+#include        <linux/netdevice.h>
+#include        <linux/net.h>
+#include        <linux/ip.h>
+#include        <linux/skbuff.h>
+#include        <linux/if_arp.h>
+#include        <linux/if_ether.h>
+#include        <linux/etherdevice.h>
+#include        <net/arp.h>
+#include        <linux/rtnetlink.h>
+
+/* Wireless header */
+#include        <net/iw_handler.h>
+
+#endif
diff --git a/drivers/net/wireless/8686_wlan/os/linux/os_macros.h b/drivers/net/wireless/8686_wlan/os/linux/os_macros.h
new file mode 100755
index 0000000..c729cd4
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/os/linux/os_macros.h
@@ -0,0 +1,234 @@
+/*
+ *  
+ * (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+
+#ifndef	_OS_MACROS_H
+#define _OS_MACROS_H
+
+#define os_time_get()	jiffies
+
+extern spinlock_t driver_lock;
+
+extern unsigned long driver_flags;
+
+#define OS_INT_DISABLE	spin_lock_irqsave(&driver_lock, driver_flags)
+#define	OS_INT_RESTORE	spin_unlock_irqrestore(&driver_lock, driver_flags); \
+			driver_lock = SPIN_LOCK_UNLOCKED
+
+/*
+#define OS_INT_DISABLE	wlan_int_disable()
+#define	OS_INT_RESTORE  wlan_int_restore()
+
+static inline void wlan_int_disable()
+{
+	spin_lock_irqsave(&driver_lock, driver_flags);
+}
+
+static inline void wlan_int_restore()
+{
+	spin_unlock_irqrestore(&driver_lock, driver_flags);
+	driver_lock = RAW_SPIN_LOCK_UNLOCKED(driver_lock);
+}
+*/
+
+#define UpdateTransStart(dev) { \
+	dev->trans_start = jiffies; \
+}
+
+#define OS_SET_THREAD_STATE(x)		set_current_state(x)
+
+#define MODULE_GET	try_module_get(THIS_MODULE)
+#define MODULE_PUT	module_put(THIS_MODULE)
+
+#define OS_INIT_SEMAPHORE(x)    	init_MUTEX(x)
+#define OS_ACQ_SEMAPHORE_BLOCK(x)	down_interruptible(x)
+#define OS_ACQ_SEMAPHORE_NOBLOCK(x)	down_trylock(x)
+#define OS_REL_SEMAPHORE(x) 		up(x)
+
+/* Definitions below are needed for other OS like threadx */
+#define	TX_DISABLE
+#define TX_RESTORE
+#define	ConfigureThreadPriority()
+#define OS_INTERRUPT_SAVE_AREA
+#define OS_FREE_LOCK(x)
+#define TX_EVENT_FLAGS_SET(x, y, z)
+
+static inline void
+os_sched_timeout(u32 millisec)
+{
+    set_current_state(TASK_INTERRUPTIBLE);
+
+    schedule_timeout((millisec * HZ) / 1000);
+}
+
+static inline void
+os_schedule(u32 millisec)
+{
+    schedule_timeout((millisec * HZ) / 1000);
+}
+
+static inline int
+CopyMulticastAddrs(wlan_adapter * Adapter, struct net_device *dev)
+{
+    int i = 0;
+    struct dev_mc_list *mcptr = dev->mc_list;
+
+    for (i = 0; i < dev->mc_count; i++) {
+        memcpy(&Adapter->MulticastList[i], mcptr->dmi_addr, ETH_ALEN);
+        mcptr = mcptr->next;
+    }
+
+    return i;
+}
+
+static inline u32
+get_utimeofday(void)
+{
+    struct timeval t;
+    u32 ut;
+
+    do_gettimeofday(&t);
+    ut = (u32) t.tv_sec * 1000000 + ((u32) t.tv_usec);
+    return ut;
+}
+
+static inline int
+os_upload_rx_packet(wlan_private * priv, struct sk_buff *skb)
+{
+
+#define IPFIELD_ALIGN_OFFSET	2
+
+    skb->dev = priv->wlan_dev.netdev;
+    skb->protocol = eth_type_trans(skb, priv->wlan_dev.netdev);
+    skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+    netif_rx(skb);
+
+    /* add by feng for softirq issue fix. netif_rx() should
+       be only called in interrupt context */
+       /*
+    if(local_softirq_pending())
+    	 do_softirq();  
+         */
+
+    return 0;
+}
+
+static inline void
+os_free_tx_packet(wlan_private * priv)
+{
+    ulong flags;
+
+    if (priv->adapter->CurrentTxSkb) {
+        kfree_skb(priv->adapter->CurrentTxSkb);
+        spin_lock_irqsave(&priv->adapter->CurrentTxLock, flags);
+        priv->adapter->CurrentTxSkb = NULL;
+        spin_unlock_irqrestore(&priv->adapter->CurrentTxLock, flags);
+    }
+}
+
+/* netif carrier_on/off and start(wake)/stop_queue handling
+		carrier_on	carrier_off	start_queue	stop_queue
+ open		x(connect)	x(disconnect)	x
+ close				x				x
+ assoc		x				x
+ deauth				x				x
+ adhoc-start
+ adhoc-join
+ adhoc-link	x				x
+ adhoc-bcnlost			x				x
+ scan-begin			x				x
+ scan-end	x				x
+ ds-enter			x				x
+ ds-exit	x				x
+ xmit								x
+ xmit-done					x
+ tx-timeout
+ */
+
+static inline void
+os_carrier_on(wlan_private * priv)
+{
+    if (!netif_carrier_ok(priv->wlan_dev.netdev) &&
+        (priv->adapter->MediaConnectStatus == WlanMediaStateConnected) &&
+        ((priv->adapter->InfrastructureMode != Wlan802_11IBSS) ||
+         (priv->adapter->AdhocLinkSensed))) {
+        netif_carrier_on(priv->wlan_dev.netdev);
+    }
+}
+
+static inline void
+os_carrier_off(wlan_private * priv)
+{
+    if (netif_carrier_ok(priv->wlan_dev.netdev))
+        netif_carrier_off(priv->wlan_dev.netdev);
+}
+
+static inline void
+os_start_queue(wlan_private * priv)
+{
+    if (netif_queue_stopped(priv->wlan_dev.netdev) &&
+        (priv->adapter->MediaConnectStatus == WlanMediaStateConnected) &&
+        ((priv->adapter->InfrastructureMode != Wlan802_11IBSS) ||
+         (priv->adapter->AdhocLinkSensed))) {
+        netif_wake_queue(priv->wlan_dev.netdev);
+    }
+}
+
+static inline void
+os_stop_queue(wlan_private * priv)
+{
+    if (!netif_queue_stopped(priv->wlan_dev.netdev)) {
+        netif_stop_queue(priv->wlan_dev.netdev);
+    }
+}
+
+static inline int
+os_queue_is_active(wlan_private * priv)
+{
+    return (netif_carrier_ok(priv->wlan_dev.netdev)
+            && !netif_queue_stopped(priv->wlan_dev.netdev));
+}
+
+/* feng add for temply use */
+//#define DBG_2621 1
+
+#ifdef DBG_2621
+
+#ifdef DBG_DELAY
+#define umd_dbg(f, x...) \
+	do { \
+		printk(KERN_ALERT "[%s()]: " f "\n", __func__,## x); \
+		mdelay(3000); \
+	} while(0)
+#else
+#define umd_dbg(f, x...) \
+	printk(KERN_ALERT "[%s()]: " f "\n", __func__,## x)
+#endif	/* end of DBG_DELAY */
+
+#define umd_enter() \
+	printk(KERN_ERR "[%s()]: enter\n", __func__)
+#define umd_exit() \
+	printk(KERN_ERR "[%s()]: exit\n", __func__)
+#else
+#define umd_dbg(f, x...)  do{} while(0)
+#define umd_enter()  do{} while(0)
+#define umd_exit()  do{} while(0)
+#endif	/* end of DBG_2621 */
+
+#endif /* _OS_MACROS_H */
diff --git a/drivers/net/wireless/8686_wlan/os/linux/os_timers.h b/drivers/net/wireless/8686_wlan/os/linux/os_timers.h
new file mode 100644
index 0000000..2890eb3
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/os/linux/os_timers.h
@@ -0,0 +1,98 @@
+/*
+ *  
+ * (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+
+#ifndef	_OS_TIMERS_H
+#define _OS_TIMERS_H
+
+typedef struct __WLAN_DRV_TIMER
+{
+    struct timer_list tl;
+    void (*timer_function) (void *context);
+    void *function_context;
+    UINT time_period;
+    BOOLEAN timer_is_periodic;
+    BOOLEAN timer_is_canceled;
+} __ATTRIB_PACK__ WLAN_DRV_TIMER, *PWLAN_DRV_TIMER;
+
+static inline void
+TimerHandler(unsigned long fcontext)
+{
+    PWLAN_DRV_TIMER timer = (PWLAN_DRV_TIMER) fcontext;
+
+    timer->timer_function(timer->function_context);
+
+    if (timer->timer_is_periodic == TRUE) {
+        mod_timer(&timer->tl, jiffies + ((timer->time_period * HZ) / 1000));
+    }
+}
+
+static inline void
+InitializeTimer(PWLAN_DRV_TIMER timer,
+                void (*TimerFunction) (void *context), void *FunctionContext)
+{
+    // first, setup the timer to trigger the WlanTimerHandler proxy
+    init_timer(&timer->tl);
+    timer->tl.function = TimerHandler;
+    timer->tl.data = (u32) timer;
+
+    // then tell the proxy which function to call and what to pass it       
+    timer->timer_function = TimerFunction;
+    timer->function_context = FunctionContext;
+    timer->timer_is_canceled = FALSE;
+}
+
+static inline void
+SetTimer(PWLAN_DRV_TIMER timer, UINT MillisecondPeriod)
+{
+    timer->time_period = MillisecondPeriod;
+    timer->timer_is_periodic = FALSE;
+    timer->tl.expires = jiffies + (MillisecondPeriod * HZ) / 1000;
+    add_timer(&timer->tl);
+    timer->timer_is_canceled = FALSE;
+}
+
+static inline void
+ModTimer(PWLAN_DRV_TIMER timer, UINT MillisecondPeriod)
+{
+    timer->time_period = MillisecondPeriod;
+    timer->timer_is_periodic = FALSE;
+    mod_timer(&timer->tl, jiffies + (MillisecondPeriod * HZ) / 1000);
+    timer->timer_is_canceled = FALSE;
+}
+
+static inline void
+SetPeriodicTimer(PWLAN_DRV_TIMER timer, UINT MillisecondPeriod)
+{
+    timer->time_period = MillisecondPeriod;
+    timer->timer_is_periodic = TRUE;
+    timer->tl.expires = jiffies + (MillisecondPeriod * HZ) / 1000;
+    add_timer(&timer->tl);
+    timer->timer_is_canceled = FALSE;
+}
+
+#define	FreeTimer(x)	do {} while (0)
+
+static inline void
+CancelTimer(WLAN_DRV_TIMER * timer)
+{
+    del_timer(&timer->tl);
+    timer->timer_is_canceled = TRUE;
+}
+
+#endif /* _OS_TIMERS_H */
diff --git a/drivers/net/wireless/8686_wlan/os/linux/wlan_thread.h b/drivers/net/wireless/8686_wlan/os/linux/wlan_thread.h
new file mode 100644
index 0000000..ed8bb22
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/os/linux/wlan_thread.h
@@ -0,0 +1,73 @@
+/*
+ *  
+ * (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+
+#ifndef	__WLAN_THREAD_H_
+#define	__WLAN_THREAD_H_
+
+#include	<linux/kthread.h>
+
+typedef struct
+{
+    struct task_struct *task;
+    wait_queue_head_t waitQ;
+    pid_t pid;
+    void *priv;
+} wlan_thread;
+
+static inline void
+wlan_activate_thread(wlan_thread * thr)
+{
+        /** Record the thread pid */
+    thr->pid = current->pid;
+
+        /** Initialize the wait queue */
+    init_waitqueue_head(&thr->waitQ);
+}
+
+static inline void
+wlan_deactivate_thread(wlan_thread * thr)
+{
+    ENTER();
+
+    LEAVE();
+}
+
+static inline void
+wlan_create_thread(int (*wlanfunc) (void *), wlan_thread * thr, char *name)
+{
+    thr->task = kthread_run(wlanfunc, thr, "%s", name);
+}
+
+static inline int
+wlan_terminate_thread(wlan_thread * thr)
+{
+    ENTER();
+
+    /* Check if the thread is active or not */
+    if (!thr->pid) {
+        PRINTM(INFO, "Thread does not exist\n");
+        return -1;
+    }
+    kthread_stop(thr->task);
+
+    LEAVE();
+    return 0;
+}
+
+#endif
diff --git a/drivers/net/wireless/8686_wlan/release_version.h b/drivers/net/wireless/8686_wlan/release_version.h
new file mode 100644
index 0000000..32b1b71
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/release_version.h
@@ -0,0 +1,19 @@
+/**
+  * (c) Copyright © 2003-2006, Marvell International Ltd. 
+  *
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+
+#define DRIVER_RELEASE_VERSION		"26340.p58"
diff --git a/drivers/net/wireless/8686_wlan/wlan/host.h b/drivers/net/wireless/8686_wlan/wlan/host.h
new file mode 100644
index 0000000..b54d8bc
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/host.h
@@ -0,0 +1,393 @@
+/** @file host.h
+ * 
+ * @brief This file contains definitions of WLAN commands.
+ *  
+ * (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change log:
+    10/11/05: Add Doxygen format comments
+    01/11/06: Remove assoc response codes; full IEEE assoc resp now returned
+    04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+    04/10/06: Add power_adapt_cfg_ext command
+    04/18/06: Remove old Subscrive Event and add new Subscribe Event
+              implementation through generic hostcmd API
+    05/03/06: Add auto_tx hostcmd
+    05/04/06: Add IBSS coalescing related new hostcmd and event
+********************************************************/
+
+#ifndef _HOST_H_
+#define _HOST_H_
+
+/** PUBLIC DEFINITIONS */
+#define DEFAULT_AD_HOC_CHANNEL       6
+#define DEFAULT_AD_HOC_CHANNEL_A    36
+
+/** IEEE 802.11 OIDs */
+#define OID_802_11_INFRASTRUCTURE_MODE        0x00008001
+#define OID_802_11_FRAGMENTATION_THRESHOLD    0x00008002
+#define OID_802_11_RTS_THRESHOLD              0x00008003
+#define OID_802_11_ADD_WEP                    0x00008004
+#define OID_802_11_REMOVE_WEP                 0x00008005
+#define OID_802_11_TX_RETRYCOUNT              0x00008006
+#define OID_802_11D_ENABLE                    0x00008007
+
+#define HostCmd_OPTION_WAITFORRSP             0x0002
+
+/** Host Command ID */
+#define HostCmd_CMD_GET_HW_SPEC               0x0003
+#define HostCmd_CMD_EEPROM_UPDATE             0x0004
+#define HostCmd_CMD_802_11_RESET              0x0005
+#define HostCmd_CMD_802_11_SCAN               0x0006
+#define HostCmd_CMD_802_11_GET_LOG            0x000b
+#define HostCmd_CMD_MAC_MULTICAST_ADR         0x0010
+#define HostCmd_CMD_802_11_AUTHENTICATE       0x0011
+#define HostCmd_CMD_802_11_EEPROM_ACCESS      0x0059
+#define HostCmd_CMD_802_11_ASSOCIATE          0x0050
+#define HostCmd_CMD_802_11_SET_WEP            0x0013
+#define HostCmd_CMD_802_11_GET_STAT           0x0014
+#define HostCmd_CMD_802_3_GET_STAT            0x0015
+#define HostCmd_CMD_802_11_SNMP_MIB           0x0016
+#define HostCmd_CMD_MAC_REG_MAP               0x0017
+#define HostCmd_CMD_BBP_REG_MAP               0x0018
+#define HostCmd_CMD_MAC_REG_ACCESS            0x0019
+#define HostCmd_CMD_BBP_REG_ACCESS            0x001a
+#define HostCmd_CMD_RF_REG_ACCESS             0x001b
+#define HostCmd_CMD_802_11_RADIO_CONTROL      0x001c
+#define HostCmd_CMD_802_11_RF_CHANNEL         0x001d
+#define HostCmd_CMD_802_11_RF_TX_POWER        0x001e
+#define HostCmd_CMD_802_11_RSSI               0x001f
+#define HostCmd_CMD_802_11_RF_ANTENNA         0x0020
+
+#define HostCmd_CMD_802_11_PS_MODE	      0x0021
+
+#define HostCmd_CMD_802_11_DATA_RATE          0x0022
+#define HostCmd_CMD_RF_REG_MAP                0x0023
+#define HostCmd_CMD_802_11_DEAUTHENTICATE     0x0024
+#define HostCmd_CMD_802_11_REASSOCIATE        0x0025
+#define HostCmd_CMD_802_11_DISASSOCIATE       0x0026
+#define HostCmd_CMD_MAC_CONTROL               0x0028
+#define HostCmd_CMD_802_11_AD_HOC_START       0x002b
+#define HostCmd_CMD_802_11_AD_HOC_JOIN        0x002c
+
+#define HostCmd_CMD_802_11_QUERY_TKIP_REPLY_CNTRS  0x002e
+#define HostCmd_CMD_802_11_ENABLE_RSN              0x002f
+#define HostCmd_CMD_802_11_PAIRWISE_TSC       0x0036
+#define HostCmd_CMD_802_11_GROUP_TSC          0x0037
+#define HostCmd_CMD_802_11_KEY_MATERIAL       0x005e
+
+#define HostCmd_CMD_802_11_DEEP_SLEEP         0x003e
+
+#define HostCmd_CMD_802_11_SET_AFC            0x003c
+#define HostCmd_CMD_802_11_GET_AFC            0x003d
+
+#define HostCmd_CMD_802_11_AD_HOC_STOP        0x0040
+
+#define HostCmd_CMD_802_11_HOST_SLEEP_CFG   0x0043
+#define HostCmd_CMD_802_11_HOST_SLEEP_AWAKE_CONFIRM 0x0044
+
+#define HostCmd_CMD_802_11_BEACON_STOP        0x0049
+
+#define HostCmd_CMD_802_11_MAC_ADDRESS        0x004D
+#define HostCmd_CMD_802_11_EEPROM_ACCESS      0x0059
+
+#define HostCmd_CMD_802_11_BAND_CONFIG        0x0058
+
+#define HostCmd_CMD_802_11D_DOMAIN_INFO       0x005b
+
+#define HostCmd_CMD_WMM_ACK_POLICY            0x005C
+#define HostCmd_CMD_WMM_PRIO_PKT_AVAIL        0x005D
+
+#define HostCmd_CMD_802_11_SLEEP_PARAMS          0x0066
+
+#define HostCmd_CMD_802_11_INACTIVITY_TIMEOUT    0x0067
+
+#define HostCmd_CMD_802_11_SLEEP_PERIOD          0x0068
+#define HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE  0x0069
+
+#define HostCmd_CMD_802_11_BG_SCAN_CONFIG        0x006b
+#define HostCmd_CMD_802_11_BG_SCAN_QUERY         0x006c
+
+#define HostCmd_CMD_802_11_CAL_DATA_EXT          0x006d
+
+#define HostCmd_CMD_WMM_ADDTS_REQ                0x006E
+#define HostCmd_CMD_WMM_DELTS_REQ                0x006F
+#define HostCmd_CMD_WMM_QUEUE_CONFIG             0x0070
+#define HostCmd_CMD_WMM_GET_STATUS               0x0071
+
+#define HostCmd_CMD_802_11_TPC_CFG               0x0072
+
+#define HostCmd_CMD_802_11_FW_WAKEUP_METHOD      0x0074
+
+#define HostCmd_CMD_802_11_LED_GPIO_CTRL         0x004e
+
+#define HostCmd_CMD_802_11_SUBSCRIBE_EVENT       0x0075
+
+#define HostCmd_CMD_802_11_RATE_ADAPT_RATESET    0x0076
+
+#define HostCmd_CMD_802_11_TX_RATE_QUERY	0x007f
+
+#define HostCmd_CMD_802_11_POWER_ADAPT_CFG_EXT	0x007e
+
+#define HostCmd_CMD_GET_TSF                      0x0080
+
+#define HostCmd_CMD_WMM_QUEUE_STATS              0x0081
+
+#define HostCmd_CMD_802_11_AUTO_TX		0x0082
+#define HostCmd_CMD_802_11_IBSS_COALESCING_STATUS 0x0083
+
+#define HostCmd_CMD_MEM_ACCESS			0x0086
+
+#ifdef MFG_CMD_SUPPORT
+#define HostCmd_CMD_MFG_COMMAND               0x0089
+#define HostCmd_RET_MFG_COMMAND               0x8089
+#endif
+
+#define HostCmd_CMD_802_11_LDO_CONFIG         0x0096
+
+/* For the IEEE Power Save */
+#define HostCmd_SubCmd_Enter_PS               0x0030
+#define HostCmd_SubCmd_Exit_PS                0x0031
+#define HostCmd_SubCmd_Sleep_Confirmed        0x0034
+#define HostCmd_SubCmd_Full_PowerDown         0x0035
+#define HostCmd_SubCmd_Full_PowerUp           0x0036
+
+/* Command RET code, MSB is set to 1 */
+#define HostCmd_RET_HW_SPEC_INFO              0x8003
+#define HostCmd_RET_EEPROM_UPDATE             0x8004
+#define HostCmd_RET_802_11_RESET              0x8005
+#define HostCmd_RET_802_11_SCAN               0x8006
+#define HostCmd_RET_802_11_GET_LOG            0x800b
+#define HostCmd_RET_MAC_CONTROL               0x8028
+#define HostCmd_RET_MAC_MULTICAST_ADR         0x8010
+#define HostCmd_RET_802_11_AUTHENTICATE       0x8011
+#define HostCmd_RET_802_11_DEAUTHENTICATE     0x8024
+#define HostCmd_RET_802_11_ASSOCIATE          0x8012
+#define HostCmd_RET_802_11_REASSOCIATE        0x8025
+#define HostCmd_RET_802_11_DISASSOCIATE       0x8026
+#define HostCmd_RET_802_11_SET_WEP            0x8013
+#define HostCmd_RET_802_11_STAT               0x8014
+#define HostCmd_RET_802_3_STAT                0x8015
+#define HostCmd_RET_802_11_SNMP_MIB           0x8016
+#define HostCmd_RET_MAC_REG_MAP               0x8017
+#define HostCmd_RET_BBP_REG_MAP               0x8018
+#define HostCmd_RET_RF_REG_MAP                0x8023
+#define HostCmd_RET_MAC_REG_ACCESS            0x8019
+#define HostCmd_RET_BBP_REG_ACCESS            0x801a
+#define HostCmd_RET_RF_REG_ACCESS             0x801b
+#define HostCmd_RET_802_11_RADIO_CONTROL      0x801c
+#define HostCmd_RET_802_11_RF_CHANNEL         0x801d
+#define HostCmd_RET_802_11_RSSI               0x801f
+#define HostCmd_RET_802_11_RF_TX_POWER        0x801e
+#define HostCmd_RET_802_11_RF_ANTENNA         0x8020
+#define HostCmd_RET_802_11_PS_MODE            0x8021
+#define HostCmd_RET_802_11_DATA_RATE          0x8022
+
+#define HostCmd_RET_802_11_AD_HOC_START       0x802B
+#define HostCmd_RET_802_11_AD_HOC_JOIN        0x802C
+
+#define HostCmd_RET_802_11_QUERY_TKIP_REPLY_CNTRS  0x802e
+#define HostCmd_RET_802_11_ENABLE_RSN              0x802f
+#define HostCmd_RET_802_11_PAIRWISE_TSC       0x8036
+#define HostCmd_RET_802_11_GROUP_TSC          0x8037
+#define HostCmd_RET_802_11_KEY_MATERIAL       0x805e
+
+#define HostCmd_ENABLE_RSN                    0x0001
+#define HostCmd_DISABLE_RSN                   0x0000
+#define TYPE_ANTENNA_DIVERSITY                0xffff
+
+#define HostCmd_ACT_SET                       0x0001
+#define HostCmd_ACT_GET                       0x0000
+
+#define HostCmd_RET_802_11_SET_AFC            0x803c
+#define HostCmd_RET_802_11_GET_AFC            0x803d
+
+#define HostCmd_RET_802_11_AD_HOC_STOP        0x8040
+
+#define HostCmd_RET_802_11_HOST_SLEEP_CFG  	 0x8043
+#define HostCmd_RET_802_11_HOST_SLEEP_AWAKE_CONFIRM 0x8044
+
+#define HostCmd_RET_802_11_BEACON_STOP        0x8049
+
+#define HostCmd_RET_802_11_MAC_ADDRESS        0x804D
+#define HostCmd_RET_802_11_EEPROM_ACCESS      0x8059
+
+#define HostCmd_RET_802_11_BAND_CONFIG        0x8058
+
+#define HostCmd_RET_802_11_SLEEP_PARAMS          0x8066
+
+#define HostCmd_RET_802_11_INACTIVITY_TIMEOUT    0x8067
+
+#define HostCmd_RET_802_11_SLEEP_PERIOD          0x8068
+#define HostCmd_RET_802_11_BCA_CONFIG_TIMESHARE  0x8069
+
+#define HostCmd_RET_802_11D_DOMAIN_INFO          0x805B
+
+#define HostCmd_RET_WMM_ACK_POLICY           0x805C
+#define HostCmd_RET_WMM_PRIO_PKT_AVAIL       0x805D
+
+#define HostCmd_RET_802_11_BG_SCAN_CONFIG    0x806b
+#define HostCmd_RET_802_11_BG_SCAN_QUERY     0x806c
+
+#define HostCmd_RET_802_11_CAL_DATA_EXT      0x806d
+
+#define HostCmd_RET_WMM_ADDTS_REQ            0x806E
+#define HostCmd_RET_WMM_DELTS_REQ            0x806F
+#define HostCmd_RET_WMM_QUEUE_CONFIG         0x8070
+#define HostCmd_RET_WMM_GET_STATUS           0x8071
+
+#define HostCmd_RET_802_11_TPC_CFG           0x8072
+
+#define HostCmd_RET_802_11_LED_GPIO_CTRL     0x804e
+
+#define HostCmd_RET_802_11_FW_WAKEUP_METHOD	0x8074
+
+#define HostCmd_RET_802_11_SUBSCRIBE_EVENT	0x8075
+
+#define HostCmd_RET_802_11_RATE_ADAPT_RATESET	0x8076
+
+#define HostCmd_RTE_802_11_TX_RATE_QUERY 	0x807f
+
+#define HostCmd_RET_GET_TSF             	0x8080
+
+#define HostCmd_RET_WMM_QUEUE_STATS     	0x8081
+
+#define HostCmd_RET_802_11_POWER_ADAPT_CFG_EXT	0x807e
+
+#define HostCmd_RET_802_11_AUTO_TX		0x8082
+#define HostCmd_RET_802_11_IBSS_COALESCING_STATUS	0x8083
+
+#define HostCmd_RET_MEM_ACCESS		      0x8086
+
+#define HostCmd_RET_802_11_LDO_CONFIG         0x8096
+
+/** General Result Code*/
+/* OK */
+#define HostCmd_RESULT_OK                    0x0000
+/* Genenral error */
+#define HostCmd_RESULT_ERROR                 0x0001
+/* Command is not valid */
+#define HostCmd_RESULT_NOT_SUPPORT           0x0002
+/* Command is pending */
+#define HostCmd_RESULT_PENDING               0x0003
+/* System is busy (command ignored) */
+#define HostCmd_RESULT_BUSY                  0x0004
+/* Data buffer is not big enough */
+#define HostCmd_RESULT_PARTIAL_DATA          0x0005
+
+/* Definition of action or option for each command */
+
+/* Define general purpose action */
+#define HostCmd_ACT_GEN_READ                    0x0000
+#define HostCmd_ACT_GEN_WRITE                   0x0001
+#define HostCmd_ACT_GEN_GET                     0x0000
+#define HostCmd_ACT_GEN_SET                     0x0001
+#define HostCmd_ACT_GEN_REMOVE			0x0002
+#define HostCmd_ACT_GEN_OFF                     0x0000
+#define HostCmd_ACT_GEN_ON                      0x0001
+
+/* Define action or option for HostCmd_CMD_802_11_SET_WEP */
+#define HostCmd_ACT_ADD                         0x0002
+#define HostCmd_ACT_REMOVE                      0x0004
+
+#define HostCmd_TYPE_WEP_40_BIT                 0x0001
+#define HostCmd_TYPE_WEP_104_BIT                0x0002
+
+#define HostCmd_WEP_KEY_INDEX_MASK              0x3fff
+
+/* Define action or option for HostCmd_CMD_802_11_SCAN */
+#define HostCmd_BSS_TYPE_BSS                    0x0001
+#define HostCmd_BSS_TYPE_IBSS                   0x0002
+#define HostCmd_BSS_TYPE_ANY                    0x0003
+
+/* Define action or option for HostCmd_CMD_802_11_SCAN */
+#define HostCmd_SCAN_TYPE_ACTIVE                0x0000
+#define HostCmd_SCAN_TYPE_PASSIVE               0x0001
+
+#define HostCmd_SCAN_RADIO_TYPE_BG		0
+#define HostCmd_SCAN_RADIO_TYPE_A		1
+
+/* Define action or option for HostCmd_CMD_MAC_CONTROL */
+#define HostCmd_ACT_MAC_RX_ON                   0x0001
+#define HostCmd_ACT_MAC_TX_ON                   0x0002
+#define HostCmd_ACT_MAC_LOOPBACK_ON             0x0004
+#define HostCmd_ACT_MAC_WEP_ENABLE              0x0008
+#define HostCmd_ACT_MAC_INT_ENABLE              0x0010
+#define HostCmd_ACT_MAC_MULTICAST_ENABLE        0x0020
+#define HostCmd_ACT_MAC_BROADCAST_ENABLE        0x0040
+#define HostCmd_ACT_MAC_PROMISCUOUS_ENABLE      0x0080
+#define HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE    0x0100
+#define HostCmd_ACT_MAC_STRICT_PROTECTION_ENABLE  0x0400
+#define HostCmd_ACT_MAC_WMM_ENABLE              0x0800
+
+/* Define action or option or constant for HostCmd_CMD_MAC_MULTICAST_ADR */
+#define HostCmd_SIZE_MAC_ADR                    6
+#define HostCmd_MAX_MCAST_ADRS                  32
+
+/* Define action or option for HostCmd_CMD_802_11_RADIO_CONTROL */
+#define HostCmd_TYPE_AUTO_PREAMBLE              0x0001
+#define HostCmd_TYPE_SHORT_PREAMBLE             0x0002
+#define HostCmd_TYPE_LONG_PREAMBLE              0x0003
+
+#define TURN_ON_RF                              0x01
+#define RADIO_ON                                0x01
+#define RADIO_OFF                               0x00
+
+#define SET_AUTO_PREAMBLE                       0x05
+#define SET_SHORT_PREAMBLE                      0x03
+#define SET_LONG_PREAMBLE                       0x01
+
+/* Define action or option for CMD_802_11_RF_CHANNEL */
+#define HostCmd_OPT_802_11_RF_CHANNEL_GET       0x00
+#define HostCmd_OPT_802_11_RF_CHANNEL_SET       0x01
+
+#define HostCmd_ACT_SET_RX                      0x0001
+#define HostCmd_ACT_SET_TX                      0x0002
+#define HostCmd_ACT_SET_BOTH                    0x0003
+#define HostCmd_ACT_GET_RX                      0x0004
+#define HostCmd_ACT_GET_TX                      0x0008
+#define HostCmd_ACT_GET_BOTH                    0x000c
+
+/** Card Event definition */
+#define MACREG_INT_CODE_DUMMY_HOST_WAKEUP_SIGNAL       0x00000001
+#define MACREG_INT_CODE_LINK_LOSE_NO_SCAN       0x00000003
+#define MACREG_INT_CODE_LINK_SENSED             0x00000004
+#define MACREG_INT_CODE_MIB_CHANGED             0x00000006
+#define MACREG_INT_CODE_INIT_DONE               0x00000007
+#define MACREG_INT_CODE_DEAUTHENTICATED         0x00000008
+#define MACREG_INT_CODE_DISASSOCIATED           0x00000009
+#define MACREG_INT_CODE_PS_AWAKE                0x0000000a
+#define MACREG_INT_CODE_PS_SLEEP                0x0000000b
+#define MACREG_INT_CODE_MIC_ERR_MULTICAST       0x0000000d
+#define MACREG_INT_CODE_MIC_ERR_UNICAST         0x0000000e
+#define MACREG_INT_CODE_WM_AWAKE                0x0000000f
+#define MACREG_INT_CODE_DEEP_SLEEP_AWAKE        0x00000010
+#define MACREG_INT_CODE_ADHOC_BCN_LOST          0x00000011
+#define MACREG_INT_CODE_HOST_SLEEP_AWAKE        0x00000012
+#define MACREG_INT_CODE_WMM_STATUS_CHANGE	0x00000017
+#define MACREG_INT_CODE_BG_SCAN_REPORT		0x00000018
+#define MACREG_INT_CODE_RSSI_LOW		0x00000019
+#define MACREG_INT_CODE_SNR_LOW			0x0000001a
+#define MACREG_INT_CODE_MAX_FAIL		0x0000001b
+#define MACREG_INT_CODE_RSSI_HIGH		0x0000001c
+#define MACREG_INT_CODE_SNR_HIGH		0x0000001d
+#define MACREG_INT_CODE_IBSS_COALESCED		0x0000001e
+
+/* Define bitmap conditions for HOST_SLEEP_CFG */
+#define HOST_SLEEP_CFG_CANCEL			0xffffffff
+
+#endif /* _HOST_H_ */
diff --git a/drivers/net/wireless/8686_wlan/wlan/hostcmd.h b/drivers/net/wireless/8686_wlan/wlan/hostcmd.h
new file mode 100644
index 0000000..1c5dffa
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/hostcmd.h
@@ -0,0 +1,1256 @@
+/** @file hostcmd.h
+ * 
+ * @brief This file contains the function prototypes, data structure 
+ * and defines for all the host/station commands
+ *  
+ * (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change log:
+	10/11/05: Add Doxygen format comments
+	01/11/06: Update association struct to reflect IEEE passthrough response
+	          Conditionalize new scan/join structures
+	04/10/06: Add hostcmd generic API and power_adapt_cfg_ext command
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	05/03/06: Add auto_tx hostcmd
+	05/04/06: Add IBSS coalescing related new hostcmd
+********************************************************/
+
+#ifndef __HOSTCMD__H
+#define __HOSTCMD__H
+
+/*  802.11-related definitions */
+
+/** TxPD descriptor */
+typedef struct _TxPD
+{
+        /** Current Tx packet status */
+    u32 TxStatus;
+        /** Tx Control */
+    u32 TxControl;
+    u32 TxPacketLocation;
+        /** Tx packet length */
+    u16 TxPacketLength;
+        /** First 2 byte of destination MAC address */
+    u8 TxDestAddrHigh[2];
+        /** Last 4 byte of destination MAC address */
+    u8 TxDestAddrLow[4];
+        /** Pkt Priority */
+    u8 Priority;
+        /** Pkt Trasnit Power control*/
+    u8 PowerMgmt;
+        /** Amount of time the packet has been queued in the driver (units = 2ms)*/
+    u8 PktDelay_2ms;
+        /** Reserved */
+    u8 Reserved1;
+
+} __ATTRIB_PACK__ TxPD, *PTxPD;
+
+/** RxPD Descriptor */
+typedef struct _RxPD
+{
+        /** Current Rx packet status */
+    u16 RxStatus;
+
+        /** SNR */
+    u8 SNR;
+
+        /** Tx Control */
+    u8 RxControl;
+
+        /** Pkt Length */
+    u16 PktLen;
+
+        /** Noise Floor */
+    u8 NF;
+
+        /** Rx Packet Rate */
+    u8 RxRate;
+
+        /** Pkt addr*/
+    u32 PktPtr;
+    u8 RxPacketType;
+    u8 Reserved_1[3];
+        /** Pkt Priority */
+    u8 Priority;
+    u8 Reserved[3];
+
+} __ATTRIB_PACK__ RxPD, *PRxPD;
+
+#if defined(__KERNEL__)
+
+/** CmdCtrlNode */
+typedef struct _CmdCtrlNode
+{
+    /* CMD link list */
+    struct list_head list;
+
+    u32 Status;
+
+    /* CMD ID */
+    WLAN_OID cmd_oid;
+
+    /*CMD wait option: wait for finish or no wait */
+    u16 wait_option;
+
+    /* command parameter */
+    void *pdata_buf;
+
+    /*command data */
+    u8 *BufVirtualAddr;
+
+    u16 CmdFlags;
+
+    /* wait queue */
+    u16 CmdWaitQWoken;
+    wait_queue_head_t cmdwait_q __ATTRIB_ALIGN__;
+} __ATTRIB_PACK__ CmdCtrlNode, *PCmdCtrlNode;
+
+#endif
+
+/** MRVL_WEP_KEY */
+typedef struct _MRVL_WEP_KEY
+{
+    u32 Length;
+    u32 KeyIndex;
+    u32 KeyLength;
+    u8 KeyMaterial[MRVL_KEY_BUFFER_SIZE_IN_BYTE];
+} __ATTRIB_PACK__ MRVL_WEP_KEY, *PMRVL_WEP_KEY;
+
+typedef ULONGLONG WLAN_802_11_KEY_RSC;
+
+/** WLAN_802_11_KEY */
+typedef struct _WLAN_802_11_KEY
+{
+    u32 Length;
+    u32 KeyIndex;
+    u32 KeyLength;
+    WLAN_802_11_MAC_ADDRESS BSSID;
+    WLAN_802_11_KEY_RSC KeyRSC;
+    u8 KeyMaterial[MRVL_MAX_KEY_WPA_KEY_LENGTH];
+} __ATTRIB_PACK__ WLAN_802_11_KEY, *PWLAN_802_11_KEY;
+
+/** MRVL_WPA_KEY */
+typedef struct _MRVL_WPA_KEY
+{
+    u32 KeyIndex;
+    u32 KeyLength;
+    u32 KeyRSC;
+    u8 KeyMaterial[MRVL_MAX_KEY_WPA_KEY_LENGTH];
+} MRVL_WPA_KEY, *PMRVL_WPA_KEY;
+
+/** MRVL_WLAN_WPA_KEY */
+typedef struct _MRVL_WLAN_WPA_KEY
+{
+    u8 EncryptionKey[16];
+    u8 MICKey1[8];
+    u8 MICKey2[8];
+} MRVL_WLAN_WPA_KEY, *PMRVL_WLAN_WPA_KEY;
+
+/** IE_WPA */
+typedef struct _IE_WPA
+{
+    u8 Elementid;
+    u8 Len;
+    u8 oui[4];
+    u16 version;
+} IE_WPA, *PIE_WPA;
+
+/* Received Signal Strength Indication  in dBm*/
+typedef LONG WLAN_802_11_RSSI;
+
+/** WLAN_802_11_WEP */
+typedef struct _WLAN_802_11_WEP
+{
+    /* Length of this structure */
+    u32 Length;
+
+    /* 0 is the per-client key, 1-N are the global keys */
+    u32 KeyIndex;
+
+    /* length of key in bytes */
+    u32 KeyLength;
+
+    /* variable length depending on above field */
+    u8 KeyMaterial[1];
+} __ATTRIB_PACK__ WLAN_802_11_WEP, *PWLAN_802_11_WEP;
+
+/** WLAN_802_11_SSID */
+typedef struct _WLAN_802_11_SSID
+{
+    /* SSID Length */
+    u32 SsidLength;
+
+    /* SSID information field */
+    u8 Ssid[WLAN_MAX_SSID_LENGTH];
+} __ATTRIB_PACK__ WLAN_802_11_SSID, *PWLAN_802_11_SSID;
+
+typedef struct _WPA_SUPPLICANT
+{
+    u8 Wpa_ie[256];
+    u8 Wpa_ie_len;
+} WPA_SUPPLICANT, *PWPA_SUPPLICANT;
+
+typedef u32 WLAN_802_11_FRAGMENTATION_THRESHOLD;
+typedef u32 WLAN_802_11_RTS_THRESHOLD;
+typedef u32 WLAN_802_11_ANTENNA;
+
+/** wlan_offset_value */
+typedef struct _wlan_offset_value
+{
+    u32 offset;
+    u32 value;
+} wlan_offset_value;
+
+/** WLAN_802_11_FIXED_IEs */
+typedef struct _WLAN_802_11_FIXED_IEs
+{
+    u8 Timestamp[8];
+    u16 BeaconInterval;
+    u16 Capabilities;
+} WLAN_802_11_FIXED_IEs, *PWLAN_802_11_FIXED_IEs;
+
+/** WLAN_802_11_VARIABLE_IEs */
+typedef struct _WLAN_802_11_VARIABLE_IEs
+{
+    u8 ElementID;
+    u8 Length;
+    u8 data[1];
+} WLAN_802_11_VARIABLE_IEs, *PWLAN_802_11_VARIABLE_IEs;
+
+/** WLAN_802_11_AI_RESFI */
+typedef struct _WLAN_802_11_AI_RESFI
+{
+    u16 Capabilities;
+    u16 StatusCode;
+    u16 AssociationId;
+} WLAN_802_11_AI_RESFI, *PWLAN_802_11_AI_RESFI;
+
+/** WLAN_802_11_AI_REQFI */
+typedef struct _WLAN_802_11_AI_REQFI
+{
+    u16 Capabilities;
+    u16 ListenInterval;
+    WLAN_802_11_MAC_ADDRESS CurrentAPAddress;
+} WLAN_802_11_AI_REQFI, *PWLAN_802_11_AI_REQFI;
+
+/* Define general data structure */
+/** HostCmd_DS_GEN */
+typedef struct _HostCmd_DS_GEN
+{
+    u16 Command;
+    u16 Size;
+    u16 SeqNum;
+    u16 Result;
+} __ATTRIB_PACK__ HostCmd_DS_GEN, *PHostCmd_DS_GEN,
+    HostCmd_DS_802_11_DEEP_SLEEP, *PHostCmd_DS_802_11_DEEP_SLEEP;
+
+#define S_DS_GEN    sizeof(HostCmd_DS_GEN)
+/*
+ * Define data structure for HostCmd_CMD_GET_HW_SPEC
+ * This structure defines the response for the GET_HW_SPEC command
+ */
+/** HostCmd_DS_GET_HW_SPEC */
+typedef struct _HostCmd_DS_GET_HW_SPEC
+{
+    /* HW Interface version number */
+    u16 HWIfVersion;
+
+    /* HW version number */
+    u16 Version;
+
+    /* Max number of TxPD FW can handle */
+    u16 NumOfTxPD;
+
+    /* Max no of Multicast address  */
+    u16 NumOfMCastAdr;
+
+    /* MAC address */
+    u8 PermanentAddr[6];
+
+    /* Region Code */
+    u16 RegionCode;
+
+    /* Number of antenna used */
+    u16 NumberOfAntenna;
+
+    /* FW release number, example 0x1234=1.2.3.4 */
+    u32 FWReleaseNumber;
+
+    u32 Reserved_1;
+
+    u32 Reserved_2;
+
+    u32 Reserved_3;
+
+    /*FW/HW Capability */
+    u32 fwCapInfo;
+} __ATTRIB_PACK__ HostCmd_DS_GET_HW_SPEC, *PHostCmd_DS_GET_HW_SPEC;
+
+/**  HostCmd_CMD_EEPROM_UPDATE */
+typedef struct _HostCmd_DS_EEPROM_UPDATE
+{
+    u16 Action;
+    u32 Value;
+} __ATTRIB_PACK__ HostCmd_DS_EEPROM_UPDATE, *PHostCmd_DS_EEPROM_UPDATE;
+
+typedef struct _HostCmd_DS_802_11_SUBSCRIBE_EVENT
+{
+    u16 Action;
+    u16 Events;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SUBSCRIBE_EVENT;
+
+/* 
+ * This scan handle Country Information IE(802.11d compliant) 
+ * Define data structure for HostCmd_CMD_802_11_SCAN 
+ */
+/** HostCmd_DS_802_11_SCAN */
+typedef struct _HostCmd_DS_802_11_SCAN
+{
+    u8 BSSType;
+    u8 BSSID[ETH_ALEN];
+    u8 TlvBuffer[1];
+    /* MrvlIEtypes_SsIdParamSet_t   SsIdParamSet; 
+     * MrvlIEtypes_ChanListParamSet_t       ChanListParamSet;
+     * MrvlIEtypes_RatesParamSet_t  OpRateSet; 
+     * */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SCAN, *PHostCmd_DS_802_11_SCAN;
+
+typedef struct _HostCmd_DS_802_11_SCAN_RSP
+{
+    u16 BSSDescriptSize;
+    u8 NumberOfSets;
+    u8 BssDescAndTlvBuffer[1];
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SCAN_RSP, *PHostCmd_DS_802_11_SCAN_RSP;
+
+/** HostCmd_CMD_802_11_GET_LOG */
+typedef struct _HostCmd_DS_802_11_GET_LOG
+{
+    u32 mcasttxframe;
+    u32 failed;
+    u32 retry;
+    u32 multiretry;
+    u32 framedup;
+    u32 rtssuccess;
+    u32 rtsfailure;
+    u32 ackfailure;
+    u32 rxfrag;
+    u32 mcastrxframe;
+    u32 fcserror;
+    u32 txframe;
+    u32 wepundecryptable;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_GET_LOG, *PHostCmd_DS_802_11_GET_LOG;
+
+/**  HostCmd_CMD_MAC_CONTROL */
+typedef struct _HostCmd_DS_MAC_CONTROL
+{
+    u16 Action;
+    u16 Reserved;
+} __ATTRIB_PACK__ HostCmd_DS_MAC_CONTROL, *PHostCmd_DS_MAC_CONTROL;
+
+/**  HostCmd_CMD_MAC_MULTICAST_ADR */
+typedef struct _HostCmd_DS_MAC_MULTICAST_ADR
+{
+    u16 Action;
+    u16 NumOfAdrs;
+    u8 MACList[MRVDRV_ETH_ADDR_LEN * MRVDRV_MAX_MULTICAST_LIST_SIZE];
+} __ATTRIB_PACK__ HostCmd_DS_MAC_MULTICAST_ADR,
+    *PHostCmd_DS_MAC_MULTICAST_ADR;
+
+/** HostCmd_CMD_802_11_AUTHENTICATE */
+typedef struct _HostCmd_DS_802_11_AUTHENTICATE
+{
+    u8 MacAddr[ETH_ALEN];
+    u8 AuthType;
+    u8 Reserved[10];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AUTHENTICATE,
+    *PHostCmd_DS_802_11_AUTHENTICATE;
+
+/** HostCmd_RET_802_11_AUTHENTICATE */
+typedef struct _HostCmd_DS_802_11_AUTHENTICATE_RSP
+{
+    u8 MacAddr[6];
+    u8 AuthType;
+    u8 AuthStatus;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AUTHENTICATE_RSP,
+    *PHostCmd_DS_802_11_AUTHENTICATE_RSP;
+
+/**  HostCmd_CMD_802_11_DEAUTHENTICATE */
+typedef struct _HostCmd_DS_802_11_DEAUTHENTICATE
+{
+    u8 MacAddr[6];
+    u16 ReasonCode;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_DEAUTHENTICATE,
+    *PHostCmd_DS_802_11_DEAUTHENTICATE;
+
+/** HostCmd_DS_802_11_ASSOCIATE */
+typedef struct _HostCmd_DS_802_11_ASSOCIATE
+{
+    u8 PeerStaAddr[6];
+    IEEEtypes_CapInfo_t CapInfo;
+    u16 ListenInterval;
+    u16 BcnPeriod;
+    u8 DtimPeriod;
+
+    /*
+     *      MrvlIEtypes_SsIdParamSet_t      SsIdParamSet;
+     *      MrvlIEtypes_PhyParamSet_t       PhyParamSet;
+     *      MrvlIEtypes_SsParamSet_t        SsParamSet;
+     *      MrvlIEtypes_RatesParamSet_t     RatesParamSet;
+     */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_ASSOCIATE, *PHostCmd_DS_802_11_ASSOCIATE;
+
+/**  HostCmd_CMD_802_11_DISASSOCIATE */
+typedef struct _HostCmd_DS_802_11_DISASSOCIATE
+{
+    u8 DestMacAddr[6];
+    u16 ReasonCode;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_DISASSOCIATE,
+    *PHostCmd_DS_802_11_DISASSOCIATE;
+
+/** HostCmd_RET_802_11_ASSOCIATE */
+typedef struct
+{
+    IEEEtypes_AssocRsp_t assocRsp;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_ASSOCIATE_RSP;
+
+/**  HostCmd_RET_802_11_AD_HOC_JOIN */
+typedef struct _HostCmd_DS_802_11_AD_HOC_RESULT
+{
+    u8 PAD[3];
+    u8 BSSID[MRVDRV_ETH_ADDR_LEN];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AD_HOC_RESULT,
+    *PHostCmd_DS_802_11_AD_HOC_RESULT;
+
+/**  HostCmd_CMD_802_11_SET_WEP */
+typedef struct _HostCmd_DS_802_11_SET_WEP
+{
+    /* ACT_ADD, ACT_REMOVE or ACT_ENABLE  */
+    u16 Action;
+
+    /* Key Index selected for Tx */
+    u16 KeyIndex;
+
+    /* 40, 128bit or TXWEP */
+    u8 WEPTypeForKey1;
+
+    u8 WEPTypeForKey2;
+    u8 WEPTypeForKey3;
+    u8 WEPTypeForKey4;
+    u8 WEP1[16];
+    u8 WEP2[16];
+    u8 WEP3[16];
+    u8 WEP4[16];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SET_WEP, *PHostCmd_DS_802_11_SET_WEP;
+
+/**  HostCmd_CMD_802_3_GET_STAT */
+typedef struct _HostCmd_DS_802_3_GET_STAT
+{
+    u32 XmitOK;
+    u32 RcvOK;
+    u32 XmitError;
+    u32 RcvError;
+    u32 RcvNoBuffer;
+    u32 RcvCRCError;
+} __ATTRIB_PACK__ HostCmd_DS_802_3_GET_STAT, *PHostCmd_DS_802_3_GET_STAT;
+
+/** HostCmd_CMD_802_11_GET_STAT */
+typedef struct _HostCmd_DS_802_11_GET_STAT
+{
+    u32 TXFragmentCnt;
+    u32 MCastTXFrameCnt;
+    u32 FailedCnt;
+    u32 RetryCnt;
+    u32 MultipleRetryCnt;
+    u32 RTSSuccessCnt;
+    u32 RTSFailureCnt;
+    u32 ACKFailureCnt;
+    u32 FrameDuplicateCnt;
+    u32 RXFragmentCnt;
+    u32 MCastRXFrameCnt;
+    u32 FCSErrorCnt;
+    u32 BCastTXFrameCnt;
+    u32 BCastRXFrameCnt;
+    u32 TXBeacon;
+    u32 RXBeacon;
+    u32 WEPUndecryptable;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_GET_STAT, *PHostCmd_DS_802_11_GET_STAT;
+
+/** HostCmd_DS_802_11_AD_HOC_STOP */
+typedef struct _HostCmd_DS_802_11_AD_HOC_STOP
+{
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AD_HOC_STOP,
+    *PHostCmd_DS_802_11_AD_HOC_STOP;
+
+/** HostCmd_DS_802_11_BEACON_STOP */
+typedef struct _HostCmd_DS_802_11_BEACON_STOP
+{
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BEACON_STOP,
+    *PHostCmd_DS_802_11_BEACON_STOP;
+
+/**  HostCmd_CMD_802_11_SNMP_MIB */
+typedef struct _HostCmd_DS_802_11_SNMP_MIB
+{
+    u16 QueryType;
+    u16 OID;
+    u16 BufSize;
+    u8 Value[128];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SNMP_MIB, *PHostCmd_DS_802_11_SNMP_MIB;
+
+/**  HostCmd_CMD_MAC_REG_MAP */
+typedef struct _HostCmd_DS_MAC_REG_MAP
+{
+    u16 BufferSize;
+    u8 RegMap[128];
+    u16 Reserved;
+} __ATTRIB_PACK__ HostCmd_DS_MAC_REG_MAP, *PHostCmd_DS_MAC_REG_MAP;
+
+/*  HostCmd_CMD_BBP_REG_MAP */
+typedef struct _HostCmd_DS_BBP_REG_MAP
+{
+    u16 BufferSize;
+    u8 RegMap[128];
+    u16 Reserved;
+} __ATTRIB_PACK__ HostCmd_DS_BBP_REG_MAP, *PHostCmd_DS_BBP_REG_MAP;
+
+/** HostCmd_CMD_RF_REG_MAP */
+typedef struct _HostCmd_DS_RF_REG_MAP
+{
+    u16 BufferSize;
+    u8 RegMap[64];
+    u16 Reserved;
+} __ATTRIB_PACK__ HostCmd_DS_RF_REG_MAP, *PHostCmd_DS_RF_REG_MAP;
+
+/** HostCmd_CMD_MAC_REG_ACCESS */
+typedef struct _HostCmd_DS_MAC_REG_ACCESS
+{
+    u16 Action;
+    u16 Offset;
+    u32 Value;
+} __ATTRIB_PACK__ HostCmd_DS_MAC_REG_ACCESS, *PHostCmd_DS_MAC_REG_ACCESS;
+
+/** HostCmd_CMD_BBP_REG_ACCESS */
+typedef struct _HostCmd_DS_BBP_REG_ACCESS
+{
+    u16 Action;
+    u16 Offset;
+    u8 Value;
+    u8 Reserved[3];
+} __ATTRIB_PACK__ HostCmd_DS_BBP_REG_ACCESS, *PHostCmd_DS_BBP_REG_ACCESS;
+
+/**  HostCmd_CMD_RF_REG_ACCESS */
+typedef struct _HostCmd_DS_RF_REG_ACCESS
+{
+    u16 Action;
+    u16 Offset;
+    u8 Value;
+    u8 Reserved[3];
+} __ATTRIB_PACK__ HostCmd_DS_RF_REG_ACCESS, *PHostCmd_DS_RF_REG_ACCESS;
+
+/** HostCmd_CMD_802_11_RADIO_CONTROL */
+typedef struct _HostCmd_DS_802_11_RADIO_CONTROL
+{
+    u16 Action;
+    u16 Control;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RADIO_CONTROL,
+    *PHostCmd_DS_802_11_RADIO_CONTROL;
+
+/* HostCmd_DS_802_11_SLEEP_PARAMS */
+typedef struct _HostCmd_DS_802_11_SLEEP_PARAMS
+{
+    /* ACT_GET/ACT_SET */
+    u16 Action;
+
+    /* Sleep clock error in ppm */
+    u16 Error;
+
+    /* Wakeup offset in usec */
+    u16 Offset;
+
+    /* Clock stabilization time in usec */
+    u16 StableTime;
+
+    /* Control periodic calibration */
+    u8 CalControl;
+
+    /* Control the use of external sleep clock */
+    u8 ExternalSleepClk;
+
+    /* Reserved field, should be set to zero */
+    u16 Reserved;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SLEEP_PARAMS,
+    *PHostCmd_DS_802_11_SLEEP_PARAMS;
+
+/* HostCmd_DS_802_11_SLEEP_PERIOD */
+typedef struct _HostCmd_DS_802_11_SLEEP_PERIOD
+{
+    /* ACT_GET/ACT_SET */
+    u16 Action;
+
+    /* Sleep Period in msec */
+    u16 Period;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SLEEP_PERIOD,
+    *PHostCmd_DS_802_11_SLEEP_PERIOD;
+
+/* HostCmd_DS_802_11_BCA_TIMESHARE */
+typedef struct _HostCmd_DS_802_11_BCA_TIMESHARE
+{
+    /* ACT_GET/ACT_SET */
+    u16 Action;
+
+    /* Type: WLAN, BT */
+    u16 TrafficType;
+
+    /* 20msec - 60000msec */
+    u32 TimeShareInterval;
+
+    /* PTA arbiter time in msec */
+    u32 BTTime;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BCA_TIMESHARE,
+    *PHostCmd_DS_802_11_BCA_TIMESHARE;
+
+/* HostCmd_DS_802_11_INACTIVITY_TIMEOUT */
+typedef struct _HostCmd_DS_802_11_INACTIVITY_TIMEOUT
+{
+    /* ACT_GET/ACT_SET */
+    u16 Action;
+
+    /* Inactivity timeout in msec */
+    u16 Timeout;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_INACTIVITY_TIMEOUT,
+    *PHostCmd_DS_802_11_INACTIVITY_TIMEOUT;
+
+/** HostCmd_CMD_802_11_RF_CHANNEL */
+typedef struct _HostCmd_DS_802_11_RF_CHANNEL
+{
+    u16 Action;
+    u16 CurrentChannel;
+    u16 RFType;
+    u16 Reserved;
+    u8 ChannelList[32];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RF_CHANNEL,
+    *PHostCmd_DS_802_11_RF_CHANNEL;
+
+/**  HostCmd_CMD_802_11_RSSI */
+typedef struct _HostCmd_DS_802_11_RSSI
+{
+    /* weighting factor */
+    u16 N;
+
+    u16 Reserved_0;
+    u16 Reserved_1;
+    u16 Reserved_2;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RSSI, *PHostCmd_DS_802_11_RSSI;
+
+/** HostCmd_DS_802_11_RSSI_RSP */
+typedef struct _HostCmd_DS_802_11_RSSI_RSP
+{
+    u16 SNR;
+    u16 NoiseFloor;
+    u16 AvgSNR;
+    u16 AvgNoiseFloor;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RSSI_RSP, *PHostCmd_DS_802_11_RSSI_RSP;
+
+/** HostCmd_DS_802_11_MAC_ADDRESS */
+typedef struct _HostCmd_DS_802_11_MAC_ADDRESS
+{
+    u16 Action;
+    u8 MacAdd[ETH_ALEN];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_MAC_ADDRESS,
+    *PHostCmd_DS_802_11_MAC_ADDRESS;
+
+/** HostCmd_CMD_802_11_RF_TX_POWER */
+typedef struct _HostCmd_DS_802_11_RF_TX_POWER
+{
+    u16 Action;
+    u16 CurrentLevel;
+    u8 MaxPower;
+    u8 MinPower;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RF_TX_POWER,
+    *PHostCmd_DS_802_11_RF_TX_POWER;
+
+/** HostCmd_CMD_802_11_RF_ANTENNA */
+typedef struct _HostCmd_DS_802_11_RF_ANTENNA
+{
+    u16 Action;
+
+    /*  Number of antennas or 0xffff(diversity) */
+    u16 AntennaMode;
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RF_ANTENNA,
+    *PHostCmd_DS_802_11_RF_ANTENNA;
+
+/** HostCmd_CMD_802_11_PS_MODE */
+typedef struct _HostCmd_DS_802_11_PS_MODE
+{
+    u16 Action;
+    u16 NullPktInterval;
+    u16 MultipleDtim;
+    u16 Reserved;
+    u16 LocalListenInterval;
+    u16 AdhocAwakePeriod;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_PS_MODE, *PHostCmd_DS_802_11_PS_MODE;
+
+/** PS_CMD_ConfirmSleep */
+typedef struct _PS_CMD_ConfirmSleep
+{
+    u16 Command;
+    u16 Size;
+    u16 SeqNum;
+    u16 Result;
+
+    u16 Action;
+    u16 Reserved1;
+    u16 MultipleDtim;
+    u16 Reserved;
+    u16 LocalListenInterval;
+} __ATTRIB_PACK__ PS_CMD_ConfirmSleep, *PPS_CMD_ConfirmSleep;
+
+/** HostCmd_CMD_802_11_FW_WAKEUP_METHOD */
+typedef struct _HostCmd_DS_802_11_FW_WAKEUP_METHOD
+{
+    u16 Action;
+    u16 Method;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_FW_WAKEUP_METHOD,
+    *PHostCmd_DS_802_11_FW_WAKEUP_METHOD;
+
+/** HostCmd_CMD_802_11_DATA_RATE */
+typedef struct _HostCmd_DS_802_11_DATA_RATE
+{
+    u16 Action;
+    u16 Reserverd;
+    u8 DataRate[HOSTCMD_SUPPORTED_RATES];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_DATA_RATE, *PHostCmd_DS_802_11_DATA_RATE;
+
+/** HostCmd_DS_802_11_RATE_ADAPT_RATESET */
+typedef struct _HostCmd_DS_802_11_RATE_ADAPT_RATESET
+{
+    u16 Action;
+    u16 HWRateDropMode;
+    u16 Bitmap;
+    u16 Threshold;
+    u16 FinalRate;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RATE_ADAPT_RATESET,
+    *PHostCmd_DS_802_11_RATE_ADAPT_RATESET;
+
+/** HostCmd_DS_802_11_AD_HOC_START*/
+typedef struct _HostCmd_DS_802_11_AD_HOC_START
+{
+    u8 SSID[MRVDRV_MAX_SSID_LENGTH];
+    u8 BSSType;
+    u16 BeaconPeriod;
+    u8 DTIMPeriod;
+    IEEEtypes_SsParamSet_t SsParamSet;
+    IEEEtypes_PhyParamSet_t PhyParamSet;
+    u16 Reserved1;
+    IEEEtypes_CapInfo_t Cap;
+    u8 DataRate[HOSTCMD_SUPPORTED_RATES];
+    u8 tlv_memory_size_pad[100];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AD_HOC_START,
+    *PHostCmd_DS_802_11_AD_HOC_START;
+
+/** AdHoc_BssDesc_t */
+typedef struct _AdHoc_BssDesc_t
+{
+    u8 BSSID[6];
+    u8 SSID[32];
+    u8 BSSType;
+    u16 BeaconPeriod;
+    u8 DTIMPeriod;
+    u8 TimeStamp[8];
+    u8 LocalTime[8];
+    IEEEtypes_PhyParamSet_t PhyParamSet;
+    IEEEtypes_SsParamSet_t SsParamSet;
+    IEEEtypes_CapInfo_t Cap;
+    u8 DataRates[HOSTCMD_SUPPORTED_RATES];
+
+    /* DO NOT ADD ANY FIELDS TO THIS STRUCTURE.      It is used below in the
+     *      Adhoc join command and will cause a binary layout mismatch with 
+     *      the firmware 
+     */
+} __ATTRIB_PACK__ AdHoc_BssDesc_t;
+
+/** HostCmd_DS_802_11_AD_HOC_JOIN */
+typedef struct _HostCmd_DS_802_11_AD_HOC_JOIN
+{
+    AdHoc_BssDesc_t BssDescriptor;
+    u16 Reserved1;
+    u16 Reserved2;
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AD_HOC_JOIN,
+    *PHostCmd_DS_802_11_AD_HOC_JOIN;
+
+/** HostCmd_DS_802_11_ENABLE_RSN */
+typedef struct _HostCmd_DS_802_11_ENABLE_RSN
+{
+    u16 Action;
+    u16 Enable;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_ENABLE_RSN,
+    *PHostCmd_DS_802_11_ENABLE_RSN;
+
+/** HostCmd_DS_802_11_QUERY_TKIP_REPLY_CNTRS */
+typedef struct _HostCmd_DS_802_11_QUERY_TKIP_REPLY_CNTRS
+{
+    u16 CmdCode;
+    u16 Size;
+    u16 SeqNum;
+    u16 Result;
+    u32 NumTkipCntrs;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_QUERY_TKIP_REPLY_CNTRS,
+    *PHostCmd_DS_802_11_QUERY_TKIP_REPLY_CNTRS;
+
+/** HostCmd_DS_802_11_PAIRWISE_TSC */
+typedef struct _HostCmd_DS_802_11_PAIRWISE_TSC
+{
+    u16 CmdCode;
+    u16 Size;
+    u16 SeqNum;
+    u16 Result;
+    u16 Action;
+    u32 Txlv32;
+    u16 Txlv16;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_PAIRWISE_TSC,
+    *PHostCmd_DS_802_11_PAIRWISE_TSC;
+
+/** HostCmd_DS_802_11_GROUP_TSC */
+typedef struct _HostCmd_DS_802_11_GROUP_TSC
+{
+    u16 CmdCode;
+    u16 Size;
+    u16 SeqNum;
+    u16 Result;
+    u16 Action;
+    u32 Txlv32;
+    u16 Txlv16;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_GROUP_TSC, *PHostCmd_DS_802_11_GROUP_TSC;
+
+typedef union _KeyInfo_WEP_t
+{
+    u8 Reserved;
+
+    /* bits 1-4: Specifies the index of key */
+    u8 WepKeyIndex;
+
+    /* bit 0: Specifies that this key is 
+     * to be used as the default for TX data packets 
+     * */
+    u8 isWepDefaultKey;
+} __ATTRIB_PACK__ KeyInfo_WEP_t;
+
+typedef union _KeyInfo_TKIP_t
+{
+    u8 Reserved;
+
+    /* bit 2: Specifies that this key is 
+     * enabled and valid to use */
+    u8 isKeyEnabled;
+
+    /* bit 1: Specifies that this key is
+     * to be used as the unicast key */
+    u8 isUnicastKey;
+
+    /* bit 0: Specifies that this key is 
+     * to be used as the multicast key */
+    u8 isMulticastKey;
+} __ATTRIB_PACK__ KeyInfo_TKIP_t;
+
+typedef union _KeyInfo_AES_t
+{
+    u8 Reserved;
+
+    /* bit 2: Specifies that this key is
+     * enabled and valid to use */
+    u8 isKeyEnabled;
+
+    /* bit 1: Specifies that this key is
+     * to be used as the unicast key */
+    u8 isUnicastKey;
+
+    /* bit 0: Specifies that this key is 
+     * to be used as the multicast key */
+    u8 isMulticastKey;
+} __ATTRIB_PACK__ KeyInfo_AES_t;
+
+/** KeyMaterial_TKIP_t */
+typedef struct _KeyMaterial_TKIP_t
+{
+    /* TKIP encryption/decryption key */
+    u8 TkipKey[16];
+
+    /* TKIP TX MIC Key */
+    u8 TkipTxMicKey[16];
+
+    /* TKIP RX MIC Key */
+    u8 TkipRxMicKey[16];
+} __ATTRIB_PACK__ KeyMaterial_TKIP_t, *PKeyMaterial_TKIP_t;
+
+/** KeyMaterial_AES_t */
+typedef struct _KeyMaterial_AES_t
+{
+    /* AES encryption/decryption key */
+    u8 AesKey[16];
+} __ATTRIB_PACK__ KeyMaterial_AES_t, *PKeyMaterial_AES_t;
+
+/** MrvlIEtype_KeyParamSet_t */
+typedef struct _MrvlIEtype_KeyParamSet_t
+{
+    /* Type ID */
+    u16 Type;
+
+    /* Length of Payload */
+    u16 Length;
+
+    /* Type of Key: WEP=0, TKIP=1, AES=2 */
+    u16 KeyTypeId;
+
+    /* Key Control Info specific to a KeyTypeId */
+    u16 KeyInfo;
+
+    /* Length of key */
+    u16 KeyLen;
+
+    /* Key material of size KeyLen */
+    u8 Key[32];
+} __ATTRIB_PACK__ MrvlIEtype_KeyParamSet_t, *PMrvlIEtype_KeyParamSet_t;
+
+/** HostCmd_DS_802_11_KEY_MATERIAL */
+typedef struct _HostCmd_DS_802_11_KEY_MATERIAL
+{
+    u16 Action;
+
+    MrvlIEtype_KeyParamSet_t KeyParamSet;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_KEY_MATERIAL,
+    *PHostCmd_DS_802_11_KEY_MATERIAL;
+
+/** HostCmd_DS_802_11_HOST_SLEEP_CFG */
+typedef struct _HostCmd_DS_HOST_802_11_HOST_SLEEP_CFG
+{
+    /* bit0=1: non-unicast data
+     * bit1=1: unicast data
+     * bit2=1: mac events
+     * bit3=1: magic packet 
+     */
+    u32 conditions;
+
+    u8 gpio;
+
+    /* in milliseconds */
+    u8 gap;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_HOST_SLEEP_CFG;
+
+/** HostCmd_DS_802_11_CAL_DATA_EXT */
+typedef struct _HostCmd_DS_802_11_CAL_DATA_EXT
+{
+    u16 Action;
+    u16 Revision;
+    u16 CalDataLen;
+    u8 CalData[1024];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_CAL_DATA_EXT,
+    *pHostCmd_DS_802_11_CAL_DATA_EXT;
+
+/** HostCmd_DS_802_11_EEPROM_ACCESS */
+typedef struct _HostCmd_DS_802_11_EEPROM_ACCESS
+{
+    u16 Action;
+
+    /* multiple 4 */
+    u16 Offset;
+    u16 ByteCount;
+    u8 Value;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_EEPROM_ACCESS,
+    *pHostCmd_DS_802_11_EEPROM_ACCESS;
+
+/** HostCmd_DS_802_11_BG_SCAN_CONFIG */
+typedef struct _HostCmd_DS_802_11_BG_SCAN_CONFIG
+{
+        /** Action */
+    u16 Action;
+
+        /** Enable */
+    /*  0 - Disable 1 - Enable */
+    u8 Enable;
+
+        /** bssType */
+    /*  1 - Infrastructure
+     *  2 - IBSS
+     *  3 - any 
+     */
+    u8 BssType;
+
+        /** ChannelsPerScan */
+    /* No of channels to scan at one scan */
+    u8 ChannelsPerScan;
+
+    /* 0 - Discard old scan results
+     * 1 - Discard new scan results 
+     */
+    u8 DiscardWhenFull;
+
+    u16 Reserved;
+
+        /** ScanInterval */
+    u32 ScanInterval;
+
+        /** StoreCondition */
+    /* - SSID Match
+     * - Exceed RSSI threshold
+     * - SSID Match & Exceed RSSI Threshold 
+     * - Always 
+     */
+    u32 StoreCondition;
+
+        /** ReportConditions */
+    /* - SSID Match
+     * - Exceed RSSI threshold
+     * - SSID Match & Exceed RSSIThreshold
+     * - Exceed MaxScanResults
+     * - Entire channel list scanned once 
+     * - Domain Mismatch in country IE 
+     */
+    u32 ReportConditions;
+
+        /** MaxScanResults */
+    /* Max scan results that will trigger 
+     * a scn completion event */
+    u16 MaxScanResults;
+
+    /*      attach TLV based parameters as needed, e.g.
+     *      MrvlIEtypes_SsIdParamSet_t      SsIdParamSet;
+     *      MrvlIEtypes_ChanListParamSet_t  ChanListParamSet;
+     *      MrvlIEtypes_NumProbes_t         NumProbes;
+     */
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BG_SCAN_CONFIG,
+    *pHostCmd_DS_802_11_BG_SCAN_CONFIG;
+
+/** HostCmd_DS_802_11_BG_SCAN_QUERY */
+typedef struct _HostCmd_DS_802_11_BG_SCAN_QUERY
+{
+    u8 Flush;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BG_SCAN_QUERY,
+    *pHostCmd_DS_802_11_BG_SCAN_QUERY;
+
+/** HostCmd_DS_802_11_BG_SCAN_QUERY_RSP */
+typedef struct _HostCmd_DS_802_11_BG_SCAN_QUERY_RSP
+{
+    u32 ReportCondition;
+    HostCmd_DS_802_11_SCAN_RSP scanresp;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BG_SCAN_QUERY_RSP,
+    *PHostCmd_DS_802_11_BG_SCAN_QUERY_RSP;
+
+/** HostCmd_DS_802_11_TPC_CFG */
+typedef struct _HostCmd_DS_802_11_TPC_CFG
+{
+    u16 Action;
+    u8 Enable;
+    s8 P0;
+    s8 P1;
+    s8 P2;
+    u8 UseSNR;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_TPC_CFG;
+
+/** HostCmd_DS_802_11_LED_CTRL */
+typedef struct _HostCmd_DS_802_11_LED_CTRL
+{
+    u16 Action;
+    u16 NumLed;
+    u8 data[256];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_LED_CTRL;
+
+/** HostCmd_DS_802_11_POWER_ADAPT_CFG_EXT */
+typedef struct _HostCmd_DS_802_11_POWER_ADAPT_CFG_EXT
+{
+        /** Action */
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    u16 EnablePA;               /* 0 = disable; 1 = enable; */
+    MrvlIEtypes_PowerAdapt_Group_t PowerAdaptGroup;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_POWER_ADAPT_CFG_EXT,
+    *PHostCmd_DS_802_11_POWER_ADAPT_CFG_EXT;
+
+/** HostCmd_DS_802_11_AFC */
+typedef struct _HostCmd_DS_802_11_AFC
+{
+    u16 afc_auto;
+    union
+    {
+        struct
+        {
+            u16 threshold;
+            u16 period;
+        } auto_mode;
+
+        struct
+        {
+            s16 timing_offset;
+            s16 carrier_offset;
+        } manual_mode;
+    } b;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AFC;
+
+#define afc_data    b.data
+#define afc_thre    b.auto_mode.threshold
+#define afc_period  b.auto_mode.period
+#define afc_toff    b.manual_mode.timing_offset
+#define afc_foff    b.manual_mode.carrier_offset
+
+typedef struct _HostCmd_DS_802_11_IBSS_Status
+{
+    u16 Action;
+    u16 Enable;
+    u8 BSSID[ETH_ALEN];
+    u16 BeaconInterval;
+    u16 ATIMWindow;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_IBSS_Status;
+
+typedef struct _HostCmd_TX_RATE_QUERY
+{
+    u16 TxRate;
+} __ATTRIB_PACK__ HostCmd_TX_RATE_QUERY, *PHostCmd_TX_RATE_QUERY;
+
+/** HostCmd_DS_802_11_AUTO_TX */
+typedef struct _HostCmd_DS_802_11_AUTO_TX
+{
+        /** Action */
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    MrvlIEtypes_AutoTx_t AutoTx;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AUTO_TX, *PHostCmd_DS_802_11_AUTO_TX;
+
+/** HostCmd_MEM_ACCESS */
+typedef struct _HostCmd_DS_MEM_ACCESS
+{
+        /** Action */
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    u16 Reserved;
+    u32 Addr;
+    u32 Value;
+} __ATTRIB_PACK__ HostCmd_DS_MEM_ACCESS, *PHostCmd_DS_MEM_ACCESS;
+
+typedef struct
+{
+    u64 TsfValue;
+} __ATTRIB_PACK__ HostCmd_DS_GET_TSF;
+
+#define	LDO_INTERNAL	0
+#define LDO_EXTERNAL	1
+
+typedef struct _HostCmd_DS_802_11_LDO_CONFIG
+{
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    u16 PMSource;               /* 0 = LDO_INTERNAL; 1 = LDO_EXTERNAL */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_LDO_CONFIG;
+
+/** Define data structure for HostCmd_CMD_802_11D_DOMAIN_INFO */
+typedef struct _HostCmd_DS_802_11D_DOMAIN_INFO
+{
+    u16 Action;
+    MrvlIEtypes_DomainParamSet_t Domain;
+} __ATTRIB_PACK__ HostCmd_DS_802_11D_DOMAIN_INFO,
+    *PHostCmd_DS_802_11D_DOMAIN_INFO;
+
+/** Define data structure for HostCmd_RET_802_11D_DOMAIN_INFO */
+typedef struct _HostCmd_DS_802_11D_DOMAIN_INFO_RSP
+{
+    u16 Action;
+    MrvlIEtypes_DomainParamSet_t Domain;
+} __ATTRIB_PACK__ HostCmd_DS_802_11D_DOMAIN_INFO_RSP,
+    *PHostCmd_DS_802_11D_DOMIAN_INFO_RSP;
+
+/** _HostCmd_DS_COMMAND*/
+struct _HostCmd_DS_COMMAND
+{
+
+    /** Command Header */
+    u16 Command;
+    u16 Size;
+    u16 SeqNum;
+    u16 Result;
+
+    /** Command Body */
+    union
+    {
+        HostCmd_DS_GET_HW_SPEC hwspec;
+        HostCmd_DS_802_11_PS_MODE psmode;
+        HostCmd_DS_802_11_SCAN scan;
+        HostCmd_DS_802_11_SCAN_RSP scanresp;
+        HostCmd_DS_MAC_CONTROL macctrl;
+        HostCmd_DS_802_11_ASSOCIATE associate;
+        HostCmd_DS_802_11_ASSOCIATE_RSP associatersp;
+        HostCmd_DS_802_11_DEAUTHENTICATE deauth;
+        HostCmd_DS_802_11_SET_WEP wep;
+        HostCmd_DS_802_11_AD_HOC_START ads;
+        HostCmd_DS_802_11_AD_HOC_RESULT result;
+        HostCmd_DS_802_11_GET_LOG glog;
+        HostCmd_DS_802_11_AUTHENTICATE auth;
+        HostCmd_DS_802_11_AUTHENTICATE_RSP rauth;
+        HostCmd_DS_802_11_GET_STAT gstat;
+        HostCmd_DS_802_3_GET_STAT gstat_8023;
+        HostCmd_DS_802_11_SNMP_MIB smib;
+        HostCmd_DS_802_11_RF_TX_POWER txp;
+        HostCmd_DS_802_11_RF_ANTENNA rant;
+        HostCmd_DS_802_11_DATA_RATE drate;
+        HostCmd_DS_802_11_RATE_ADAPT_RATESET rateset;
+        HostCmd_DS_MAC_MULTICAST_ADR madr;
+        HostCmd_DS_802_11_AD_HOC_JOIN adj;
+        HostCmd_DS_802_11_RADIO_CONTROL radio;
+        HostCmd_DS_802_11_RF_CHANNEL rfchannel;
+        HostCmd_DS_802_11_RSSI rssi;
+        HostCmd_DS_802_11_RSSI_RSP rssirsp;
+        HostCmd_DS_802_11_DISASSOCIATE dassociate;
+        HostCmd_DS_802_11_AD_HOC_STOP adhoc_stop;
+        HostCmd_DS_802_11_MAC_ADDRESS macadd;
+        HostCmd_DS_802_11_ENABLE_RSN enbrsn;
+        HostCmd_DS_802_11_KEY_MATERIAL keymaterial;
+        HostCmd_DS_MAC_REG_ACCESS macreg;
+        HostCmd_DS_BBP_REG_ACCESS bbpreg;
+        HostCmd_DS_RF_REG_ACCESS rfreg;
+        HostCmd_DS_802_11_BEACON_STOP beacon_stop;
+        HostCmd_DS_802_11_CAL_DATA_EXT caldataext;
+        HostCmd_DS_802_11_HOST_SLEEP_CFG hostsleepcfg;
+        HostCmd_DS_802_11_EEPROM_ACCESS rdeeprom;
+
+        HostCmd_DS_802_11D_DOMAIN_INFO domaininfo;
+        HostCmd_DS_802_11D_DOMAIN_INFO_RSP domaininforesp;
+        HostCmd_DS_802_11_BG_SCAN_CONFIG bgscancfg;
+        HostCmd_DS_802_11_BG_SCAN_QUERY bgscanquery;
+        HostCmd_DS_802_11_BG_SCAN_QUERY_RSP bgscanqueryresp;
+        HostCmd_DS_WMM_GET_STATUS getWmmStatus;
+        HostCmd_DS_WMM_ACK_POLICY ackpolicy;
+        HostCmd_DS_WMM_ADDTS_REQ addTsReq;
+        HostCmd_DS_WMM_DELTS_REQ delTsReq;
+        HostCmd_DS_WMM_QUEUE_CONFIG queueConfig;
+        HostCmd_DS_WMM_QUEUE_STATS queueStats;
+        HostCmd_DS_802_11_SLEEP_PARAMS sleep_params;
+        HostCmd_DS_802_11_BCA_TIMESHARE bca_timeshare;
+        HostCmd_DS_802_11_INACTIVITY_TIMEOUT inactivity_timeout;
+        HostCmd_DS_802_11_SLEEP_PERIOD ps_sleeppd;
+        HostCmd_DS_802_11_TPC_CFG tpccfg;
+        HostCmd_DS_802_11_AFC afc;
+        HostCmd_DS_802_11_LED_CTRL ledgpio;
+        HostCmd_DS_802_11_FW_WAKEUP_METHOD fwwakeupmethod;
+
+        HostCmd_TX_RATE_QUERY txrate;
+        HostCmd_DS_GET_TSF gettsf;
+        HostCmd_DS_802_11_IBSS_Status ibssCoalescing;
+        HostCmd_DS_802_11_LDO_CONFIG ldocfg;
+    } params;
+} __ATTRIB_PACK__;
+
+#endif
diff --git a/drivers/net/wireless/8686_wlan/wlan/include.h b/drivers/net/wireless/8686_wlan/wlan/include.h
new file mode 100644
index 0000000..d344cd1
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/include.h
@@ -0,0 +1,56 @@
+/** @file include.h
+ * 
+ * @brief This file contains all the necessary include file.
+ *
+ * (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change log:
+	10/11/05: Add Doxygen format comments
+	01/11/06: Conditional include file removal/addition
+	01/30/06: Add kernel 2.6 support
+	
+********************************************************/
+
+#ifndef _INCLUDE_H_
+#define _INCLUDE_H_
+
+#include    "os_headers.h"
+#include    "wlan_types.h"
+#include    "wlan_defs.h"
+#include    "wlan_thread.h"
+
+#include    "wlan_wmm.h"
+#include    "wlan_11d.h"
+
+#include    "os_timers.h"
+
+#include    "host.h"
+#include    "hostcmd.h"
+
+#include    "wlan_scan.h"
+#include    "wlan_join.h"
+
+#include    "wlan_dev.h"
+#include    "os_macros.h"
+#include    "sbi.h"
+
+#include    "wlan_fw.h"
+#include    "wlan_wext.h"
+#include    "wlan_decl.h"
+
+#endif /* _INCLUDE_H_ */
diff --git a/drivers/net/wireless/8686_wlan/wlan/sbi.h b/drivers/net/wireless/8686_wlan/wlan/sbi.h
new file mode 100644
index 0000000..f5437cb
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/sbi.h
@@ -0,0 +1,129 @@
+/** @file sbi.h
+ * 
+ * @brief This file contains IF layer definitions.
+ *
+ * (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change log:
+	10/11/05: Add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	
+********************************************************/
+
+#ifndef	_SBI_H_
+#define	_SBI_H_
+
+/**Bit Definition*/
+#define B_BIT_0		0x01
+#define B_BIT_1		0x02
+#define B_BIT_2		0x04
+#define B_BIT_3		0x08
+#define B_BIT_4		0x10
+#define B_BIT_5		0x20
+#define B_BIT_6		0x40
+#define B_BIT_7		0x80
+#define B_BIT_8		0x100
+#define B_BIT_9		0X200
+#define B_BIT_10	0x400
+
+/** INT Status Bit Definition*/
+#define HIS_RxUpLdRdy			B_BIT_0
+#define HIS_TxDnLdRdy			B_BIT_1
+#define HIS_CmdDnLdRdy			B_BIT_2
+#define HIS_CardEvent			B_BIT_3
+#define HIS_CmdUpLdRdy			B_BIT_4
+#define HIS_WrFifoOvrflow		B_BIT_5
+#define HIS_RdFifoUndrflow		B_BIT_6
+#define HIS_WlanReady			B_BIT_7
+
+#define	HIM_DISABLE			0xff
+#define HIM_ENABLE			0x03
+
+#define FIRMWARE_READY			0xfedc
+#ifndef DEV_NAME_LEN
+#define DEV_NAME_LEN			32
+#endif
+#define MAXKEYLEN			13
+
+/* The number of times to try when polling for status bits */
+#define MAX_POLL_TRIES			100
+
+/* The number of times to try when waiting for downloaded firmware to 
+     become active. (polling the scratch register). */
+
+#define MAX_FIRMWARE_POLL_TRIES		100
+
+#define FIRMWARE_TRANSFER_NBLOCK	2
+#define SBI_EVENT_CAUSE_SHIFT		3
+
+typedef enum _mv_sd_type
+{
+    MVSD_DAT = 0,
+    MVSD_CMD = 1,
+    MVSD_EVENT = 3
+} mv_sd_type;
+
+/** Function Prototype Declaration */
+typedef wlan_private *(*wlan_notifier_fn_add) (void *dev_id);
+typedef int (*wlan_notifier_fn_remove) (void *dev_id);
+
+typedef IRQ_RET_TYPE(*isr_notifier_fn_t) (s32 irq, void *dev_id,
+                                          struct pt_regs * reg);
+typedef IRQ_RET_TYPE(*handler_fn_t) (s32 irq, void *dev_id, struct pt_regs *);
+
+/* Probe and Check if the card is present*/
+int sbi_probe_card(void *card);
+int sbi_register_dev(wlan_private * priv);
+int sbi_unregister_dev(wlan_private *);
+int sbi_disable_host_int(wlan_private * priv);
+int sbi_get_int_status(wlan_private * priv, u8 *);
+int *sbi_register(wlan_notifier_fn_add, wlan_notifier_fn_remove, void *);
+void sbi_unregister(void);
+int sbi_prog_firmware(wlan_private *);
+int sbi_verify_fw_download(wlan_private *);
+
+int sbi_prog_helper(wlan_private *);
+int sbi_prog_firmware_w_helper(wlan_private *);
+
+int sbi_read_event_cause(wlan_private *);
+int sbi_reenable_host_interrupt(wlan_private *, u8);
+int sbi_host_to_card(wlan_private * priv, u8 type, u8 * payload, u16 nb);
+int sbi_card_to_host(wlan_private * priv, u32 type, u32 * nb, u8 * payload,
+                     u16 npayload);
+int sbi_enable_host_int(wlan_private *);
+
+int sbi_exit_deep_sleep(wlan_private *);
+int sbi_reset_deepsleep_wakeup(wlan_private *);
+#ifdef ENABLE_PM
+int sbi_suspend(wlan_private *);
+int sbi_resume(wlan_private *);
+#endif
+
+//int sbi_read_ioreg(wlan_private * priv, u8 func, u32 reg, u8 * dat);
+int sbi_read_ioreg(wlan_private *priv, u32 reg, u8 * dat);
+//int sbi_write_ioreg(wlan_private *priv, u8 func, u32 reg, u8 dat);
+int sbi_write_ioreg(wlan_private *priv, u32 reg, u8 dat);
+int sbi_set_bus_clock(wlan_private * priv, u8 option);
+
+int sbi_get_cis_info(wlan_private * priv);
+
+/* add by feng for thread debug */
+extern int threadrunning;
+
+
+#endif /* _SBI_H */
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_11d.c b/drivers/net/wireless/8686_wlan/wlan/wlan_11d.c
new file mode 100644
index 0000000..b28ba7b
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_11d.c
@@ -0,0 +1,913 @@
+/** @file wlan_11d.c
+  * @brief This file contains functions for 802.11D.
+  *
+  * (c) Copyright © 2003-2006, Marvell International Ltd. 
+  *
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	10/04/05: Add Doxygen format comments
+	
+********************************************************/
+#include	"include.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+#define TX_PWR_DEFAULT	10
+
+static region_code_mapping_t region_code_mapping[] = {
+    {"US ", 0x10},              /* US FCC      */
+    {"CA ", 0x20},              /* IC Canada   */
+    {"SG ", 0x10},              /* Singapore   */
+    {"EU ", 0x30},              /* ETSI        */
+    {"AU ", 0x30},              /* Australia   */
+    {"KR ", 0x30},              /* Republic Of Korea */
+    {"ES ", 0x31},              /* Spain       */
+    {"FR ", 0x32},              /* France      */
+    {"JP ", 0x40},              /* Japan       */
+    {"JP ", 0x41},              /* Japan       */
+};
+
+/********************************************************
+		Global Variables
+********************************************************/
+/* Following 2 structure defines the supported channels */
+CHANNEL_FREQ_POWER channel_freq_power_UN_BG[] = {
+    {1, 2412, TX_PWR_DEFAULT},
+    {2, 2417, TX_PWR_DEFAULT},
+    {3, 2422, TX_PWR_DEFAULT},
+    {4, 2427, TX_PWR_DEFAULT},
+    {5, 2432, TX_PWR_DEFAULT},
+    {6, 2437, TX_PWR_DEFAULT},
+    {7, 2442, TX_PWR_DEFAULT},
+    {8, 2447, TX_PWR_DEFAULT},
+    {9, 2452, TX_PWR_DEFAULT},
+    {10, 2457, TX_PWR_DEFAULT},
+    {11, 2462, TX_PWR_DEFAULT},
+    {12, 2467, TX_PWR_DEFAULT},
+    {13, 2472, TX_PWR_DEFAULT},
+    {14, 2484, TX_PWR_DEFAULT}
+};
+
+CHANNEL_FREQ_POWER channel_freq_power_UN_AJ[] = {
+    {8, 5040, TX_PWR_DEFAULT},
+    {12, 5060, TX_PWR_DEFAULT},
+    {16, 5080, TX_PWR_DEFAULT},
+    {34, 5170, TX_PWR_DEFAULT},
+    {38, 5190, TX_PWR_DEFAULT},
+    {42, 5210, TX_PWR_DEFAULT},
+    {46, 5230, TX_PWR_DEFAULT},
+    {36, 5180, TX_PWR_DEFAULT},
+    {40, 5200, TX_PWR_DEFAULT},
+    {44, 5220, TX_PWR_DEFAULT},
+    {48, 5240, TX_PWR_DEFAULT},
+    {52, 5260, TX_PWR_DEFAULT},
+    {56, 5280, TX_PWR_DEFAULT},
+    {60, 5300, TX_PWR_DEFAULT},
+    {64, 5320, TX_PWR_DEFAULT},
+    {100, 5500, TX_PWR_DEFAULT},
+    {104, 5520, TX_PWR_DEFAULT},
+    {108, 5540, TX_PWR_DEFAULT},
+    {112, 5560, TX_PWR_DEFAULT},
+    {116, 5580, TX_PWR_DEFAULT},
+    {120, 5600, TX_PWR_DEFAULT},
+    {124, 5620, TX_PWR_DEFAULT},
+    {128, 5640, TX_PWR_DEFAULT},
+    {132, 5660, TX_PWR_DEFAULT},
+    {136, 5680, TX_PWR_DEFAULT},
+    {140, 5700, TX_PWR_DEFAULT},
+    {149, 5745, TX_PWR_DEFAULT},
+    {153, 5765, TX_PWR_DEFAULT},
+    {157, 5785, TX_PWR_DEFAULT},
+    {161, 5805, TX_PWR_DEFAULT},
+    {165, 5825, TX_PWR_DEFAULT},
+/*	{240, 4920, TX_PWR_DEFAULT}, 
+	{244, 4940, TX_PWR_DEFAULT}, 
+	{248, 4960, TX_PWR_DEFAULT}, 
+	{252, 4980, TX_PWR_DEFAULT}, 
+channels for 11J JP 10M channel gap */
+};
+
+extern CHANNEL_FREQ_POWER *wlan_get_region_cfp_table(u8 region,
+                                                     u8 band, int *cfp_no);
+
+/********************************************************
+		Local Functions
+********************************************************/
+/** 
+ *  @brief This function convert Region string to code integer
+ *  @param region     region string
+ *  @return 	      region id
+*/
+static u8
+wlan_region_2_code(s8 * region)
+{
+    u8 i;
+    u8 size = sizeof(region_code_mapping) / sizeof(region_code_mapping_t);
+
+    for (i = 0; region[i] && i < COUNTRY_CODE_LEN; i++)
+        region[i] = toupper(region[i]);
+
+    for (i = 0; i < size; i++) {
+        if (!memcmp(region, region_code_mapping[i].region, COUNTRY_CODE_LEN))
+            return (region_code_mapping[i].code);
+    }
+
+    /* default is US */
+    return (region_code_mapping[0].code);
+}
+
+/** 
+ *  @brief This function converts interger code to region string
+ *  @param code       region code
+ *  @return 	      region string
+*/
+static u8 *
+wlan_code_2_region(u8 code)
+{
+    u8 i;
+    u8 size = sizeof(region_code_mapping) / sizeof(region_code_mapping_t);
+    for (i = 0; i < size; i++) {
+        if (region_code_mapping[i].code == code)
+            return (region_code_mapping[i].region);
+    }
+    /* default is US */
+    return (region_code_mapping[0].region);
+}
+
+/** 
+ *  @brief This function finds the NoOfChan-th chan after the firstChan
+ *  @param band       band
+ *  @param firstChan  first channel number
+ *  @param NoOfChan   number of channels
+ *  @return 	      the NoOfChan-th chan number
+*/
+static BOOLEAN
+wlan_get_chan_11d(u8 band, u8 firstChan, u8 NoOfChan, u8 * chan)
+/*find the NoOfChan-th chan after the firstChan*/
+{
+    u8 i;
+    CHANNEL_FREQ_POWER *cfp;
+    u8 cfp_no;
+
+    ENTER();
+
+    {
+        cfp = channel_freq_power_UN_BG;
+        cfp_no = sizeof(channel_freq_power_UN_BG) /
+            sizeof(CHANNEL_FREQ_POWER);
+    }
+
+    for (i = 0; i < cfp_no; i++) {
+        if ((cfp + i)->Channel == firstChan) {
+            PRINTM(INFO, "firstChan found\n");
+            break;
+        }
+    }
+
+    if (i < cfp_no) {
+        /*if beyond the boundary */
+        if (i + NoOfChan < cfp_no) {
+            *chan = (cfp + i + NoOfChan)->Channel;
+            return TRUE;
+        }
+    }
+
+    LEAVE();
+    return FALSE;
+}
+
+/** 
+ *  @brief This function Checks if chan txpwr is learned from AP/IBSS
+ *  @param chan                 chan number
+ *  @param parsed_region_chan   pointer to parsed_region_chan_11d_t     
+ *  @return 	                TRUE; FALSE
+*/
+BOOLEAN
+wlan_channel_known_11d(u8 chan, parsed_region_chan_11d_t * parsed_region_chan)
+{
+    chan_power_11d_t *chanPwr = parsed_region_chan->chanPwr;
+    u8 NoOfChan = parsed_region_chan->NoOfChan;
+    u8 i = 0;
+
+    ENTER();
+    HEXDUMP("11D:parsed_region_chan:", (char *) chanPwr,
+            sizeof(chan_power_11d_t) * NoOfChan);
+
+    for (i = 0; i < NoOfChan; i++) {
+        if (chan == chanPwr[i].chan) {
+            PRINTM(INFO, "11D: Found Chan:%d\n", chan);
+            LEAVE();
+            return TRUE;
+        }
+    }
+
+    PRINTM(INFO, "11D: Not Find Chan:%d\n", chan);
+    LEAVE();
+    return FALSE;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function Converts chan to frequency
+ *  @param chan                 channel number
+ *  @param band                 band
+ *  @return 	                channel frequency
+*/
+u32
+chan_2_freq(u8 chan, u8 band)
+{
+    CHANNEL_FREQ_POWER *cf;
+    u16 cnt;
+    u16 i;
+    u32 freq = 0;
+
+    ENTER();
+
+    {
+        cf = channel_freq_power_UN_BG;
+        cnt = sizeof(channel_freq_power_UN_BG) / sizeof(CHANNEL_FREQ_POWER);
+    }
+
+    for (i = 0; i < cnt; i++) {
+        if (chan == cf[i].Channel)
+            freq = cf[i].Freq;
+    }
+
+    LEAVE();
+    return freq;
+}
+
+/** 
+ *  @brief This function generates domaininfo from parsed_region_chan
+ *  @param parsed_region_chan   pointer to parsed_region_chan_11d_t
+ *  @param domaininfo           pointer to wlan_802_11d_domain_reg_t
+ *  @return 	                WLAN_STATUS_SUCCESS
+*/
+int
+wlan_generate_domain_info_11d(parsed_region_chan_11d_t * parsed_region_chan,
+                              wlan_802_11d_domain_reg_t * domaininfo)
+{
+    u8 NoOfSubband = 0;
+
+    u8 NoOfChan = parsed_region_chan->NoOfChan;
+    u8 NoOfParsedChan = 0;
+
+    u8 firstChan = 0, nextChan = 0, maxPwr = 0;
+
+    u8 i, flag = 0;
+
+    ENTER();
+
+    memcpy(domaininfo->CountryCode, parsed_region_chan->CountryCode,
+           COUNTRY_CODE_LEN);
+
+    PRINTM(INFO, "11D:NoOfChan=%d\n", NoOfChan);
+    HEXDUMP("11D:parsed_region_chan:", (char *) parsed_region_chan,
+            sizeof(parsed_region_chan_11d_t));
+
+    for (i = 0; i < NoOfChan; i++) {
+        if (!flag) {
+            flag = 1;
+            nextChan = firstChan = parsed_region_chan->chanPwr[i].chan;
+            maxPwr = parsed_region_chan->chanPwr[i].pwr;
+            NoOfParsedChan = 1;
+            continue;
+        }
+
+        if (parsed_region_chan->chanPwr[i].chan == nextChan + 1 &&
+            parsed_region_chan->chanPwr[i].pwr == maxPwr) {
+            nextChan++;
+            NoOfParsedChan++;
+        } else {
+            domaininfo->Subband[NoOfSubband].FirstChan = firstChan;
+            domaininfo->Subband[NoOfSubband].NoOfChan = NoOfParsedChan;
+            domaininfo->Subband[NoOfSubband].MaxTxPwr = maxPwr;
+            NoOfSubband++;
+            NoOfParsedChan = 1;
+            nextChan = firstChan = parsed_region_chan->chanPwr[i].chan;
+            maxPwr = parsed_region_chan->chanPwr[i].pwr;
+        }
+    }
+
+    if (flag) {
+        domaininfo->Subband[NoOfSubband].FirstChan = firstChan;
+        domaininfo->Subband[NoOfSubband].NoOfChan = NoOfParsedChan;
+        domaininfo->Subband[NoOfSubband].MaxTxPwr = maxPwr;
+        NoOfSubband++;
+    }
+    domaininfo->NoOfSubband = NoOfSubband;
+
+    PRINTM(INFO, "NoOfSubband=%x\n", domaininfo->NoOfSubband);
+    HEXDUMP("11D:domaininfo:", (char *) domaininfo,
+            COUNTRY_CODE_LEN + 1 +
+            sizeof(IEEEtypes_SubbandSet_t) * NoOfSubband);
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function generates parsed_region_chan from Domain Info learned from AP/IBSS
+ *  @param region_chan          pointer to REGION_CHANNEL
+ *  @param *parsed_region_chan  pointer to parsed_region_chan_11d_t
+ *  @return 	                N/A
+*/
+void
+wlan_generate_parsed_region_chan_11d(REGION_CHANNEL * region_chan,
+                                     parsed_region_chan_11d_t *
+                                     parsed_region_chan)
+{
+    u8 i;
+    CHANNEL_FREQ_POWER *cfp;
+
+    ENTER();
+
+    if (region_chan == NULL) {
+        PRINTM(INFO, "11D: region_chan is NULL\n");
+        return;
+    }
+
+    cfp = region_chan->CFP;
+    if (cfp == NULL) {
+        PRINTM(INFO, "11D: cfp equal NULL \n");
+        return;
+    }
+
+    parsed_region_chan->band = region_chan->Band;
+    parsed_region_chan->region = region_chan->Region;
+    memcpy(parsed_region_chan->CountryCode,
+           wlan_code_2_region(region_chan->Region), COUNTRY_CODE_LEN);
+
+    PRINTM(INFO, "11D: region[0x%x] band[%d]\n", parsed_region_chan->region,
+           parsed_region_chan->band);
+
+    for (i = 0; i < region_chan->NrCFP; i++, cfp++) {
+        parsed_region_chan->chanPwr[i].chan = cfp->Channel;
+        parsed_region_chan->chanPwr[i].pwr = cfp->MaxTxPower;
+        PRINTM(INFO, "11D: Chan[%d] Pwr[%d]\n",
+               parsed_region_chan->chanPwr[i].chan,
+               parsed_region_chan->chanPwr[i].pwr);
+    }
+    parsed_region_chan->NoOfChan = region_chan->NrCFP;
+
+    PRINTM(INFO, "11D: NoOfChan[%d]\n", parsed_region_chan->NoOfChan);
+
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief generate parsed_region_chan from Domain Info learned from AP/IBSS
+ *  @param region               region ID
+ *  @param band                 band
+ *  @param chan                 chan
+ *  @return 	                TRUE;FALSE
+*/
+BOOLEAN
+wlan_region_chan_supported_11d(u8 region, u8 band, u8 chan)
+{
+    CHANNEL_FREQ_POWER *cfp;
+    int cfp_no;
+    u8 idx;
+
+    ENTER();
+
+    if ((cfp = wlan_get_region_cfp_table(region, band, &cfp_no)) == NULL) {
+        return FALSE;
+    }
+
+    for (idx = 0; idx < cfp_no; idx++) {
+        if (chan == (cfp + idx)->Channel) {
+            /* If Mrvl Chip Supported? */
+            if ((cfp + idx)->Unsupported) {
+                return FALSE;
+            } else {
+                return TRUE;
+            }
+        }
+    }
+
+    /*chan is not in the region table */
+    LEAVE();
+    return FALSE;
+}
+
+/** 
+ *  @brief This function checks if chan txpwr is learned from AP/IBSS
+ *  @param chan                 chan number
+ *  @param parsed_region_chan   pointer to parsed_region_chan_11d_t     
+ *  @return 	                WLAN_STATUS_SUCCESS       
+*/
+int
+wlan_parse_domain_info_11d(IEEEtypes_CountryInfoFullSet_t * CountryInfo,
+                           u8 band,
+                           parsed_region_chan_11d_t * parsed_region_chan)
+{
+    u8 NoOfSubband, NoOfChan;
+    u8 lastChan, firstChan, curChan;
+    u8 region;
+
+    u8 idx = 0;                 /*chan index in parsed_region_chan */
+
+    u8 j, i;
+
+    ENTER();
+
+    /*Validation Rules:
+       1. Valid Region Code
+       2. First Chan increment
+       3. Channel range no overlap
+       4. Channel is valid?
+       5. Channel is supported by Region?
+       6. Others
+     */
+
+    HEXDUMP("CountryInfo:", (s8 *) CountryInfo, 30);
+
+    if ((*(CountryInfo->CountryCode)) == 0 ||
+        (CountryInfo->Len <= COUNTRY_CODE_LEN)) {
+        /* No region Info or Wrong region info: treat as No 11D info */
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    /*Step1: check region_code */
+    parsed_region_chan->region = region =
+        wlan_region_2_code(CountryInfo->CountryCode);
+
+    PRINTM(INFO, "regioncode=%x\n", (u8) parsed_region_chan->region);
+    HEXDUMP("CountryCode:", (char *) CountryInfo->CountryCode,
+            COUNTRY_CODE_LEN);
+
+    parsed_region_chan->band = band;
+
+    memcpy(parsed_region_chan->CountryCode, CountryInfo->CountryCode,
+           COUNTRY_CODE_LEN);
+
+    NoOfSubband = (CountryInfo->Len - COUNTRY_CODE_LEN) /
+        sizeof(IEEEtypes_SubbandSet_t);
+
+    for (j = 0, lastChan = 0; j < NoOfSubband; j++) {
+
+        if (CountryInfo->Subband[j].FirstChan <= lastChan) {
+            /*Step2&3. Check First Chan Num increment and no overlap */
+            PRINTM(INFO, "11D: Chan[%d>%d] Overlap\n",
+                   CountryInfo->Subband[j].FirstChan, lastChan);
+            continue;
+        }
+
+        firstChan = CountryInfo->Subband[j].FirstChan;
+        NoOfChan = CountryInfo->Subband[j].NoOfChan;
+
+        for (i = 0; idx < MAX_NO_OF_CHAN && i < NoOfChan; i++) {
+            /*step4: channel is supported? */
+
+            if (wlan_get_chan_11d(band, firstChan, i, &curChan)
+                == FALSE) {
+                /* Chan is not found in UN table */
+                PRINTM(INFO, "chan is not supported: %d \n", i);
+                break;
+            }
+
+            lastChan = curChan;
+
+            /*step5: We don't need to check if curChan is supported by mrvl in region */
+            parsed_region_chan->chanPwr[idx].chan = curChan;
+            parsed_region_chan->chanPwr[idx].pwr =
+                CountryInfo->Subband[j].MaxTxPwr;
+            idx++;
+        }
+
+        /*Step6: Add other checking if any */
+
+    }
+
+    parsed_region_chan->NoOfChan = idx;
+
+    PRINTM(INFO, "NoOfChan=%x\n", parsed_region_chan->NoOfChan);
+    HEXDUMP("11D:parsed_region_chan:", (s8 *) parsed_region_chan,
+            2 + COUNTRY_CODE_LEN + sizeof(parsed_region_chan_11d_t) * idx);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function calculates the scan type for channels
+ *  @param chan                 chan number
+ *  @param parsed_region_chan   pointer to parsed_region_chan_11d_t     
+ *  @return 	                PASSIVE if chan is unknown; ACTIVE if chan is known
+*/
+u8
+wlan_get_scan_type_11d(u8 chan, parsed_region_chan_11d_t * parsed_region_chan)
+{
+    u8 scan_type = HostCmd_SCAN_TYPE_PASSIVE;
+
+    ENTER();
+
+    if (wlan_channel_known_11d(chan, parsed_region_chan)) {
+        PRINTM(INFO, "11D: Found and do Active Scan\n");
+        scan_type = HostCmd_SCAN_TYPE_ACTIVE;
+    } else {
+        PRINTM(INFO, "11D: Not Find and do Passive Scan\n");
+    }
+
+    LEAVE();
+    return scan_type;
+
+}
+
+/** 
+ *  @brief This function gets if 11D is enabled
+ *  @param priv       pointer to wlan_private
+ *  @return 	      ENABLE_11D;DISABLE_11D
+*/
+state_11d_t
+wlan_get_state_11d(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_802_11d_state_t *state = &Adapter->State11D;
+    return (state->Enable11D);
+}
+
+/** 
+ *  @brief initialize internal variable for 11D
+ *  @param priv       pointer to wlan_private
+ *  @return 	      N/A
+*/
+void
+wlan_init_11d(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_802_11d_state_t *state = &Adapter->State11D;
+
+    state->Enable11D = DISABLE_11D;
+
+    memset(&(priv->adapter->parsed_region_chan), 0,
+           sizeof(parsed_region_chan_11d_t));
+
+    return;
+}
+
+/** 
+ *  @brief This function enable/disable 11D
+ *  @param priv       pointer to wlan_private
+ *  @param flag       enable/disable flag
+ *  @return 	      WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+*/
+int
+wlan_enable_11d(wlan_private * priv, state_11d_t flag)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_802_11d_state_t *state = &Adapter->State11D;
+    int ret;
+    state_11d_t enable = flag;
+
+    ENTER();
+
+    state->Enable11D = flag;
+
+    /* send cmd to FW to enable/disable 11D fucntion in FW */
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_SNMP_MIB,
+                                HostCmd_ACT_SET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11D_ENABLE, &enable);
+    if (ret) {
+        PRINTM(INFO, "11D: Fail to enable 11D \n");
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function sets DOMAIN INFO to FW
+ *  @param priv       pointer to wlan_private
+ *  @return 	      WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+*/
+int
+wlan_set_domain_info_11d(wlan_private * priv)
+{
+    int ret;
+
+    if (!wlan_get_state_11d(priv)) {
+        PRINTM(INFO, "11D: dnld domain Info with 11d disabled\n");
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11D_DOMAIN_INFO,
+                                HostCmd_ACT_GEN_SET,
+                                HostCmd_OPTION_WAITFORRSP, 0, NULL);
+    if (ret) {
+        PRINTM(INFO, "11D: Fail to dnld domain Info\n");
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function setups scan channels
+ *  @param priv       pointer to wlan_private
+ *  @param band       band
+ *  @return 	      WLAN_STATUS_SUCCESS
+*/
+int
+wlan_set_universaltable(wlan_private * priv, u8 band)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u16 size = sizeof(CHANNEL_FREQ_POWER);
+    u16 i = 0;
+
+    ENTER();
+
+    memset(Adapter->universal_channel, 0, sizeof(Adapter->universal_channel));
+
+    {
+        Adapter->universal_channel[i].NrCFP =
+            sizeof(channel_freq_power_UN_BG) / size;
+        PRINTM(INFO, "11D: BG-band NrCFP=%d\n",
+               Adapter->universal_channel[i].NrCFP);
+
+        Adapter->universal_channel[i].CFP = channel_freq_power_UN_BG;
+        Adapter->universal_channel[i].Valid = TRUE;
+        Adapter->universal_channel[i].Region = UNIVERSAL_REGION_CODE;
+        Adapter->universal_channel[i].Band = band;
+        i++;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function implements command CMD_802_11D_DOMAIN_INFO
+ *  @param priv       pointer to wlan_private
+ *  @param cmd        pointer to cmd buffer
+ *  @param cmdno      cmd ID
+ *  @param CmdOption  cmd action 
+ *  @return 	      WLAN_STATUS_SUCCESS
+*/
+int
+wlan_cmd_802_11d_domain_info(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, u16 cmdno,
+                             u16 CmdOption)
+{
+    HostCmd_DS_802_11D_DOMAIN_INFO *pDomainInfo = &cmd->params.domaininfo;
+    MrvlIEtypes_DomainParamSet_t *domain = &pDomainInfo->Domain;
+    wlan_adapter *Adapter = priv->adapter;
+    u8 NoOfSubband = Adapter->DomainReg.NoOfSubband;
+
+    ENTER();
+
+    PRINTM(INFO, "NoOfSubband=%x\n", NoOfSubband);
+
+    cmd->Command = wlan_cpu_to_le16(cmdno);
+    pDomainInfo->Action = wlan_cpu_to_le16(CmdOption);
+    if (CmdOption == HostCmd_ACT_GET) {
+        cmd->Size = wlan_cpu_to_le16(sizeof(pDomainInfo->Action) + S_DS_GEN);
+        HEXDUMP("11D: 802_11D_DOMAIN_INFO:", (u8 *) cmd, (int) (cmd->Size));
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    domain->Header.Type = wlan_cpu_to_le16(TLV_TYPE_DOMAIN);
+    memcpy(domain->CountryCode, Adapter->DomainReg.CountryCode,
+           sizeof(domain->CountryCode));
+
+    domain->Header.Len =
+        wlan_cpu_to_le16(NoOfSubband * sizeof(IEEEtypes_SubbandSet_t) +
+                         sizeof(domain->CountryCode));
+
+    if (NoOfSubband) {
+        memcpy(domain->Subband, Adapter->DomainReg.Subband,
+               NoOfSubband * sizeof(IEEEtypes_SubbandSet_t));
+
+        cmd->Size = wlan_cpu_to_le16(sizeof(pDomainInfo->Action) +
+                                     domain->Header.Len +
+                                     sizeof(MrvlIEtypesHeader_t) + S_DS_GEN);
+    } else {
+        cmd->Size = wlan_cpu_to_le16(sizeof(pDomainInfo->Action) + S_DS_GEN);
+    }
+
+    HEXDUMP("11D:802_11D_DOMAIN_INFO:", (u8 *) cmd, (int) (cmd->Size));
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function implements private cmd: enable/disable 11D
+ *  @param priv    pointer to wlan_private
+ *  @param wrq     pointer to user data 
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_enable_11d(wlan_private * priv, struct iwreq *wrq)
+{
+    int data = 0;
+    int *val;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+
+    PRINTM(INFO, "Enable 11D: %s\n",
+           (data == CMD_ENABLED) ? "Enable" : "Disable");
+    switch (data) {
+    case CMD_ENABLED:
+        wlan_enable_11d(priv, ENABLE_11D);
+        break;
+    case CMD_DISABLED:
+        wlan_enable_11d(priv, DISABLE_11D);
+        break;
+    default:
+        break;
+    }
+
+    data =
+        (Adapter->State11D.Enable11D ==
+         ENABLE_11D) ? CMD_ENABLED : CMD_DISABLED;
+    val = (int *) wrq->u.name;
+    *val = data;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function parses countryinfo from AP and download country info to FW
+ *  @param priv    pointer to wlan_private
+ *  @param resp    pointer to command response buffer
+ *  @return 	   WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11d_domain_info(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11D_DOMAIN_INFO_RSP
+        * domaininfo = &resp->params.domaininforesp;
+    MrvlIEtypes_DomainParamSet_t * domain = &domaininfo->Domain;
+    u16 Action = wlan_le16_to_cpu(domaininfo->Action);
+    s16 ret = WLAN_STATUS_SUCCESS;
+    u8 NoOfSubband = 0;
+
+    ENTER();
+
+    HEXDUMP("11D DOMAIN Info Rsp Data:", (u8 *) resp,
+            (int) wlan_le16_to_cpu(resp->Size));
+
+    NoOfSubband =
+        (wlan_le16_to_cpu(domain->Header.Len) -
+         3) / sizeof(IEEEtypes_SubbandSet_t);
+    /* countrycode 3 bytes */
+
+    PRINTM(INFO, "11D Domain Info Resp: NoOfSubband=%d\n", NoOfSubband);
+
+    if (NoOfSubband > MRVDRV_MAX_SUBBAND_802_11D) {
+        PRINTM(INFO, "Invalid Numrer of Subband returned!!\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    switch (Action) {
+    case HostCmd_ACT_SET:      /*Proc Set Action */
+        break;
+
+    case HostCmd_ACT_GET:
+        break;
+    default:
+        PRINTM(INFO, "Invalid Action:%d\n", domaininfo->Action);
+        ret = WLAN_STATUS_FAILURE;
+        break;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function parses countryinfo from AP and download country info to FW
+ *  @param priv    pointer to wlan_private
+ *  @return 	   WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+ */
+int
+wlan_parse_dnld_countryinfo_11d(wlan_private * priv)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+    if (wlan_get_state_11d(priv) == ENABLE_11D) {
+
+        memset(&Adapter->parsed_region_chan, 0,
+               sizeof(parsed_region_chan_11d_t));
+
+        ret =
+            wlan_parse_domain_info_11d(&Adapter->pAttemptedBSSDesc->
+                                       CountryInfo, 0,
+                                       &Adapter->parsed_region_chan);
+
+        if (ret == WLAN_STATUS_FAILURE) {
+            PRINTM(INFO, "11D: Err Parse domain_info from AP..\n");
+            LEAVE();
+            return ret;
+        }
+
+        memset(&Adapter->DomainReg, 0, sizeof(wlan_802_11d_domain_reg_t));
+        wlan_generate_domain_info_11d(&Adapter->parsed_region_chan,
+                                      &Adapter->DomainReg);
+
+        ret = wlan_set_domain_info_11d(priv);
+
+        if (ret) {
+            PRINTM(INFO, "11D: Err set domainInfo to FW\n");
+            LEAVE();
+            return ret;
+        }
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function generates 11D info from user specified regioncode and download to FW
+ *  @param priv    pointer to wlan_private
+ *  @return 	   WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+ */
+int
+wlan_create_dnld_countryinfo_11d(wlan_private * priv)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+    REGION_CHANNEL *region_chan;
+    u8 j;
+
+    ENTER();
+    PRINTM(INFO, "11D:CurBssParams.Band[%d]\n", Adapter->CurBssParams.band);
+
+    if (wlan_get_state_11d(priv) == ENABLE_11D) {
+        /* update parsed_region_chan_11; dnld domaininf to FW */
+
+        for (j = 0; j < sizeof(Adapter->region_channel) /
+             sizeof(Adapter->region_channel[0]); j++) {
+            region_chan = &Adapter->region_channel[j];
+
+            PRINTM(INFO, "11D:[%d] region_chan->Band[%d]\n", j,
+                   region_chan->Band);
+
+            if (!region_chan || !region_chan->Valid || !region_chan->CFP)
+                continue;
+            if (region_chan->Band != Adapter->CurBssParams.band)
+                continue;
+            break;
+        }
+
+        if (j >= sizeof(Adapter->region_channel) /
+            sizeof(Adapter->region_channel[0])) {
+            PRINTM(INFO, "11D:region_chan not found. Band[%d]\n",
+                   Adapter->CurBssParams.band);
+            LEAVE();
+            return WLAN_STATUS_FAILURE;
+        }
+
+        memset(&Adapter->parsed_region_chan, 0,
+               sizeof(parsed_region_chan_11d_t));
+        wlan_generate_parsed_region_chan_11d(region_chan,
+                                             &Adapter->parsed_region_chan);
+
+        memset(&Adapter->DomainReg, 0, sizeof(wlan_802_11d_domain_reg_t));
+        wlan_generate_domain_info_11d(&Adapter->parsed_region_chan,
+                                      &Adapter->DomainReg);
+
+        ret = wlan_set_domain_info_11d(priv);
+
+        if (ret) {
+            PRINTM(INFO, "11D: Err set domainInfo to FW\n");
+            LEAVE();
+            return ret;
+        }
+
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_11d.h b/drivers/net/wireless/8686_wlan/wlan/wlan_11d.h
new file mode 100644
index 0000000..ce033c6
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_11d.h
@@ -0,0 +1,124 @@
+/** @file wlan_11d.h
+ *  @brief This header file contains data structures and 
+ *  function declarations of 802.11d  
+ *
+ * (c) Copyright © 2003-2006, Marvell International Ltd.  
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change log:
+	09/26/05: add Doxygen format comments 
+ ************************************************************/
+
+#ifndef _WLAN_11D_
+#define _WLAN_11D_
+
+#define MAX_CHAN_NUM				255
+
+#define UNIVERSAL_REGION_CODE			0xff
+
+/** (Beaconsize(256)-5(IEId,len,contrystr(3))/3(FirstChan,NoOfChan,MaxPwr) 
+ */
+#define MAX_NO_OF_CHAN 				40
+
+typedef struct _REGION_CHANNEL *PREGION_CHANNEL;
+
+typedef enum
+{
+    DISABLE_11D = 0,
+    ENABLE_11D = 1,
+} state_11d_t;
+
+/** domain regulatory information */
+typedef struct _wlan_802_11d_domain_reg
+{
+        /** country Code*/
+    u8 CountryCode[COUNTRY_CODE_LEN];
+        /** No. of subband*/
+    u8 NoOfSubband;
+    IEEEtypes_SubbandSet_t Subband[MRVDRV_MAX_SUBBAND_802_11D];
+} wlan_802_11d_domain_reg_t;
+
+typedef struct _chan_power_11d
+{
+    u8 chan;
+    u8 pwr;
+} __ATTRIB_PACK__ chan_power_11d_t;
+
+typedef struct _parsed_region_chan_11d
+{
+    u8 band;
+    u8 region;
+    s8 CountryCode[COUNTRY_CODE_LEN];
+    chan_power_11d_t chanPwr[MAX_NO_OF_CHAN];
+    u8 NoOfChan;
+} __ATTRIB_PACK__ parsed_region_chan_11d_t;
+
+/** Data for state machine */
+typedef struct _wlan_802_11d_state
+{
+        /** True for Enabling  11D*/
+    BOOLEAN Enable11D;
+} wlan_802_11d_state_t;
+
+typedef struct _region_code_mapping
+{
+    s8 region[COUNTRY_CODE_LEN];
+    u8 code;
+} region_code_mapping_t;
+
+/* function prototypes*/
+int wlan_generate_domain_info_11d(parsed_region_chan_11d_t *
+                                  parsed_region_chan,
+                                  wlan_802_11d_domain_reg_t * domaininfo);
+
+int wlan_parse_domain_info_11d(IEEEtypes_CountryInfoFullSet_t * CountryInfo,
+                               u8 band,
+                               parsed_region_chan_11d_t * parsed_region_chan);
+
+u8 wlan_get_scan_type_11d(u8 chan,
+                          parsed_region_chan_11d_t * parsed_region_chan);
+
+u32 chan_2_freq(u8 chan, u8 band);
+
+int wlan_set_domain_info_11d(wlan_private * priv);
+
+state_11d_t wlan_get_state_11d(wlan_private * priv);
+
+void wlan_init_11d(wlan_private * priv);
+
+int wlan_enable_11d(wlan_private * priv, state_11d_t flag);
+
+int wlan_set_universaltable(wlan_private * priv, u8 band);
+
+void wlan_generate_parsed_region_chan_11d(PREGION_CHANNEL region_chan,
+                                          parsed_region_chan_11d_t *
+                                          parsed_region_chan);
+
+int wlan_cmd_802_11d_domain_info(wlan_private * priv,
+                                 HostCmd_DS_COMMAND * cmd, u16 cmdno,
+                                 u16 CmdOption);
+
+int wlan_cmd_enable_11d(wlan_private * priv, struct iwreq *wrq);
+
+int wlan_ret_802_11d_domain_info(wlan_private * priv,
+                                 HostCmd_DS_COMMAND * resp);
+
+int wlan_parse_dnld_countryinfo_11d(wlan_private * priv);
+
+int wlan_create_dnld_countryinfo_11d(wlan_private * priv);
+
+#endif /* _WLAN_11D_ */
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_cmd.c b/drivers/net/wireless/8686_wlan/wlan/wlan_cmd.c
new file mode 100644
index 0000000..ad7961b
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_cmd.c
@@ -0,0 +1,2480 @@
+/** @file wlan_cmd.c
+  *  
+  * @brief This file contains the handling of command.
+  * it prepares command and sends it to firmware when
+  * it is ready.
+  * 
+  * (c) Copyright © 2003-2007, Marvell International Ltd.  
+  *
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+    10/04/05: Add Doxygen format comments
+    01/05/06: Add kernel 2.6.x support  
+    01/11/06: Conditionalize new scan/join structures
+    01/31/06: Add support to selectively enabe the FW Scan channel filter
+    02/16/06: Clear scan in progress flag when scan command failed and dropped
+    04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+    04/18/06: Remove old Subscrive Event and add new Subscribe Event
+              implementation through generic hostcmd API
+    05/04/06: Add IBSS coalescing related new hostcmd handling	      
+********************************************************/
+
+#include	"include.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+static u16 Commands_Allowed_In_PS[] = {
+    HostCmd_CMD_802_11_RSSI,
+    HostCmd_CMD_802_11_HOST_SLEEP_CFG,
+    HostCmd_CMD_802_11_HOST_SLEEP_AWAKE_CONFIRM,
+};
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function checks if the commans is allowed
+ *  in PS mode not.
+ *  
+ *  @param Command the command ID
+ *  @return 	   TRUE or FALSE
+ */
+static BOOLEAN
+Is_Command_Allowed_In_PS(u16 Command)
+{
+    int count = sizeof(Commands_Allowed_In_PS)
+        / sizeof(Commands_Allowed_In_PS[0]);
+    int i;
+
+    for (i = 0; i < count; i++) {
+        if (Command == wlan_cpu_to_le16(Commands_Allowed_In_PS[i]))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+/** 
+ *  @brief This function prepares command of get_hw_spec.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param cmd	   A pointer to HostCmd_DS_COMMAND structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_hw_spec(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    HostCmd_DS_GET_HW_SPEC *hwspec = &cmd->params.hwspec;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_GET_HW_SPEC);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_GET_HW_SPEC) + S_DS_GEN);
+    memcpy(hwspec->PermanentAddr, priv->adapter->CurrentAddr, ETH_ALEN);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of ps_mode.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 	the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_ps_mode(wlan_private * priv,
+                        HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    HostCmd_DS_802_11_PS_MODE *psm = &cmd->params.psmode;
+    u16 Action = cmd_action;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_PS_MODE);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_PS_MODE) + S_DS_GEN);
+    psm->Action = wlan_cpu_to_le16(cmd_action);
+    psm->MultipleDtim = 0;
+    switch (Action) {
+    case HostCmd_SubCmd_Enter_PS:
+        PRINTM(INFO, "PS Command:" "SubCode- Enter PS\n");
+        PRINTM(INFO, "LocalListenInterval = %d\n",
+               Adapter->LocalListenInterval);
+
+        psm->LocalListenInterval =
+            wlan_cpu_to_le16(Adapter->LocalListenInterval);
+        psm->NullPktInterval = wlan_cpu_to_le16(Adapter->NullPktInterval);
+        psm->MultipleDtim = wlan_cpu_to_le16(priv->adapter->MultipleDtim);
+        if (priv->adapter->InfrastructureMode == Wlan802_11IBSS)
+            psm->AdhocAwakePeriod =
+                wlan_cpu_to_le16(priv->adapter->AdhocAwakePeriod);
+        break;
+
+    case HostCmd_SubCmd_Exit_PS:
+        PRINTM(INFO, "PS Command:" "SubCode- Exit PS\n");
+        break;
+
+    case HostCmd_SubCmd_Sleep_Confirmed:
+        PRINTM(INFO, "PS Command: SubCode- sleep confirm\n");
+        break;
+
+    default:
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of fw_wakeup_method.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 	the action: GET or SET
+ *  @param pdata_buf 	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_fw_wakeup_method(wlan_private * priv,
+                                 HostCmd_DS_COMMAND * cmd,
+                                 int cmd_action, void *pdata_buf)
+{
+    HostCmd_DS_802_11_FW_WAKEUP_METHOD *fwwm = &cmd->params.fwwakeupmethod;
+    u16 action = (u16) cmd_action;
+    u16 method = *((u16 *) pdata_buf);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_FW_WAKEUP_METHOD);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_FW_WAKEUP_METHOD) +
+                         S_DS_GEN);
+    fwwm->Action = wlan_cpu_to_le16(action);
+    switch (action) {
+    case HostCmd_ACT_SET:
+        fwwm->Method = wlan_cpu_to_le16(method);
+        break;
+    case HostCmd_ACT_GET:
+    default:
+        fwwm->Method = 0;
+        break;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function sends the HS_Activated event to the application
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_host_sleep_activated_event(wlan_private * priv)
+{
+    ENTER();
+
+#if WIRELESS_EXT > 14
+    send_iwevcustom_event(priv, CUS_EVT_HWM_CFG_DONE);
+#endif /* WIRELESS_EXT */
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of host_sleep_cfg.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf 	A pointer to HostCmd_DS_802_11_HOST_SLEEP_CFG structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_host_sleep_cfg(wlan_private * priv,
+                               HostCmd_DS_COMMAND * cmd,
+                               HostCmd_DS_802_11_HOST_SLEEP_CFG * pdata_buf)
+{
+    HostCmd_DS_802_11_HOST_SLEEP_CFG *phwuc = &cmd->params.hostsleepcfg;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_HOST_SLEEP_CFG);
+    if ((pdata_buf->conditions != HOST_SLEEP_CFG_CANCEL)
+        && (priv->adapter->ArpFilterSize > 0)) {
+        PRINTM(INFO, "Attach %d bytes ArpFilter to HSCfg cmd\n",
+               priv->adapter->ArpFilterSize);
+        memcpy(((u8 *) phwuc) + sizeof(HostCmd_DS_802_11_HOST_SLEEP_CFG),
+               priv->adapter->ArpFilter, priv->adapter->ArpFilterSize);
+        cmd->Size =
+            wlan_cpu_to_le16(priv->adapter->ArpFilterSize +
+                             sizeof(HostCmd_DS_802_11_HOST_SLEEP_CFG) +
+                             S_DS_GEN);
+    } else
+        cmd->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_HOST_SLEEP_CFG) +
+                             S_DS_GEN);
+    phwuc->conditions = wlan_cpu_to_le32(pdata_buf->conditions);
+    phwuc->gpio = pdata_buf->gpio;
+    phwuc->gap = pdata_buf->gap;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of inactivity_timeout.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   Action: GET SET
+ *  @param pdata_buf 	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_inactivity_timeout(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * cmd,
+                                   u16 cmd_action, void *pdata_buf)
+{
+    u16 *timeout = (u16 *) pdata_buf;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_INACTIVITY_TIMEOUT);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_INACTIVITY_TIMEOUT) +
+                         S_DS_GEN);
+
+    cmd->params.inactivity_timeout.Action = wlan_cpu_to_le16(cmd_action);
+
+    if (cmd_action)
+        cmd->params.inactivity_timeout.Timeout = wlan_cpu_to_le16(*timeout);
+    else
+        cmd->params.inactivity_timeout.Timeout = 0;
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of sleep_period.
+ *  
+ *  @param priv    		A pointer to wlan_private structure
+ *  @param cmd	   		A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 		the action: GET or SET
+ *  @param pdata_buf		A pointer to data buffer
+ *  @return 	   		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_sleep_period(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd,
+                             u16 cmd_action, void *pdata_buf)
+{
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SLEEP_PERIOD);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_SLEEP_PERIOD) +
+                                 S_DS_GEN);
+    memmove(&cmd->params.ps_sleeppd, pdata_buf,
+            sizeof(HostCmd_DS_802_11_SLEEP_PERIOD));
+    cmd->params.ps_sleeppd.Period =
+        wlan_cpu_to_le16(cmd->params.ps_sleeppd.Period);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of sleep_params.
+ *  
+ *  @param priv    		A pointer to wlan_private structure
+ *  @param cmd	   		A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 		the action: GET or SET
+ *  @return 	   		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_sleep_params(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_SLEEP_PARAMS *sp = &cmd->params.sleep_params;
+
+    ENTER();
+
+    cmd->Size = wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_SLEEP_PARAMS)) +
+                                 S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SLEEP_PARAMS);
+
+    if (cmd_action == HostCmd_ACT_GEN_GET) {
+        memset(&Adapter->sp, 0, sizeof(SleepParams));
+        memset(sp, 0, sizeof(HostCmd_DS_802_11_SLEEP_PARAMS));
+        sp->Action = wlan_cpu_to_le16(cmd_action);
+    } else if (cmd_action == HostCmd_ACT_GEN_SET) {
+        sp->Action = wlan_cpu_to_le16(cmd_action);
+        sp->Error = wlan_cpu_to_le16(Adapter->sp.sp_error);
+        sp->Offset = wlan_cpu_to_le16(Adapter->sp.sp_offset);
+        sp->StableTime = wlan_cpu_to_le16(Adapter->sp.sp_stabletime);
+        sp->CalControl = (u8) Adapter->sp.sp_calcontrol;
+        sp->ExternalSleepClk = (u8) Adapter->sp.sp_extsleepclk;
+        sp->Reserved = wlan_cpu_to_le16(Adapter->sp.sp_reserved);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+#define WEP_40_BIT_LEN	5
+#define WEP_104_BIT_LEN	13
+
+/** 
+ *  @brief This function prepares command of set_wep.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_oid   OID: ADD_WEP KEY or REMOVE_WEP KEY
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_set_wep(wlan_private * priv,
+                        HostCmd_DS_COMMAND * cmd, u32 cmd_oid)
+{
+    HostCmd_DS_802_11_SET_WEP *wep = &cmd->params.wep;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (cmd_oid == OID_802_11_ADD_WEP) {
+        cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SET_WEP);
+        cmd->Size =
+            wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_SET_WEP)) + S_DS_GEN);
+        wep->Action = wlan_cpu_to_le16(HostCmd_ACT_ADD);
+
+        /* default tx key index */
+        wep->KeyIndex = wlan_cpu_to_le16(Adapter->CurrentWepKeyIndex &
+                                         HostCmd_WEP_KEY_INDEX_MASK);
+
+        PRINTM(INFO, "Tx Key Index: %u\n", wep->KeyIndex);
+
+        switch (Adapter->WepKey[0].KeyLength) {
+        case WEP_40_BIT_LEN:
+            wep->WEPTypeForKey1 = HostCmd_TYPE_WEP_40_BIT;
+            memmove(wep->WEP1, Adapter->WepKey[0].KeyMaterial,
+                    Adapter->WepKey[0].KeyLength);
+            break;
+        case WEP_104_BIT_LEN:
+            wep->WEPTypeForKey1 = HostCmd_TYPE_WEP_104_BIT;
+            memmove(wep->WEP1, Adapter->WepKey[0].KeyMaterial,
+                    Adapter->WepKey[0].KeyLength);
+            break;
+        case 0:
+            break;
+        default:
+            PRINTM(INFO, "Key1 Length = %d is incorrect\n",
+                   Adapter->WepKey[0].KeyLength);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        switch (Adapter->WepKey[1].KeyLength) {
+        case WEP_40_BIT_LEN:
+            wep->WEPTypeForKey2 = HostCmd_TYPE_WEP_40_BIT;
+            memmove(wep->WEP2, Adapter->WepKey[1].KeyMaterial,
+                    Adapter->WepKey[1].KeyLength);
+            break;
+        case WEP_104_BIT_LEN:
+            wep->WEPTypeForKey2 = HostCmd_TYPE_WEP_104_BIT;
+            memmove(wep->WEP2, Adapter->WepKey[1].KeyMaterial,
+                    Adapter->WepKey[1].KeyLength);
+            break;
+        case 0:
+            break;
+        default:
+            PRINTM(INFO, "Key2 Length = %d is incorrect\n",
+                   Adapter->WepKey[1].KeyLength);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        switch (Adapter->WepKey[2].KeyLength) {
+        case WEP_40_BIT_LEN:
+            wep->WEPTypeForKey3 = HostCmd_TYPE_WEP_40_BIT;
+            memmove(wep->WEP3, Adapter->WepKey[2].KeyMaterial,
+                    Adapter->WepKey[2].KeyLength);
+            break;
+        case WEP_104_BIT_LEN:
+            wep->WEPTypeForKey3 = HostCmd_TYPE_WEP_104_BIT;
+            memmove(wep->WEP3, Adapter->WepKey[2].KeyMaterial,
+                    Adapter->WepKey[2].KeyLength);
+            break;
+        case 0:
+            break;
+        default:
+            PRINTM(INFO, "Key3 Length = %d is incorrect\n",
+                   Adapter->WepKey[2].KeyLength);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        switch (Adapter->WepKey[3].KeyLength) {
+        case WEP_40_BIT_LEN:
+            wep->WEPTypeForKey4 = HostCmd_TYPE_WEP_40_BIT;
+            memmove(wep->WEP4, Adapter->WepKey[3].KeyMaterial,
+                    Adapter->WepKey[3].KeyLength);
+            break;
+        case WEP_104_BIT_LEN:
+            wep->WEPTypeForKey4 = HostCmd_TYPE_WEP_104_BIT;
+            memmove(wep->WEP4, Adapter->WepKey[3].KeyMaterial,
+                    Adapter->WepKey[3].KeyLength);
+            break;
+        case 0:
+            break;
+        default:
+            PRINTM(INFO, "Key4 Length = %d is incorrect\n",
+                   Adapter->WepKey[3].KeyLength);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+    } else if (cmd_oid == OID_802_11_REMOVE_WEP) {
+        cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SET_WEP);
+        cmd->Size =
+            wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_SET_WEP)) + S_DS_GEN);
+        wep->Action = wlan_cpu_to_le16(HostCmd_ACT_REMOVE);
+
+        /* default tx key index */
+        wep->KeyIndex = wlan_cpu_to_le16((u16) (Adapter->CurrentWepKeyIndex &
+                                                (u32)
+                                                HostCmd_WEP_KEY_INDEX_MASK));
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function prepares command of enable_rsn.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 	the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_enable_rsn(wlan_private * priv,
+                           HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    HostCmd_DS_802_11_ENABLE_RSN *pEnableRSN = &cmd->params.enbrsn;
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_ENABLE_RSN);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_ENABLE_RSN) + S_DS_GEN);
+    pEnableRSN->Action = wlan_cpu_to_le16(cmd_action);
+    if (Adapter->SecInfo.WPAEnabled || Adapter->SecInfo.WPA2Enabled) {
+        pEnableRSN->Enable = wlan_cpu_to_le16(HostCmd_ENABLE_RSN);
+    } else {
+        pEnableRSN->Enable = wlan_cpu_to_le16(HostCmd_DISABLE_RSN);
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of key_material.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 	the action: GET or SET
+ *  @param cmd_oid	OID: ENABLE or DISABLE
+ *  @param pdata_buf    A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_key_material(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd,
+                             u16 cmd_action,
+                             WLAN_OID cmd_oid, void *pdata_buf)
+{
+    HostCmd_DS_802_11_KEY_MATERIAL *pKeyMaterial = &cmd->params.keymaterial;
+    PWLAN_802_11_KEY pKey = (PWLAN_802_11_KEY) pdata_buf;
+    u16 KeyParamSet_len;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_KEY_MATERIAL);
+    pKeyMaterial->Action = wlan_cpu_to_le16(cmd_action);
+
+    if (cmd_action == HostCmd_ACT_GET) {
+        cmd->Size = wlan_cpu_to_le16(2 + S_DS_GEN);
+        ret = WLAN_STATUS_SUCCESS;
+        goto done;
+    }
+
+    memset(&pKeyMaterial->KeyParamSet, 0, sizeof(MrvlIEtype_KeyParamSet_t));
+
+    if (pKey->KeyLength == WPA_AES_KEY_LEN) {
+        PRINTM(INFO, "WPA_AES\n");
+        pKeyMaterial->KeyParamSet.KeyTypeId =
+            wlan_cpu_to_le16(KEY_TYPE_ID_AES);
+
+        if (cmd_oid == (WLAN_OID) KEY_INFO_ENABLED)
+            pKeyMaterial->KeyParamSet.KeyInfo =
+                wlan_cpu_to_le16(KEY_INFO_AES_ENABLED);
+        else
+            pKeyMaterial->KeyParamSet.KeyInfo =
+                !(wlan_cpu_to_le16(KEY_INFO_AES_ENABLED));
+
+        if (pKey->KeyIndex & 0x40000000)        //AES pairwise key: unicast
+            pKeyMaterial->KeyParamSet.KeyInfo |=
+                wlan_cpu_to_le16(KEY_INFO_AES_UNICAST);
+        else                    //AES group key: multicast
+            pKeyMaterial->KeyParamSet.KeyInfo |=
+                wlan_cpu_to_le16(KEY_INFO_AES_MCAST);
+    } else if (pKey->KeyLength == WPA_TKIP_KEY_LEN) {
+        PRINTM(INFO, "WPA_TKIP\n");
+        pKeyMaterial->KeyParamSet.KeyTypeId =
+            wlan_cpu_to_le16(KEY_TYPE_ID_TKIP);
+        pKeyMaterial->KeyParamSet.KeyInfo =
+            wlan_cpu_to_le16(KEY_INFO_TKIP_ENABLED);
+
+        if (pKey->KeyIndex & 0x40000000)        //TKIP pairwise key: unicast
+            pKeyMaterial->KeyParamSet.KeyInfo |=
+                wlan_cpu_to_le16(KEY_INFO_TKIP_UNICAST);
+        else                    //TKIP group key: multicast
+            pKeyMaterial->KeyParamSet.KeyInfo |=
+                wlan_cpu_to_le16(KEY_INFO_TKIP_MCAST);
+    }
+
+    if (pKeyMaterial->KeyParamSet.KeyTypeId) {
+        pKeyMaterial->KeyParamSet.Type =
+            wlan_cpu_to_le16(TLV_TYPE_KEY_MATERIAL);
+        pKeyMaterial->KeyParamSet.KeyLen = wlan_cpu_to_le16(pKey->KeyLength);
+        memcpy(pKeyMaterial->KeyParamSet.Key,
+               pKey->KeyMaterial, pKey->KeyLength);
+        pKeyMaterial->KeyParamSet.Length =
+            wlan_cpu_to_le16(pKey->KeyLength + 6);
+
+#define TYPE_LEN_FIELDS_LEN 4
+        KeyParamSet_len = (pKey->KeyLength + 6) + TYPE_LEN_FIELDS_LEN;
+#define ACTION_FIELD_LEN 2
+        cmd->Size =
+            wlan_cpu_to_le16(KeyParamSet_len + ACTION_FIELD_LEN + S_DS_GEN);
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function prepares command of get_log.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_get_log(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_GET_LOG);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_GET_LOG) + S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of get_stat.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_get_stat(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_GET_STAT);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_GET_STAT) + S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of snmp_mib.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param cmd_oid   	the OID of SNMP MIB
+ *  @param pdata_buf	the pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_snmp_mib(wlan_private * priv,
+                         HostCmd_DS_COMMAND * cmd,
+                         int cmd_action, int cmd_oid, void *pdata_buf)
+{
+    HostCmd_DS_802_11_SNMP_MIB *pSNMPMIB = &cmd->params.smib;
+    wlan_adapter *Adapter = priv->adapter;
+    u8 ucTemp;
+
+    ENTER();
+
+    PRINTM(INFO, "SNMP_CMD: cmd_oid = 0x%x\n", cmd_oid);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SNMP_MIB);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_SNMP_MIB) + S_DS_GEN);
+
+    switch (cmd_oid) {
+    case OID_802_11_INFRASTRUCTURE_MODE:
+        pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+        pSNMPMIB->OID = wlan_cpu_to_le16((u16) DesiredBssType_i);
+        pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u8));
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure)
+            ucTemp = SNMP_MIB_VALUE_INFRA;
+        else
+            ucTemp = SNMP_MIB_VALUE_ADHOC;
+
+        memmove(pSNMPMIB->Value, &ucTemp, sizeof(u8));
+
+        break;
+
+    case OID_802_11D_ENABLE:
+        {
+            u32 ulTemp;
+
+            pSNMPMIB->OID = wlan_cpu_to_le16((u16) Dot11D_i);
+
+            if (cmd_action == HostCmd_ACT_SET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+                pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+                ulTemp = *(u32 *) pdata_buf;
+                *((PUSHORT) (pSNMPMIB->Value)) =
+                    wlan_cpu_to_le16((u16) ulTemp);
+            }
+            break;
+        }
+
+    case OID_802_11_FRAGMENTATION_THRESHOLD:
+        {
+            WLAN_802_11_FRAGMENTATION_THRESHOLD ulTemp;
+
+            pSNMPMIB->OID = wlan_cpu_to_le16((u16) FragThresh_i);
+
+            if (cmd_action == HostCmd_ACT_GET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+            } else if (cmd_action == HostCmd_ACT_SET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+                pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+                ulTemp = *((WLAN_802_11_FRAGMENTATION_THRESHOLD *)
+                           pdata_buf);
+                *((PUSHORT) (pSNMPMIB->Value)) =
+                    wlan_cpu_to_le16((u16) ulTemp);
+
+            }
+
+            break;
+        }
+
+    case OID_802_11_RTS_THRESHOLD:
+        {
+
+            WLAN_802_11_RTS_THRESHOLD ulTemp;
+            pSNMPMIB->OID = wlan_le16_to_cpu((u16) RtsThresh_i);
+
+            if (cmd_action == HostCmd_ACT_GET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+            } else if (cmd_action == HostCmd_ACT_SET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+                pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+                ulTemp = *((WLAN_802_11_RTS_THRESHOLD *)
+                           pdata_buf);
+                *(PUSHORT) (pSNMPMIB->Value) = wlan_cpu_to_le16((u16) ulTemp);
+
+            }
+            break;
+        }
+    case OID_802_11_TX_RETRYCOUNT:
+        pSNMPMIB->OID = wlan_cpu_to_le16((u16) ShortRetryLim_i);
+
+        if (cmd_action == HostCmd_ACT_GET) {
+            pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+        } else if (cmd_action == HostCmd_ACT_SET) {
+            pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+            pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+            *((PUSHORT) (pSNMPMIB->Value)) =
+                wlan_cpu_to_le16((u16) Adapter->TxRetryCount);
+        }
+
+        break;
+    default:
+        break;
+    }
+
+    PRINTM(INFO,
+           "SNMP_CMD: Command=0x%x, Size=0x%x, SeqNum=0x%x, Result=0x%x\n",
+           cmd->Command, cmd->Size, cmd->SeqNum, cmd->Result);
+
+    PRINTM(INFO,
+           "SNMP_CMD: Action=0x%x, OID=0x%x, OIDSize=0x%x, Value=0x%x\n",
+           pSNMPMIB->QueryType, pSNMPMIB->OID, pSNMPMIB->BufSize,
+           *(u16 *) pSNMPMIB->Value);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of radio_control.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_radio_control(wlan_private * priv,
+                              HostCmd_DS_COMMAND * cmd, int cmd_action)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_RADIO_CONTROL *pRadioControl = &cmd->params.radio;
+
+    ENTER();
+
+    cmd->Size =
+        wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_RADIO_CONTROL)) +
+                         S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RADIO_CONTROL);
+
+    pRadioControl->Action = wlan_cpu_to_le16(cmd_action);
+
+    switch (Adapter->Preamble) {
+    case HostCmd_TYPE_SHORT_PREAMBLE:
+        pRadioControl->Control = wlan_cpu_to_le16(SET_SHORT_PREAMBLE);
+        break;
+
+    case HostCmd_TYPE_LONG_PREAMBLE:
+        pRadioControl->Control = wlan_cpu_to_le16(SET_LONG_PREAMBLE);
+        break;
+
+    case HostCmd_TYPE_AUTO_PREAMBLE:
+    default:
+        pRadioControl->Control = wlan_cpu_to_le16(SET_AUTO_PREAMBLE);
+        break;
+    }
+
+    if (Adapter->RadioOn)
+        pRadioControl->Control |= wlan_cpu_to_le16(TURN_ON_RF);
+    else
+        pRadioControl->Control &= wlan_cpu_to_le16(~TURN_ON_RF);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of bca_timeshare.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param user_bca_ts	A pointer to HostCmd_DS_802_11_BCA_TIMESHARE structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_bca_timeshare(wlan_private * priv,
+                              HostCmd_DS_COMMAND * cmd,
+                              u16 cmd_action,
+                              HostCmd_DS_802_11_BCA_TIMESHARE * user_bca_ts)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_BCA_TIMESHARE *bca_ts = &cmd->params.bca_timeshare;
+
+    ENTER();
+
+    cmd->Size = wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_BCA_TIMESHARE)) +
+                                 S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE);
+
+    if (cmd_action == HostCmd_ACT_GEN_GET) {
+        memset(&Adapter->bca_ts, 0, sizeof(bca_ts));
+        memset(bca_ts, 0, sizeof(HostCmd_DS_802_11_BCA_TIMESHARE));
+        bca_ts->Action = wlan_cpu_to_le16(cmd_action);
+        bca_ts->TrafficType = wlan_cpu_to_le16(user_bca_ts->TrafficType);
+    } else if (cmd_action == HostCmd_ACT_GEN_SET) {
+        bca_ts->Action = wlan_cpu_to_le16(cmd_action);
+        bca_ts->TrafficType = wlan_cpu_to_le16(user_bca_ts->TrafficType);
+        bca_ts->TimeShareInterval =
+            wlan_cpu_to_le32(user_bca_ts->TimeShareInterval);
+        bca_ts->BTTime = wlan_cpu_to_le32(user_bca_ts->BTTime);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rf_tx_power.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rf_tx_power(wlan_private * priv,
+                            HostCmd_DS_COMMAND * cmd,
+                            u16 cmd_action, void *pdata_buf)
+{
+
+    HostCmd_DS_802_11_RF_TX_POWER *pRTP = &cmd->params.txp;
+
+    ENTER();
+
+    cmd->Size =
+        wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_RF_TX_POWER)) + S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RF_TX_POWER);
+    pRTP->Action = cmd_action;
+
+    PRINTM(INFO, "RF_TX_POWER_CMD: Size:%d Cmd:0x%x Act:%d\n", cmd->Size,
+           cmd->Command, pRTP->Action);
+
+    switch (cmd_action) {
+    case HostCmd_ACT_GEN_GET:
+        pRTP->Action = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+        pRTP->CurrentLevel = 0;
+        break;
+
+    case HostCmd_ACT_GEN_SET:
+        pRTP->Action = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+        pRTP->CurrentLevel = wlan_cpu_to_le16(*((u16 *) pdata_buf));
+        break;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rf_antenna.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rf_antenna(wlan_private * priv,
+                           HostCmd_DS_COMMAND * cmd,
+                           u16 cmd_action, void *pdata_buf)
+{
+    HostCmd_DS_802_11_RF_ANTENNA *rant = &cmd->params.rant;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RF_ANTENNA);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_RF_ANTENNA) + S_DS_GEN);
+
+    rant->Action = wlan_cpu_to_le16(cmd_action);
+    if ((cmd_action == HostCmd_ACT_SET_RX) ||
+        (cmd_action == HostCmd_ACT_SET_TX)) {
+        rant->AntennaMode =
+            wlan_cpu_to_le16((u16) (*(WLAN_802_11_ANTENNA *) pdata_buf));
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rate_adapt_rateset.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rate_adapt_rateset(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    HostCmd_DS_802_11_RATE_ADAPT_RATESET * rateadapt = &cmd->params.rateset;
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_RATE_ADAPT_RATESET) +
+                         S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RATE_ADAPT_RATESET);
+
+    ENTER();
+
+    rateadapt->Action = wlan_cpu_to_le16(cmd_action);
+    rateadapt->HWRateDropMode = wlan_cpu_to_le16(Adapter->HWRateDropMode);
+    rateadapt->Threshold = wlan_cpu_to_le16(Adapter->Threshold);
+    rateadapt->FinalRate = wlan_cpu_to_le16(Adapter->FinalRate);
+    rateadapt->Bitmap = wlan_cpu_to_le16(Adapter->RateBitmap);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of mac_multicast_adr.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_mac_multicast_adr(wlan_private * priv,
+                           HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    HostCmd_DS_MAC_MULTICAST_ADR *pMCastAdr = &cmd->params.madr;
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_MAC_MULTICAST_ADR) + S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_MAC_MULTICAST_ADR);
+
+    pMCastAdr->Action = wlan_cpu_to_le16(cmd_action);
+    pMCastAdr->NumOfAdrs =
+        wlan_cpu_to_le16((u16) Adapter->NumOfMulticastMACAddr);
+    memcpy(pMCastAdr->MACList, Adapter->MulticastList,
+           Adapter->NumOfMulticastMACAddr * ETH_ALEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rf_channel.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rf_channel(wlan_private * priv,
+                           HostCmd_DS_COMMAND * cmd,
+                           int option, void *pdata_buf)
+{
+    HostCmd_DS_802_11_RF_CHANNEL *rfchan = &cmd->params.rfchannel;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RF_CHANNEL);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_RF_CHANNEL)
+                                 + S_DS_GEN);
+
+    if (option == HostCmd_OPT_802_11_RF_CHANNEL_SET) {
+        rfchan->CurrentChannel = wlan_cpu_to_le16(*((u16 *) pdata_buf));
+    }
+
+    rfchan->Action = wlan_cpu_to_le16(option);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rssi.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rssi(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RSSI);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_RSSI) + S_DS_GEN);
+    cmd->params.rssi.N = wlan_cpu_to_le16(Adapter->bcn_avg_factor);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of reg_access.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_reg_access(wlan_private * priv,
+                    HostCmd_DS_COMMAND * CmdPtr,
+                    u8 cmd_action, void *pdata_buf)
+{
+    wlan_offset_value *offval;
+
+    ENTER();
+
+    offval = (wlan_offset_value *) pdata_buf;
+
+    switch (CmdPtr->Command) {
+    case HostCmd_CMD_MAC_REG_ACCESS:
+        {
+            HostCmd_DS_MAC_REG_ACCESS *macreg;
+
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_MAC_REG_ACCESS) +
+                                 S_DS_GEN);
+            macreg = (PHostCmd_DS_MAC_REG_ACCESS) & CmdPtr->params.macreg;
+
+            macreg->Action = wlan_cpu_to_le16(cmd_action);
+            macreg->Offset = wlan_cpu_to_le16((u16) offval->offset);
+            macreg->Value = wlan_cpu_to_le32(offval->value);
+
+            break;
+        }
+
+    case HostCmd_CMD_BBP_REG_ACCESS:
+        {
+            HostCmd_DS_BBP_REG_ACCESS *bbpreg;
+
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_BBP_REG_ACCESS) +
+                                 S_DS_GEN);
+            bbpreg = (PHostCmd_DS_BBP_REG_ACCESS) & CmdPtr->params.bbpreg;
+
+            bbpreg->Action = wlan_cpu_to_le16(cmd_action);
+            bbpreg->Offset = wlan_cpu_to_le16((u16) offval->offset);
+            bbpreg->Value = (u8) offval->value;
+
+            break;
+        }
+
+    case HostCmd_CMD_RF_REG_ACCESS:
+        {
+            HostCmd_DS_RF_REG_ACCESS *rfreg;
+
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_RF_REG_ACCESS) + S_DS_GEN);
+            rfreg = (PHostCmd_DS_RF_REG_ACCESS) & CmdPtr->params.rfreg;
+
+            rfreg->Action = wlan_cpu_to_le16(cmd_action);
+            rfreg->Offset = wlan_cpu_to_le16((u16) offval->offset);
+            rfreg->Value = (u8) offval->value;
+
+            break;
+        }
+
+    default:
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of mac_address.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_mac_address(wlan_private * priv,
+                            HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_MAC_ADDRESS);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_MAC_ADDRESS) +
+                                 S_DS_GEN);
+    cmd->Result = 0;
+
+    cmd->params.macadd.Action = wlan_cpu_to_le16(cmd_action);
+
+    if (cmd_action == HostCmd_ACT_SET) {
+        memcpy(cmd->params.macadd.MacAdd, Adapter->CurrentAddr, ETH_ALEN);
+        HEXDUMP("SET_CMD: MAC ADDRESS-", Adapter->CurrentAddr, 6);
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of cal_data_ext.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_cal_data_ext(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    HostCmd_DS_802_11_CAL_DATA_EXT *PCalDataext = pdata_buf;
+
+    pHostCmd_DS_802_11_CAL_DATA_EXT pCmdCalData =
+        (pHostCmd_DS_802_11_CAL_DATA_EXT) & cmd->params.caldataext;
+
+    ENTER();
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_CAL_DATA_EXT);
+
+    PRINTM(INFO, "CalDataLen = %d(d)\n", PCalDataext->CalDataLen);
+
+#define MAX_ALLOWED_LEN	1024
+    if (PCalDataext->CalDataLen > MAX_ALLOWED_LEN) {
+        PRINTM(MSG, "CAL_DATA_EXT: Cal data lenght too large!\n");
+        return WLAN_STATUS_FAILURE;
+    }
+#define ACTION_REV_CALDATA_LEN_FIELDS_LEN 6
+    memcpy(pCmdCalData, PCalDataext,
+           PCalDataext->CalDataLen + ACTION_REV_CALDATA_LEN_FIELDS_LEN);
+
+    pCmdCalData->Action = wlan_cpu_to_le16(pCmdCalData->Action);
+    pCmdCalData->Revision = wlan_cpu_to_le16(pCmdCalData->Revision);
+    pCmdCalData->CalDataLen = wlan_cpu_to_le16(pCmdCalData->CalDataLen);
+
+    cmd->Size = wlan_cpu_to_le16(PCalDataext->CalDataLen +
+                                 ACTION_REV_CALDATA_LEN_FIELDS_LEN +
+                                 S_DS_GEN);
+
+    PRINTM(INFO, "CAL_DATA_EXT: cmd->Size = %d(d)\n", cmd->Size);
+
+    cmd->Result = 0;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of eeprom_access.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_eeprom_access(wlan_private * priv,
+                              HostCmd_DS_COMMAND * cmd,
+                              int cmd_action, void *pdata_buf)
+{
+    wlan_ioctl_regrdwr *ea = pdata_buf;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_EEPROM_ACCESS);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_EEPROM_ACCESS) + S_DS_GEN);
+    cmd->Result = 0;
+
+    cmd->params.rdeeprom.Action = wlan_cpu_to_le16(ea->Action);
+    cmd->params.rdeeprom.Offset = wlan_cpu_to_le16(ea->Offset);
+    cmd->params.rdeeprom.ByteCount = wlan_cpu_to_le16(ea->NOB);
+    cmd->params.rdeeprom.Value = 0;
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+static int
+wlan_cmd_802_11_IBSS_Coalesced_Status(wlan_private * priv,
+                                      HostCmd_DS_COMMAND * cmd,
+                                      int cmd_action, void *pdata_buf)
+{
+    HostCmd_DS_802_11_IBSS_Status *pIBSSReq = &(cmd->params.ibssCoalescing);
+    u16 *enable = pdata_buf;
+
+    PRINTM(INFO, "HostCmd_CMD_802_11_BSSID_QUERY request");
+
+    cmd->Command =
+        wlan_cpu_to_le16(HostCmd_CMD_802_11_IBSS_COALESCING_STATUS);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_IBSS_Status) + S_DS_GEN);
+    cmd->Result = 0;
+    pIBSSReq->Action = wlan_cpu_to_le16(cmd_action);
+
+    switch (cmd_action) {
+    case HostCmd_ACT_SET:
+        pIBSSReq->Enable = wlan_cpu_to_le16(*enable);
+        break;
+
+        /* In other case.. Noting to do */
+    case HostCmd_ACT_GET:
+    default:
+        break;
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function queues the command to cmd list.
+ *  
+ *  @param Adapter	A pointer to wlan_adapter structure
+ *  @param CmdNode   	A pointer to CmdCtrlNode structure
+ *  @param addtail	specify if the cmd needs to be queued in the header or tail
+ *  @return 	   	n/a
+ */
+void
+QueueCmd(wlan_adapter * Adapter, CmdCtrlNode * CmdNode, BOOLEAN addtail)
+{
+    ulong flags;
+    HostCmd_DS_COMMAND *CmdPtr;
+    u16 command;
+
+    ENTER();
+
+    if (!CmdNode) {
+        PRINTM(WARN, "QUEUE_CMD: CmdNode is NULL\n");
+        goto done;
+    }
+
+    CmdPtr = (HostCmd_DS_COMMAND *) CmdNode->BufVirtualAddr;
+    if (!CmdPtr) {
+        PRINTM(WARN, "QUEUE_CMD: CmdPtr is NULL\n");
+        goto done;
+    }
+
+    command = wlan_le16_to_cpu(CmdPtr->Command);
+
+    /* Exit_PS command needs to be queued in the header always. */
+    if (command == HostCmd_CMD_802_11_PS_MODE) {
+        HostCmd_DS_802_11_PS_MODE *psm = &CmdPtr->params.psmode;
+        if (wlan_le16_to_cpu(psm->Action) == HostCmd_SubCmd_Exit_PS) {
+            if (Adapter->PSState != PS_STATE_FULL_POWER)
+                addtail = FALSE;
+        }
+    }
+
+    if ((command == HostCmd_CMD_802_11_HOST_SLEEP_AWAKE_CONFIRM)
+        ) {
+        addtail = FALSE;
+    }
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+
+    if (addtail)
+        list_add_tail((struct list_head *) CmdNode, &Adapter->CmdPendingQ);
+    else
+        list_add((struct list_head *) CmdNode, &Adapter->CmdPendingQ);
+
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+    PRINTM(INFO, "QUEUE_CMD: cmd=0x%x is queued\n", command);
+
+  done:
+    LEAVE();
+    return;
+}
+
+#ifdef MFG_CMD_SUPPORT
+/** 
+ *  @brief This function sends general command to firmware.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param CmdNode   	A pointer to CmdCtrlNode structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+SendMfgCommand(wlan_private * priv, CmdCtrlNode * cmdnode)
+{
+    HostCmd_DS_GEN *pCmdPtr;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    pCmdPtr = (PHostCmd_DS_GEN) Adapter->mfg_cmd;
+
+    pCmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_MFG_COMMAND);
+
+    SetCmdCtrlNode(priv, cmdnode, OID_MRVL_MFG_COMMAND,
+                   HostCmd_OPTION_WAITFORRSP, pCmdPtr);
+
+    /* Assign new sequence number */
+    pCmdPtr->SeqNum = wlan_cpu_to_le16(priv->adapter->SeqNum);
+
+    PRINTM(INFO, "Sizeof CmdPtr->size %d\n", (u32) pCmdPtr->Size);
+
+    /* copy the command from information buffer to command queue */
+    memcpy((void *) cmdnode->BufVirtualAddr, (void *) pCmdPtr, pCmdPtr->Size);
+
+    Adapter->mfg_cmd_flag = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+#endif
+
+/** 
+ *  @brief This function downloads the command to firmware.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param CmdNode   	A pointer to CmdCtrlNode structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+DownloadCommandToStation(wlan_private * priv, CmdCtrlNode * CmdNode)
+{
+    ulong flags;
+    HostCmd_DS_COMMAND *CmdPtr;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 CmdSize;
+    u16 Command;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+    //umd_enter();
+
+    if (!Adapter || !CmdNode) {
+        umd_dbg("Error! DNLD_CMD: Adapter = %#x, CmdNode = %#x\n",
+               (int) Adapter, (int) CmdNode);
+        if (CmdNode)
+            CleanupAndInsertCmd(priv, CmdNode);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    CmdPtr = (HostCmd_DS_COMMAND *) CmdNode->BufVirtualAddr;
+
+    if (!CmdPtr || !CmdPtr->Size) {
+        PRINTM(ERROR, "DNLD_CMD: CmdPtr is Null or Cmd Size is Zero, "
+               "Not sending\n");
+        CleanupAndInsertCmd(priv, CmdNode);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+    Adapter->CurCmd = CmdNode;
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+    Adapter->CurCmdRetCode = 0;
+
+    CmdSize = CmdPtr->Size;
+
+    Command = wlan_cpu_to_le16(CmdPtr->Command);
+
+    CmdNode->CmdWaitQWoken = FALSE;
+    CmdSize = wlan_cpu_to_le16(CmdSize);
+
+    ret = sbi_host_to_card(priv, MVMS_CMD, (u8 *) CmdPtr, CmdSize);
+
+    /* clear TxDone interrupt bit */
+    OS_INT_DISABLE;
+    Adapter->HisRegCpy &= ~HIS_TxDnLdRdy;
+    OS_INT_RESTORE;
+
+    if (ret != 0) {
+        umd_dbg("Error! DNLD_CMD: Host to Card Failed\n");
+        /* set error code that will be transferred back to PrepareAndSendCommand() */
+        Adapter->CurCmdRetCode = WLAN_STATUS_FAILURE;
+        CleanupAndInsertCmd(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+        Adapter->dbg.num_cmd_host_to_card_failure++;
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    Adapter->dbg.LastCmdId = Command;
+
+    if (Command == HostCmd_CMD_802_11_PS_MODE) {
+        HostCmd_DS_802_11_PS_MODE *psmode = &CmdPtr->params.psmode;
+        PRINTM(CMND, "DNLD_CMD: 0x%x, act 0x%x, len %d, seqno %d @ %lu\n",
+               Command, wlan_cpu_to_le16(psmode->Action), CmdSize,
+               wlan_le16_to_cpu(CmdPtr->SeqNum), os_time_get());
+    } else {
+        PRINTM(CMND, "DNLD_CMD: 0x%x, len %d, seqno %d @ %lu\n",
+               Command, CmdSize, wlan_le16_to_cpu(CmdPtr->SeqNum),
+               os_time_get());
+    }
+    DBG_HEXDUMP(CMD_D, "DNLD_CMD", CmdNode->BufVirtualAddr, CmdSize);
+
+    /* Setup the timer after transmit command */
+    if (Command == HostCmd_CMD_802_11_SCAN
+        || Command == HostCmd_CMD_802_11_DEAUTHENTICATE
+        || Command == HostCmd_CMD_802_11_ASSOCIATE
+        || Command == HostCmd_CMD_WMM_ADDTS_REQ) {
+        ModTimer(&Adapter->MrvDrvCommandTimer, MRVDRV_TIMER_10S);
+    } else {
+        ModTimer(&Adapter->MrvDrvCommandTimer, MRVDRV_TIMER_5S);
+    }
+
+    Adapter->CommandTimerIsSet = TRUE;
+
+    if (Command == HostCmd_CMD_802_11_DEEP_SLEEP) {
+        if (Adapter->IntCounter || Adapter->CurrentTxSkb)
+            PRINTM(INFO, "DNLD_CMD: DS- IntCnt=%d CurTxSkb=%s\n",
+                   Adapter->IntCounter, (Adapter->CurrentTxSkb) ? "Y" : "N");
+
+        if (Adapter->IntCounter) {
+            OS_INT_DISABLE;
+            Adapter->IntCounterSaved = Adapter->IntCounter;
+            Adapter->IntCounter = 0;
+            OS_INT_RESTORE;
+        }
+        if (Adapter->CurrentTxSkb) {
+            kfree_skb(Adapter->CurrentTxSkb);
+            OS_INT_DISABLE;
+            Adapter->CurrentTxSkb = NULL;
+            OS_INT_RESTORE;
+            priv->stats.tx_dropped++;
+        }
+        /* 1. change the PS state to DEEP_SLEEP
+         * 2. since there is no response for this command, so 
+         *    delete the command timer and free the Node. */
+
+        Adapter->IsDeepSleep = TRUE;
+
+        CleanupAndInsertCmd(priv, CmdNode);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+        if (Adapter->CommandTimerIsSet) {
+            CancelTimer(&Adapter->MrvDrvCommandTimer);
+            Adapter->CommandTimerIsSet = FALSE;
+        }
+
+        /* stop clock to save more power */
+        sbi_set_bus_clock(priv, FALSE);
+
+        if (Adapter->bHostSleepConfigured) {
+            Adapter->bWakeupDevRequired = TRUE;
+            wlan_host_sleep_activated_event(priv);
+        }
+
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+
+  done:
+//	umd_exit();
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function prepares command of mac_control.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd		A pointer to HostCmd_DS_COMMAND structure
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_mac_control(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    HostCmd_DS_MAC_CONTROL *mac = &cmd->params.macctrl;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_MAC_CONTROL);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_MAC_CONTROL) + S_DS_GEN);
+    mac->Action = wlan_cpu_to_le16(priv->adapter->CurrentPacketFilter);
+
+    PRINTM(INFO, "wlan_cmd_mac_control(): Action=0x%X Size=%d\n",
+           mac->Action, cmd->Size);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function inserts command node to CmdFreeQ
+ *  after cleans it.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param pTempCmd	A pointer to CmdCtrlNode structure
+ *  @return 		n/a
+ */
+void
+CleanupAndInsertCmd(wlan_private * priv, CmdCtrlNode * pTempCmd)
+{
+    ulong flags;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!pTempCmd)
+        goto done;
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+    CleanUpCmdCtrlNode(pTempCmd);
+    list_add_tail((struct list_head *) pTempCmd, &Adapter->CmdFreeQ);
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+  done:
+    LEAVE();
+}
+
+/** 
+ *  @brief This function sets radio control.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+SetRadioControl(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_RADIO_CONTROL,
+                                HostCmd_ACT_GEN_SET,
+                                HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    PRINTM(INFO, "RADIO_SET: on or off: 0x%X, Preamble = 0x%X\n",
+           priv->adapter->RadioOn, priv->adapter->Preamble);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function sets packet filter.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+SetMacPacketFilter(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    PRINTM(INFO, "SetMacPacketFilter Value = %x\n",
+           priv->adapter->CurrentPacketFilter);
+
+    /* Send MAC control command to station */
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_MAC_CONTROL, 0, 0, 0, NULL);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function prepare the command before send to firmware.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd_no	command number
+ *  @param cmd_action	command action: GET or SET
+ *  @param wait_option	wait option: wait response or not
+ *  @param cmd_oid	cmd oid: treated as sub command
+ *  @param pdata_buf	A pointer to informaion buffer
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+PrepareAndSendCommand(wlan_private * priv,
+                      u16 cmd_no,
+                      u16 cmd_action,
+                      u16 wait_option, WLAN_OID cmd_oid, void *pdata_buf)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    CmdCtrlNode *CmdNode;
+    HostCmd_DS_COMMAND *CmdPtr;
+
+    ENTER();
+
+    if (!Adapter) {
+        PRINTM(ERROR, "PREP_CMD: Adapter is Null\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (Adapter->IsDeepSleep == TRUE) {
+        PRINTM(ERROR, "PREP_CMD: Deep sleep enabled\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (Adapter->SurpriseRemoved) {
+        PRINTM(ERROR, "PREP_CMD: Card is Removed\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    CmdNode = GetFreeCmdCtrlNode(priv);
+
+    if (CmdNode == NULL) {
+        umd_dbg("PREP_CMD: No free CmdNode!!!");
+
+        /* Wake up main thread to execute next command */
+        wake_up_interruptible(&priv->MainThread.waitQ);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    SetCmdCtrlNode(priv, CmdNode, cmd_oid, wait_option, pdata_buf);
+
+    CmdPtr = (HostCmd_DS_COMMAND *) CmdNode->BufVirtualAddr;
+
+    if (!CmdPtr) {
+        PRINTM(MSG, "PREP_CMD: BufVirtualAddr of CmdNode is NULL\n");
+        CleanupAndInsertCmd(priv, CmdNode);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Set sequence number, command and INT option */
+    Adapter->SeqNum++;
+    CmdPtr->SeqNum = wlan_cpu_to_le16(Adapter->SeqNum);
+
+    CmdPtr->Command = cmd_no;
+    CmdPtr->Result = 0;
+
+    TX_EVENT_FLAGS_SET(&CmdNode->cmdwait_q, 0, TX_AND);
+    switch (cmd_no) {
+    case HostCmd_CMD_GET_HW_SPEC:
+        ret = wlan_cmd_hw_spec(priv, CmdPtr);
+        break;
+    case HostCmd_CMD_802_11_PS_MODE:
+        ret = wlan_cmd_802_11_ps_mode(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_SCAN:
+        ret = wlan_cmd_802_11_scan(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_MAC_CONTROL:
+        ret = wlan_cmd_mac_control(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_ASSOCIATE:
+    case HostCmd_CMD_802_11_REASSOCIATE:
+        ret = wlan_cmd_802_11_associate(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_DEAUTHENTICATE:
+        ret = wlan_cmd_802_11_deauthenticate(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_SET_WEP:
+        ret = wlan_cmd_802_11_set_wep(priv, CmdPtr, cmd_oid);
+        break;
+
+    case HostCmd_CMD_802_11_AD_HOC_START:
+        ret = wlan_cmd_802_11_ad_hoc_start(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_RESET:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size = wlan_cpu_to_le16(S_DS_GEN);
+        break;
+
+    case HostCmd_CMD_802_11_GET_LOG:
+        ret = wlan_cmd_802_11_get_log(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_AUTHENTICATE:
+        ret = wlan_cmd_802_11_authenticate(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_GET_STAT:
+        ret = wlan_cmd_802_11_get_stat(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_SNMP_MIB:
+        ret = wlan_cmd_802_11_snmp_mib(priv, CmdPtr,
+                                       cmd_action, cmd_oid, pdata_buf);
+        break;
+
+    case HostCmd_CMD_MAC_REG_ACCESS:
+    case HostCmd_CMD_BBP_REG_ACCESS:
+    case HostCmd_CMD_RF_REG_ACCESS:
+        ret = wlan_cmd_reg_access(priv, CmdPtr, cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RF_CHANNEL:
+        ret = wlan_cmd_802_11_rf_channel(priv, CmdPtr, cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RF_TX_POWER:
+        ret = wlan_cmd_802_11_rf_tx_power(priv, CmdPtr,
+                                          cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RADIO_CONTROL:
+        ret = wlan_cmd_802_11_radio_control(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_RF_ANTENNA:
+        ret = wlan_cmd_802_11_rf_antenna(priv, CmdPtr, cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RATE_ADAPT_RATESET:
+        ret = wlan_cmd_802_11_rate_adapt_rateset(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_MAC_MULTICAST_ADR:
+        ret = wlan_cmd_mac_multicast_adr(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_AD_HOC_JOIN:
+        ret = wlan_cmd_802_11_ad_hoc_join(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RSSI:
+        ret = wlan_cmd_802_11_rssi(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_AD_HOC_STOP:
+        ret = wlan_cmd_802_11_ad_hoc_stop(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_ENABLE_RSN:
+        ret = wlan_cmd_802_11_enable_rsn(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_KEY_MATERIAL:
+        ret = wlan_cmd_802_11_key_material(priv, CmdPtr,
+                                           cmd_action, cmd_oid, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_PAIRWISE_TSC:
+        break;
+    case HostCmd_CMD_802_11_GROUP_TSC:
+        break;
+
+    case HostCmd_CMD_802_11_MAC_ADDRESS:
+        ret = wlan_cmd_802_11_mac_address(priv, CmdPtr, cmd_action);
+        break;
+    case HostCmd_CMD_802_11_CAL_DATA_EXT:
+        ret = wlan_cmd_802_11_cal_data_ext(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_DEEP_SLEEP:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size = wlan_cpu_to_le16((u16)
+                                        (sizeof
+                                         (HostCmd_DS_802_11_DEEP_SLEEP)));
+        break;
+
+    case HostCmd_CMD_802_11_HOST_SLEEP_CFG:
+        ret = wlan_cmd_802_11_host_sleep_cfg(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_HOST_SLEEP_AWAKE_CONFIRM:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size = wlan_cpu_to_le16(S_DS_GEN);
+        break;
+
+    case HostCmd_CMD_802_11_EEPROM_ACCESS:
+        ret = wlan_cmd_802_11_eeprom_access(priv, CmdPtr,
+                                            cmd_action, pdata_buf);
+        break;
+
+#ifdef MFG_CMD_SUPPORT
+    case HostCmd_CMD_MFG_COMMAND:
+        ret = SendMfgCommand(priv, CmdNode);
+        break;
+#endif
+
+    case HostCmd_CMD_802_11_SET_AFC:
+    case HostCmd_CMD_802_11_GET_AFC:
+
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_AFC) + S_DS_GEN);
+
+        memmove(&CmdPtr->params.afc,
+                pdata_buf, sizeof(HostCmd_DS_802_11_AFC));
+
+        ret = WLAN_STATUS_SUCCESS;
+        goto done;
+
+    case HostCmd_CMD_802_11D_DOMAIN_INFO:
+        ret = wlan_cmd_802_11d_domain_info(priv, CmdPtr, cmd_no, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_SLEEP_PARAMS:
+        ret = wlan_cmd_802_11_sleep_params(priv, CmdPtr, cmd_action);
+        break;
+    case HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE:
+        ret = wlan_cmd_802_11_bca_timeshare(priv, CmdPtr,
+                                            cmd_action, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_INACTIVITY_TIMEOUT:
+        ret = wlan_cmd_802_11_inactivity_timeout(priv, CmdPtr,
+                                                 cmd_action, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_BG_SCAN_CONFIG:
+        ret = wlan_cmd_802_11_bg_scan_config(priv, CmdPtr,
+                                             cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_BG_SCAN_QUERY:
+        ret = wlan_cmd_802_11_bg_scan_query(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_FW_WAKEUP_METHOD:
+        ret = wlan_cmd_802_11_fw_wakeup_method(priv, CmdPtr,
+                                               cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_WMM_GET_STATUS:
+        ret = wlan_cmd_wmm_get_status(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_WMM_ACK_POLICY:
+        ret = wlan_cmd_wmm_ack_policy(priv, CmdPtr, pdata_buf);
+        break;
+#if 0
+    case HostCmd_CMD_WMM_PRIO_PKT_AVAIL:
+        break;
+#endif
+
+    case HostCmd_CMD_WMM_ADDTS_REQ:
+        ret = wlan_cmd_wmm_addts_req(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_WMM_DELTS_REQ:
+        ret = wlan_cmd_wmm_delts_req(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_WMM_QUEUE_CONFIG:
+        ret = wlan_cmd_wmm_queue_config(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_WMM_QUEUE_STATS:
+        ret = wlan_cmd_wmm_queue_stats(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_TPC_CFG:
+        CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_TPC_CFG);
+        CmdPtr->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_TPC_CFG) + S_DS_GEN);
+
+        memmove(&CmdPtr->params.tpccfg,
+                pdata_buf, sizeof(HostCmd_DS_802_11_TPC_CFG));
+
+        ret = WLAN_STATUS_SUCCESS;
+        break;
+    case HostCmd_CMD_802_11_LED_GPIO_CTRL:
+        {
+            MrvlIEtypes_LedGpio_t *gpio =
+                (MrvlIEtypes_LedGpio_t *) CmdPtr->params.ledgpio.data;
+
+            memmove(&CmdPtr->params.ledgpio,
+                    pdata_buf, sizeof(HostCmd_DS_802_11_LED_CTRL));
+
+            CmdPtr->Command =
+                wlan_cpu_to_le16(HostCmd_CMD_802_11_LED_GPIO_CTRL);
+
+#define ACTION_NUMLED_TLVTYPE_LEN_FIELDS_LEN 8
+            CmdPtr->Size = wlan_cpu_to_le16(gpio->Header.Len + S_DS_GEN
+                                            +
+                                            ACTION_NUMLED_TLVTYPE_LEN_FIELDS_LEN);
+            gpio->Header.Len = wlan_cpu_to_le16(gpio->Header.Len);
+
+            ret = WLAN_STATUS_SUCCESS;
+            break;
+        }
+    case HostCmd_CMD_802_11_SLEEP_PERIOD:
+        ret = wlan_cmd_802_11_sleep_period(priv, CmdPtr,
+                                           cmd_action, pdata_buf);
+        break;
+    case HostCmd_CMD_GET_TSF:
+        CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_GET_TSF);
+        CmdPtr->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_GET_TSF)
+                                        + S_DS_GEN);
+        ret = WLAN_STATUS_SUCCESS;
+        break;
+    case HostCmd_CMD_802_11_TX_RATE_QUERY:
+        CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);
+        CmdPtr->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_TX_RATE_QUERY) + S_DS_GEN);
+        Adapter->TxRate = 0;
+        ret = WLAN_STATUS_SUCCESS;
+        break;
+    case HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:
+        ret =
+            wlan_cmd_802_11_IBSS_Coalesced_Status(priv, CmdPtr, cmd_action,
+                                                  pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_LDO_CONFIG:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_LDO_CONFIG) + S_DS_GEN);
+        memcpy(&CmdPtr->params.ldocfg, pdata_buf,
+               sizeof(HostCmd_DS_802_11_LDO_CONFIG));
+        CmdPtr->params.ldocfg.Action =
+            wlan_cpu_to_le16(CmdPtr->params.ldocfg.Action);
+        CmdPtr->params.ldocfg.PMSource =
+            wlan_cpu_to_le16(CmdPtr->params.ldocfg.PMSource);
+        break;
+
+    default:
+        PRINTM(INFO, "PREP_CMD: unknown command- %#x\n", cmd_no);
+        ret = WLAN_STATUS_FAILURE;
+        break;
+    }
+
+    /* return error, since the command preparation failed */
+    if (ret != WLAN_STATUS_SUCCESS) {
+        PRINTM(ERROR, "PREP_CMD: Command 0x%x preparation failed\n", cmd_no);
+        CleanupAndInsertCmd(priv, CmdNode);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    umd_dbg("PREP_CMD: 0x%x", cmd_no);
+
+    CmdNode->CmdWaitQWoken = FALSE;
+    QueueCmd(Adapter, CmdNode, TRUE);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+    sbi_reenable_host_interrupt(priv, 0x00);
+
+    if (wait_option & HostCmd_OPTION_WAITFORRSP) {
+        umd_dbg("PREP_CMD: Wait for CMD response...");
+        wait_event_interruptible(CmdNode->cmdwait_q, CmdNode->CmdWaitQWoken);
+
+        if (Adapter->CurCmdRetCode) {
+            umd_dbg("PREP_CMD: Command failed with return code=%d\n",
+                   Adapter->CurCmdRetCode);
+            Adapter->CurCmdRetCode = 0;
+            ret = WLAN_STATUS_FAILURE;
+        }
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function allocates the command buffer and link
+ *  it to command free queue.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+AllocateCmdBuffer(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u32 ulBufSize;
+    u32 i;
+    CmdCtrlNode *TempCmdArray;
+    u8 *pTempVirtualAddr;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /* Allocate and initialize CmdCtrlNode */
+    ulBufSize = sizeof(CmdCtrlNode) * MRVDRV_NUM_OF_CMD_BUFFER;
+
+    if (!(TempCmdArray = kmalloc(ulBufSize, GFP_KERNEL))) {
+        PRINTM(INFO, "ALLOC_CMD_BUF: Failed to allocate TempCmdArray\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    Adapter->CmdArray = TempCmdArray;
+    memset(Adapter->CmdArray, 0, ulBufSize);
+
+    /* Allocate and initialize command buffers */
+    ulBufSize = MRVDRV_SIZE_OF_CMD_BUFFER;
+    for (i = 0; i < MRVDRV_NUM_OF_CMD_BUFFER; i++) {
+        if (!(pTempVirtualAddr = kmalloc(ulBufSize, GFP_KERNEL))) {
+            PRINTM(INFO, "ALLOC_CMD_BUF: pTempVirtualAddr: out of memory\n");
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        memset(pTempVirtualAddr, 0, ulBufSize);
+
+        /* Update command buffer virtual */
+        TempCmdArray[i].BufVirtualAddr = pTempVirtualAddr;
+    }
+
+    for (i = 0; i < MRVDRV_NUM_OF_CMD_BUFFER; i++) {
+        init_waitqueue_head(&TempCmdArray[i].cmdwait_q);
+        CleanupAndInsertCmd(priv, &TempCmdArray[i]);
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function frees the command buffer.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+FreeCmdBuffer(wlan_private * priv)
+{
+    u32 ulBufSize;
+    UINT i;
+    CmdCtrlNode *TempCmdArray;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /* need to check if cmd array is allocated or not */
+    if (Adapter->CmdArray == NULL) {
+        PRINTM(INFO, "FREE_CMD_BUF: CmdArray is Null\n");
+        goto done;
+    }
+
+    TempCmdArray = Adapter->CmdArray;
+
+    /* Release shared memory buffers */
+    ulBufSize = MRVDRV_SIZE_OF_CMD_BUFFER;
+    for (i = 0; i < MRVDRV_NUM_OF_CMD_BUFFER; i++) {
+        if (TempCmdArray[i].BufVirtualAddr) {
+            PRINTM(INFO, "Free all the array\n");
+            kfree(TempCmdArray[i].BufVirtualAddr);
+            TempCmdArray[i].BufVirtualAddr = NULL;
+        }
+    }
+
+    /* Release CmdCtrlNode */
+    if (Adapter->CmdArray) {
+        PRINTM(INFO, "Free CmdArray\n");
+        kfree(Adapter->CmdArray);
+        Adapter->CmdArray = NULL;
+    }
+
+  done:
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function gets a free command node if available in
+ *  command free queue.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @return CmdCtrlNode A pointer to CmdCtrlNode structure or NULL
+ */
+CmdCtrlNode *
+GetFreeCmdCtrlNode(wlan_private * priv)
+{
+    CmdCtrlNode *TempNode;
+    wlan_adapter *Adapter = priv->adapter;
+    ulong flags;
+
+    ENTER();
+
+    if (!Adapter)
+        return NULL;
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+
+    if (!list_empty(&Adapter->CmdFreeQ)) {
+        TempNode = (CmdCtrlNode *) Adapter->CmdFreeQ.next;
+        list_del((struct list_head *) TempNode);
+    } else {
+        PRINTM(WARN, "GET_CMD_NODE: CmdCtrlNode is not available\n");
+        TempNode = NULL;
+    }
+
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+    if (TempNode) {
+        CleanUpCmdCtrlNode(TempNode);
+    }
+
+    LEAVE();
+    return TempNode;
+}
+
+/** 
+ *  @brief This function cleans command node.
+ *  
+ *  @param pTempNode	A pointer to CmdCtrlNode structure
+ *  @return 		n/a
+ */
+void
+CleanUpCmdCtrlNode(CmdCtrlNode * pTempNode)
+{
+    ENTER();
+
+    if (!pTempNode)
+        return;
+    pTempNode->CmdWaitQWoken = TRUE;
+    wake_up_interruptible(&pTempNode->cmdwait_q);
+    pTempNode->Status = 0;
+    pTempNode->cmd_oid = (WLAN_OID) 0;
+    pTempNode->wait_option = 0;
+    pTempNode->CmdFlags = 0;
+    pTempNode->pdata_buf = NULL;
+
+    if (pTempNode->BufVirtualAddr != NULL)
+        memset(pTempNode->BufVirtualAddr, 0, MRVDRV_SIZE_OF_CMD_BUFFER);
+
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function initializes the command node.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param pTempNode	A pointer to CmdCtrlNode structure
+ *  @param cmd_oid	cmd oid: treated as sub command
+ *  @param wait_option	wait option: wait response or not
+ *  @param pdata_buf	A pointer to informaion buffer
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+void
+SetCmdCtrlNode(wlan_private * priv,
+               CmdCtrlNode * pTempNode,
+               WLAN_OID cmd_oid, u16 wait_option, void *pdata_buf)
+{
+    ENTER();
+
+    if (!pTempNode)
+        return;
+
+    pTempNode->cmd_oid = cmd_oid;
+    pTempNode->wait_option = wait_option;
+    pTempNode->pdata_buf = pdata_buf;
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function executes next command in command
+ *  pending queue. It will put fimware back to PS mode
+ *  if applicable.
+ *  
+ *  @param priv     A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+ExecuteNextCommand(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    CmdCtrlNode *CmdNode = NULL;
+    HostCmd_DS_COMMAND *CmdPtr;
+    ulong flags;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    //umd_enter();
+
+    if (!Adapter) {
+        PRINTM(MSG, "EXEC_NEXT_CMD: Adapter is NULL\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (Adapter->IsDeepSleep == TRUE) {
+        PRINTM(MSG, "EXEC_NEXT_CMD: Device is in deep sleep mode.\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+
+    if (Adapter->CurCmd) {
+        PRINTM(MSG, "EXEC_NEXT_CMD: there is command in processing!\n");
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (!list_empty(&Adapter->CmdPendingQ)) {
+        CmdNode = (CmdCtrlNode *)
+            Adapter->CmdPendingQ.next;
+    }
+
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+    if (CmdNode) {
+        CmdPtr = (HostCmd_DS_COMMAND *) CmdNode->BufVirtualAddr;
+
+        if (Is_Command_Allowed_In_PS(CmdPtr->Command)) {
+            if ((Adapter->PSState == PS_STATE_SLEEP)
+                || (Adapter->PSState == PS_STATE_PRE_SLEEP)
+                ) {
+                PRINTM(INFO,
+                       "EXEC_NEXT_CMD: Cannot send cmd 0x%x in PSState %d\n",
+                       CmdPtr->Command, Adapter->PSState);
+                ret = WLAN_STATUS_FAILURE;
+                goto done;
+            }
+            PRINTM(INFO, "EXEC_NEXT_CMD: OK to send command "
+                   "0x%x in PSState %d\n", CmdPtr->Command, Adapter->PSState);
+        } else if (Adapter->PSState != PS_STATE_FULL_POWER) {
+            /*
+             * 1. Non-PS command: 
+             * Queue it. set NeedToWakeup to TRUE if current state 
+             * is SLEEP, otherwise call PSWakeup to send Exit_PS.
+             * 2. PS command but not Exit_PS: 
+             * Ignore it.
+             * 3. PS command Exit_PS:
+             * Set NeedToWakeup to TRUE if current state is SLEEP, 
+             * otherwise send this command down to firmware
+             * immediately.
+             */
+            if (CmdPtr->Command !=
+                wlan_cpu_to_le16(HostCmd_CMD_802_11_PS_MODE)) {
+                /*  Prepare to send Exit PS,
+                 *  this non PS command will be sent later */
+                if ((Adapter->PSState == PS_STATE_SLEEP)
+                    || (Adapter->PSState == PS_STATE_PRE_SLEEP)
+                    ) {
+                    /* w/ new scheme, it will not reach here.
+                       since it is blocked in main_thread. */
+                    Adapter->NeedToWakeup = TRUE;
+                } else
+                    PSWakeup(priv, 0);
+
+                ret = WLAN_STATUS_SUCCESS;
+                goto done;
+            } else {
+                /*
+                 * PS command. Ignore it if it is not Exit_PS. 
+                 * otherwise send it down immediately.
+                 */
+                HostCmd_DS_802_11_PS_MODE *psm = &CmdPtr->params.psmode;
+
+                PRINTM(INFO, "EXEC_NEXT_CMD: PS cmd- Action=0x%x\n",
+                       psm->Action);
+                if (psm->Action != wlan_cpu_to_le16(HostCmd_SubCmd_Exit_PS)) {
+                    PRINTM(INFO, "EXEC_NEXT_CMD: Ignore Enter PS cmd\n");
+                    list_del((struct list_head *) CmdNode);
+                    CleanupAndInsertCmd(priv, CmdNode);
+
+                    ret = WLAN_STATUS_SUCCESS;
+                    goto done;
+                }
+
+                if ((Adapter->PSState == PS_STATE_SLEEP)
+                    || (Adapter->PSState == PS_STATE_PRE_SLEEP)
+                    ) {
+                    PRINTM(INFO,
+                           "EXEC_NEXT_CMD: Ignore ExitPS cmd in sleep\n");
+                    list_del((struct list_head *) CmdNode);
+                    CleanupAndInsertCmd(priv, CmdNode);
+                    Adapter->NeedToWakeup = TRUE;
+
+                    ret = WLAN_STATUS_SUCCESS;
+                    goto done;
+                }
+
+                PRINTM(INFO, "EXEC_NEXT_CMD: Sending Exit_PS down...\n");
+            }
+        }
+        list_del((struct list_head *) CmdNode);
+        DownloadCommandToStation(priv, CmdNode);
+    } else {
+        /*
+         * check if in power save mode, if yes, put the device back
+         * to PS mode
+         */
+        if ((Adapter->PSMode != Wlan802_11PowerModeCAM) &&
+            (Adapter->PSState == PS_STATE_FULL_POWER) &&
+            (Adapter->MediaConnectStatus == WlanMediaStateConnected)) {
+            if (Adapter->SecInfo.WPAEnabled || Adapter->SecInfo.WPA2Enabled) {
+                if (Adapter->IsGTK_SET) {
+                    PRINTM(INFO, "EXEC_NEXT_CMD: WPA enabled and GTK_SET"
+                           " go back to PS_SLEEP");
+                    PSSleep(priv, 0);
+                }
+            } else {
+                {
+                    PRINTM(INFO, "EXEC_NEXT_CMD: Command PendQ is empty,"
+                           " go back to PS_SLEEP");
+                    PSSleep(priv, 0);
+                }
+            }
+        }
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+	//umd_exit();
+    LEAVE();
+    return ret;
+}
+
+#if WIRELESS_EXT > 14
+/** 
+ *  @brief This function sends customized event to application.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @para str	   A pointer to event string
+ *  @return 	   n/a
+ */
+void
+send_iwevcustom_event(wlan_private * priv, s8 * str)
+{
+    union iwreq_data iwrq;
+    u8 buf[50];
+
+    ENTER();
+
+    memset(&iwrq, 0, sizeof(union iwreq_data));
+    memset(buf, 0, sizeof(buf));
+
+    snprintf(buf, sizeof(buf) - 1, "%s", str);
+
+    iwrq.data.pointer = buf;
+    iwrq.data.length = strlen(buf) + 1 + IW_EV_LCP_LEN;
+
+    /* Send Event to upper layer */
+    wireless_send_event(priv->wlan_dev.netdev, IWEVCUSTOM, &iwrq, buf);
+    PRINTM(INFO, "Wireless event %s is sent to app\n", str);
+
+    LEAVE();
+    return;
+}
+#endif
+
+/** 
+ *  @brief This function sends sleep confirm command to firmware.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param cmdptr  A pointer to the command
+ *  @param size	   the size of command
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+SendConfirmSleep(wlan_private * priv, u8 * CmdPtr, u16 size)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    static u32 i = 0;
+
+    ENTER();
+
+    HEXDUMP("SLEEP_CFM", CmdPtr, size);
+
+    ret = sbi_host_to_card(priv, MVMS_CMD, CmdPtr, size);
+    priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+
+    if (ret) {
+        PRINTM(MSG, "SLEEP_CFM: sbi_host_to_card() failed\n");
+        Adapter->dbg.num_cmd_sleep_cfm_host_to_card_failure++;
+    } else {
+        Adapter->PSState = PS_STATE_SLEEP;
+        if (Adapter->bHostSleepConfigured &&
+            (Adapter->sleep_period.period == 0)) {
+            Adapter->bWakeupDevRequired = TRUE;
+            wlan_host_sleep_activated_event(priv);
+        }
+#define NUM_SC_PER_LINE		16
+        if (++i % NUM_SC_PER_LINE == 0) {
+            PRINTM(EVENT, "+\n");
+        } else {
+            PRINTM(EVENT, "+");
+        }
+
+        /* check if interrupt is received after sleep confirm */
+        if (Adapter->IntCounter) {
+            PRINTM(INFO, "SLEEP_CFM: After sent, IntCnt=%d\n",
+                   Adapter->IntCounter);
+            Adapter->PSState = PS_STATE_AWAKE;
+        }
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function sends Enter_PS command to firmware.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param wait_option	wait response or not
+ *  @return 	   	n/a 
+ */
+void
+PSSleep(wlan_private * priv, int wait_option)
+{
+
+    ENTER();
+
+    PrepareAndSendCommand(priv, HostCmd_CMD_802_11_PS_MODE,
+                          HostCmd_SubCmd_Enter_PS, wait_option, 0, NULL);
+
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function sends Eixt_PS command to firmware.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param wait_option	wait response or not
+ *  @return 	   	n/a 
+ */
+void
+PSWakeup(wlan_private * priv, int wait_option)
+{
+    WLAN_802_11_POWER_MODE LocalPSMode;
+
+    ENTER();
+
+    LocalPSMode = Wlan802_11PowerModeCAM;
+
+    PrepareAndSendCommand(priv, HostCmd_CMD_802_11_PS_MODE,
+                          HostCmd_SubCmd_Exit_PS,
+                          wait_option, 0, &LocalPSMode);
+
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function checks condition and prepares to
+ *  send sleep confirm command to firmware if ok.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param PSMode  	Power Saving mode
+ *  @return 	   	n/a 
+ */
+void
+PSConfirmSleep(wlan_private * priv, u16 PSMode)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!priv->wlan_dev.dnld_sent && !Adapter->CurCmd && !Adapter->IntCounter) {
+        SendConfirmSleep(priv, (u8 *) & Adapter->PSConfirmSleep,
+                         sizeof(PS_CMD_ConfirmSleep));
+    } else {
+        PRINTM(INFO, "Delay Sleep Confirm (%s%s%s)\n",
+               (priv->wlan_dev.dnld_sent) ? "D" : "",
+               (Adapter->CurCmd) ? "C" : "",
+               (Adapter->IntCounter) ? "I" : "");
+    }
+
+    LEAVE();
+}
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_cmdresp.c b/drivers/net/wireless/8686_wlan/wlan/wlan_cmdresp.c
new file mode 100644
index 0000000..e39269e
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_cmdresp.c
@@ -0,0 +1,1581 @@
+/** @file wlan_cmdresp.c
+  * @brief This file contains the handling of command
+  * responses as well as events generated by firmware.
+  *
+  * (c) Copyright © 2003-2007, Marvell International Ltd. 
+  *  
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	10/10/05: Add Doxygen format comments
+	11/11/05: Add support for WMM Status change event
+	12/13/05: Add Proprietary periodic sleep support
+	12/23/05: Fix bug in adhoc start where the current index was
+	          not properly being assigned before it was used.
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join structures.
+	          Update assoc response handling; entire IEEE response returned
+	04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+	04/10/06: Add hostcmd generic API
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	05/04/06: Add IBSS coalescing related new hostcmd response handling
+	05/08/06: Remove PermanentAddr from Adapter
+	06/08/06: Remove function HandleMICFailureEvent()
+********************************************************/
+
+#include	"include.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function handles disconnect event. it
+ *  reports disconnect to upper layer, clean tx/rx packets,
+ *  reset link state etc.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+void
+MacEventDisconnected(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    union iwreq_data wrqu;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus != WlanMediaStateConnected)
+        return;
+
+    PRINTM(INFO, "Handles disconnect event.\n");
+
+    /* Free Tx and Rx packets */
+    /* report disconnect to upper layer */
+    wlan_clean_txrx(priv);
+
+    memset(wrqu.ap_addr.sa_data, 0x00, ETH_ALEN);
+    wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+
+    /* 
+     * Cisco AP sends EAP failure and de-auth in less than 0.5 ms.
+     * It causes problem in the Supplicant
+     */
+
+    os_sched_timeout(1000);
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+
+    /* reset SNR/NF/RSSI values */
+    memset(Adapter->SNR, 0x00, sizeof(Adapter->SNR));
+    memset(Adapter->NF, 0x00, sizeof(Adapter->NF));
+    memset(Adapter->RSSI, 0x00, sizeof(Adapter->RSSI));
+    memset(Adapter->rawSNR, 0x00, sizeof(Adapter->rawSNR));
+    memset(Adapter->rawNF, 0x00, sizeof(Adapter->rawNF));
+    Adapter->nextSNRNF = 0;
+    Adapter->numSNRNF = 0;
+    Adapter->RxPDRate = 0;
+    PRINTM(INFO, "Current SSID=%s, Ssid Length=%u\n",
+           Adapter->CurBssParams.ssid.Ssid,
+           Adapter->CurBssParams.ssid.SsidLength);
+    PRINTM(INFO, "Previous SSID=%s, Ssid Length=%u\n",
+           Adapter->PreviousSSID.Ssid, Adapter->PreviousSSID.SsidLength);
+
+    Adapter->SecInfo.WPAEnabled = FALSE;
+    Adapter->SecInfo.WPA2Enabled = FALSE;
+    Adapter->Wpa_ie_len = 0;
+    Adapter->SecInfo.EncryptionMode = CIPHER_NONE;
+
+    Adapter->MediaConnectStatus = WlanMediaStateDisconnected;
+    Adapter->AdhocLinkSensed = FALSE;
+    Adapter->LinkSpeed = MRVDRV_LINK_SPEED_1mbps;
+
+    /* 
+     * memorize the previous SSID and BSSID
+     * it could be used for re-assoc
+     */
+    memcpy(&Adapter->PreviousSSID,
+           &Adapter->CurBssParams.ssid, sizeof(WLAN_802_11_SSID));
+    memcpy(Adapter->PreviousBSSID,
+           Adapter->CurBssParams.bssid, MRVDRV_ETH_ADDR_LEN);
+
+    /* need to erase the current SSID and BSSID info */
+    Adapter->pAttemptedBSSDesc = 0;
+    memset(&Adapter->CurBssParams, 0, sizeof(Adapter->CurBssParams));
+
+    if (Adapter->PSState != PS_STATE_FULL_POWER) {
+        /* make firmware to exit PS mode */
+        PRINTM(INFO, "Disconnected, so exit PS mode.\n");
+        PSWakeup(priv, 0);
+    }
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function handles link lost, deauth and
+ *  disassoc events.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+static void
+HandleDisconnectEvent(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        MacEventDisconnected(priv);
+#ifdef REASSOCIATION
+        if (Adapter->Reassoc_on == TRUE) {
+            PRINTM(INFO, "RE-ASSOC: trigger the timer\n");
+            Adapter->TimerIsSet = TRUE;
+            ModTimer(&Adapter->MrvDrvTimer, 0);
+        }
+#endif /* REASSOCIATION */
+    }
+}
+
+/** 
+ *  @brief This function handles the command response of reg_access
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param type	   the type of reg access (MAC, BBP or RF)
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_reg_access(wlan_private * priv, u16 type, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    switch (type) {
+    case HostCmd_RET_MAC_REG_ACCESS:
+        {
+            HostCmd_DS_MAC_REG_ACCESS *reg;
+
+            reg = (PHostCmd_DS_MAC_REG_ACCESS) & resp->params.macreg;
+
+            Adapter->OffsetValue.offset = wlan_le16_to_cpu(reg->Offset);
+            Adapter->OffsetValue.value = wlan_le32_to_cpu(reg->Value);
+            break;
+        }
+
+    case HostCmd_RET_BBP_REG_ACCESS:
+        {
+            HostCmd_DS_BBP_REG_ACCESS *reg;
+            reg = (PHostCmd_DS_BBP_REG_ACCESS) & resp->params.bbpreg;
+
+            Adapter->OffsetValue.offset = wlan_le16_to_cpu(reg->Offset);
+            Adapter->OffsetValue.value = (u8) reg->Value;
+            break;
+        }
+
+    case HostCmd_RET_RF_REG_ACCESS:
+        {
+            HostCmd_DS_RF_REG_ACCESS *reg;
+            reg = (PHostCmd_DS_RF_REG_ACCESS) & resp->params.rfreg;
+
+            Adapter->OffsetValue.offset = wlan_le16_to_cpu(reg->Offset);
+            Adapter->OffsetValue.value = (u8) reg->Value;
+            break;
+        }
+
+    default:
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of get_hw_spec
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_get_hw_spec(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    u32 i;
+    HostCmd_DS_GET_HW_SPEC *hwspec = &resp->params.hwspec;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    Adapter->fwCapInfo = wlan_le32_to_cpu(hwspec->fwCapInfo);
+
+    Adapter->FWReleaseNumber = wlan_le32_to_cpu(hwspec->FWReleaseNumber);
+
+    PRINTM(INFO, "GET_HW_SPEC: FWReleaseVersion- 0x%X\n",
+           Adapter->FWReleaseNumber);
+    PRINTM(INFO, "GET_HW_SPEC: Permanent addr- %2x:%2x:%2x:%2x:%2x:%2x\n",
+           hwspec->PermanentAddr[0], hwspec->PermanentAddr[1],
+           hwspec->PermanentAddr[2], hwspec->PermanentAddr[3],
+           hwspec->PermanentAddr[4], hwspec->PermanentAddr[5]);
+    PRINTM(INFO, "GET_HW_SPEC: HWIfVersion=0x%X  Version=0x%X\n",
+           wlan_le16_to_cpu(hwspec->HWIfVersion),
+           wlan_le16_to_cpu(hwspec->Version));
+
+    Adapter->RegionCode = wlan_le16_to_cpu(hwspec->RegionCode);
+
+    for (i = 0; i < MRVDRV_MAX_REGION_CODE; i++) {
+        /* use the region code to search for the index */
+        if (Adapter->RegionCode == RegionCodeToIndex[i]) {
+            Adapter->RegionTableIndex = (u16) i;
+            break;
+        }
+    }
+
+    /* if it's unidentified region code, use the default (USA) */
+    if (i >= MRVDRV_MAX_REGION_CODE) {
+        Adapter->RegionCode = 0x10;
+        Adapter->RegionTableIndex = 0;
+        PRINTM(WARN, "unidentified region code, use the default (USA)\n");
+    }
+
+    if (Adapter->CurrentAddr[0] == 0xff) {
+        memmove(Adapter->CurrentAddr, hwspec->PermanentAddr,
+                MRVDRV_ETH_ADDR_LEN);
+    }
+    memcpy(priv->wlan_dev.netdev->dev_addr, Adapter->CurrentAddr, ETH_ALEN);
+
+    if (wlan_set_regiontable(priv, Adapter->RegionCode, 0)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (wlan_set_universaltable(priv, 0)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function handles the command response of host_sleep_cfg
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_host_sleep_cfg(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_HOST_SLEEP_CFG *hscfg = &resp->params.hostsleepcfg;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (hscfg->conditions != HOST_SLEEP_CFG_CANCEL) {
+        Adapter->bHostSleepConfigured = TRUE;
+    } else {
+        Adapter->bHostSleepConfigured = FALSE;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function handles the command response of fw_wakeup_method
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_fw_wakeup_method(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_FW_WAKEUP_METHOD *fwwm = &resp->params.fwwakeupmethod;
+    u16 action;
+
+    ENTER();
+
+    action = wlan_le16_to_cpu(fwwm->Action);
+
+    switch (action) {
+    case HostCmd_ACT_GET:
+    case HostCmd_ACT_SET:
+        Adapter->fwWakeupMethod = wlan_le16_to_cpu(fwwm->Method);
+        break;
+    default:
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of sleep_params
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_sleep_params(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_SLEEP_PARAMS *sp = &resp->params.sleep_params;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, "error=%x offset=%x stabletime=%x calcontrol=%x\n"
+           " extsleepclk=%x\n", sp->Error, sp->Offset,
+           sp->StableTime, sp->CalControl, sp->ExternalSleepClk);
+    Adapter->sp.sp_error = wlan_le16_to_cpu(sp->Error);
+    Adapter->sp.sp_offset = wlan_le16_to_cpu(sp->Offset);
+    Adapter->sp.sp_stabletime = wlan_le16_to_cpu(sp->StableTime);
+    Adapter->sp.sp_calcontrol = wlan_le16_to_cpu(sp->CalControl);
+    Adapter->sp.sp_extsleepclk = wlan_le16_to_cpu(sp->ExternalSleepClk);
+    Adapter->sp.sp_reserved = wlan_le16_to_cpu(sp->Reserved);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of sleep_params
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_sleep_period(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_SLEEP_PERIOD *sp_period = &resp->params.ps_sleeppd;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    Adapter->sleep_period.period = wlan_le16_to_cpu(sp_period->Period);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of bca_timeshare
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_bca_timeshare(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_BCA_TIMESHARE *bca_ts = &resp->params.bca_timeshare;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(MSG, "TrafficType=%x TimeShareInterva=%x BTTime=%x\n",
+           bca_ts->TrafficType, bca_ts->TimeShareInterval, bca_ts->BTTime);
+
+    Adapter->bca_ts.TrafficType = wlan_le16_to_cpu(bca_ts->TrafficType);
+    Adapter->bca_ts.TimeShareInterval =
+        wlan_le32_to_cpu(bca_ts->TimeShareInterval);
+    Adapter->bca_ts.BTTime = wlan_le32_to_cpu(bca_ts->BTTime);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of mac_control
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_mac_control(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of set_wep
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_set_wep(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of reset
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_reset(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    ENTER();
+    PRINTM(INFO, "HWAC - Reset command successful\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of statistics
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_stat(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_GET_STAT *p11Stat = &resp->params.gstat;
+    wlan_adapter *Adapter = priv->adapter;
+
+    /* TODO Convert it to Big endian befor copy */
+    memcpy(&Adapter->wlan802_11Stat,
+           p11Stat, sizeof(HostCmd_DS_802_11_GET_STAT));
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of snmp_mib
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_snmp_mib(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_SNMP_MIB *smib = &resp->params.smib;
+    u16 OID = wlan_le16_to_cpu(smib->OID);
+    u16 QueryType = wlan_le16_to_cpu(smib->QueryType);
+
+    ENTER();
+
+    PRINTM(INFO, "SNMP_RESP: value of the OID = %x, QueryType=%x\n", OID,
+           QueryType);
+    PRINTM(INFO, "SNMP_RESP: Buf size  = %x\n",
+           wlan_le16_to_cpu(smib->BufSize));
+
+    if (QueryType == HostCmd_ACT_GEN_GET) {
+        switch (OID) {
+        case FragThresh_i:
+            priv->adapter->FragThsd =
+                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
+            PRINTM(INFO, "SNMP_RESP: FragThsd =%u\n",
+                   priv->adapter->FragThsd);
+            break;
+        case RtsThresh_i:
+            priv->adapter->RTSThsd =
+                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
+            PRINTM(INFO, "SNMP_RESP: RTSThsd =%u\n", priv->adapter->RTSThsd);
+            break;
+        case ShortRetryLim_i:
+            priv->adapter->TxRetryCount =
+                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
+            PRINTM(INFO, "SNMP_RESP: TxRetryCount =%u\n",
+                   priv->adapter->RTSThsd);
+            break;
+        default:
+            break;
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of radio_control
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_radio_control(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    ENTER();
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of key_material
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_key_material(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_KEY_MATERIAL *pKey = &resp->params.keymaterial;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wlan_le16_to_cpu(pKey->Action) == HostCmd_ACT_SET) {
+        if ((wlan_le16_to_cpu(pKey->KeyParamSet.KeyInfo) &
+             KEY_INFO_TKIP_MCAST)
+            || (wlan_le16_to_cpu(pKey->KeyParamSet.KeyInfo) &
+                KEY_INFO_AES_MCAST)) {
+            PRINTM(INFO, "Key: GTK is set\n");
+            Adapter->IsGTK_SET = TRUE;
+        }
+    }
+
+    memcpy(Adapter->aeskey.KeyParamSet.Key, pKey->KeyParamSet.Key,
+           sizeof(pKey->KeyParamSet.Key));
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of mac_address
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_mac_address(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_MAC_ADDRESS *MacAdd = &resp->params.macadd;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    memcpy(Adapter->CurrentAddr, MacAdd->MacAdd, ETH_ALEN);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rf_tx_power
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rf_tx_power(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RF_TX_POWER *rtp = &resp->params.txp;
+    wlan_adapter *Adapter = priv->adapter;
+    u16 Action = wlan_le16_to_cpu(rtp->Action);
+
+    ENTER();
+
+    Adapter->TxPowerLevel = wlan_le16_to_cpu(rtp->CurrentLevel);
+
+    if (Action == HostCmd_ACT_GET) {
+        Adapter->MaxTxPowerLevel = rtp->MaxPower;
+        Adapter->MinTxPowerLevel = rtp->MinPower;
+    }
+
+    PRINTM(INFO, "Current TxPower Level = %d,Max Power=%d, Min Power=%d\n",
+           Adapter->TxPowerLevel, Adapter->MaxTxPowerLevel,
+           Adapter->MinTxPowerLevel);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rf_antenna
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rf_antenna(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    PHostCmd_DS_802_11_RF_ANTENNA pAntenna = &resp->params.rant;
+    wlan_adapter *Adapter = priv->adapter;
+    u16 Action = wlan_le16_to_cpu(pAntenna->Action);
+
+    if (Action == HostCmd_ACT_GET_RX)
+        Adapter->RxAntennaMode = wlan_le16_to_cpu(pAntenna->AntennaMode);
+
+    if (Action == HostCmd_ACT_GET_TX)
+        Adapter->TxAntennaMode = wlan_le16_to_cpu(pAntenna->AntennaMode);
+
+    PRINTM(INFO, "RF_ANT_RESP: Action = 0x%x, Mode = 0x%04x\n",
+           Action, wlan_le16_to_cpu(pAntenna->AntennaMode));
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of multicast_address
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_mac_multicast_adr(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rate_adapt_rateset
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rate_adapt_rateset(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RATE_ADAPT_RATESET *rates = &resp->params.rateset;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wlan_le16_to_cpu(rates->Action) == HostCmd_ACT_GET) {
+        Adapter->HWRateDropMode = wlan_le16_to_cpu(rates->HWRateDropMode);
+        Adapter->Threshold = wlan_le16_to_cpu(rates->Threshold);
+        Adapter->FinalRate = wlan_le16_to_cpu(rates->FinalRate);
+        Adapter->RateBitmap = wlan_le16_to_cpu(rates->Bitmap);
+    }
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rf_channel
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rf_channel(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RF_CHANNEL *rfchannel = &resp->params.rfchannel;
+    wlan_adapter *Adapter = priv->adapter;
+    u16 Action = wlan_le16_to_cpu(rfchannel->Action);
+    u16 newChannel = wlan_le16_to_cpu(rfchannel->CurrentChannel);
+
+    ENTER();
+
+    if (Action == HostCmd_OPT_802_11_RF_CHANNEL_GET
+        && Adapter->CurBssParams.channel != newChannel) {
+        PRINTM(INFO, "Channel Switch: %d to %d\n",
+               Adapter->CurBssParams.channel, newChannel);
+
+        /* Update the channel again */
+        Adapter->CurBssParams.channel = newChannel;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rssi
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rssi(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RSSI_RSP *rssirsp = &resp->params.rssirsp;
+    wlan_adapter *Adapter = priv->adapter;
+
+    /* store the non average value */
+    Adapter->SNR[TYPE_BEACON][TYPE_NOAVG] = wlan_le16_to_cpu(rssirsp->SNR);
+    Adapter->NF[TYPE_BEACON][TYPE_NOAVG] =
+        wlan_le16_to_cpu(rssirsp->NoiseFloor);
+
+    Adapter->SNR[TYPE_BEACON][TYPE_AVG] = wlan_le16_to_cpu(rssirsp->AvgSNR);
+    Adapter->NF[TYPE_BEACON][TYPE_AVG] =
+        wlan_le16_to_cpu(rssirsp->AvgNoiseFloor);
+
+    Adapter->RSSI[TYPE_BEACON][TYPE_NOAVG] =
+        CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_NOAVG],
+                 Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+
+    Adapter->RSSI[TYPE_BEACON][TYPE_AVG] =
+        CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_AVG] / AVG_SCALE,
+                 Adapter->NF[TYPE_BEACON][TYPE_AVG] / AVG_SCALE);
+
+    PRINTM(INFO, "Beacon RSSI value = 0x%x\n",
+           Adapter->RSSI[TYPE_BEACON][TYPE_AVG]);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+#ifdef	MFG_CMD_SUPPORT
+/** 
+ *  @brief This function handles the command response of mfg_cmd
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_mfg_cmd(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->mfg_cmd_flag == 1) {
+        // enough buffer for the response
+        if (priv->wlan_dev.upld_len <= Adapter->mfg_cmd_len) {
+            memcpy(Adapter->mfg_cmd,
+                   Adapter->CurCmd->BufVirtualAddr, priv->wlan_dev.upld_len);
+            Adapter->mfg_cmd_resp_len = priv->wlan_dev.upld_len;
+        } else {
+            memset(Adapter->mfg_cmd, 0, Adapter->mfg_cmd_len);
+            Adapter->mfg_cmd_resp_len = -1;
+        }
+        wake_up_interruptible(&(Adapter->mfg_cmd_q));
+        Adapter->mfg_cmd_flag = 0;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+#endif /* MFG_CMD_SUPPORT */
+
+/** 
+ *  @brief This function handles the command response of cal_data_ext.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param resp		A pointer to HostCmd_DS_COMMAND
+ *  @return    		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_cal_data_ext(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_CAL_DATA_EXT *pCalDataExt = &resp->params.caldataext;
+
+    ENTER();
+
+    if (wlan_le16_to_cpu(pCalDataExt->Action) == HostCmd_ACT_GEN_GET) {
+        pCalDataExt->Action = wlan_le16_to_cpu(pCalDataExt->Action);
+        pCalDataExt->Revision = wlan_le16_to_cpu(pCalDataExt->Revision);
+        pCalDataExt->CalDataLen = wlan_le16_to_cpu(pCalDataExt->CalDataLen);
+
+        memmove(Adapter->CurCmd->pdata_buf,
+                pCalDataExt, sizeof(HostCmd_DS_802_11_CAL_DATA_EXT));
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of eeprom_access
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_eeprom_access(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_regrdwr *pBuf = (wlan_ioctl_regrdwr *) Adapter->pRdeeprom;
+    PRINTM(INFO, "eeprom read len=%x\n",
+           wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount));
+    if (pBuf->NOB < wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount)) {
+        pBuf->NOB = 0;
+        PRINTM(INFO, "eeprom read return length is too big\n");
+        return WLAN_STATUS_FAILURE;
+    }
+    pBuf->NOB = wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount);
+    if (pBuf->NOB > 0) {
+
+        memcpy(&pBuf->Value, (u8 *) & resp->params.rdeeprom.Value,
+               wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount));
+        HEXDUMP("Adapter", (char *) &pBuf->Value,
+                wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount));
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of get_log
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_get_log(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    PHostCmd_DS_802_11_GET_LOG LogMessage =
+        (PHostCmd_DS_802_11_GET_LOG) & resp->params.glog;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /* TODO Convert it to Big Endian before copy */
+    memcpy(&Adapter->LogMsg, LogMessage, sizeof(HostCmd_DS_802_11_GET_LOG));
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+static void
+wlan_ret_802_11_IBSS_Coalesced_Status(wlan_private * priv,
+                                      HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_IBSS_Status *IBSSStatusRsp;
+    wlan_adapter *Adapter;
+    union iwreq_data wrqu;
+    u8 nullMac[6] = { 0, 0, 0, 0, 0, 0 };
+
+    Adapter = priv->adapter;
+    IBSSStatusRsp = &(resp->params.ibssCoalescing);
+
+    if (Adapter->CurCmd->pdata_buf)
+        *(int *) Adapter->CurCmd->pdata_buf = IBSSStatusRsp->Enable;
+
+    if (wlan_le16_to_cpu(IBSSStatusRsp->Action) == HostCmd_ACT_SET) {
+        return;
+    }
+
+    PRINTM(INFO, "New BSSID %x:%x:%x:%x:%x:%x\n",
+           IBSSStatusRsp->BSSID[0],
+           IBSSStatusRsp->BSSID[1],
+           IBSSStatusRsp->BSSID[2],
+           IBSSStatusRsp->BSSID[3],
+           IBSSStatusRsp->BSSID[4], IBSSStatusRsp->BSSID[5]);
+
+    /* if rsp has NULL BSSID, Just return.. No Action */
+    if (!memcmp(IBSSStatusRsp->BSSID, nullMac, MRVDRV_ETH_ADDR_LEN)) {
+        PRINTM(MSG, "New BSSID is NULL\n");
+        return;
+    }
+
+    /* if BSSID is diff, Send evnet to Linux */
+    if (memcmp(Adapter->CurBssParams.bssid,
+               IBSSStatusRsp->BSSID, MRVDRV_ETH_ADDR_LEN)) {
+        memcpy((void *) (Adapter->CurBssParams.bssid),
+               (void *) (IBSSStatusRsp->BSSID), MRVDRV_ETH_ADDR_LEN);
+
+        /* Beacon Interval and ATIM window */
+        Adapter->CurBssParams.BSSDescriptor.BeaconPeriod =
+            IBSSStatusRsp->BeaconInterval;
+        Adapter->CurBssParams.BSSDescriptor.ATIMWindow =
+            IBSSStatusRsp->ATIMWindow;
+
+        memset(&wrqu, 0, sizeof(wrqu));
+        memcpy(wrqu.ap_addr.sa_data, Adapter->CurBssParams.bssid, ETH_ALEN);
+        wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+
+        wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+    }
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+/** 
+ *  @brief This function stop tx/rx queue and free skb
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+void
+wlan_clean_txrx(wlan_private * priv)
+{
+    /* report disconnect to upper layer */
+    os_stop_queue(priv);
+    os_carrier_off(priv);
+    if (priv->adapter->wmm.enabled) {
+        priv->adapter->wmm.enabled = FALSE;
+        wmm_cleanup_queues(priv);
+    }
+    cleanup_txqueues(priv);
+    /* Free Tx and Rx packets */
+    os_free_tx_packet(priv);
+    wlan_send_rxskbQ(priv);
+
+    return;
+}
+
+/** 
+ *  @brief This function handles the command response
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_process_rx_command(wlan_private * priv)
+{
+    u16 RespCmd;
+    HostCmd_DS_COMMAND *resp;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    ulong flags;
+    u16 Result;
+
+    ENTER();
+
+    /* Now we got response from FW, cancel the command timer */
+    if (Adapter->CommandTimerIsSet) {
+        CancelTimer(&Adapter->MrvDrvCommandTimer);
+        Adapter->CommandTimerIsSet = FALSE;
+    }
+
+    if (!Adapter->CurCmd) {
+        PRINTM(ERROR, "CMD_RESP: NULL CurCmd=%p\n", Adapter->CurCmd);
+        umd_dbg("CMD_RESP: NULL CurCmd=%p\n", Adapter->CurCmd);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    Adapter->num_cmd_timeout = 0;
+
+    DBG_HEXDUMP(CMD_D, "CMD_RESP", Adapter->CurCmd->BufVirtualAddr,
+                priv->wlan_dev.upld_len);
+
+    resp = (HostCmd_DS_COMMAND *) (Adapter->CurCmd->BufVirtualAddr);
+
+    RespCmd = wlan_le16_to_cpu(resp->Command);
+
+    Result = wlan_le16_to_cpu(resp->Result);
+
+    Adapter->dbg.LastCmdRespId = RespCmd;
+
+    PRINTM(CMND, "CMD_RESP: 0x%x, result %d, len %d, seqno %d @ %lu\n",
+           RespCmd, Result, wlan_le16_to_cpu(resp->Size),
+           wlan_le16_to_cpu(resp->SeqNum), os_time_get());
+
+    umd_dbg("CMD_RESP: 0x%x, result %d, len %d, seqno %d @ %lu",
+           RespCmd, Result, wlan_le16_to_cpu(resp->Size),
+           wlan_le16_to_cpu(resp->SeqNum), os_time_get());
+
+    if (!(RespCmd & 0x8000)) {
+        PRINTM(ERROR, "CMD_RESP: Invalid response to command!");
+        umd_dbg("CMD_RESP: Invalid response to command!");
+        Adapter->CurCmdRetCode = WLAN_STATUS_FAILURE;
+        CleanupAndInsertCmd(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Store the response code to CurCmdRetCode. */
+    Adapter->CurCmdRetCode = wlan_le16_to_cpu(resp->Result);
+
+    if (RespCmd == HostCmd_RET_802_11_PS_MODE) {
+        HostCmd_DS_802_11_PS_MODE *psmode;
+
+        psmode = &resp->params.psmode;
+        PRINTM(INFO, "CMD_RESP: PS_MODE cmd reply result=%#x action=0x%X\n",
+               resp->Result, psmode->Action);
+        psmode->Action = wlan_cpu_to_le16(psmode->Action);
+
+        if (Result) {
+            PRINTM(ERROR, "CMD_RESP: PS command failed- %#x \n",
+                   resp->Result);
+            if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+                /* 
+                 * We should not re-try enter-ps command in 
+                 * ad-hoc mode. It takes place in 
+                 * ExecuteNextCommand().
+                 */
+                if (psmode->Action == HostCmd_SubCmd_Enter_PS)
+                    Adapter->PSMode = Wlan802_11PowerModeCAM;
+            }
+        } else if (psmode->Action == HostCmd_SubCmd_Enter_PS) {
+            Adapter->NeedToWakeup = FALSE;
+            Adapter->PSState = PS_STATE_AWAKE;
+            if (Adapter->MediaConnectStatus != WlanMediaStateConnected) {
+                /*
+                 * When Deauth Event received before Enter_PS command
+                 * response, We need to wake up the firmware.
+                 */
+                PRINTM(INFO,
+                       "CMD_RESP: Disconnected, Going to invoke PSWakeup\n");
+                PSWakeup(priv, 0);
+            }
+        } else if (psmode->Action == HostCmd_SubCmd_Exit_PS) {
+            Adapter->NeedToWakeup = FALSE;
+            Adapter->PSState = PS_STATE_FULL_POWER;
+        } else {
+            PRINTM(INFO, "CMD_RESP: PS- Action=0x%X\n", psmode->Action);
+        }
+
+        CleanupAndInsertCmd(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+        ret = WLAN_STATUS_SUCCESS;
+        goto done;
+    }
+
+    if (Adapter->CurCmd->CmdFlags & CMD_F_HOSTCMD) {
+        /* Copy the response back to response buffer */
+        memcpy(Adapter->CurCmd->pdata_buf, resp, resp->Size);
+
+        Adapter->CurCmd->CmdFlags &= ~CMD_F_HOSTCMD;
+
+        if ((Result == HostCmd_RESULT_OK)
+            && (RespCmd == HostCmd_RET_802_11_HOST_SLEEP_CFG)) {
+            ret = wlan_ret_host_sleep_cfg(priv, resp);
+        }
+    }
+
+    /* If the command is not successful, cleanup and return failure */
+    if ((Result != HostCmd_RESULT_OK || !(RespCmd & 0x8000))) {
+        PRINTM(ERROR, "CMD_RESP: cmd %#x error, result=%#x\n",
+               resp->Command, resp->Result);
+        umd_dbg("Error!!! CMD_RESP: cmd %#x error, result=%#x\n",
+               resp->Command, resp->Result);
+        /*
+         * Handling errors here
+         */
+        switch (RespCmd) {
+        case HostCmd_RET_HW_SPEC_INFO:
+            PRINTM(INFO, "CMD_RESP: HW spec command Failed\n");
+            umd_dbg("CMD_RESP: HW spec command Failed\n");
+            break;
+
+        }
+
+        CleanupAndInsertCmd(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+        return WLAN_STATUS_FAILURE;
+    }
+
+    switch (RespCmd) {
+    case HostCmd_RET_MAC_REG_ACCESS:
+    case HostCmd_RET_BBP_REG_ACCESS:
+    case HostCmd_RET_RF_REG_ACCESS:
+        ret = wlan_ret_reg_access(priv, RespCmd, resp);
+        break;
+
+    case HostCmd_RET_HW_SPEC_INFO:
+        ret = wlan_ret_get_hw_spec(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_BG_SCAN_QUERY:
+        {
+            union iwreq_data wrqu;
+
+            ret = wlan_ret_802_11_scan(priv, resp);
+            memset(&wrqu, 0, sizeof(union iwreq_data));
+            wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu,
+                                NULL);
+            PRINTM(INFO, "CMD_RESP: BG_SCAN result is ready!\n");
+            break;
+        }
+    case HostCmd_RET_802_11_SCAN:
+        ret = wlan_ret_802_11_scan(priv, resp);
+        break;
+
+    case HostCmd_RET_MAC_CONTROL:
+        ret = wlan_ret_mac_control(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_GET_LOG:
+        ret = wlan_ret_get_log(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_ASSOCIATE:
+    case HostCmd_RET_802_11_REASSOCIATE:
+        ret = wlan_ret_802_11_associate(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_DISASSOCIATE:
+    case HostCmd_RET_802_11_DEAUTHENTICATE:
+        ret = wlan_ret_802_11_disassociate(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_SET_WEP:
+        ret = wlan_ret_802_11_set_wep(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_AD_HOC_START:
+    case HostCmd_RET_802_11_AD_HOC_JOIN:
+        ret = wlan_ret_802_11_ad_hoc(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_RESET:
+        ret = wlan_ret_802_11_reset(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_AUTHENTICATE:
+        ret = wlan_ret_802_11_authenticate(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_STAT:
+        ret = wlan_ret_802_11_stat(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_SNMP_MIB:
+        ret = wlan_ret_802_11_snmp_mib(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_RF_TX_POWER:
+        ret = wlan_ret_802_11_rf_tx_power(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_RADIO_CONTROL:
+        ret = wlan_ret_802_11_radio_control(priv, resp);
+        break;
+    case HostCmd_RET_802_11_HOST_SLEEP_CFG:
+        ret = wlan_ret_host_sleep_cfg(priv, resp);
+        break;
+    case HostCmd_RET_802_11_HOST_SLEEP_AWAKE_CONFIRM:
+        break;
+
+    case HostCmd_RET_802_11_SET_AFC:
+    case HostCmd_RET_802_11_GET_AFC:
+        memmove(Adapter->CurCmd->pdata_buf,
+                &resp->params.afc, sizeof(HostCmd_DS_802_11_AFC));
+
+        break;
+    case HostCmd_RET_802_11_RF_ANTENNA:
+        ret = wlan_ret_802_11_rf_antenna(priv, resp);
+        break;
+
+    case HostCmd_RET_MAC_MULTICAST_ADR:
+        ret = wlan_ret_mac_multicast_adr(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_RATE_ADAPT_RATESET:
+        ret = wlan_ret_802_11_rate_adapt_rateset(priv, resp);
+        break;
+    case HostCmd_RET_802_11_RF_CHANNEL:
+        ret = wlan_ret_802_11_rf_channel(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_RSSI:
+        ret = wlan_ret_802_11_rssi(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_MAC_ADDRESS:
+        ret = wlan_ret_802_11_mac_address(priv, resp);
+        break;
+
+#ifdef MFG_CMD_SUPPORT
+    case HostCmd_RET_MFG_COMMAND:
+        ret = wlan_ret_mfg_cmd(priv, resp);
+        break;
+#endif
+    case HostCmd_RET_802_11_AD_HOC_STOP:
+        ret = wlan_ret_802_11_ad_hoc_stop(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_BEACON_STOP:
+        break;
+
+    case HostCmd_RET_802_11_CAL_DATA_EXT:
+        ret = wlan_ret_802_11_cal_data_ext(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_ENABLE_RSN:
+        break;
+    case HostCmd_RET_802_11_KEY_MATERIAL:
+        ret = wlan_ret_802_11_key_material(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_EEPROM_ACCESS:
+        ret = wlan_ret_802_11_eeprom_access(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11D_DOMAIN_INFO:
+        ret = wlan_ret_802_11d_domain_info(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_SLEEP_PARAMS:
+        ret = wlan_ret_802_11_sleep_params(priv, resp);
+        break;
+    case HostCmd_RET_802_11_BCA_CONFIG_TIMESHARE:
+        ret = wlan_ret_802_11_bca_timeshare(priv, resp);
+        break;
+    case HostCmd_RET_802_11_INACTIVITY_TIMEOUT:
+        *((u16 *) Adapter->CurCmd->pdata_buf) =
+            wlan_le16_to_cpu(resp->params.inactivity_timeout.Timeout);
+        break;
+    case HostCmd_RET_802_11_BG_SCAN_CONFIG:
+        break;
+
+    case HostCmd_RET_802_11_FW_WAKEUP_METHOD:
+        ret = wlan_ret_fw_wakeup_method(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_SLEEP_PERIOD:
+        ret = wlan_ret_802_11_sleep_period(priv, resp);
+        break;
+    case HostCmd_RET_WMM_ACK_POLICY:
+        ret = wlan_cmdresp_wmm_ack_policy(priv, resp);
+        break;
+    case HostCmd_RET_WMM_GET_STATUS:
+        ret = wlan_cmdresp_wmm_get_status(priv, resp);
+        break;
+    case HostCmd_RET_WMM_ADDTS_REQ:
+        ret = wlan_cmdresp_wmm_addts_req(priv, resp);
+        break;
+    case HostCmd_RET_WMM_DELTS_REQ:
+        ret = wlan_cmdresp_wmm_delts_req(priv, resp);
+        break;
+    case HostCmd_RET_WMM_QUEUE_CONFIG:
+        ret = wlan_cmdresp_wmm_queue_config(priv, resp);
+        break;
+    case HostCmd_RET_WMM_QUEUE_STATS:
+        ret = wlan_cmdresp_wmm_queue_stats(priv, resp);
+        break;
+    case HostCmd_RET_802_11_TPC_CFG:
+        memmove(Adapter->CurCmd->pdata_buf,
+                &resp->params.tpccfg, sizeof(HostCmd_DS_802_11_TPC_CFG));
+        break;
+    case HostCmd_RET_802_11_LED_GPIO_CTRL:
+        memmove(Adapter->CurCmd->pdata_buf,
+                &resp->params.ledgpio, sizeof(HostCmd_DS_802_11_LED_CTRL));
+        break;
+
+    case HostCmd_RET_GET_TSF:
+        resp->params.gettsf.TsfValue =
+            wlan_le64_to_cpu(resp->params.gettsf.TsfValue);
+        memcpy(priv->adapter->CurCmd->pdata_buf,
+               &resp->params.gettsf.TsfValue, sizeof(u64));
+        break;
+    case HostCmd_RTE_802_11_TX_RATE_QUERY:
+        priv->adapter->TxRate = wlan_le16_to_cpu(resp->params.txrate.TxRate);
+        break;
+    case HostCmd_RET_802_11_IBSS_COALESCING_STATUS:
+        wlan_ret_802_11_IBSS_Coalesced_Status(priv, resp);
+        break;
+
+    case HostCmd_RET_802_11_LDO_CONFIG:
+        resp->params.ldocfg.Action =
+            wlan_le16_to_cpu(resp->params.ldocfg.Action);
+        resp->params.ldocfg.PMSource =
+            wlan_le16_to_cpu(resp->params.ldocfg.PMSource);
+        memmove(Adapter->CurCmd->pdata_buf, &resp->params.ldocfg,
+                sizeof(HostCmd_DS_802_11_LDO_CONFIG));
+        break;
+
+    default:
+        PRINTM(INFO, "CMD_RESP: Unknown command response %#x\n",
+               resp->Command);
+        break;
+    }
+
+    if (Adapter->CurCmd) {
+        /* Clean up and Put current command back to CmdFreeQ */
+        CleanupAndInsertCmd(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+#if WIRELESS_EXT >= 18
+/** 
+ *  @brief This function sends mic error event to application.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @para event    MIC ERROR EVENT. 
+ *  @return 	   n/a
+ */
+void
+send_mic_error_event(wlan_private * priv, u32 event)
+{
+    union iwreq_data iwrq;
+    struct iw_michaelmicfailure mic;
+
+    ENTER();
+
+    memset(&iwrq, 0, sizeof(iwrq));
+    memset(&mic, 0, sizeof(mic));
+    if (event == MACREG_INT_CODE_MIC_ERR_UNICAST) {
+        mic.flags = IW_MICFAILURE_PAIRWISE;
+    } else {
+        mic.flags = IW_MICFAILURE_GROUP;
+    }
+
+    iwrq.data.pointer = &mic;
+    iwrq.data.length = sizeof(mic);
+
+    wireless_send_event(priv->wlan_dev.netdev, IWEVMICHAELMICFAILURE, &iwrq,
+                        (u8 *) & mic);
+
+    LEAVE();
+    return;
+}
+#endif
+
+/** 
+ *  @brief This function handles events generated by firmware
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_process_event(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    u32 eventcause = Adapter->EventCause >> SBI_EVENT_CAUSE_SHIFT;
+
+    ENTER();
+
+    if (eventcause != MACREG_INT_CODE_PS_SLEEP &&
+        eventcause != MACREG_INT_CODE_PS_AWAKE)
+        PRINTM(EVENT, "EVENT: 0x%x @ %lu\n", eventcause, os_time_get());
+
+    switch (eventcause) {
+    case MACREG_INT_CODE_DUMMY_HOST_WAKEUP_SIGNAL:
+        PRINTM(INFO, "EVENT: DUMMY_HOST_WAKEUP_SIGNAL\n");
+        break;
+    case MACREG_INT_CODE_LINK_SENSED:
+        PRINTM(INFO, "EVENT: LINK_SENSED\n");
+        Adapter->AdhocLinkSensed = TRUE;
+        os_carrier_on(priv);
+        os_start_queue(priv);
+        send_iwevcustom_event(priv, CUS_EVT_ADHOC_LINK_SENSED);
+        break;
+
+    case MACREG_INT_CODE_DEAUTHENTICATED:
+        PRINTM(INFO, "EVENT: Deauthenticated\n");
+        Adapter->dbg.num_event_deauth++;
+        HandleDisconnectEvent(priv);
+        break;
+
+    case MACREG_INT_CODE_DISASSOCIATED:
+        PRINTM(INFO, "EVENT: Disassociated\n");
+        Adapter->dbg.num_event_disassoc++;
+        HandleDisconnectEvent(priv);
+        break;
+
+    case MACREG_INT_CODE_LINK_LOSE_NO_SCAN:
+        PRINTM(INFO, "EVENT: Link lost\n");
+        Adapter->dbg.num_event_link_lost++;
+        HandleDisconnectEvent(priv);
+        break;
+
+    case MACREG_INT_CODE_PS_SLEEP:
+        PRINTM(INFO, "EVENT: SLEEP\n");
+        PRINTM(EVENT, "_");
+
+        /* handle unexpected PS SLEEP event */
+        if (Adapter->PSState == PS_STATE_FULL_POWER) {
+            PRINTM(INFO, "EVENT: In FULL POWER mode - ignore PS SLEEP\n");
+            break;
+        }
+        Adapter->PSState = PS_STATE_PRE_SLEEP;
+
+        PSConfirmSleep(priv, (u16) Adapter->PSMode);
+
+        break;
+
+    case MACREG_INT_CODE_PS_AWAKE:
+        PRINTM(INFO, "EVENT: AWAKE \n");
+        PRINTM(EVENT, "|");
+
+        /* handle unexpected PS AWAKE event */
+        if (Adapter->PSState == PS_STATE_FULL_POWER) {
+            PRINTM(INFO, "EVENT: In FULL POWER mode - ignore PS AWAKE\n");
+            break;
+        }
+
+        Adapter->TxLockFlag = FALSE;
+        if (TRUE == CheckLastPacketIndication(priv)) {
+            if (!priv->wlan_dev.dnld_sent && Adapter->gen_null_pkg) {
+                SendNullPacket(priv, MRVDRV_TxPD_POWER_MGMT_NULL_PACKET |
+                               MRVDRV_TxPD_POWER_MGMT_LAST_PACKET);
+                Adapter->TxLockFlag = TRUE;
+            }
+        }
+
+        Adapter->PSState = PS_STATE_AWAKE;
+
+        if (Adapter->NeedToWakeup == TRUE) {
+            /*
+             * wait for the command processing to finish
+             * before resuming sending 
+             * Adapter->NeedToWakeup will be set to FALSE 
+             * in PSWakup()
+             */
+            PRINTM(INFO, "Waking up...\n");
+            PSWakeup(priv, 0);
+        }
+        break;
+
+    case MACREG_INT_CODE_DEEP_SLEEP_AWAKE:
+        sbi_reset_deepsleep_wakeup(priv);
+        PRINTM(INFO, "EVENT: DS_AWAKE\n");
+        if (priv->adapter->IsDeepSleep == TRUE) {
+            Adapter->IsDeepSleep = FALSE;
+            priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+            priv->adapter->HisRegCpy |= HIS_TxDnLdRdy;
+            send_iwevcustom_event(priv, CUS_EVT_DEEP_SLEEP_AWAKE);
+            wake_up_interruptible(&Adapter->ds_awake_q);
+        }
+        break;
+
+    case MACREG_INT_CODE_HOST_SLEEP_AWAKE:
+        PRINTM(INFO, "EVENT: HS_AWAKE\n");
+        Adapter->bWakeupDevRequired = FALSE;
+        Adapter->WakeupTries = 0;
+        sbi_reset_deepsleep_wakeup(priv);
+        /*
+         * in BG SCAN mode w/ deep sleep, WAKE UP event
+         * will be sent first, Deep Sleep Awake will
+         * be sent later.
+         */
+        if (priv->adapter->IsDeepSleep == TRUE) {
+            priv->adapter->IsDeepSleep = FALSE;
+            priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+            priv->adapter->HisRegCpy |= HIS_TxDnLdRdy;
+
+            send_iwevcustom_event(priv, CUS_EVT_DEEP_SLEEP_AWAKE);
+            wake_up_interruptible(&Adapter->ds_awake_q);
+        }
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_HOST_SLEEP_AWAKE_CONFIRM,
+                                    0, 0, 0, NULL);
+        break;
+
+    case MACREG_INT_CODE_MIC_ERR_UNICAST:
+        PRINTM(INFO, "EVENT: UNICAST MIC ERROR\n");
+#if WIRELESS_EXT >= 18
+        send_mic_error_event(priv, MACREG_INT_CODE_MIC_ERR_UNICAST);
+#else
+        send_iwevcustom_event(priv, CUS_EVT_MLME_MIC_ERR_UNI);
+#endif
+        break;
+
+    case MACREG_INT_CODE_MIC_ERR_MULTICAST:
+        PRINTM(INFO, "EVENT: MULTICAST MIC ERROR\n");
+#if WIRELESS_EXT >= 18
+        send_mic_error_event(priv, MACREG_INT_CODE_MIC_ERR_MULTICAST);
+#else
+        send_iwevcustom_event(priv, CUS_EVT_MLME_MIC_ERR_MUL);
+#endif
+        break;
+    case MACREG_INT_CODE_MIB_CHANGED:
+    case MACREG_INT_CODE_INIT_DONE:
+        break;
+
+    case MACREG_INT_CODE_ADHOC_BCN_LOST:
+        PRINTM(INFO, "EVENT: ADHOC_BCN_LOST\n");
+        Adapter->AdhocLinkSensed = FALSE;
+        /* Free Tx and Rx packets */
+        os_free_tx_packet(priv);
+        wlan_send_rxskbQ(priv);
+        /* report disconnect to upper layer */
+        os_stop_queue(priv);
+        os_carrier_off(priv);
+        send_iwevcustom_event(priv, CUS_EVT_ADHOC_BCN_LOST);
+        break;
+
+    case MACREG_INT_CODE_BG_SCAN_REPORT:
+        PRINTM(INFO, "EVENT: BGS_REPORT\n");
+        Adapter->bgScanConfig->Enable = FALSE;
+        ret = sendBgScanQueryCmd(priv);
+        break;
+    case MACREG_INT_CODE_WMM_STATUS_CHANGE:
+        PRINTM(INFO, "EVENT: WMM status changed\n");
+        ret = sendWMMStatusChangeCmd(priv);
+        break;
+
+    case MACREG_INT_CODE_RSSI_LOW:
+        PRINTM(INFO, "EVENT: RSSI_LOW\n");
+        send_iwevcustom_event(priv, CUS_EVT_BEACON_RSSI_LOW);
+        break;
+    case MACREG_INT_CODE_SNR_LOW:
+        PRINTM(INFO, "EVENT: SNR_LOW\n");
+        send_iwevcustom_event(priv, CUS_EVT_BEACON_SNR_LOW);
+        break;
+    case MACREG_INT_CODE_MAX_FAIL:
+        PRINTM(INFO, "EVENT: MAX_FAIL\n");
+        send_iwevcustom_event(priv, CUS_EVT_MAX_FAIL);
+        break;
+    case MACREG_INT_CODE_RSSI_HIGH:
+        PRINTM(INFO, "EVENT: RSSI_HIGH\n");
+        send_iwevcustom_event(priv, CUS_EVT_BEACON_RSSI_HIGH);
+        break;
+    case MACREG_INT_CODE_SNR_HIGH:
+        PRINTM(INFO, "EVENT: SNR_HIGH\n");
+        send_iwevcustom_event(priv, CUS_EVT_BEACON_SNR_HIGH);
+        break;
+    case MACREG_INT_CODE_IBSS_COALESCED:
+        PRINTM(INFO, "EVENT: IBSS_COALESCED\n");
+        ret = sendADHOCBSSIDQuery(priv);
+        break;
+    default:
+        PRINTM(INFO, "EVENT: unknown event id: %#x\n", eventcause);
+        break;
+    }
+
+    Adapter->EventCause = 0;
+    LEAVE();
+    return ret;
+}
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_debug.c b/drivers/net/wireless/8686_wlan/wlan/wlan_debug.c
new file mode 100644
index 0000000..c9fe311
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_debug.c
@@ -0,0 +1,292 @@
+/** @file wlan_debug.c
+  * @brief This file contains functions for debug proc file.
+  *   
+  * (c) Copyright © 2003-2006, Marvell International Ltd.  
+  *   
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	10/04/05: Add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	
+********************************************************/
+
+#include  "include.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+#define item_size(n) (sizeof ((wlan_adapter *)0)->n)
+#define item_addr(n) ((u32) &((wlan_adapter *)0)->n)
+
+#define item_dbg_size(n) (sizeof (((wlan_adapter *)0)->dbg.n))
+#define item_dbg_addr(n) ((u32) &(((wlan_adapter *)0)->dbg.n))
+
+#define item1_size(n) (sizeof ((wlan_dev_t *)0)->n)
+#define item1_addr(n) ((u32) &((wlan_dev_t *)0)->n)
+
+struct debug_data
+{
+    char name[32];
+    u32 size;
+    u32 addr;
+    u32 offset;
+};
+
+/* To debug any member of wlan_adapter or wlan_dev_t, simply add one line here.
+ */
+#define ITEMS_FROM_WLAN_DEV		1
+
+static struct debug_data items[] = {
+    {"IntCounter", item_size(IntCounter), 0, item_addr(IntCounter)},
+    {"ConnectStatus", item_size(MediaConnectStatus), 0,
+     item_addr(MediaConnectStatus)},
+    {"TxSkbNum", item_size(TxSkbNum), 0, item_addr(TxSkbNum)},
+    {"PSMode", item_size(PSMode), 0, item_addr(PSMode)},
+    {"PSState", item_size(PSState), 0, item_addr(PSState)},
+    {"HS_Configured", item_size(bHostSleepConfigured), 0,
+     item_addr(bHostSleepConfigured)},
+    {"WakeupDevReq", item_size(bWakeupDevRequired), 0,
+     item_addr(bWakeupDevRequired)},
+    {"WakeupTries", item_size(WakeupTries), 0, item_addr(WakeupTries)},
+    {"num_tx_timeout", item_dbg_size(num_tx_timeout), 0,
+     item_dbg_addr(num_tx_timeout)},
+    {"num_cmd_timeout", item_dbg_size(num_cmd_timeout), 0,
+     item_dbg_addr(num_cmd_timeout)},
+    {"TimeoutCmdId", item_dbg_size(TimeoutCmdId), 0,
+     item_dbg_addr(TimeoutCmdId)},
+    {"TimeoutCmdAct", item_dbg_size(TimeoutCmdAct), 0,
+     item_dbg_addr(TimeoutCmdAct)},
+    {"LastCmdId", item_dbg_size(LastCmdId), 0, item_dbg_addr(LastCmdId)},
+    {"LastCmdRespId", item_dbg_size(LastCmdRespId), 0,
+     item_dbg_addr(LastCmdRespId)},
+    {"num_cmd_h2c_fail", item_dbg_size(num_cmd_host_to_card_failure), 0,
+     item_dbg_addr(num_cmd_host_to_card_failure)},
+    {"num_cmd_sleep_cfm_fail",
+     item_dbg_size(num_cmd_sleep_cfm_host_to_card_failure), 0,
+     item_dbg_addr(num_cmd_sleep_cfm_host_to_card_failure)},
+    {"num_tx_h2c_fail", item_dbg_size(num_tx_host_to_card_failure), 0,
+     item_dbg_addr(num_tx_host_to_card_failure)},
+    {"num_evt_deauth", item_dbg_size(num_event_deauth), 0,
+     item_dbg_addr(num_event_deauth)},
+    {"num_evt_disassoc", item_dbg_size(num_event_disassoc), 0,
+     item_dbg_addr(num_event_disassoc)},
+    {"num_evt_link_lost", item_dbg_size(num_event_link_lost), 0,
+     item_dbg_addr(num_event_link_lost)},
+    {"num_cmd_deauth", item_dbg_size(num_cmd_deauth), 0,
+     item_dbg_addr(num_cmd_deauth)},
+    {"num_cmd_assoc_ok", item_dbg_size(num_cmd_assoc_success), 0,
+     item_dbg_addr(num_cmd_assoc_success)},
+    {"num_cmd_assoc_fail", item_dbg_size(num_cmd_assoc_failure), 0,
+     item_dbg_addr(num_cmd_assoc_failure)},
+
+    {"dnld_sent", item1_size(dnld_sent), 0, item1_addr(dnld_sent)},
+};
+
+static int num_of_items = sizeof(items) / sizeof(items[0]);
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief convert string to number
+ *
+ *  @param s   	   pointer to numbered string
+ *  @return 	   converted number from string s
+ */
+int
+string_to_number(char *s)
+{
+    int r = 0;
+    int base = 0;
+
+    if ((strncmp(s, "0x", 2) == 0) || (strncmp(s, "0X", 2) == 0))
+        base = 16;
+    else
+        base = 10;
+    if (base == 16)
+        s += 2;
+    for (s = s; *s != 0; s++) {
+        if ((*s >= 48) && (*s <= 57))
+            r = (r * base) + (*s - 48);
+        else if ((*s >= 65) && (*s <= 70))
+            r = (r * base) + (*s - 55);
+        else if ((*s >= 97) && (*s <= 102))
+            r = (r * base) + (*s - 87);
+        else
+            break;
+    }
+
+    return r;
+}
+
+/** 
+ *  @brief proc read function
+ *
+ *  @param page	   pointer to buffer
+ *  @param s       read data starting position
+ *  @param off     offset
+ *  @param cnt     counter 
+ *  @param eof     end of file flag
+ *  @param data    data to output
+ *  @return 	   number of output data
+ */
+static int
+wlan_debug_read(char *page, char **s, off_t off, int cnt, int *eof,
+                void *data)
+{
+    int val = 0;
+    char *p = page;
+    int i;
+
+    struct debug_data *d = (struct debug_data *) data;
+
+    MODULE_GET;
+
+    for (i = 0; i < num_of_items; i++) {
+        if (d[i].size == 1)
+            val = *((u8 *) d[i].addr);
+        else if (d[i].size == 2)
+            val = *((u16 *) d[i].addr);
+        else if (d[i].size == 4)
+            val = *((u32 *) d[i].addr);
+        if (strstr(d[i].name, "Id"))
+            p += sprintf(p, "%s=0x%x\n", d[i].name, val);
+        else
+            p += sprintf(p, "%s=%d\n", d[i].name, val);
+    }
+    MODULE_PUT;
+    return p - page;
+}
+
+/** 
+ *  @brief proc write function
+ *
+ *  @param f	   file pointer
+ *  @param buf     pointer to data buffer
+ *  @param cnt     data number to write
+ *  @param data    data to write
+ *  @return 	   number of data
+ */
+static int
+wlan_debug_write(struct file *f, const char *buf, unsigned long cnt,
+                 void *data)
+{
+    int r, i;
+    char *pdata;
+    char *p;
+    char *p0;
+    char *p1;
+    char *p2;
+    struct debug_data *d = (struct debug_data *) data;
+
+    MODULE_GET;
+
+    pdata = (char *) kmalloc(cnt, GFP_KERNEL);
+    if (pdata == NULL) {
+        MODULE_PUT;
+        return 0;
+    }
+
+    if (copy_from_user(pdata, buf, cnt)) {
+        PRINTM(INFO, "Copy from user failed\n");
+        kfree(pdata);
+        MODULE_PUT;
+        return 0;
+    }
+
+    p0 = pdata;
+    for (i = 0; i < num_of_items; i++) {
+        do {
+            p = strstr(p0, d[i].name);
+            if (p == NULL)
+                break;
+            p1 = strchr(p, '\n');
+            if (p1 == NULL)
+                break;
+            p0 = p1++;
+            p2 = strchr(p, '=');
+            if (!p2)
+                break;
+            p2++;
+            r = string_to_number(p2);
+            if (d[i].size == 1)
+                *((u8 *) d[i].addr) = (u8) r;
+            else if (d[i].size == 2)
+                *((u16 *) d[i].addr) = (u16) r;
+            else if (d[i].size == 4)
+                *((u32 *) d[i].addr) = (u32) r;
+            break;
+        } while (TRUE);
+    }
+    kfree(pdata);
+    MODULE_PUT;
+    return cnt;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+/** 
+ *  @brief create debug proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @param dev     pointer net_device
+ *  @return 	   N/A
+ */
+void
+wlan_debug_entry(wlan_private * priv, struct net_device *dev)
+{
+    int i;
+    struct proc_dir_entry *r;
+
+    if (priv->proc_entry == NULL)
+        return;
+
+    for (i = 0; i < (num_of_items - ITEMS_FROM_WLAN_DEV); i++) {
+        items[i].addr = items[i].offset + (u32) priv->adapter;
+    }
+    for (i = num_of_items - ITEMS_FROM_WLAN_DEV; i < num_of_items; i++) {
+        items[i].addr = items[i].offset + (u32) & priv->wlan_dev;
+    }
+    r = create_proc_entry("debug", 0644, priv->proc_entry);
+    if (r == NULL)
+        return;
+
+    r->data = &items[0];
+    r->read_proc = wlan_debug_read;
+    r->write_proc = wlan_debug_write;
+    r->owner = THIS_MODULE;
+
+}
+
+/** 
+ *  @brief remove proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @return 	   N/A
+ */
+void
+wlan_debug_remove(wlan_private * priv)
+{
+    remove_proc_entry("debug", priv->proc_entry);
+}
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_decl.h b/drivers/net/wireless/8686_wlan/wlan/wlan_decl.h
new file mode 100644
index 0000000..f486b14
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_decl.h
@@ -0,0 +1,113 @@
+/** @file wlan_decl.h
+ *  @brief This file contains declaration referring to
+ *  functions defined in other source files
+ *     
+ *  (c) Copyright © 2003-2007, Marvell International Ltd.  
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/******************************************************
+Change log:
+	09/29/05: add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join structures.
+	          Move wlan_wext statics to their source file.
+******************************************************/
+
+#ifndef _WLAN_DECL_H_
+#define _WLAN_DECL_H_
+
+/** Function Prototype Declaration */
+int wlan_tx_packet(wlan_private * priv, struct sk_buff *skb);
+void wlan_free_adapter(wlan_private * priv);
+int SetMacPacketFilter(wlan_private * priv);
+
+int SendNullPacket(wlan_private * priv, u8 pwr_mgmt);
+BOOLEAN CheckLastPacketIndication(wlan_private * priv);
+
+void Wep_encrypt(wlan_private * priv, u8 * Buf, u32 Len);
+int FreeCmdBuffer(wlan_private * priv);
+void CleanUpCmdCtrlNode(CmdCtrlNode * pTempNode);
+CmdCtrlNode *GetFreeCmdCtrlNode(wlan_private * priv);
+
+void SetCmdCtrlNode(wlan_private * priv,
+                    CmdCtrlNode * pTempNode,
+                    WLAN_OID cmd_oid, u16 wait_option, void *pdata_buf);
+
+BOOLEAN Is_Command_Allowed(wlan_private * priv);
+
+int PrepareAndSendCommand(wlan_private * priv,
+                          u16 cmd_no,
+                          u16 cmd_action,
+                          u16 wait_option, WLAN_OID cmd_oid, void *pdata_buf);
+
+void QueueCmd(wlan_adapter * Adapter, CmdCtrlNode * CmdNode, BOOLEAN addtail);
+
+int SetDeepSleep(wlan_private * priv, BOOLEAN bDeepSleep);
+int AllocateCmdBuffer(wlan_private * priv);
+int ExecuteNextCommand(wlan_private * priv);
+int wlan_process_event(wlan_private * priv);
+void wlan_interrupt(struct net_device *);
+int SetRadioControl(wlan_private * priv);
+u32 index_to_data_rate(u8 index);
+u8 data_rate_to_index(u32 rate);
+void HexDump(char *prompt, u8 * data, int len);
+void get_version(wlan_adapter * adapter, char *version, int maxlen);
+void wlan_read_write_rfreg(wlan_private * priv);
+
+/** The proc fs interface */
+void wlan_proc_entry(wlan_private * priv, struct net_device *dev);
+void wlan_proc_remove(wlan_private * priv);
+void wlan_debug_entry(wlan_private * priv, struct net_device *dev);
+void wlan_debug_remove(wlan_private * priv);
+int wlan_process_rx_command(wlan_private * priv);
+void wlan_process_tx(wlan_private * priv);
+void CleanupAndInsertCmd(wlan_private * priv, CmdCtrlNode * pTempCmd);
+void MrvDrvCommandTimerFunction(void *FunctionContext);
+
+#ifdef REASSOCIATION
+void MrvDrvTimerFunction(void *FunctionContext);
+#endif /* REASSOCIATION */
+
+int wlan_set_essid(struct net_device *dev, struct iw_request_info *info,
+                   struct iw_point *dwrq, char *extra);
+int wlan_set_regiontable(wlan_private * priv, u8 region, u8 band);
+void wlan_clean_txrx(wlan_private * priv);
+
+int wlan_host_sleep_activated_event(wlan_private * priv);
+int wlan_deep_sleep_ioctl(wlan_private * priv, struct ifreq *rq);
+
+int ProcessRxedPacket(wlan_private * priv, struct sk_buff *);
+
+void PSSleep(wlan_private * priv, int wait_option);
+void PSConfirmSleep(wlan_private * priv, u16 PSMode);
+void PSWakeup(wlan_private * priv, int wait_option);
+
+void wlan_send_rxskbQ(wlan_private * priv);
+
+extern CHANNEL_FREQ_POWER *find_cfp_by_band_and_channel(wlan_adapter *
+                                                        adapter, u8 band,
+                                                        u16 channel);
+
+extern void MacEventDisconnected(wlan_private * priv);
+
+#if WIRELESS_EXT > 14
+void send_iwevcustom_event(wlan_private * priv, s8 * str);
+#endif
+
+void cleanup_txqueues(wlan_private * priv);
+void wlan_process_txqueue(wlan_private * priv);
+
+#endif /* _WLAN_DECL_H_ */
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_defs.h b/drivers/net/wireless/8686_wlan/wlan/wlan_defs.h
new file mode 100644
index 0000000..21bb9f6
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_defs.h
@@ -0,0 +1,652 @@
+/** @file wlan_defs.h
+ *  @brief This header file contains global constant/enum definitions,
+ *  global variable declaration.
+ *       
+ *  (c) Copyright © 2003-2007, Marvell International Ltd.   
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change log:
+	10/11/05: add Doxygen format comments 
+	01/11/06: Add NELEMENTS, BAND_XX defines
+	04/10/06: Add hostcmd generic API and power_adapt_cfg_ext command
+************************************************************/
+
+#ifndef _WLAN_DEFS_H_
+#define _WLAN_DEFS_H_
+
+#include	"os_defs.h"
+
+/** Double-Word(32Bit) Bit definition */
+#define DW_BIT_0	0x00000001
+#define DW_BIT_1	0x00000002
+#define DW_BIT_2	0x00000004
+#define DW_BIT_3	0x00000008
+#define DW_BIT_4	0x00000010
+#define DW_BIT_5	0x00000020
+#define DW_BIT_6	0x00000040
+#define DW_BIT_7	0x00000080
+#define DW_BIT_8	0x00000100
+#define DW_BIT_9	0x00000200
+#define DW_BIT_10	0x00000400
+#define DW_BIT_11       0x00000800
+#define DW_BIT_12       0x00001000
+#define DW_BIT_13       0x00002000
+#define DW_BIT_14       0x00004000
+#define DW_BIT_15       0x00008000
+#define DW_BIT_16       0x00010000
+#define DW_BIT_17       0x00020000
+#define DW_BIT_18       0x00040000
+#define DW_BIT_19       0x00080000
+#define DW_BIT_20       0x00100000
+#define DW_BIT_21       0x00200000
+#define DW_BIT_22       0x00400000
+#define DW_BIT_23       0x00800000
+#define DW_BIT_24       0x01000000
+#define DW_BIT_25       0x02000000
+#define DW_BIT_26       0x04000000
+#define DW_BIT_27       0x08000000
+#define DW_BIT_28       0x10000000
+#define DW_BIT_29       0x20000000
+#define DW_BIT_30	0x40000000
+#define DW_BIT_31	0x80000000
+
+/** Word (16bit) Bit Definition*/
+#define W_BIT_0		0x0001
+#define W_BIT_1		0x0002
+#define W_BIT_2		0x0004
+#define W_BIT_3		0x0008
+#define W_BIT_4		0x0010
+#define W_BIT_5		0x0020
+#define W_BIT_6		0x0040
+#define W_BIT_7		0x0080
+#define W_BIT_8		0x0100
+#define W_BIT_9		0x0200
+#define W_BIT_10	0x0400
+#define W_BIT_11	0x0800
+#define W_BIT_12	0x1000
+#define W_BIT_13	0x2000
+#define W_BIT_14	0x4000
+#define W_BIT_15	0x8000
+
+/** Byte (8Bit) Bit definition*/
+#define B_BIT_0		0x01
+#define B_BIT_1		0x02
+#define B_BIT_2		0x04
+#define B_BIT_3		0x08
+#define B_BIT_4		0x10
+#define B_BIT_5		0x20
+#define B_BIT_6		0x40
+#define B_BIT_7		0x80
+
+/** Debug Macro definition*/
+#ifdef	DEBUG_LEVEL1
+
+extern u32 drvdbg;
+extern u32 ifdbg;
+
+/* Debug message control bit definition for drvdbg */
+#define	DBG_MSG		DW_BIT_0
+#define DBG_FATAL	DW_BIT_1
+#define DBG_ERROR	DW_BIT_2
+#define DBG_DATA	DW_BIT_3
+#define DBG_CMND	DW_BIT_4
+#define DBG_EVENT	DW_BIT_5
+#define DBG_INTR	DW_BIT_6
+
+#define DBG_DAT_D	DW_BIT_16
+#define DBG_CMD_D	DW_BIT_17
+#define DBG_FW_D	DW_BIT_18
+
+#define DBG_ENTRY	DW_BIT_28
+#define DBG_WARN	DW_BIT_29
+#define DBG_INFO	DW_BIT_30
+
+/* Debug message control bit definition for ifdbg */
+#define DBG_IF_D	DW_BIT_0
+
+#ifdef	DEBUG_LEVEL2
+#define	PRINTM_INFO(msg...)  {if (drvdbg & DBG_INFO) printk(KERN_DEBUG msg);}
+#define	PRINTM_WARN(msg...)  {if (drvdbg & DBG_WARN) printk(KERN_DEBUG msg);}
+#define	PRINTM_ENTRY(msg...) {if (drvdbg & DBG_ENTRY) printk(KERN_DEBUG msg);}
+#else
+#define	PRINTM_INFO(msg...)  do {} while (0)
+#define	PRINTM_WARN(msg...)  do {} while (0)
+#define	PRINTM_ENTRY(msg...) do {} while (0)
+#endif /* DEBUG_LEVEL2 */
+
+#define	PRINTM_FW_D(msg...)  {if (drvdbg & DBG_FW_D) printk(KERN_DEBUG msg);}
+#define	PRINTM_CMD_D(msg...) {if (drvdbg & DBG_CMD_D) printk(KERN_DEBUG msg);}
+#define	PRINTM_DAT_D(msg...) {if (drvdbg & DBG_DAT_D) printk(KERN_DEBUG msg);}
+
+#define	PRINTM_INTR(msg...)  {if (drvdbg & DBG_INTR) printk(KERN_DEBUG msg);}
+#define	PRINTM_EVENT(msg...) {if (drvdbg & DBG_EVENT) printk(msg);}
+#define	PRINTM_CMND(msg...)  {if (drvdbg & DBG_CMND) printk(KERN_DEBUG msg);}
+#define	PRINTM_DATA(msg...)  {if (drvdbg & DBG_DATA) printk(KERN_DEBUG msg);}
+#define	PRINTM_ERROR(msg...) {if (drvdbg & DBG_ERROR) printk(KERN_DEBUG msg);}
+#define	PRINTM_FATAL(msg...) {if (drvdbg & DBG_FATAL) printk(KERN_DEBUG msg);}
+#define	PRINTM_MSG(msg...)   {if (drvdbg & DBG_MSG) printk(KERN_ALERT msg);}
+
+#define	PRINTM_IF_D(msg...)  {if (ifdbg & DBG_IF_D) printk(KERN_DEBUG msg);}
+
+#define	PRINTM(level,msg...) PRINTM_##level(msg)
+
+#else
+
+#define	PRINTM(level,msg...) do {} while (0)
+
+#endif /* DEBUG_LEVEL1 */
+
+#define ASSERT(cond)						\
+do {								\
+	if (!(cond))						\
+		PRINTM(INFO, "ASSERT: %s, %s:%i\n",		\
+		       __FUNCTION__, __FILE__, __LINE__);	\
+} while(0)
+
+#define	ENTER()			PRINTM(ENTRY, "Enter: %s, %s:%i\n", __FUNCTION__, \
+							__FILE__, __LINE__)
+#define	LEAVE()			PRINTM(ENTRY, "Leave: %s, %s:%i\n", __FUNCTION__, \
+							__FILE__, __LINE__)
+
+#if defined(DEBUG_LEVEL1) && defined(__KERNEL__)
+#define DBG_DUMP_BUF_LEN 	64
+#define MAX_DUMP_PER_LINE	16
+#define MAX_DATA_DUMP_LEN	48
+
+static inline void
+hexdump(char *prompt, u8 * buf, int len)
+{
+    int i;
+    char dbgdumpbuf[DBG_DUMP_BUF_LEN];
+    char *ptr = dbgdumpbuf;
+
+    printk(KERN_DEBUG "%s:\n", prompt);
+    for (i = 1; i <= len; i++) {
+        ptr += sprintf(ptr, "%02x ", *buf);
+        buf++;
+        if (i % MAX_DUMP_PER_LINE == 0) {
+            *ptr = 0;
+            printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+            ptr = dbgdumpbuf;
+        }
+    }
+    if (len % MAX_DUMP_PER_LINE) {
+        *ptr = 0;
+        printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+    }
+}
+
+#ifdef  DEBUG_LEVEL2
+#define HEXDUMP(x,y,z)              {if (drvdbg & DBG_INFO) hexdump(x,y,z);}
+#else
+#define HEXDUMP(x,y,z)              do {} while (0)
+#endif
+#define DBG_HEXDUMP_CMD_D(x,y,z)    {if (drvdbg & DBG_CMD_D) hexdump(x,y,z);}
+#define DBG_HEXDUMP_DAT_D(x,y,z)    {if (drvdbg & DBG_DAT_D) hexdump(x,y,z);}
+#define DBG_HEXDUMP_IF_D(x,y,z)     {if (ifdbg & DBG_IF_D) hexdump(x,y,z);}
+
+#define	DBG_HEXDUMP(level,x,y,z)    DBG_HEXDUMP_##level(x,y,z)
+
+#else
+//temply add by feng
+#define HEXDUMP(x,y,z)              do {} while (0)
+#define DBG_HEXDUMP(level,x,y,z)    do {} while (0)
+#endif
+
+#ifndef	TRUE
+#define TRUE			1
+#endif
+#ifndef	FALSE
+#define	FALSE			0
+#endif
+
+#ifndef MIN
+#define MIN(a,b)		((a) < (b) ? (a) : (b))
+#endif
+
+#ifndef MAX
+#define MAX(a,b)		((a) > (b) ? (a) : (b))
+#endif
+
+#ifndef NELEMENTS
+#define NELEMENTS(x) (sizeof(x)/sizeof(x[0]))
+#endif
+
+/** Buffer Constants */
+
+/*	The size of SQ memory PPA, DPA are 8 DWORDs, that keep the physical
+*	addresses of TxPD buffers. Station has only 8 TxPD available, Whereas
+*	driver has more local TxPDs. Each TxPD on the host memory is associated 
+*	with a Tx control node. The driver maintains 8 RxPD descriptors for 
+*	station firmware to store Rx packet information.
+*
+*	Current version of MAC has a 32x6 multicast address buffer.
+*
+*	802.11b can have up to  14 channels, the driver keeps the
+*	BSSID(MAC address) of each APs or Ad hoc stations it has sensed.
+*/
+
+#define MRVDRV_SIZE_OF_PPA		0x00000008
+#define MRVDRV_SIZE_OF_DPA		0x00000008
+#define MRVDRV_NUM_OF_TxPD		0x00000020
+#define MRVDRV_NUM_OF_CMD_BUFFER        10
+#define MRVDRV_SIZE_OF_CMD_BUFFER       (2 * 1024)
+#define MRVDRV_MAX_BSSID_LIST		64
+#define MRVDRV_TIMER_10S		10000
+#define MRVDRV_TIMER_5S			5000
+#define MRVDRV_TIMER_1S			1000
+#define MRVDRV_SNAP_HEADER_LEN          8
+#define MRVDRV_ETH_HEADER_SIZE          14
+
+#define ARP_FILTER_MAX_BUF_SIZE		20
+
+#define	WLAN_UPLD_SIZE			2312
+#define DEV_NAME_LEN			32
+
+#ifndef	ETH_ALEN
+#define ETH_ALEN			6
+#endif
+
+/** Misc constants */
+/* This section defines 802.11 specific contants */
+#define SDIO_HEADER_LEN		4
+
+#define MRVDRV_MAX_REGION_CODE			7
+
+#define MRVDRV_IGNORE_MULTIPLE_DTIM		0xfffe
+#define MRVDRV_MIN_MULTIPLE_DTIM		1
+#define MRVDRV_MAX_MULTIPLE_DTIM		5
+#define MRVDRV_DEFAULT_MULTIPLE_DTIM		1
+
+#define MRVDRV_DEFAULT_LISTEN_INTERVAL		10
+#define MRVDRV_DEFAULT_LOCAL_LISTEN_INTERVAL		0
+
+#define	MRVDRV_CHANNELS_PER_SCAN		4
+#define	MRVDRV_MAX_CHANNELS_PER_SCAN		14
+
+#define	MRVDRV_CHANNELS_PER_ACTIVE_SCAN		14
+#define MRVDRV_MIN_BEACON_INTERVAL		20
+#define MRVDRV_MAX_BEACON_INTERVAL		1000
+#define MRVDRV_BEACON_INTERVAL			100
+
+/** TxPD Status */
+
+/*	Station firmware use TxPD status field to report final Tx transmit
+*	result, Bit masks are used to present combined situations.
+*/
+
+#define MRVDRV_TxPD_POWER_MGMT_NULL_PACKET 0x01
+#define MRVDRV_TxPD_POWER_MGMT_LAST_PACKET 0x08
+
+/** Tx control node status */
+
+#define MRVDRV_TX_CTRL_NODE_STATUS_IDLE      0x0000
+
+/* Link spped */
+#define MRVDRV_LINK_SPEED_1mbps          10000  /* in unit of 100bps */
+#define MRVDRV_LINK_SPEED_11mbps         110000
+
+/** RSSI-related defines */
+/*	RSSI constants are used to implement 802.11 RSSI threshold 
+*	indication. if the Rx packet signal got too weak for 5 consecutive
+*	times, miniport driver (driver) will report this event to wrapper
+*/
+
+#define MRVDRV_NF_DEFAULT_SCAN_VALUE		(-96)
+
+/** RTS/FRAG related defines */
+#define MRVDRV_RTS_MIN_VALUE		0
+#define MRVDRV_RTS_MAX_VALUE		2347
+#define MRVDRV_FRAG_MIN_VALUE		256
+#define MRVDRV_FRAG_MAX_VALUE		2346
+
+/* Fixed IE size is 8 bytes time stamp + 2 bytes beacon interval +
+ * 2 bytes cap */
+#define MRVL_FIXED_IE_SIZE      12
+
+/* This is for firmware specific length */
+#define EXTRA_LEN	36
+#define MRVDRV_MAXIMUM_ETH_PACKET_SIZE	1514
+
+#define MRVDRV_ETH_TX_PACKET_BUFFER_SIZE \
+	(MRVDRV_MAXIMUM_ETH_PACKET_SIZE + sizeof(TxPD) + EXTRA_LEN)
+
+#define MRVDRV_ETH_RX_PACKET_BUFFER_SIZE \
+	(MRVDRV_MAXIMUM_ETH_PACKET_SIZE + sizeof(RxPD) \
+	 + MRVDRV_SNAP_HEADER_LEN + EXTRA_LEN)
+
+#define	CMD_F_HOSTCMD		(1 << 0)
+
+/* to resolve CISCO AP extension */
+#define MRVDRV_SCAN_LIST_VAR_IE_SPACE  	256
+#define FW_IS_WPA_ENABLED(_adapter) \
+		(_adapter->fwCapInfo & FW_CAPINFO_WPA)
+
+#define FW_CAPINFO_WPA  	(1 << 0)
+#define WLAN_802_11_AI_REQFI_CAPABILITIES 	1
+#define WLAN_802_11_AI_REQFI_LISTENINTERVAL 	2
+#define WLAN_802_11_AI_REQFI_CURRENTAPADDRESS 	4
+
+#define WLAN_802_11_AI_RESFI_CAPABILITIES 	1
+#define WLAN_802_11_AI_RESFI_STATUSCODE 	2
+#define WLAN_802_11_AI_RESFI_ASSOCIATIONID 	4
+
+#define MRVL_NUM_WEP_KEY		4
+
+/** WPA Key LENGTH*/
+/* Support 4 keys per key set */
+#define MRVL_NUM_WPA_KEY_PER_SET        4
+#define MRVL_MAX_WPA_KEY_LENGTH 	32
+
+#define WPA_AES_KEY_LEN 		16
+#define WPA_TKIP_KEY_LEN 		32
+
+/* A few details needed for WEP (Wireless Equivalent Privacy) */
+/* 104 bits */
+#define MAX_KEY_SIZE		13
+/*40 bits RC4 - WEP*/
+#define MIN_KEY_SIZE		5
+
+#define RF_ANTENNA_1		0x1
+#define RF_ANTENNA_2		0x2
+#define RF_ANTENNA_AUTO		0xFFFF
+
+#define KEY_INFO_ENABLED	0x01
+
+/* For Wireless Extensions */
+#define		OID_MRVL_MFG_COMMAND	1
+
+#define SNR_BEACON		0
+#define SNR_RXPD		1
+#define NF_BEACON		2
+#define NF_RXPD			3
+
+/** MACRO DEFINITIONS */
+#define CAL_NF(NF)			((s32)(-(s32)(NF)))
+#define CAL_RSSI(SNR, NF) 		((s32)((s32)(SNR) + CAL_NF(NF)))
+#define SCAN_RSSI(RSSI)			(0x100 - ((u8)(RSSI)))
+
+#define DEFAULT_BCN_AVG_FACTOR		8
+#define DEFAULT_DATA_AVG_FACTOR		8
+#define MIN_BCN_AVG_FACTOR		1
+#define MAX_BCN_AVG_FACTOR		8
+#define MIN_DATA_AVG_FACTOR		1
+#define MAX_DATA_AVG_FACTOR		8
+#define AVG_SCALE			100
+#define CAL_AVG_SNR_NF(AVG, SNRNF, N)         \
+                        (((AVG) == 0) ? ((u16)(SNRNF) * AVG_SCALE) : \
+                        ((((int)(AVG) * (N -1)) + ((u16)(SNRNF) * \
+                        AVG_SCALE))  / N))
+
+#define WLAN_STATUS_SUCCESS			(0)
+#define WLAN_STATUS_FAILURE			(-1)
+#define WLAN_STATUS_NOT_ACCEPTED                (-2)
+
+#define	MAX_LEDS			8
+
+/* S_SWAP : To swap 2 u8 */
+#define S_SWAP(a,b) 	do { \
+				u8  t = SArr[a]; \
+				SArr[a] = SArr[b]; SArr[b] = t; \
+			} while(0)
+
+/* SWAP: swap u8 */
+#define SWAP_U8(a,b)	{u8 t; t=a; a=b; b=t;}
+
+/* SWAP: swap u8 */
+#define SWAP_U16(a,b)	{u16 t; t=a; a=b; b=t;}
+
+#define wlan_le16_to_cpu(x) x
+#define wlan_le32_to_cpu(x) x
+#define wlan_le64_to_cpu(x) x
+#define wlan_cpu_to_le16(x) x
+#define wlan_cpu_to_le32(x) x
+#define wlan_cpu_to_le64(x) x
+
+/** Global Varibale Declaration */
+typedef struct _wlan_private wlan_private;
+typedef struct _wlan_adapter wlan_adapter;
+typedef struct _HostCmd_DS_COMMAND HostCmd_DS_COMMAND;
+
+extern u32 DSFreqList[15];
+extern const char driver_version[];
+extern u32 DSFreqList[];
+extern u16 RegionCodeToIndex[MRVDRV_MAX_REGION_CODE];
+
+extern u8 WlanDataRates[WLAN_SUPPORTED_RATES];
+
+extern u8 SupportedRates[G_SUPPORTED_RATES];
+
+extern u8 AdhocRates_G[G_SUPPORTED_RATES];
+
+extern u8 AdhocRates_B[4];
+extern wlan_private *wlanpriv;
+
+#ifdef MFG_CMD_SUPPORT
+/* For the mfg command */
+typedef struct PkHeader
+{
+    u16 cmd;
+    u16 len;
+    u16 seq;
+    u16 result;
+    u32 MfgCmd;
+} PkHeader;
+
+#define SIOCCFMFG SIOCDEVPRIVATE
+#endif /* MFG_CMD_SUPPORT */
+
+/** ENUM definition*/
+/** SNRNF_TYPE */
+typedef enum _SNRNF_TYPE
+{
+    TYPE_BEACON = 0,
+    TYPE_RXPD,
+    MAX_TYPE_B
+} SNRNF_TYPE;
+
+/** SNRNF_DATA*/
+typedef enum _SNRNF_DATA
+{
+    TYPE_NOAVG = 0,
+    TYPE_AVG,
+    MAX_TYPE_AVG
+} SNRNF_DATA;
+
+/** WLAN_802_11_AUTH_ALG*/
+typedef enum _WLAN_802_11_AUTH_ALG
+{
+    AUTH_ALG_OPEN_SYSTEM = 1,
+    AUTH_ALG_SHARED_KEY = 2,
+    AUTH_ALG_NETWORK_EAP = 8,
+} WLAN_802_11_AUTH_ALG;
+
+/** WLAN_802_1X_AUTH_ALG */
+typedef enum _WLAN_802_1X_AUTH_ALG
+{
+    WLAN_1X_AUTH_ALG_NONE = 1,
+    WLAN_1X_AUTH_ALG_LEAP = 2,
+    WLAN_1X_AUTH_ALG_TLS = 4,
+    WLAN_1X_AUTH_ALG_TTLS = 8,
+    WLAN_1X_AUTH_ALG_MD5 = 16,
+} WLAN_802_1X_AUTH_ALG;
+
+/** WLAN_802_11_ENCRYPTION_MODE */
+typedef enum _WLAN_802_11_ENCRYPTION_MODE
+{
+    CIPHER_NONE,
+    CIPHER_WEP40,
+    CIPHER_TKIP,
+    CIPHER_CCMP,
+    CIPHER_WEP104,
+} WLAN_802_11_ENCRYPTION_MODE;
+
+/** WLAN_802_11_POWER_MODE */
+typedef enum _WLAN_802_11_POWER_MODE
+{
+    Wlan802_11PowerModeCAM,
+    Wlan802_11PowerModeMAX_PSP,
+    Wlan802_11PowerModeFast_PSP,
+
+    /*not a real mode, defined as an upper bound */
+    Wlan802_11PowerModeMax
+} WLAN_802_11_POWER_MODE, *PWLAN_802_11_POWER_MODE;
+
+/** PS_STATE */
+typedef enum _PS_STATE
+{
+    PS_STATE_FULL_POWER,
+    PS_STATE_AWAKE,
+    PS_STATE_PRE_SLEEP,
+    PS_STATE_SLEEP
+} PS_STATE;
+
+/** DNLD_STATE */
+typedef enum _DNLD_STATE
+{
+    DNLD_RES_RECEIVED,
+    DNLD_DATA_SENT,
+    DNLD_CMD_SENT
+} DNLD_STATE;
+
+/** WLAN_MEDIA_STATE */
+typedef enum _WLAN_MEDIA_STATE
+{
+    WlanMediaStateDisconnected,
+    WlanMediaStateConnected
+} WLAN_MEDIA_STATE, *PWLAN_MEDIA_STATE;
+
+/** WLAN_802_11_PRIVACY_FILTER */
+typedef enum _WLAN_802_11_PRIVACY_FILTER
+{
+    Wlan802_11PrivFilterAcceptAll,
+    Wlan802_11PrivFilter8021xWEP
+} WLAN_802_11_PRIVACY_FILTER, *PWLAN_802_11_PRIVACY_FILTER;
+
+/** mv_ms_type */
+typedef enum _mv_ms_type
+{
+    MVMS_DAT = 0,
+    MVMS_CMD = 1,
+    /* 2: reserved */
+    MVMS_EVENT = 3
+} mv_ms_type;
+
+/* Hardware status codes */
+typedef enum _WLAN_HARDWARE_STATUS
+{
+    WlanHardwareStatusReady,
+    WlanHardwareStatusInitializing,
+    WlanHardwareStatusReset,
+    WlanHardwareStatusClosing,
+    WlanHardwareStatusNotReady
+} WLAN_HARDWARE_STATUS, *PWLAN_HARDWARE_STATUS;
+
+/** WLAN_802_11_AUTHENTICATION_MODE */
+typedef enum _WLAN_802_11_AUTHENTICATION_MODE
+{
+    Wlan802_11AuthModeOpen = 0x00,
+    Wlan802_11AuthModeShared = 0x01,
+    Wlan802_11AuthModeNetworkEAP = 0x80,
+} WLAN_802_11_AUTHENTICATION_MODE, *PWLAN_802_11_AUTHENTICATION_MODE;
+
+/** WLAN_802_11_WEP_STATUS */
+typedef enum _WLAN_802_11_WEP_STATUS
+{
+    Wlan802_11WEPEnabled,
+    Wlan802_11WEPDisabled,
+    Wlan802_11WEPKeyAbsent,
+    Wlan802_11WEPNotSupported, Wlan802_11Encryption2Enabled,
+    Wlan802_11Encryption2KeyAbsent,
+    Wlan802_11Encryption3Enabled,
+    Wlan802_11Encryption3KeyAbsent
+} WLAN_802_11_WEP_STATUS, *PWLAN_802_11_WEP_STATUS,
+    WLAN_802_11_ENCRYPTION_STATUS, *PWLAN_802_11_ENCRYPTION_STATUS;
+
+/** SNMP_MIB_INDEX_e */
+typedef enum _SNMP_MIB_INDEX_e
+{
+    DesiredBssType_i = 0,
+    OpRateSet_i,
+    BcnPeriod_i,
+    DtimPeriod_i,
+    AssocRspTimeOut_i,
+    RtsThresh_i,
+    ShortRetryLim_i,
+    LongRetryLim_i,
+    FragThresh_i,
+    Dot11D_i,
+    Dot11H_i,
+    ManufId_i,
+    ProdId_i,
+    ManufOui_i,
+    ManufName_i,
+    ManufProdName_i,
+    ManufProdVer_i
+} SNMP_MIB_INDEX_e;
+
+/** KEY_TYPE_ID */
+typedef enum _KEY_TYPE_ID
+{
+    KEY_TYPE_ID_WEP = 0,
+    KEY_TYPE_ID_TKIP,
+    KEY_TYPE_ID_AES
+} KEY_TYPE_ID;
+
+/** KEY_INFO_WEP*/
+typedef enum _KEY_INFO_WEP
+{
+    KEY_INFO_WEP_DEFAULT_KEY = 0x01
+} KEY_INFO_WEP;
+
+/** KEY_INFO_TKIP */
+typedef enum _KEY_INFO_TKIP
+{
+    KEY_INFO_TKIP_MCAST = 0x01,
+    KEY_INFO_TKIP_UNICAST = 0x02,
+    KEY_INFO_TKIP_ENABLED = 0x04
+} KEY_INFO_TKIP;
+
+/** KEY_INFO_AES*/
+typedef enum _KEY_INFO_AES
+{
+    KEY_INFO_AES_MCAST = 0x01,
+    KEY_INFO_AES_UNICAST = 0x02,
+    KEY_INFO_AES_ENABLED = 0x04
+} KEY_INFO_AES;
+
+/** SNMP_MIB_VALUE_e */
+typedef enum _SNMP_MIB_VALUE_e
+{
+    SNMP_MIB_VALUE_INFRA = 1,
+    SNMP_MIB_VALUE_ADHOC
+} SNMP_MIB_VALUE_e;
+
+/** HWRateDropMode */
+typedef enum _HWRateDropMode
+{
+    NO_HW_RATE_DROP,
+    HW_TABLE_RATE_DROP,
+    HW_SINGLE_RATE_DROP
+} HWRateDropMode;
+
+#ifdef __KERNEL__
+extern struct iw_handler_def wlan_handler_def;
+struct iw_statistics *wlan_get_wireless_stats(struct net_device *dev);
+int wlan_do_ioctl(struct net_device *dev, struct ifreq *req, int i);
+#endif /* __KERNEL__ */
+#endif /* _WLAN_DEFS_H_ */
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_dev.h b/drivers/net/wireless/8686_wlan/wlan/wlan_dev.h
new file mode 100644
index 0000000..10052c0
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_dev.h
@@ -0,0 +1,481 @@
+/** @file wlan_dev.h
+ *  @brief This file contains definitions and data structures specific
+ *          to Marvell 802.11 NIC. It contains the Device Information
+ *          structure wlan_adapter.  
+ *  
+ *  (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *      
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change log:
+	09/26/05: add Doxygen format comments 
+	01/11/06: Conditionalize new scan/join structures.
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+		  implementation through generic hostcmd API
+	05/08/06: Remove PermanentAddr from Adapter
+
+ ************************************************************/
+
+#ifndef _WLAN_DEV_H_
+#define _WLAN_DEV_H_
+
+#define	MAX_BSSID_PER_CHANNEL		16
+
+#define MAX_NUM_IN_TX_Q			3
+
+/* For the extended Scan */
+#define MAX_EXTENDED_SCAN_BSSID_LIST    MAX_BSSID_PER_CHANNEL * \
+						MRVDRV_MAX_CHANNEL_SIZE + 1
+
+typedef struct _PER_CHANNEL_BSSID_LIST_DATA
+{
+    u8 ucStart;
+    u8 ucNumEntry;
+} PER_CHANNEL_BSSID_LIST_DATA, *PPER_CHANNEL_BSSID_LIST_DATA;
+
+typedef struct _MRV_BSSID_IE_LIST
+{
+    WLAN_802_11_FIXED_IEs FixedIE;
+    u8 VariableIE[MRVDRV_SCAN_LIST_VAR_IE_SPACE];
+} MRV_BSSID_IE_LIST, *PMRV_BSSID_IE_LIST;
+
+#define	MAX_REGION_CHANNEL_NUM	2
+
+/** Chan-Freq-TxPower mapping table*/
+typedef struct _CHANNEL_FREQ_POWER
+{
+        /** Channel Number		*/
+    u16 Channel;
+        /** Frequency of this Channel	*/
+    u32 Freq;
+        /** Max allowed Tx power level	*/
+    u16 MaxTxPower;
+        /** TRUE:channel unsupported;  FLASE:supported*/
+    BOOLEAN Unsupported;
+} CHANNEL_FREQ_POWER;
+
+/** region-band mapping table*/
+typedef struct _REGION_CHANNEL
+{
+        /** TRUE if this entry is valid		     */
+    BOOLEAN Valid;
+        /** Region code for US, Japan ...	     */
+    u8 Region;
+        /** Band B/G/A, used for BAND_CONFIG cmd	     */
+    u8 Band;
+        /** Actual No. of elements in the array below */
+    u8 NrCFP;
+        /** chan-freq-txpower mapping table*/
+    CHANNEL_FREQ_POWER *CFP;
+} REGION_CHANNEL;
+
+typedef struct _wlan_802_11_security_t
+{
+    BOOLEAN WPAEnabled;
+    BOOLEAN WPA2Enabled;
+    WLAN_802_11_WEP_STATUS WEPStatus;
+    WLAN_802_11_AUTHENTICATION_MODE AuthenticationMode;
+    WLAN_802_11_ENCRYPTION_MODE EncryptionMode;
+} wlan_802_11_security_t;
+
+/** Current Basic Service Set State Structure */
+typedef struct CurrentBSSParams
+{
+
+    BSSDescriptor_t BSSDescriptor;
+        /** bssid */
+    u8 bssid[MRVDRV_ETH_ADDR_LEN];
+        /** ssid */
+    WLAN_802_11_SSID ssid;
+
+        /** band */
+    u8 band;
+        /** channel */
+    u8 channel;
+        /** number of rates supported */
+    int NumOfRates;
+        /** supported rates*/
+    u8 DataRates[WLAN_SUPPORTED_RATES];
+        /** wmm enable? */
+    u8 wmm_enabled;
+        /** wmm queue priority table*/
+    u8 wmm_queue_prio[MAX_AC_QUEUES];
+        /** uapse enable?*/
+    u8 wmm_uapsd_enabled;
+} CurrentBSSParams;
+
+/** sleep_params */
+typedef struct SleepParams
+{
+    u16 sp_error;
+    u16 sp_offset;
+    u16 sp_stabletime;
+    u8 sp_calcontrol;
+    u8 sp_extsleepclk;
+    u16 sp_reserved;
+} SleepParams;
+
+/** sleep_period */
+typedef struct SleepPeriod
+{
+    u16 period;
+    u16 reserved;
+} SleepPeriod;
+
+/** info for debug purpose */
+typedef struct _wlan_dbg
+{
+    u32 num_cmd_host_to_card_failure;
+    u32 num_cmd_sleep_cfm_host_to_card_failure;
+    u32 num_tx_host_to_card_failure;
+    u32 num_event_deauth;
+    u32 num_event_disassoc;
+    u32 num_event_link_lost;
+    u32 num_cmd_deauth;
+    u32 num_cmd_assoc_success;
+    u32 num_cmd_assoc_failure;
+    u32 num_tx_timeout;
+    u32 num_cmd_timeout;
+    u16 TimeoutCmdId;
+    u16 TimeoutCmdAct;
+    u16 LastCmdId;
+    u16 LastCmdRespId;
+} wlan_dbg;
+
+/** Data structure for the Marvell WLAN device */
+typedef struct _wlan_dev
+{
+        /** device name */
+    char name[DEV_NAME_LEN];
+        /** card pointer */
+    void *card;
+        /** IO port */
+    u32 ioport;
+        /** Upload received */
+    u32 upld_rcv;
+        /** Upload type */
+    u32 upld_typ;
+        /** Upload length */
+    u32 upld_len;
+        /** netdev pointer */
+    struct net_device *netdev;
+    /* Upload buffer */
+    u8 upld_buf[WLAN_UPLD_SIZE];
+    /* Download sent: 
+       bit0 1/0=data_sent/data_tx_done, 
+       bit1 1/0=cmd_sent/cmd_tx_done, 
+       all other bits reserved 0 */
+    u8 dnld_sent;
+} wlan_dev_t, *pwlan_dev_t;
+
+/** Private structure for the MV device */
+struct _wlan_private
+{
+    int open;
+
+    wlan_adapter *adapter;
+    wlan_dev_t wlan_dev;
+
+    struct net_device_stats stats;
+
+    struct iw_statistics wstats;
+    struct proc_dir_entry *proc_entry;
+    struct proc_dir_entry *proc_dev;
+    const struct firmware *fw_helper;
+    const struct firmware *firmware;
+    struct device *hotplug_device;
+
+        /** thread to service interrupts */
+    wlan_thread MainThread;
+
+#ifdef REASSOCIATION
+        /** thread to service mac events */
+    wlan_thread ReassocThread;
+#endif                          /* REASSOCIATION */
+};
+
+/** Wlan Adapter data structure*/
+struct _wlan_adapter
+{
+    u8 TmpTxBuf[WLAN_UPLD_SIZE] __ATTRIB_ALIGN__;
+        /** STATUS variables */
+    WLAN_HARDWARE_STATUS HardwareStatus;
+    u32 FWReleaseNumber;
+    u32 fwCapInfo;
+    u8 chip_rev;
+
+        /** Command-related variables */
+    u16 SeqNum;
+    CmdCtrlNode *CmdArray;
+        /** Current Command */
+    CmdCtrlNode *CurCmd;
+    int CurCmdRetCode;
+
+        /** Command Queues */
+        /** Free command buffers */
+    struct list_head CmdFreeQ;
+        /** Pending command buffers */
+    struct list_head CmdPendingQ;
+
+        /** Variables brought in from private structure */
+    int irq;
+
+        /** Async and Sync Event variables */
+    u32 IntCounter;
+    u32 IntCounterSaved;        /* save int for DS/PS */
+    u32 EventCause;
+    u8 nodeName[16];            /* nickname */
+
+        /** spin locks */
+    spinlock_t QueueSpinLock __ATTRIB_ALIGN__;
+
+        /** Timers */
+    WLAN_DRV_TIMER MrvDrvCommandTimer __ATTRIB_ALIGN__;
+    BOOLEAN CommandTimerIsSet;
+
+#ifdef REASSOCIATION
+        /**Reassociation timer*/
+    BOOLEAN TimerIsSet;
+    WLAN_DRV_TIMER MrvDrvTimer __ATTRIB_ALIGN__;
+#endif                          /* REASSOCIATION */
+
+        /** Event Queues */
+    wait_queue_head_t ds_awake_q __ATTRIB_ALIGN__;
+
+    u8 HisRegCpy;
+
+#ifdef MFG_CMD_SUPPORT
+        /** manf command related cmd variable*/
+    u32 mfg_cmd_len;
+    int mfg_cmd_flag;
+    u32 mfg_cmd_resp_len;
+    u8 *mfg_cmd;
+    wait_queue_head_t mfg_cmd_q;
+#endif
+
+        /** bg scan related variable */
+    pHostCmd_DS_802_11_BG_SCAN_CONFIG bgScanConfig;
+    u32 bgScanConfigSize;
+
+        /** WMM related variable*/
+    WMM_DESC wmm;
+
+        /** current ssid/bssid related parameters*/
+    CurrentBSSParams CurBssParams;
+
+    WLAN_802_11_NETWORK_INFRASTRUCTURE InfrastructureMode;
+
+    BSSDescriptor_t *pAttemptedBSSDesc;
+
+    WLAN_802_11_SSID AttemptedSSIDBeforeScan;
+    WLAN_802_11_SSID PreviousSSID;
+    u8 PreviousBSSID[MRVDRV_ETH_ADDR_LEN];
+
+    BSSDescriptor_t *ScanTable;
+    u32 NumInScanTable;
+
+    u8 ScanType;
+    u32 ScanMode;
+    u16 SpecificScanTime;
+    u16 ActiveScanTime;
+    u16 PassiveScanTime;
+
+    u16 BeaconPeriod;
+    u8 AdhocCreate;
+    BOOLEAN AdhocLinkSensed;
+
+        /** Capability Info used in Association, start, join */
+    IEEEtypes_CapInfo_t capInfo;
+
+#ifdef REASSOCIATION
+        /** Reassociation on and off */
+    BOOLEAN Reassoc_on;
+    SEMAPHORE ReassocSem;
+#endif                          /* REASSOCIATION */
+
+    BOOLEAN ATIMEnabled;
+
+        /** MAC address information */
+    u8 CurrentAddr[MRVDRV_ETH_ADDR_LEN];
+    u8 MulticastList[MRVDRV_MAX_MULTICAST_LIST_SIZE]
+        [MRVDRV_ETH_ADDR_LEN];
+    u32 NumOfMulticastMACAddr;
+
+        /** 802.11 statistics */
+    HostCmd_DS_802_11_GET_STAT wlan802_11Stat;
+
+    u16 HWRateDropMode;
+    u16 RateBitmap;
+    u16 Threshold;
+    u16 FinalRate;
+        /** control G Rates */
+    BOOLEAN adhoc_grate_enabled;
+
+    WLAN_802_11_ANTENNA TxAntenna;
+    WLAN_802_11_ANTENNA RxAntenna;
+
+    u8 AdhocChannel;
+    WLAN_802_11_FRAGMENTATION_THRESHOLD FragThsd;
+    WLAN_802_11_RTS_THRESHOLD RTSThsd;
+
+    u32 DataRate;
+    BOOLEAN Is_DataRate_Auto;
+
+        /** number of association attempts for the current SSID cmd */
+    u32 m_NumAssociationAttemp;
+    u16 ListenInterval;
+    u16 Prescan;
+    u8 TxRetryCount;
+
+        /** Tx-related variables (for single packet tx) */
+    spinlock_t TxSpinLock __ATTRIB_ALIGN__;
+    struct sk_buff *CurrentTxSkb;
+    struct sk_buff RxSkbQ;
+    struct sk_buff TxSkbQ;
+    u32 TxSkbNum;
+    BOOLEAN TxLockFlag;
+    u16 gen_null_pkg;
+    spinlock_t CurrentTxLock __ATTRIB_ALIGN__;
+
+        /** NIC Operation characteristics */
+    u32 LinkSpeed;
+    u16 CurrentPacketFilter;
+    u32 MediaConnectStatus;
+    u16 RegionCode;
+    u16 RegionTableIndex;
+    u16 TxPowerLevel;
+    u8 MaxTxPowerLevel;
+    u8 MinTxPowerLevel;
+
+        /** POWER MANAGEMENT AND PnP SUPPORT */
+    BOOLEAN SurpriseRemoved;
+    u16 AtimWindow;
+
+    u16 PSMode;                 /* Wlan802_11PowerModeCAM=disable
+                                   Wlan802_11PowerModeMAX_PSP=enable */
+    u16 MultipleDtim;
+    u32 PSState;
+    BOOLEAN NeedToWakeup;
+
+    PS_CMD_ConfirmSleep PSConfirmSleep;
+    u16 LocalListenInterval;
+    u16 NullPktInterval;
+    u16 AdhocAwakePeriod;
+    u16 fwWakeupMethod;
+    BOOLEAN IsDeepSleep;
+        /** Host wakeup parameter */
+    BOOLEAN bWakeupDevRequired;
+    BOOLEAN bHostSleepConfigured;
+    HostCmd_DS_802_11_HOST_SLEEP_CFG HSCfg;
+        /** ARP filter related variable */
+    u8 ArpFilter[ARP_FILTER_MAX_BUF_SIZE];
+    u32 ArpFilterSize;
+    u32 WakeupTries;
+
+        /** Encryption parameter */
+    wlan_802_11_security_t SecInfo;
+
+    MRVL_WEP_KEY WepKey[MRVL_NUM_WEP_KEY];
+    u16 CurrentWepKeyIndex;
+    u8 mrvlTlvBuffer[256];
+    u8 mrvlTlvBufferLen;
+
+    u8 assocRspBuffer[MRVDRV_ASSOC_RSP_BUF_SIZE];
+    int assocRspSize;
+    u8 genIeBuffer[256];
+    u8 genIeBufferLen;
+    WLAN_802_11_ENCRYPTION_STATUS EncryptionStatus;
+
+    BOOLEAN IsGTK_SET;
+
+        /** Encryption Key*/
+    u8 Wpa_ie[256];
+    u8 Wpa_ie_len;
+
+    MRVL_WPA_KEY WpaPwkKey, WpaGrpKey;
+
+    HostCmd_DS_802_11_KEY_MATERIAL aeskey;
+
+    /* Advanced Encryption Standard */
+    BOOLEAN AdhocAESEnabled;
+    wait_queue_head_t cmd_EncKey __ATTRIB_ALIGN__;
+
+    u16 RxAntennaMode;
+    u16 TxAntennaMode;
+
+        /** Requested Signal Strength*/
+    u16 bcn_avg_factor;
+    u16 data_avg_factor;
+    u16 SNR[MAX_TYPE_B][MAX_TYPE_AVG];
+    u16 NF[MAX_TYPE_B][MAX_TYPE_AVG];
+    u8 RSSI[MAX_TYPE_B][MAX_TYPE_AVG];
+    u8 rawSNR[DEFAULT_DATA_AVG_FACTOR];
+    u8 rawNF[DEFAULT_DATA_AVG_FACTOR];
+    u16 nextSNRNF;
+    u16 numSNRNF;
+    u32 RxPDAge;
+    u16 RxPDRate;
+
+    BOOLEAN RadioOn;
+    u32 Preamble;
+
+        /** Blue Tooth Co-existence Arbitration */
+    HostCmd_DS_802_11_BCA_TIMESHARE bca_ts;
+
+        /** sleep_params */
+    SleepParams sp;
+
+        /** sleep_period (Enhanced Power Save) */
+    SleepPeriod sleep_period;
+
+#define	MAX_REGION_CHANNEL_NUM	2
+        /** Region Channel data */
+    REGION_CHANNEL region_channel[MAX_REGION_CHANNEL_NUM];
+
+    REGION_CHANNEL universal_channel[MAX_REGION_CHANNEL_NUM];
+
+        /** 11D and Domain Regulatory Data */
+    wlan_802_11d_domain_reg_t DomainReg;
+    parsed_region_chan_11d_t parsed_region_chan;
+
+        /** FSM variable for 11d support */
+    wlan_802_11d_state_t State11D;
+    int reassocAttempt;
+    WLAN_802_11_MAC_ADDRESS reassocCurrentAp;
+    u8 beaconBuffer[MAX_SCAN_BEACON_BUFFER];
+    u8 *pBeaconBufEnd;
+
+        /**	MISCELLANEOUS */
+    /* Card Information Structure */
+    u8 CisInfoBuf[512];
+    u16 CisInfoLen;
+    u8 *pRdeeprom;
+    wlan_offset_value OffsetValue;
+
+    wait_queue_head_t cmd_get_log;
+
+    HostCmd_DS_802_11_GET_LOG LogMsg;
+    u16 ScanProbes;
+
+    u32 PktTxCtrl;
+
+    u16 TxRate;
+
+    wlan_dbg dbg;
+    u32 num_cmd_timeout;
+};
+
+#endif /* _WLAN_DEV_H_ */
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_fw.c b/drivers/net/wireless/8686_wlan/wlan/wlan_fw.c
new file mode 100644
index 0000000..8703f3a
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_fw.c
@@ -0,0 +1,608 @@
+/** @file wlan_fw.c
+  * @brief This file contains the initialization for FW
+  * and HW
+  *
+  * (c) Copyright © 2003-2006, Marvell International Ltd. 
+  * 
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	09/28/05: Add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join functions.
+	          Cleanup association response handler initialization.
+	01/06/05: Add FW file read
+	05/08/06: Remove the 2nd GET_HW_SPEC command and TempAddr/PermanentAddr
+	06/30/06: replaced MODULE_PARM(name, type) with module_param(name, type, perm)
+
+********************************************************/
+
+#include	"include.h"
+#include <linux/vmalloc.h>
+
+#include	<linux/firmware.h>
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+char *helper_name = "helper_sd.bin";
+char *fw_name = "sd8686.bin";
+
+module_param(helper_name, charp, 0);
+module_param(fw_name, charp, 0);
+
+#ifdef MFG_CMD_SUPPORT
+int mfgmode = 0;
+module_param(mfgmode, int, 0);
+#endif
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function downloads firmware image, gets
+ *  HW spec from firmware and set basic parameters to
+ *  firmware.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int wlan_setup_station_hw(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *adapter = priv->adapter;
+
+    ENTER();
+
+    sbi_disable_host_int(priv);
+
+	umd_dbg("helper_name = %s, fw_name = %s\n",
+		helper_name, fw_name);
+
+    if ((ret =
+         request_firmware(&priv->fw_helper, helper_name,
+                          priv->hotplug_device)) < 0) {
+        PRINTM(FATAL,
+               "request_firmware() failed (helper), error code = %#x\n", ret);
+        goto done;
+    }
+
+    if ((ret =
+         request_firmware(&priv->firmware, fw_name,
+                          priv->hotplug_device)) < 0) {
+        PRINTM(FATAL, "request_firmware() failed, error code = %#x\n", ret);
+        goto done;
+    }
+
+    /* Download the helper */
+    ret = sbi_prog_helper(priv);
+
+    if (ret) {
+        PRINTM(INFO, "Bootloader in invalid state!\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    /* Download the main firmware via the helper firmware */
+    if (sbi_prog_firmware_w_helper(priv)) {
+        PRINTM(INFO, "Wlan FW download failed!\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* check if the fimware is downloaded successfully or not */
+    if (sbi_verify_fw_download(priv)) {
+        PRINTM(INFO, "FW failed to be active in time!\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+#define RF_REG_OFFSET 0x07
+#define RF_REG_VALUE  0xc8
+
+    sbi_enable_host_int(priv);
+
+#ifdef MFG_CMD_SUPPORT
+    if (mfgmode == 0) {
+#endif
+
+	umd_dbg("will read MAC from HW");
+
+        /*
+         * Read MAC address from HW
+         */
+        memset(adapter->CurrentAddr, 0xff, MRVDRV_ETH_ADDR_LEN);
+
+        ret = PrepareAndSendCommand(priv, HostCmd_CMD_GET_HW_SPEC,
+                                    0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        SetMacPacketFilter(priv);
+
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_FW_WAKEUP_METHOD,
+                                    HostCmd_ACT_GET,
+                                    HostCmd_OPTION_WAITFORRSP, 0,
+                                    &priv->adapter->fwWakeupMethod);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+#ifdef MFG_CMD_SUPPORT
+    }
+#endif
+
+	umd_dbg("will set rate!\n");
+
+#ifdef MFG_CMD_SUPPORT
+    if (mfgmode == 0) {
+#endif
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_RATE_ADAPT_RATESET,
+                                    HostCmd_ACT_GEN_GET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, NULL);
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+        priv->adapter->DataRate = 0;
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_RF_TX_POWER,
+                                    HostCmd_ACT_GEN_GET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+#ifdef MFG_CMD_SUPPORT
+    }
+#endif
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    if (priv->fw_helper) {
+        release_firmware(priv->fw_helper);
+    }
+    if (priv->firmware) {
+        release_firmware(priv->firmware);
+    }
+
+    LEAVE();
+
+    umd_dbg("ret = %d, exit!", ret);
+
+    return (ret);
+}
+
+/** 
+ *  @brief This function initializes timers.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+static void
+init_sync_objects(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    InitializeTimer(&Adapter->MrvDrvCommandTimer,
+                    MrvDrvCommandTimerFunction, priv);
+    Adapter->CommandTimerIsSet = FALSE;
+
+#ifdef REASSOCIATION
+    /* Initialize the timer for the reassociation */
+    InitializeTimer(&Adapter->MrvDrvTimer, MrvDrvTimerFunction, priv);
+    Adapter->TimerIsSet = FALSE;
+#endif /* REASSOCIATION */
+
+    return;
+}
+
+/** 
+ *  @brief This function allocates buffer for the member of adapter
+ *  structure like command buffer and BSSID list.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_allocate_adapter(wlan_private * priv)
+{
+    u32 ulBufSize;
+    wlan_adapter *Adapter = priv->adapter;
+
+    BSSDescriptor_t *pTempScanTable;
+
+    /* Allocate buffer to store the BSSID list */
+    ulBufSize = sizeof(BSSDescriptor_t) * MRVDRV_MAX_BSSID_LIST;
+    if (!(pTempScanTable = kmalloc(ulBufSize, GFP_KERNEL))) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    Adapter->ScanTable = pTempScanTable;
+    memset(Adapter->ScanTable, 0, ulBufSize);
+
+    if (!(Adapter->bgScanConfig =
+          kmalloc(sizeof(HostCmd_DS_802_11_BG_SCAN_CONFIG), GFP_KERNEL))) {
+        return WLAN_STATUS_FAILURE;
+    }
+    Adapter->bgScanConfigSize = sizeof(HostCmd_DS_802_11_BG_SCAN_CONFIG);
+    memset(Adapter->bgScanConfig, 0, Adapter->bgScanConfigSize);
+
+    spin_lock_init(&Adapter->QueueSpinLock);
+
+    /* Allocate the command buffers */
+    if (AllocateCmdBuffer(priv) != WLAN_STATUS_SUCCESS) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    memset(&Adapter->PSConfirmSleep, 0, sizeof(PS_CMD_ConfirmSleep));
+    Adapter->PSConfirmSleep.SeqNum = wlan_cpu_to_le16(++Adapter->SeqNum);
+    Adapter->PSConfirmSleep.Command =
+        wlan_cpu_to_le16(HostCmd_CMD_802_11_PS_MODE);
+    Adapter->PSConfirmSleep.Size =
+        wlan_cpu_to_le16(sizeof(PS_CMD_ConfirmSleep));
+    Adapter->PSConfirmSleep.Result = 0;
+    Adapter->PSConfirmSleep.Action =
+        wlan_cpu_to_le16(HostCmd_SubCmd_Sleep_Confirmed);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function initializes the adapter structure
+ *  and set default value to the member of adapter.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+static void
+wlan_init_adapter(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i;
+
+    Adapter->ScanProbes = 0;
+
+    Adapter->bcn_avg_factor = DEFAULT_BCN_AVG_FACTOR;
+    Adapter->data_avg_factor = DEFAULT_DATA_AVG_FACTOR;
+
+    /* ATIM params */
+    Adapter->AtimWindow = 0;
+    Adapter->ATIMEnabled = FALSE;
+
+    Adapter->MediaConnectStatus = WlanMediaStateDisconnected;
+    Adapter->LinkSpeed = MRVDRV_LINK_SPEED_1mbps;
+    memset(Adapter->CurrentAddr, 0xff, MRVDRV_ETH_ADDR_LEN);
+
+    /* Status variables */
+    Adapter->HardwareStatus = WlanHardwareStatusInitializing;
+
+    /* scan type */
+    Adapter->ScanType = HostCmd_SCAN_TYPE_ACTIVE;
+
+    /* scan mode */
+    Adapter->ScanMode = HostCmd_BSS_TYPE_ANY;
+
+    /* scan time */
+    Adapter->SpecificScanTime = MRVDRV_SPECIFIC_SCAN_CHAN_TIME;
+    Adapter->ActiveScanTime = MRVDRV_ACTIVE_SCAN_CHAN_TIME;
+    Adapter->PassiveScanTime = MRVDRV_PASSIVE_SCAN_CHAN_TIME;
+
+    /* 802.11 specific */
+    Adapter->SecInfo.WEPStatus = Wlan802_11WEPDisabled;
+    for (i = 0; i < sizeof(Adapter->WepKey) / sizeof(Adapter->WepKey[0]); i++)
+        memset(&Adapter->WepKey[i], 0, sizeof(MRVL_WEP_KEY));
+    Adapter->CurrentWepKeyIndex = 0;
+    Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+    Adapter->SecInfo.EncryptionMode = CIPHER_NONE;
+    Adapter->AdhocAESEnabled = FALSE;
+    Adapter->InfrastructureMode = Wlan802_11Infrastructure;
+
+    Adapter->NumInScanTable = 0;
+    Adapter->pAttemptedBSSDesc = NULL;
+#ifdef REASSOCIATION
+    OS_INIT_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+    Adapter->pBeaconBufEnd = Adapter->beaconBuffer;
+
+    Adapter->Prescan = CMD_ENABLED;
+    Adapter->HisRegCpy |= HIS_TxDnLdRdy;
+
+    memset(&Adapter->CurBssParams, 0, sizeof(Adapter->CurBssParams));
+
+    /* PnP and power profile */
+    Adapter->SurpriseRemoved = FALSE;
+
+    Adapter->CurrentPacketFilter =
+        HostCmd_ACT_MAC_RX_ON | HostCmd_ACT_MAC_TX_ON;
+
+    Adapter->RadioOn = RADIO_ON;
+#ifdef REASSOCIATION
+    Adapter->Reassoc_on = TRUE;
+#endif /* REASSOCIATION */
+    Adapter->TxAntenna = RF_ANTENNA_2;
+    Adapter->RxAntenna = RF_ANTENNA_AUTO;
+
+    Adapter->HWRateDropMode = HW_TABLE_RATE_DROP;
+    Adapter->Is_DataRate_Auto = TRUE;
+    Adapter->BeaconPeriod = MRVDRV_BEACON_INTERVAL;
+
+    // set default value of capInfo.
+#define SHORT_PREAMBLE_ALLOWED		1
+    memset(&Adapter->capInfo, 0, sizeof(Adapter->capInfo));
+    Adapter->capInfo.ShortPreamble = SHORT_PREAMBLE_ALLOWED;
+
+    Adapter->AdhocChannel = DEFAULT_AD_HOC_CHANNEL;
+
+    Adapter->PSMode = Wlan802_11PowerModeCAM;
+    Adapter->MultipleDtim = MRVDRV_DEFAULT_MULTIPLE_DTIM;
+
+    Adapter->ListenInterval = MRVDRV_DEFAULT_LISTEN_INTERVAL;
+
+    Adapter->PSState = PS_STATE_FULL_POWER;
+    Adapter->NeedToWakeup = FALSE;
+    Adapter->LocalListenInterval = 0;   /* default value in firmware will be used */
+    Adapter->fwWakeupMethod = WAKEUP_FW_UNCHANGED;
+
+    Adapter->IsDeepSleep = FALSE;
+
+    Adapter->bWakeupDevRequired = FALSE;
+    Adapter->bHostSleepConfigured = FALSE;
+    Adapter->WakeupTries = 0;
+    Adapter->HSCfg.conditions = HOST_SLEEP_CFG_CANCEL;
+    Adapter->HSCfg.gpio = 0;
+    Adapter->HSCfg.gap = 0;
+
+    Adapter->DataRate = 0;      // Initially indicate the rate as auto 
+
+    Adapter->adhoc_grate_enabled = FALSE;
+
+    Adapter->IntCounter = Adapter->IntCounterSaved = 0;
+    memset(&Adapter->wmm, 0, sizeof(WMM_DESC));
+    for (i = 0; i < MAX_AC_QUEUES; i++)
+        INIT_LIST_HEAD((struct list_head *) &Adapter->wmm.TxSkbQ[i]);
+    INIT_LIST_HEAD((struct list_head *) &Adapter->RxSkbQ);
+    Adapter->gen_null_pkg = TRUE;       /*Enable NULL Pkg generation */
+
+    INIT_LIST_HEAD((struct list_head *) &Adapter->TxSkbQ);
+    Adapter->TxSkbNum = 0;
+
+    init_waitqueue_head(&Adapter->cmd_EncKey);
+
+    Adapter->EncryptionStatus = Wlan802_11WEPDisabled;
+
+    spin_lock_init(&Adapter->CurrentTxLock);
+
+    Adapter->CurrentTxSkb = NULL;
+    Adapter->PktTxCtrl = 0;
+
+    return;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function initializes firmware
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int wlan_init_fw(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /* Allocate adapter structure */
+    if ((ret = wlan_allocate_adapter(priv)) != WLAN_STATUS_SUCCESS) {
+        goto done;
+    }
+
+    /* init adapter structure */
+    wlan_init_adapter(priv);
+
+    /* init timer etc. */
+    init_sync_objects(priv);
+
+    /* download fimrware etc. */
+    if ((ret = wlan_setup_station_hw(priv)) != WLAN_STATUS_SUCCESS) {
+        Adapter->HardwareStatus = WlanHardwareStatusNotReady;
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    /* init 802.11d */
+    wlan_init_11d(priv);
+
+    Adapter->HardwareStatus = WlanHardwareStatusReady;
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function frees the structure of adapter
+ *    
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+void wlan_free_adapter(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Adapter) {
+        PRINTM(INFO, "Why double free adapter?:)\n");
+        return;
+    }
+
+    PRINTM(INFO, "Free Command buffer\n");
+    FreeCmdBuffer(priv);
+
+    PRINTM(INFO, "Free CommandTimer\n");
+    if (Adapter->CommandTimerIsSet) {
+        CancelTimer(&Adapter->MrvDrvCommandTimer);
+        Adapter->CommandTimerIsSet = FALSE;
+    }
+    FreeTimer(&Adapter->MrvDrvCommandTimer);
+#ifdef REASSOCIATION
+    PRINTM(INFO, "Free MrvDrvTimer\n");
+    if (Adapter->TimerIsSet) {
+        CancelTimer(&Adapter->MrvDrvTimer);
+        Adapter->TimerIsSet = FALSE;
+    }
+    FreeTimer(&Adapter->MrvDrvTimer);
+#endif /* REASSOCIATION */
+
+    if (Adapter->bgScanConfig) {
+        kfree(Adapter->bgScanConfig);
+        Adapter->bgScanConfig = NULL;
+    }
+
+    OS_FREE_LOCK(&Adapter->CurrentTxLock);
+    OS_FREE_LOCK(&Adapter->QueueSpinLock);
+
+    PRINTM(INFO, "Free ScanTable\n");
+    if (Adapter->ScanTable) {
+        kfree(Adapter->ScanTable);
+        Adapter->ScanTable = NULL;
+    }
+
+    PRINTM(INFO, "Free Adapter\n");
+
+    /* Free the adapter object itself */
+    kfree(Adapter);
+    priv->adapter = NULL;
+    LEAVE();
+}
+
+/** 
+ *  @brief This function handles the timeout of command sending.
+ *  It will re-send the same command again.
+ *  
+ *  @param FunctionContext    A pointer to FunctionContext
+ *  @return 	   n/a
+ */
+void
+MrvDrvCommandTimerFunction(void *FunctionContext)
+{
+    wlan_private *priv = (wlan_private *) FunctionContext;
+    wlan_adapter *Adapter = priv->adapter;
+    CmdCtrlNode *pTempNode;
+    HostCmd_DS_COMMAND *CmdPtr;
+
+    ENTER();
+
+    PRINTM(CMND, "Command timeout.\n");
+    umd_dbg("Command timeout.\n");
+
+    Adapter->CommandTimerIsSet = FALSE;
+
+    if (!Adapter->num_cmd_timeout)
+        Adapter->dbg.num_cmd_timeout++;
+
+    pTempNode = Adapter->CurCmd;
+
+    if (pTempNode == NULL) {
+        PRINTM(INFO, "CurCmd Empty\n");
+        goto exit;
+    }
+
+    CmdPtr = (HostCmd_DS_COMMAND *) pTempNode->BufVirtualAddr;
+    if (CmdPtr == NULL) {
+        goto exit;
+    }
+
+    if (CmdPtr->Size) {
+        Adapter->dbg.TimeoutCmdId = wlan_cpu_to_le16(CmdPtr->Command);
+        Adapter->dbg.TimeoutCmdAct =
+            wlan_cpu_to_le16(*(u16 *) ((u8 *) CmdPtr + S_DS_GEN));
+        PRINTM(CMND, "Timeout cmd = 0x%x, act = 0x%x\n",
+               Adapter->dbg.TimeoutCmdId, Adapter->dbg.TimeoutCmdAct);
+    }
+#define MAX_CMD_TIMEOUT_COUNT	5
+    Adapter->num_cmd_timeout++;
+    if (Adapter->num_cmd_timeout > MAX_CMD_TIMEOUT_COUNT) {
+        PRINTM(FATAL, "num_cmd_timeout=%d\n", Adapter->num_cmd_timeout);
+        goto exit;
+    }
+
+    /* Restart the timer to trace command response again */
+    ModTimer(&Adapter->MrvDrvCommandTimer, MRVDRV_TIMER_1S);
+    Adapter->CommandTimerIsSet = TRUE;
+
+	umd_dbg("will wakeup the main thread!!!");
+    /* Wake up main thread to read int status register */
+    Adapter->IntCounter++;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+  exit:
+    LEAVE();
+    return;
+}
+
+#ifdef REASSOCIATION
+/** 
+ *  @brief This function triggers re-association by waking up
+ *  re-assoc thread.
+ *  
+ *  @param FunctionContext    A pointer to FunctionContext
+ *  @return 	   n/a
+ */
+void
+MrvDrvTimerFunction(void *FunctionContext)
+{
+    wlan_private *priv = (wlan_private *) FunctionContext;
+    wlan_adapter *Adapter = priv->adapter;
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    PRINTM(INFO, "MrvDrvTimer fired.\n");
+    Adapter->TimerIsSet = FALSE;
+    if (Adapter->PSState != PS_STATE_FULL_POWER) {
+        /* wait until Exit_PS command returns */
+        Adapter->TimerIsSet = TRUE;
+        ModTimer(&Adapter->MrvDrvTimer, MRVDRV_TIMER_1S);
+        PRINTM(INFO, "MrvDrvTimerFunction(PSState=%d) waiting"
+               "for Exit_PS done\n", Adapter->PSState);
+        LEAVE();
+        return;
+    }
+
+    PRINTM(INFO, "Waking Up the Reassoc Thread\n");
+
+    wake_up_interruptible(&priv->ReassocThread.waitQ);
+
+    LEAVE();
+    return;
+}
+#endif /* REASSOCIATION */
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_fw.h b/drivers/net/wireless/8686_wlan/wlan/wlan_fw.h
new file mode 100644
index 0000000..60b71d1
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_fw.h
@@ -0,0 +1,47 @@
+/** @file wlan_fw.h
+ *  @brief This header file contains FW interface related definitions.
+ *
+ * (c) Copyright © 2003-2006, Marvell International Ltd. 
+ * 
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change log:
+	09/26/05: add Doxygen format comments 
+ ************************************************************/
+
+#ifndef _WLAN_FW_H_
+#define _WLAN_FW_H_
+
+#ifndef DEV_NAME_LEN
+#define DEV_NAME_LEN            32
+#endif
+
+#define MAXKEYLEN           13
+
+/* The number of times to try when waiting for downloaded firmware to 
+ become active. (polling the scratch register). */
+
+#define MAX_FIRMWARE_POLL_TRIES     100
+
+#define FIRMWARE_TRANSFER_BLOCK_SIZE    1536
+
+/** function prototypes */
+int wlan_init_fw(wlan_private * priv);
+int wlan_disable_host_int(wlan_private * priv, u8 reg);
+int wlan_enable_host_int(wlan_private * priv, u8 mask);
+int wlan_free_cmd_buffers(wlan_private * priv);
+
+#endif /* _WLAN_FW_H_ */
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_join.c b/drivers/net/wireless/8686_wlan/wlan/wlan_join.c
new file mode 100644
index 0000000..7853b3b
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_join.c
@@ -0,0 +1,1958 @@
+/** @file wlan_join.c
+ *
+ *  @brief Functions implementing wlan infrastructure and adhoc join routines
+ *
+ *  IOCTL handlers as well as command preperation and response routines
+ *   for sending adhoc start, adhoc join, and association commands
+ *   to the firmware.
+ *  
+ *  (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *   
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change Log:
+    01/11/06: Initial revision. Match new scan code, relocate related functions
+    01/19/06: Fix failure to save adhoc ssid as current after adhoc start
+    03/16/06: Add a semaphore to protect reassociation thread
+    10/16/06: Add comments for association response status code
+
+************************************************************/
+
+#include    "include.h"
+
+/**
+ *  @brief This function finds out the common rates between rate1 and rate2.
+ *
+ * It will fill common rates in rate1 as output if found.
+ *
+ * NOTE: Setting the MSB of the basic rates need to be taken
+ *   care, either before or after calling this function
+ *
+ *  @param Adapter     A pointer to wlan_adapter structure
+ *  @param rate1       the buffer which keeps input and output
+ *  @param rate1_size  the size of rate1 buffer
+ *  @param rate2       the buffer which keeps rate2
+ *  @param rate2_size  the size of rate2 buffer.
+ *
+ *  @return            WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+get_common_rates(wlan_adapter * Adapter, u8 * rate1,
+                 int rate1_size, u8 * rate2, int rate2_size)
+{
+    u8 *ptr = rate1;
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 *tmp = NULL;
+    int i, j;
+
+    if (!(tmp = kmalloc(rate1_size, GFP_KERNEL))) {
+        PRINTM(WARN, "Allocate buffer for common rates failed\n");
+        return -ENOMEM;
+    }
+
+    memcpy(tmp, rate1, rate1_size);
+    memset(rate1, 0, rate1_size);
+
+    for (i = 0; rate2[i] && i < rate2_size; i++) {
+        for (j = 0; tmp[j] && j < rate1_size; j++) {
+            /* Check common rate, excluding the bit for basic rate */
+            if ((rate2[i] & 0x7F) == (tmp[j] & 0x7F)) {
+                *rate1++ = tmp[j];
+                break;
+            }
+        }
+    }
+
+    HEXDUMP("rate1 (AP) Rates", tmp, rate1_size);
+    HEXDUMP("rate2 (Card) Rates", rate2, rate2_size);
+    HEXDUMP("Common Rates", ptr, rate1 - ptr);
+    PRINTM(INFO, "Tx DataRate is set to 0x%X\n", Adapter->DataRate);
+
+    if (!Adapter->Is_DataRate_Auto) {
+        while (*ptr) {
+            if ((*ptr & 0x7f) == Adapter->DataRate) {
+                ret = WLAN_STATUS_SUCCESS;
+                goto done;
+            }
+            ptr++;
+        }
+        PRINTM(MSG, "Previously set fixed data rate %#x isn't "
+               "compatible with the network.\n", Adapter->DataRate);
+
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    kfree(tmp);
+    return ret;
+}
+
+/**
+ *  @brief Send Deauth Request
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @return          WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+int
+wlan_send_deauth(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->InfrastructureMode == Wlan802_11Infrastructure &&
+        Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+
+        ret = SendDeauthentication(priv);
+    } else {
+        LEAVE();
+        return -ENOTSUPP;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Retrieve the association response
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_assoc_rsp_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int copySize;
+
+    /*
+     * Set the amount to copy back to the application as the minimum of the
+     *   available assoc resp data or the buffer provided by the application
+     */
+    copySize = MIN(Adapter->assocRspSize, wrq->u.data.length);
+
+    /* Copy the (re)association response back to the application */
+    if (copy_to_user(wrq->u.data.pointer, Adapter->assocRspBuffer, copySize)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    /* Returned copy length */
+    wrq->u.data.length = copySize;
+
+    /* Reset assoc buffer */
+    Adapter->assocRspSize = 0;
+
+    /* No error on return */
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Set an opaque block of Marvell TLVs for insertion into the
+ *         association command
+ *
+ *  Pass an opaque block of data, expected to be Marvell TLVs, to the driver
+ *    for eventual passthrough to the firmware in an associate/join
+ *    (and potentially start) command.
+ *
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_mrvl_tlv_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    /* If the passed length is zero, reset the buffer */
+    if (wrq->u.data.length == 0) {
+        Adapter->mrvlTlvBufferLen = 0;
+    } else {
+        /*
+         * Verify that the passed length is not larger than the available
+         *   space remaining in the buffer
+         */
+        if (wrq->u.data.length <
+            (sizeof(Adapter->mrvlTlvBuffer) - Adapter->mrvlTlvBufferLen)) {
+            /* Append the passed data to the end of the mrvlTlvBuffer */
+            if (copy_from_user
+                (Adapter->mrvlTlvBuffer + Adapter->mrvlTlvBufferLen,
+                 wrq->u.data.pointer, wrq->u.data.length)) {
+                PRINTM(INFO, "Copy from user failed\n");
+                return -EFAULT;
+            }
+
+            /* Increment the stored buffer length by the size passed */
+            Adapter->mrvlTlvBufferLen += wrq->u.data.length;
+        } else {
+            /* Passed data does not fit in the remaining buffer space */
+            ret = WLAN_STATUS_FAILURE;
+        }
+    }
+
+    /* Return WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE */
+    return ret;
+}
+
+/**
+ *  @brief Stop Adhoc Network
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_do_adhocstop_ioctl(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->InfrastructureMode == Wlan802_11IBSS &&
+        Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+
+        ret = StopAdhocNetwork(priv);
+
+    } else {
+        LEAVE();
+        return -ENOTSUPP;
+    }
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Set essid
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int
+wlan_set_essid(struct net_device *dev, struct iw_request_info *info,
+               struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    WLAN_802_11_SSID reqSSID;
+    int i;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    /* Clear any past association response stored for application retrieval */
+    Adapter->assocRspSize = 0;
+
+#ifdef REASSOCIATION
+    // cancel re-association timer if there's one
+    if (Adapter->TimerIsSet == TRUE) {
+        CancelTimer(&Adapter->MrvDrvTimer);
+        Adapter->TimerIsSet = FALSE;
+    }
+
+    if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+        PRINTM(WARN, "Acquire semaphore error, wlan_set_essid\n");
+        return -EBUSY;
+    }
+#endif /* REASSOCIATION */
+
+    /* Check the size of the string */
+    //if (dwrq->length > IW_ESSID_MAX_SIZE + 1) { //hufh
+    if (dwrq->length > IW_ESSID_MAX_SIZE ) {
+        ret = -E2BIG;
+        goto setessid_ret;
+    }
+
+    memset(&reqSSID, 0, sizeof(WLAN_802_11_SSID));
+
+    /*
+     * Check if we asked for `any' or 'particular'
+     */
+    if (!dwrq->flags) {
+        if (FindBestNetworkSsid(priv, &reqSSID)) {
+            PRINTM(INFO, "Could not find best network\n");
+            ret = WLAN_STATUS_SUCCESS;
+            goto setessid_ret;
+        }
+    } else {
+        /* Set the SSID */
+        //reqSSID.SsidLength = dwrq->length - 1; //hufh
+        reqSSID.SsidLength = dwrq->length;
+        memcpy(reqSSID.Ssid, extra, reqSSID.SsidLength);
+
+    }
+
+    PRINTM(INFO, "Requested new SSID = %s\n",
+           (reqSSID.SsidLength > 0) ? (char *) reqSSID.Ssid : "NULL");
+
+    if (!reqSSID.SsidLength || reqSSID.Ssid[0] < 0x20) {
+        PRINTM(INFO, "Invalid SSID - aborting set_essid\n");
+        ret = -EINVAL;
+        goto setessid_ret;
+    }
+
+    /* If the requested SSID is not a NULL string, join */
+
+    if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+        /* infrastructure mode */
+        PRINTM(INFO, "SSID requested = %s\n", reqSSID.Ssid);
+
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            PRINTM(INFO, "Already Connected ..\n");
+            ret = SendDeauthentication(priv);
+
+            if (ret) {
+                goto setessid_ret;
+            }
+        }
+
+        if (Adapter->Prescan) {
+            SendSpecificSSIDScan(priv, &reqSSID);
+        }
+
+        i = FindSSIDInList(Adapter, &reqSSID, NULL, Wlan802_11Infrastructure);
+        if (i >= 0) {
+            PRINTM(INFO, "SSID found in scan list ... associating...\n");
+
+            ret = wlan_associate(priv, &Adapter->ScanTable[i]);
+
+            if (ret) {
+                goto setessid_ret;
+            }
+        } else {                /* i >= 0 */
+            ret = i;            /* return -ENETUNREACH, passed from FindSSIDInList */
+            goto setessid_ret;
+        }
+    } else {
+        /* ad hoc mode */
+        /* If the requested SSID matches current SSID return */
+        if (!SSIDcmp(&Adapter->CurBssParams.ssid, &reqSSID)) {
+            ret = WLAN_STATUS_SUCCESS;
+            goto setessid_ret;
+        }
+
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            /*
+             * Exit Adhoc mode
+             */
+            PRINTM(INFO, "Sending Adhoc Stop\n");
+            ret = StopAdhocNetwork(priv);
+
+            if (ret) {
+                goto setessid_ret;
+            }
+        }
+        Adapter->AdhocLinkSensed = FALSE;
+
+        /* Scan for the network */
+        SendSpecificSSIDScan(priv, &reqSSID);
+
+        /* Search for the requested SSID in the scan table */
+        i = FindSSIDInList(Adapter, &reqSSID, NULL, Wlan802_11IBSS);
+
+        if (i >= 0) {
+            PRINTM(INFO, "SSID found at %d in List, so join\n", i);
+            JoinAdhocNetwork(priv, &Adapter->ScanTable[i]);
+        } else {
+            /* else send START command */
+            PRINTM(INFO, "SSID not found in list, "
+                   "so creating adhoc with ssid = %s\n", reqSSID.Ssid);
+
+            StartAdhocNetwork(priv, &reqSSID);
+        }                       /* end of else (START command) */
+    }                           /* end of else (Ad hoc mode) */
+
+    /*
+     * The MediaConnectStatus change can be removed later when
+     *   the ret code is being properly returned.
+     */
+    /* Check to see if we successfully connected */
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        ret = WLAN_STATUS_SUCCESS;
+    } else {
+        ret = -ENETDOWN;
+    }
+
+  setessid_ret:
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Connect to the AP or Ad-hoc Network with specific bssid
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param awrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
+             struct sockaddr *awrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    const u8 bcast[ETH_ALEN] = { 255, 255, 255, 255, 255, 255 };
+    u8 reqBSSID[ETH_ALEN];
+    int i;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    /* Clear any past association response stored for application retrieval */
+    Adapter->assocRspSize = 0;
+
+//Application should call scan before call this function.    
+
+    if (awrq->sa_family != ARPHRD_ETHER)
+        return -EINVAL;
+
+    PRINTM(INFO, "ASSOC: WAP: sa_data: %02x:%02x:%02x:%02x:%02x:%02x\n",
+           (u8) awrq->sa_data[0], (u8) awrq->sa_data[1],
+           (u8) awrq->sa_data[2], (u8) awrq->sa_data[3],
+           (u8) awrq->sa_data[4], (u8) awrq->sa_data[5]);
+
+#ifdef REASSOCIATION
+    // cancel re-association timer if there's one
+    if (Adapter->TimerIsSet == TRUE) {
+        CancelTimer(&Adapter->MrvDrvTimer);
+        Adapter->TimerIsSet = FALSE;
+    }
+#endif /* REASSOCIATION */
+
+    if (!memcmp(bcast, awrq->sa_data, ETH_ALEN)) {
+        i = FindBestSSIDInList(Adapter);
+    } else {
+        memcpy(reqBSSID, awrq->sa_data, ETH_ALEN);
+
+        PRINTM(INFO, "ASSOC: WAP: Bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
+               reqBSSID[0], reqBSSID[1], reqBSSID[2],
+               reqBSSID[3], reqBSSID[4], reqBSSID[5]);
+
+        /* Search for index position in list for requested MAC */
+        i = FindBSSIDInList(Adapter, reqBSSID, Adapter->InfrastructureMode);
+    }
+
+    if (i < 0) {
+        PRINTM(INFO, "ASSOC: WAP: MAC address not found in BSSID List\n");
+        return -ENETUNREACH;
+    }
+
+    if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            ret = SendDeauthentication(priv);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+        }
+        ret = wlan_associate(priv, &Adapter->ScanTable[i]);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    } else {
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            /* Exit Adhoc mode */
+            ret = StopAdhocNetwork(priv);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+        }
+        Adapter->AdhocLinkSensed = FALSE;
+
+        JoinAdhocNetwork(priv, &Adapter->ScanTable[i]);
+    }
+
+    /* Check to see if we successfully connected */
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        ret = WLAN_STATUS_SUCCESS;
+    } else {
+        ret = -ENETDOWN;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Associated to a specific BSS discovered in a scan
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param pBSSDesc  Pointer to the BSS descriptor to associate with.
+ *
+ *  @return          WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+int
+wlan_associate(wlan_private * priv, BSSDescriptor_t * pBSSDesc)
+{
+    int ret;
+
+    /* Clear any past association response stored for application retrieval */
+    priv->adapter->assocRspSize = 0;
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_AUTHENTICATE,
+                                0, HostCmd_OPTION_WAITFORRSP,
+                                0, pBSSDesc->MacAddress);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_ASSOCIATE,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, pBSSDesc);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Start an Adhoc Network
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param AdhocSSID    The ssid of the Adhoc Network
+ *  @return             WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+int
+StartAdhocNetwork(wlan_private * priv, WLAN_802_11_SSID * AdhocSSID)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    Adapter->AdhocCreate = TRUE;
+
+    if (!Adapter->capInfo.ShortPreamble) {
+        PRINTM(INFO, "AdhocStart: Long Preamble\n");
+        Adapter->Preamble = HostCmd_TYPE_LONG_PREAMBLE;
+    } else {
+        PRINTM(INFO, "AdhocStart: Short Preamble\n");
+        Adapter->Preamble = HostCmd_TYPE_SHORT_PREAMBLE;
+    }
+
+    SetRadioControl(priv);
+
+    PRINTM(INFO, "Adhoc Channel = %d\n", Adapter->AdhocChannel);
+    PRINTM(INFO, "CurBssParams.channel = %d\n",
+           Adapter->CurBssParams.channel);
+    PRINTM(INFO, "CurBssParams.band = %d\n", Adapter->CurBssParams.band);
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_AD_HOC_START,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, AdhocSSID);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Join an adhoc network found in a previous scan
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param pBSSDesc     Pointer to a BSS descriptor found in a previous scan
+ *                      to attempt to join
+ *
+ *  @return             WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+int
+JoinAdhocNetwork(wlan_private * priv, BSSDescriptor_t * pBSSDesc)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    PRINTM(INFO, "JoinAdhocNetwork: CurBss.ssid =%s\n",
+           Adapter->CurBssParams.ssid.Ssid);
+    PRINTM(INFO, "JoinAdhocNetwork: CurBss.ssid_len =%u\n",
+           Adapter->CurBssParams.ssid.SsidLength);
+    PRINTM(INFO, "JoinAdhocNetwork: ssid =%s\n", pBSSDesc->Ssid.Ssid);
+    PRINTM(INFO, "JoinAdhocNetwork: ssid len =%u\n",
+           pBSSDesc->Ssid.SsidLength);
+
+    /* check if the requested SSID is already joined */
+    if (Adapter->CurBssParams.ssid.SsidLength
+        && !SSIDcmp(&pBSSDesc->Ssid, &Adapter->CurBssParams.ssid)
+        && (Adapter->CurBssParams.BSSDescriptor.InfrastructureMode ==
+            Wlan802_11IBSS)) {
+
+        PRINTM(INFO,
+               "ADHOC_J_CMD: New ad-hoc SSID is the same as current, "
+               "not attempting to re-join");
+
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /*Use ShortPreamble only when both creator and card supports
+       short preamble */
+    if (!pBSSDesc->Cap.ShortPreamble || !Adapter->capInfo.ShortPreamble) {
+        PRINTM(INFO, "AdhocJoin: Long Preamble\n");
+        Adapter->Preamble = HostCmd_TYPE_LONG_PREAMBLE;
+    } else {
+        PRINTM(INFO, "AdhocJoin: Short Preamble\n");
+        Adapter->Preamble = HostCmd_TYPE_SHORT_PREAMBLE;
+    }
+
+    SetRadioControl(priv);
+
+    PRINTM(INFO, "CurBssParams.channel = %d\n",
+           Adapter->CurBssParams.channel);
+    PRINTM(INFO, "CurBssParams.band = %c\n", Adapter->CurBssParams.band);
+
+    Adapter->AdhocCreate = FALSE;
+
+    // store the SSID info temporarily
+    memset(&Adapter->AttemptedSSIDBeforeScan, 0, sizeof(WLAN_802_11_SSID));
+    memcpy(&Adapter->AttemptedSSIDBeforeScan,
+           &pBSSDesc->Ssid, sizeof(WLAN_802_11_SSID));
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_AD_HOC_JOIN,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, pBSSDesc);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Stop the Adhoc Network
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @return          WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+int
+StopAdhocNetwork(wlan_private * priv)
+{
+    return PrepareAndSendCommand(priv, HostCmd_CMD_802_11_AD_HOC_STOP,
+                                 0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+}
+
+/**
+ *  @brief Send Deauthentication Request
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @return          WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+int
+SendDeauthentication(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    /* If a reassociation attempt is in progress, do not send the deauth */
+    if (Adapter->reassocAttempt) {
+        return WLAN_STATUS_SUCCESS;
+    }
+    return PrepareAndSendCommand(priv, HostCmd_CMD_802_11_DEAUTHENTICATE,
+                                 0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+}
+
+/**
+ *  @brief Set Idle Off
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlanidle_off(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    const u8 zeroMac[] = { 0, 0, 0, 0, 0, 0 };
+    int i;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+            if (memcmp(Adapter->PreviousBSSID, zeroMac, sizeof(zeroMac)) != 0) {
+
+                PRINTM(INFO, "Previous SSID = %s\n",
+                       Adapter->PreviousSSID.Ssid);
+                PRINTM(INFO, "Previous BSSID = "
+                       "%02x:%02x:%02x:%02x:%02x:%02x:\n",
+                       Adapter->PreviousBSSID[0], Adapter->PreviousBSSID[1],
+                       Adapter->PreviousBSSID[2], Adapter->PreviousBSSID[3],
+                       Adapter->PreviousBSSID[4], Adapter->PreviousBSSID[5]);
+
+                i = FindSSIDInList(Adapter,
+                                   &Adapter->PreviousSSID,
+                                   Adapter->PreviousBSSID,
+                                   Adapter->InfrastructureMode);
+
+                if (i < 0) {
+                    SendSpecificBSSIDScan(priv, Adapter->PreviousBSSID);
+                    i = FindSSIDInList(Adapter,
+                                       &Adapter->PreviousSSID,
+                                       Adapter->PreviousBSSID,
+                                       Adapter->InfrastructureMode);
+                }
+
+                if (i < 0) {
+                    /* If the BSSID could not be found, try just the SSID */
+                    i = FindSSIDInList(Adapter,
+                                       &Adapter->PreviousSSID,
+                                       NULL, Adapter->InfrastructureMode);
+                }
+
+                if (i < 0) {
+                    SendSpecificSSIDScan(priv, &Adapter->PreviousSSID);
+                    i = FindSSIDInList(Adapter,
+                                       &Adapter->PreviousSSID,
+                                       NULL, Adapter->InfrastructureMode);
+                }
+
+                if (i >= 0) {
+                    ret = wlan_associate(priv, &Adapter->ScanTable[i]);
+                }
+            }
+        } else if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+            ret = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_802_11_AD_HOC_START,
+                                        0, HostCmd_OPTION_WAITFORRSP,
+                                        0, &Adapter->PreviousSSID);
+        }
+    }
+    /* else it is connected */
+
+    PRINTM(INFO, "\nwlanidle is off");
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Set Idle On
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlanidle_on(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+            PRINTM(INFO, "Previous SSID = %s\n", Adapter->PreviousSSID.Ssid);
+            memmove(&Adapter->PreviousSSID,
+                    &Adapter->CurBssParams.ssid, sizeof(WLAN_802_11_SSID));
+            wlan_send_deauth(priv);
+
+        } else if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+            ret = StopAdhocNetwork(priv);
+        }
+
+    }
+#ifdef REASSOCIATION
+    if (Adapter->TimerIsSet == TRUE) {
+        CancelTimer(&Adapter->MrvDrvTimer);
+        Adapter->TimerIsSet = FALSE;
+    }
+#endif /* REASSOCIATION */
+
+    PRINTM(INFO, "\nwlanidle is on");
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Append a generic IE as a passthrough TLV to a TLV buffer.
+ *
+ *  It is called from the network join command prep. routine. If a generic
+ *    IE buffer has been setup by the application/supplication, the routine
+ *    appends the buffer as a passthrough TLV type to the request.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param ppBuffer pointer to command buffer pointer
+ *  @return         bytes added to the buffer
+ */
+int
+wlan_cmd_append_generic_ie(wlan_private * priv, u8 ** ppBuffer)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int retLen = 0;
+    MrvlIEtypesHeader_t ieHeader;
+
+    /* Null Checks */
+    if (ppBuffer == 0)
+        return 0;
+    if (*ppBuffer == 0)
+        return 0;
+
+    /*
+     * If there is a generic ie buffer setup, append it to the return
+     *   parameter buffer pointer.
+     */
+    if (Adapter->genIeBufferLen) {
+        PRINTM(INFO, "append generic %d to %p\n", Adapter->genIeBufferLen,
+               *ppBuffer);
+
+        /* Wrap the generic IE buffer with a passthrough TLV type */
+        ieHeader.Type = wlan_cpu_to_le16(TLV_TYPE_PASSTHROUGH);
+        ieHeader.Len = wlan_cpu_to_le16(Adapter->genIeBufferLen);
+        memcpy(*ppBuffer, &ieHeader, sizeof(ieHeader));
+
+        /* Increment the return size and the return buffer pointer param */
+        *ppBuffer += sizeof(ieHeader);
+        retLen += sizeof(ieHeader);
+
+        /* Copy the generic IE buffer to the output buffer, advance pointer */
+        memcpy(*ppBuffer, Adapter->genIeBuffer, Adapter->genIeBufferLen);
+
+        /* Increment the return size and the return buffer pointer param */
+        *ppBuffer += Adapter->genIeBufferLen;
+        retLen += Adapter->genIeBufferLen;
+
+        /* Reset the generic IE buffer */
+        Adapter->genIeBufferLen = 0;
+    }
+
+    /* return the length appended to the buffer */
+    return retLen;
+}
+
+/**
+ *  @brief Append any application provided Marvell TLVs to a TLV buffer.
+ *
+ *  It is called from the network join command prep. routine. If the Marvell
+ *    TLV buffer has been setup by the application/supplication, the routine
+ *    appends the buffer to the request.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param ppBuffer pointer to command buffer pointer
+ *  @return         bytes added to the buffer
+ */
+int
+wlan_cmd_append_marvell_tlv(wlan_private * priv, u8 ** ppBuffer)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int retLen = 0;
+
+    /* Null Checks */
+    if (ppBuffer == 0)
+        return 0;
+    if (*ppBuffer == 0)
+        return 0;
+
+    /*
+     * If there is a Marvell TLV buffer setup, append it to the return
+     *   parameter buffer pointer.
+     */
+    if (Adapter->mrvlTlvBufferLen) {
+        PRINTM(INFO, "append tlv %d to %p\n", Adapter->mrvlTlvBufferLen,
+               *ppBuffer);
+
+        /* Copy the TLV buffer to the output buffer, advance pointer */
+        memcpy(*ppBuffer, Adapter->mrvlTlvBuffer, Adapter->mrvlTlvBufferLen);
+
+        /* Increment the return size and the return buffer pointer param */
+        *ppBuffer += Adapter->mrvlTlvBufferLen;
+        retLen += Adapter->mrvlTlvBufferLen;
+
+        /* Reset the Marvell TLV buffer */
+        Adapter->mrvlTlvBufferLen = 0;
+    }
+
+    /* return the length appended to the buffer */
+    return retLen;
+}
+
+/**
+ *  @brief Append the reassociation TLV to the TLV buffer if appropriate.
+ *
+ *  It is called from the network join command prep. routine.
+ *    If a reassociation attempt is in progress (determined from flag in
+ *    the wlan_priv structure), a REASSOCAP TLV is added to the association
+ *    request.
+ *
+ *  This causes the firmware to send a reassociation request instead of an
+ *    association request.  The wlan_priv structure also contains the current
+ *    AP BSSID to be passed in the TLV and eventually in the management
+ *    frame to the new AP.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param ppBuffer pointer to command buffer pointer
+ *  @return         bytes added to the buffer
+ */
+int
+wlan_cmd_append_reassoc_tlv(wlan_private * priv, u8 ** ppBuffer)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int retLen = 0;
+    MrvlIEtypes_ReassocAp_t reassocIe;
+
+    /* Null Checks */
+    if (ppBuffer == 0)
+        return 0;
+    if (*ppBuffer == 0)
+        return 0;
+
+    /*
+     * If the reassocAttempt flag is set in the adapter structure, include
+     *   the appropriate TLV in the association buffer pointed to by ppBuffer
+     */
+    if (Adapter->reassocAttempt) {
+        PRINTM(INFO, "Reassoc: append current AP: %#x:%#x:%#x:%#x:%#x:%#x\n",
+               Adapter->reassocCurrentAp[0], Adapter->reassocCurrentAp[1],
+               Adapter->reassocCurrentAp[2], Adapter->reassocCurrentAp[3],
+               Adapter->reassocCurrentAp[4], Adapter->reassocCurrentAp[5]);
+
+        /* Setup a copy of the reassocIe on the stack */
+        reassocIe.Header.Type = wlan_cpu_to_le16(TLV_TYPE_REASSOCAP);
+        reassocIe.Header.Len
+            = wlan_cpu_to_le16(sizeof(MrvlIEtypes_ReassocAp_t)
+                               - sizeof(MrvlIEtypesHeader_t));
+
+        memcpy(&reassocIe.currentAp,
+               &Adapter->reassocCurrentAp, sizeof(reassocIe.currentAp));
+
+        /* Copy the stack reassocIe to the buffer pointer parameter */
+        memcpy(*ppBuffer, &reassocIe, sizeof(reassocIe));
+
+        /* Set the return length */
+        retLen = sizeof(reassocIe);
+
+        /* Advance passed buffer pointer */
+        *ppBuffer += sizeof(reassocIe);
+
+        /* Reset the reassocAttempt flag, only valid for a single attempt */
+        Adapter->reassocAttempt = FALSE;
+
+        /* Reset the reassociation AP address */
+        memset(&Adapter->reassocCurrentAp,
+               0x00, sizeof(Adapter->reassocCurrentAp));
+    }
+
+    /* return the length appended to the buffer */
+    return retLen;
+}
+
+/**
+ *  @brief This function prepares command of authenticate.
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param cmd       A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf Void cast of pointer to a BSSID to authenticate with
+ *
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_authenticate(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_AUTHENTICATE *pAuthenticate = &cmd->params.auth;
+    u8 *bssid = (u8 *) pdata_buf;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_AUTHENTICATE);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_AUTHENTICATE)
+                                 + S_DS_GEN);
+
+    pAuthenticate->AuthType = Adapter->SecInfo.AuthenticationMode;
+    memcpy(pAuthenticate->MacAddr, bssid, MRVDRV_ETH_ADDR_LEN);
+
+    PRINTM(INFO, "AUTH_CMD: Bssid is : %x:%x:%x:%x:%x:%x\n",
+           bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of deauthenticat.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param cmd      A pointer to HostCmd_DS_COMMAND structure
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_deauthenticate(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_DEAUTHENTICATE *dauth = &cmd->params.deauth;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_DEAUTHENTICATE);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_DEAUTHENTICATE) + S_DS_GEN);
+
+    /* set AP MAC address */
+    memmove(dauth->MacAddr, Adapter->CurBssParams.bssid, MRVDRV_ETH_ADDR_LEN);
+
+    /* Reason code 3 = Station is leaving */
+#define REASON_CODE_STA_LEAVING 3
+    dauth->ReasonCode = wlan_cpu_to_le16(REASON_CODE_STA_LEAVING);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of association.
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param cmd       A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf Void cast of BSSDescriptor_t from the scan table to assoc
+ *  @return          WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_associate(wlan_private * priv,
+                          HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_ASSOCIATE *pAsso = &cmd->params.associate;
+    int ret = WLAN_STATUS_SUCCESS;
+    BSSDescriptor_t *pBSSDesc;
+    u8 *card_rates;
+    u8 *pos;
+    int card_rates_size;
+    u16 TmpCap;
+    MrvlIEtypes_SsIdParamSet_t *ssid;
+    MrvlIEtypes_PhyParamSet_t *phy;
+    MrvlIEtypes_SsParamSet_t *ss;
+    MrvlIEtypes_RatesParamSet_t *rates;
+    MrvlIEtypes_RsnParamSet_t *rsn;
+
+    ENTER();
+
+    pBSSDesc = (BSSDescriptor_t *) pdata_buf;
+    pos = (u8 *) pAsso;
+
+    if (!Adapter) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_ASSOCIATE);
+
+    /* Save so we know which BSS Desc to use in the response handler */
+    Adapter->pAttemptedBSSDesc = pBSSDesc;
+
+    memcpy(pAsso->PeerStaAddr,
+           pBSSDesc->MacAddress, sizeof(pAsso->PeerStaAddr));
+    pos += sizeof(pAsso->PeerStaAddr);
+
+    /* set preamble to firmware */
+    if (Adapter->capInfo.ShortPreamble && pBSSDesc->Cap.ShortPreamble) {
+        Adapter->Preamble = HostCmd_TYPE_SHORT_PREAMBLE;
+    } else {
+        Adapter->Preamble = HostCmd_TYPE_LONG_PREAMBLE;
+    }
+
+    SetRadioControl(priv);
+
+    /* set the listen interval */
+    pAsso->ListenInterval = wlan_cpu_to_le16(Adapter->ListenInterval);
+
+    pos += sizeof(pAsso->CapInfo);
+    pos += sizeof(pAsso->ListenInterval);
+    pos += sizeof(pAsso->BcnPeriod);
+    pos += sizeof(pAsso->DtimPeriod);
+
+    ssid = (MrvlIEtypes_SsIdParamSet_t *) pos;
+    ssid->Header.Type = wlan_cpu_to_le16(TLV_TYPE_SSID);
+    ssid->Header.Len = pBSSDesc->Ssid.SsidLength;
+    memcpy(ssid->SsId, pBSSDesc->Ssid.Ssid, ssid->Header.Len);
+    pos += sizeof(ssid->Header) + ssid->Header.Len;
+    ssid->Header.Len = wlan_cpu_to_le16(ssid->Header.Len);
+
+    phy = (MrvlIEtypes_PhyParamSet_t *) pos;
+    phy->Header.Type = wlan_cpu_to_le16(TLV_TYPE_PHY_DS);
+    phy->Header.Len = sizeof(phy->fh_ds.DsParamSet);
+    memcpy(&phy->fh_ds.DsParamSet,
+           &pBSSDesc->PhyParamSet.DsParamSet.CurrentChan,
+           sizeof(phy->fh_ds.DsParamSet));
+    pos += sizeof(phy->Header) + phy->Header.Len;
+    phy->Header.Len = wlan_cpu_to_le16(phy->Header.Len);
+
+    ss = (MrvlIEtypes_SsParamSet_t *) pos;
+    ss->Header.Type = wlan_cpu_to_le16(TLV_TYPE_CF);
+    ss->Header.Len = sizeof(ss->cf_ibss.CfParamSet);
+    pos += sizeof(ss->Header) + ss->Header.Len;
+    ss->Header.Len = wlan_cpu_to_le16(ss->Header.Len);
+
+    rates = (MrvlIEtypes_RatesParamSet_t *) pos;
+    rates->Header.Type = wlan_cpu_to_le16(TLV_TYPE_RATES);
+
+    memcpy(&rates->Rates, &pBSSDesc->SupportedRates, WLAN_SUPPORTED_RATES);
+
+    card_rates = SupportedRates;
+    card_rates_size = sizeof(SupportedRates);
+
+    if (get_common_rates(Adapter, rates->Rates, WLAN_SUPPORTED_RATES,
+                         card_rates, card_rates_size)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    rates->Header.Len = MIN(strlen(rates->Rates), WLAN_SUPPORTED_RATES);
+    Adapter->CurBssParams.NumOfRates = rates->Header.Len;
+
+    pos += sizeof(rates->Header) + rates->Header.Len;
+    rates->Header.Len = wlan_cpu_to_le16(rates->Header.Len);
+
+    if (Adapter->SecInfo.WPAEnabled || Adapter->SecInfo.WPA2Enabled) {
+        rsn = (MrvlIEtypes_RsnParamSet_t *) pos;
+        rsn->Header.Type = (u16) Adapter->Wpa_ie[0];    /* WPA_IE or WPA2_IE */
+        rsn->Header.Type = rsn->Header.Type & 0x00FF;
+        rsn->Header.Type = wlan_cpu_to_le16(rsn->Header.Type);
+        rsn->Header.Len = (u16) Adapter->Wpa_ie[1];
+        rsn->Header.Len = rsn->Header.Len & 0x00FF;
+        memcpy(rsn->RsnIE, &Adapter->Wpa_ie[2], rsn->Header.Len);
+        HEXDUMP("ASSOC_CMD: RSN IE", (u8 *) rsn,
+                sizeof(rsn->Header) + rsn->Header.Len);
+        pos += sizeof(rsn->Header) + rsn->Header.Len;
+        rsn->Header.Len = wlan_cpu_to_le16(rsn->Header.Len);
+    }
+
+    wlan_wmm_process_association_req(priv, &pos, &pBSSDesc->wmmIE);
+
+    wlan_cmd_append_reassoc_tlv(priv, &pos);
+
+    wlan_cmd_append_generic_ie(priv, &pos);
+
+    wlan_cmd_append_marvell_tlv(priv, &pos);
+
+    /* update CurBssParams */
+    Adapter->CurBssParams.channel =
+        (pBSSDesc->PhyParamSet.DsParamSet.CurrentChan);
+
+    /* Copy the infra. association rates into Current BSS state structure */
+    memcpy(&Adapter->CurBssParams.DataRates, &rates->Rates,
+           MIN(sizeof(Adapter->CurBssParams.DataRates),
+               wlan_le16_to_cpu(rates->Header.Len)));
+
+    PRINTM(INFO, "ASSOC_CMD: rates->Header.Len = %d\n",
+           wlan_le16_to_cpu(rates->Header.Len));
+
+    /* set IBSS field */
+    if (pBSSDesc->InfrastructureMode == Wlan802_11Infrastructure) {
+#define CAPINFO_ESS_MODE 1
+        pAsso->CapInfo.Ess = CAPINFO_ESS_MODE;
+    }
+
+    if (wlan_parse_dnld_countryinfo_11d(priv)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    cmd->Size = wlan_cpu_to_le16((u16) (pos - (u8 *) pAsso) + S_DS_GEN);
+
+    /* set the Capability info at last */
+    memcpy(&TmpCap, &pBSSDesc->Cap, sizeof(pAsso->CapInfo));
+    TmpCap &= CAPINFO_MASK;
+    PRINTM(INFO, "ASSOC_CMD: TmpCap=%4X CAPINFO_MASK=%4X\n",
+           TmpCap, CAPINFO_MASK);
+    TmpCap = wlan_cpu_to_le16(TmpCap);
+    memcpy(&pAsso->CapInfo, &TmpCap, sizeof(pAsso->CapInfo));
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function prepares command of ad_hoc_start.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param cmd      A pointer to HostCmd_DS_COMMAND structure
+ *  @param pssid    A pointer to WLAN_802_11_SSID structure
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_ad_hoc_start(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, void *pssid)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_AD_HOC_START *adhs = &cmd->params.ads;
+    int ret = WLAN_STATUS_SUCCESS;
+    int cmdAppendSize = 0;
+    int i;
+    u16 TmpCap;
+    BSSDescriptor_t *pBSSDesc;
+
+    ENTER();
+
+    if (!Adapter) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);
+
+    pBSSDesc = &Adapter->CurBssParams.BSSDescriptor;
+    Adapter->pAttemptedBSSDesc = pBSSDesc;
+
+    /*
+     * Fill in the parameters for 2 data structures:
+     *   1. HostCmd_DS_802_11_AD_HOC_START Command
+     *   2. Adapter->ScanTable[i]
+     *
+     * Driver will fill up SSID, BSSType,IBSS param, Physical Param,
+     *   probe delay, and Cap info.
+     *
+     * Firmware will fill up beacon period, DTIM, Basic rates
+     *   and operational rates.
+     */
+
+    memset(adhs->SSID, 0, MRVDRV_MAX_SSID_LENGTH);
+
+    memcpy(adhs->SSID, ((PWLAN_802_11_SSID) pssid)->Ssid,
+           ((PWLAN_802_11_SSID) pssid)->SsidLength);
+
+    PRINTM(INFO, "ADHOC_S_CMD: SSID = %s\n", adhs->SSID);
+
+    memset(pBSSDesc->Ssid.Ssid, 0, MRVDRV_MAX_SSID_LENGTH);
+    memcpy(pBSSDesc->Ssid.Ssid,
+           ((PWLAN_802_11_SSID) pssid)->Ssid,
+           ((PWLAN_802_11_SSID) pssid)->SsidLength);
+
+    pBSSDesc->Ssid.SsidLength = ((PWLAN_802_11_SSID) pssid)->SsidLength;
+
+    /* set the BSS type */
+    adhs->BSSType = HostCmd_BSS_TYPE_IBSS;
+    pBSSDesc->InfrastructureMode = Wlan802_11IBSS;
+    adhs->BeaconPeriod = Adapter->BeaconPeriod;
+    pBSSDesc->BeaconPeriod = Adapter->BeaconPeriod;
+
+    /* set Physical param set */
+#define DS_PARA_IE_ID   3
+#define DS_PARA_IE_LEN  1
+
+    adhs->PhyParamSet.DsParamSet.ElementId = DS_PARA_IE_ID;
+    adhs->PhyParamSet.DsParamSet.Len = DS_PARA_IE_LEN;
+
+    ASSERT(Adapter->AdhocChannel);
+
+    PRINTM(INFO, "ADHOC_S_CMD: Creating ADHOC on Channel %d\n",
+           Adapter->AdhocChannel);
+
+    Adapter->CurBssParams.channel = Adapter->AdhocChannel;
+
+    pBSSDesc->Channel = Adapter->AdhocChannel;
+    adhs->PhyParamSet.DsParamSet.CurrentChan = Adapter->AdhocChannel;
+
+    memcpy(&pBSSDesc->PhyParamSet,
+           &adhs->PhyParamSet, sizeof(IEEEtypes_PhyParamSet_t));
+
+    pBSSDesc->NetworkTypeInUse = Wlan802_11DS;
+
+    /* set IBSS param set */
+#define IBSS_PARA_IE_ID   6
+#define IBSS_PARA_IE_LEN  2
+
+    adhs->SsParamSet.IbssParamSet.ElementId = IBSS_PARA_IE_ID;
+    adhs->SsParamSet.IbssParamSet.Len = IBSS_PARA_IE_LEN;
+    adhs->SsParamSet.IbssParamSet.AtimWindow = Adapter->AtimWindow;
+    pBSSDesc->ATIMWindow = Adapter->AtimWindow;
+    memcpy(&pBSSDesc->SsParamSet,
+           &adhs->SsParamSet, sizeof(IEEEtypes_SsParamSet_t));
+
+    /* set Capability info */
+    adhs->Cap.Ess = 0;
+    adhs->Cap.Ibss = 1;
+    pBSSDesc->Cap.Ibss = 1;
+
+    /* set up privacy in Adapter->ScanTable[i] */
+    if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled
+        || Adapter->AdhocAESEnabled) {
+
+#define AD_HOC_CAP_PRIVACY_ON 1
+        PRINTM(INFO, "ADHOC_S_CMD: WEPStatus set, Privacy to WEP\n");
+        pBSSDesc->Privacy = Wlan802_11PrivFilter8021xWEP;
+        adhs->Cap.Privacy = AD_HOC_CAP_PRIVACY_ON;
+    } else {
+        PRINTM(INFO, "ADHOC_S_CMD: WEPStatus NOT set, Setting "
+               "Privacy to ACCEPT ALL\n");
+        pBSSDesc->Privacy = Wlan802_11PrivFilterAcceptAll;
+    }
+
+    memset(adhs->DataRate, 0, sizeof(adhs->DataRate));
+
+    if (Adapter->adhoc_grate_enabled == TRUE) {
+        memcpy(adhs->DataRate, AdhocRates_G,
+               MIN(sizeof(adhs->DataRate), sizeof(AdhocRates_G)));
+    } else {
+        memcpy(adhs->DataRate, AdhocRates_B,
+               MIN(sizeof(adhs->DataRate), sizeof(AdhocRates_B)));
+    }
+
+    /* Find the last non zero */
+    for (i = 0; i < sizeof(adhs->DataRate) && adhs->DataRate[i]; i++);
+
+    Adapter->CurBssParams.NumOfRates = i;
+
+    /* Copy the ad-hoc creating rates into Current BSS state structure */
+    memcpy(&Adapter->CurBssParams.DataRates,
+           &adhs->DataRate, Adapter->CurBssParams.NumOfRates);
+
+    PRINTM(INFO, "ADHOC_S_CMD: Rates=%02x %02x %02x %02x \n",
+           adhs->DataRate[0], adhs->DataRate[1],
+           adhs->DataRate[2], adhs->DataRate[3]);
+
+    PRINTM(INFO, "ADHOC_S_CMD: AD HOC Start command is ready\n");
+
+    if (wlan_create_dnld_countryinfo_11d(priv)) {
+        PRINTM(INFO, "ADHOC_S_CMD: dnld_countryinfo_11d failed\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_AD_HOC_START)
+                                 + S_DS_GEN + cmdAppendSize);
+
+    adhs->BeaconPeriod = wlan_cpu_to_le16(adhs->BeaconPeriod);
+    adhs->SsParamSet.IbssParamSet.AtimWindow =
+        wlan_cpu_to_le16(adhs->SsParamSet.IbssParamSet.AtimWindow);
+
+    memcpy(&TmpCap, &adhs->Cap, sizeof(u16));
+    TmpCap = wlan_cpu_to_le16(TmpCap);
+    memcpy(&adhs->Cap, &TmpCap, sizeof(u16));
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function prepares command of ad_hoc_stop.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param cmd      A pointer to HostCmd_DS_COMMAND structure
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_ad_hoc_stop(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_STOP);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_AD_HOC_STOP)
+                                 + S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of ad_hoc_join.
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param cmd       A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf Void cast of BSSDescriptor_t from the scan table to join
+ *
+ *  @return          WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_ad_hoc_join(wlan_private * priv,
+                            HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_AD_HOC_JOIN *pAdHocJoin = &cmd->params.adj;
+    BSSDescriptor_t *pBSSDesc = (BSSDescriptor_t *) pdata_buf;
+    int cmdAppendSize = 0;
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 *card_rates;
+    int card_rates_size;
+    u16 TmpCap;
+    int i;
+
+    ENTER();
+
+    Adapter->pAttemptedBSSDesc = pBSSDesc;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_JOIN);
+
+    pAdHocJoin->BssDescriptor.BSSType = HostCmd_BSS_TYPE_IBSS;
+
+    pAdHocJoin->BssDescriptor.BeaconPeriod = pBSSDesc->BeaconPeriod;
+
+    memcpy(&pAdHocJoin->BssDescriptor.BSSID,
+           &pBSSDesc->MacAddress, MRVDRV_ETH_ADDR_LEN);
+
+    memcpy(&pAdHocJoin->BssDescriptor.SSID,
+           &pBSSDesc->Ssid.Ssid, pBSSDesc->Ssid.SsidLength);
+
+    memcpy(&pAdHocJoin->BssDescriptor.PhyParamSet,
+           &pBSSDesc->PhyParamSet, sizeof(IEEEtypes_PhyParamSet_t));
+
+    memcpy(&pAdHocJoin->BssDescriptor.SsParamSet,
+           &pBSSDesc->SsParamSet, sizeof(IEEEtypes_SsParamSet_t));
+
+    memcpy(&TmpCap, &pBSSDesc->Cap, sizeof(IEEEtypes_CapInfo_t));
+
+    TmpCap &= CAPINFO_MASK;
+
+    PRINTM(INFO, "ADHOC_J_CMD: TmpCap=%4X CAPINFO_MASK=%4X\n",
+           TmpCap, CAPINFO_MASK);
+    memcpy(&pAdHocJoin->BssDescriptor.Cap, &TmpCap,
+           sizeof(IEEEtypes_CapInfo_t));
+
+    /* information on BSSID descriptor passed to FW */
+    PRINTM(INFO, "ADHOC_J_CMD: BSSID = %2x-%2x-%2x-%2x-%2x-%2x, SSID = %s\n",
+           pAdHocJoin->BssDescriptor.BSSID[0],
+           pAdHocJoin->BssDescriptor.BSSID[1],
+           pAdHocJoin->BssDescriptor.BSSID[2],
+           pAdHocJoin->BssDescriptor.BSSID[3],
+           pAdHocJoin->BssDescriptor.BSSID[4],
+           pAdHocJoin->BssDescriptor.BSSID[5],
+           pAdHocJoin->BssDescriptor.SSID);
+
+    PRINTM(INFO, "ADHOC_J_CMD: Data Rate = %x\n",
+           (u32) pAdHocJoin->BssDescriptor.DataRates);
+
+    /* Copy Data Rates from the Rates recorded in scan response */
+    memset(pAdHocJoin->BssDescriptor.DataRates, 0,
+           sizeof(pAdHocJoin->BssDescriptor.DataRates));
+    memcpy(pAdHocJoin->BssDescriptor.DataRates, pBSSDesc->DataRates,
+           MIN(sizeof(pAdHocJoin->BssDescriptor.DataRates),
+               sizeof(pBSSDesc->DataRates)));
+
+    card_rates = SupportedRates;
+    card_rates_size = sizeof(SupportedRates);
+
+    Adapter->CurBssParams.channel = pBSSDesc->Channel;
+
+    if (get_common_rates(Adapter, pAdHocJoin->BssDescriptor.DataRates,
+                         sizeof(pAdHocJoin->BssDescriptor.DataRates),
+                         card_rates, card_rates_size)) {
+        PRINTM(INFO, "ADHOC_J_CMD: get_common_rates returns error.\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Find the last non zero */
+    for (i = 0; i < sizeof(pAdHocJoin->BssDescriptor.DataRates)
+         && pAdHocJoin->BssDescriptor.DataRates[i]; i++);
+
+    Adapter->CurBssParams.NumOfRates = i;
+
+    /*
+     * Copy the adhoc joining rates to Current BSS State structure
+     */
+    memcpy(Adapter->CurBssParams.DataRates,
+           pAdHocJoin->BssDescriptor.DataRates,
+           Adapter->CurBssParams.NumOfRates);
+
+    pAdHocJoin->BssDescriptor.SsParamSet.IbssParamSet.AtimWindow =
+        wlan_cpu_to_le16(pBSSDesc->ATIMWindow);
+
+    if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled
+        || Adapter->AdhocAESEnabled) {
+        pAdHocJoin->BssDescriptor.Cap.Privacy = AD_HOC_CAP_PRIVACY_ON;
+    }
+
+    if (Adapter->PSMode == Wlan802_11PowerModeMAX_PSP) {
+        /* wake up first */
+        WLAN_802_11_POWER_MODE LocalPSMode;
+
+        LocalPSMode = Wlan802_11PowerModeCAM;
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_PS_MODE,
+                                    HostCmd_ACT_GEN_SET, 0, 0, &LocalPSMode);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+    }
+
+    if (wlan_parse_dnld_countryinfo_11d(priv)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_AD_HOC_JOIN)
+                                 + S_DS_GEN + cmdAppendSize);
+
+    pAdHocJoin->BssDescriptor.BeaconPeriod =
+        wlan_cpu_to_le16(pAdHocJoin->BssDescriptor.BeaconPeriod);
+    pAdHocJoin->BssDescriptor.SsParamSet.IbssParamSet.AtimWindow =
+        wlan_cpu_to_le16(pAdHocJoin->BssDescriptor.SsParamSet.IbssParamSet.
+                         AtimWindow);
+
+    memcpy(&TmpCap, &pAdHocJoin->BssDescriptor.Cap,
+           sizeof(IEEEtypes_CapInfo_t));
+    TmpCap = wlan_cpu_to_le16(TmpCap);
+
+    memcpy(&pAdHocJoin->BssDescriptor.Cap,
+           &TmpCap, sizeof(IEEEtypes_CapInfo_t));
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function handles the command response of authenticate
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_authenticate(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Association firmware command response handler
+ *
+ *   The response buffer for the association command has the following
+ *      memory layout.
+ *
+ *   For cases where an association response was not received (indicated
+ *      by the CapInfo and AId field):
+ *
+ *     .------------------------------------------------------------.
+ *     |  Header(4 * sizeof(u16)):  Standard command response hdr   |
+ *     .------------------------------------------------------------.
+ *     |  CapInfo/Error Return(u16):                                |
+ *     |           0xFFFF(-1): Internal error                       |
+ *     |           0xFFFE(-2): Authentication unhandled message     |
+ *     |           0xFFFD(-3): Authentication refused               |
+ *     .------------------------------------------------------------.
+ *     |  StatusCode(u16):                                          |
+ *     |        If CapInfo is -1:                                   |
+ *     |           (1) Internal processing failure                  |
+ *     |           (2) Timeout waiting for AP response              |
+ *     |                                                            |
+ *     |        If CapInfo is -2:                                   |
+ *     |           An authentication frame was received but was     |
+ *     |           not handled by the firmware.  IEEE Status        |
+ *     |           code for the failure is returned.                |
+ *     |                                                            |
+ *     |        If CapInfo is -3:                                   |
+ *     |           An authentication frame was received and the     |
+ *     |           StatusCode is the IEEE Status reported in the    |
+ *     |           response.                                        |
+ *     .------------------------------------------------------------.
+ *     |  AId(u16): 0xFFFF                                          |
+ *     .------------------------------------------------------------.
+ *
+ *
+ *   For cases where an association response was received, the IEEE 
+ *     standard association response frame is returned:
+ *
+ *     .------------------------------------------------------------.
+ *     |  Header(4 * sizeof(u16)):  Standard command response hdr   |
+ *     .------------------------------------------------------------.
+ *     |  CapInfo(u16): IEEE Capability                             |
+ *     .------------------------------------------------------------.
+ *     |  StatusCode(u16): IEEE Status Code                         |
+ *     .------------------------------------------------------------.
+ *     |  AId(u16): IEEE Association ID                             |
+ *     .------------------------------------------------------------.
+ *     |  IEEE IEs(variable): Any received IEs comprising the       |
+ *     |                      remaining portion of a received       |
+ *     |                      association response frame.           |
+ *     .------------------------------------------------------------.
+ *
+ *  For simplistic handling, the StatusCode field can be used to determine
+ *    an association success (0) or failure (non-zero).
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_associate(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    union iwreq_data wrqu;
+    IEEEtypes_AssocRsp_t *pAssocRsp;
+    BSSDescriptor_t *pBSSDesc;
+
+    ENTER();
+
+    pAssocRsp = (IEEEtypes_AssocRsp_t *) & resp->params;
+
+    Adapter->assocRspSize = MIN(wlan_le16_to_cpu(resp->Size) - S_DS_GEN,
+                                sizeof(Adapter->assocRspBuffer));
+
+    memcpy(Adapter->assocRspBuffer, &resp->params, Adapter->assocRspSize);
+
+    if (pAssocRsp->StatusCode) {
+
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            MacEventDisconnected(priv);
+        }
+
+        priv->adapter->dbg.num_cmd_assoc_failure++;
+        PRINTM(CMND, "ASSOC_RESP: Association Failed, status code = %d\n",
+               pAssocRsp->StatusCode);
+
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Send a Media Connected event, according to the Spec */
+    Adapter->MediaConnectStatus = WlanMediaStateConnected;
+    Adapter->LinkSpeed = MRVDRV_LINK_SPEED_11mbps;
+
+    /* Set the attempted BSSID Index to current */
+    pBSSDesc = Adapter->pAttemptedBSSDesc;
+
+    PRINTM(INFO, "ASSOC_RESP: %s\n", pBSSDesc->Ssid.Ssid);
+
+    /* Set the new SSID to current SSID */
+    memcpy(&Adapter->CurBssParams.ssid,
+           &pBSSDesc->Ssid, sizeof(WLAN_802_11_SSID));
+
+    /* Set the new BSSID (AP's MAC address) to current BSSID */
+    memcpy(Adapter->CurBssParams.bssid,
+           pBSSDesc->MacAddress, MRVDRV_ETH_ADDR_LEN);
+
+    /* Make a copy of current BSSID descriptor */
+    memcpy(&Adapter->CurBssParams.BSSDescriptor,
+           pBSSDesc, sizeof(BSSDescriptor_t));
+
+    if (pBSSDesc->wmmIE.ElementId == WMM_IE) {
+        Adapter->CurBssParams.wmm_enabled = TRUE;
+    } else {
+        Adapter->CurBssParams.wmm_enabled = FALSE;
+    }
+
+    if (Adapter->wmm.required && Adapter->CurBssParams.wmm_enabled)
+        Adapter->wmm.enabled = TRUE;
+    else
+        Adapter->wmm.enabled = FALSE;
+
+    Adapter->CurBssParams.wmm_uapsd_enabled = FALSE;
+
+    if (Adapter->wmm.enabled == TRUE) {
+        Adapter->CurBssParams.wmm_uapsd_enabled
+            = pBSSDesc->wmmIE.QoSInfo.QosUAPSD;
+    }
+
+    PRINTM(INFO, "ASSOC_RESP: CurrentPacketFilter is %x\n",
+           Adapter->CurrentPacketFilter);
+
+    if (Adapter->SecInfo.WPAEnabled || Adapter->SecInfo.WPA2Enabled)
+        Adapter->IsGTK_SET = FALSE;
+
+    Adapter->SNR[TYPE_RXPD][TYPE_AVG] = 0;
+    Adapter->NF[TYPE_RXPD][TYPE_AVG] = 0;
+
+    memset(Adapter->rawSNR, 0x00, sizeof(Adapter->rawSNR));
+    memset(Adapter->rawNF, 0x00, sizeof(Adapter->rawNF));
+    Adapter->nextSNRNF = 0;
+    Adapter->numSNRNF = 0;
+
+    /* Don't enable carrier until we get the WMM_GET_STATUS event */
+    if (Adapter->wmm.enabled == FALSE) {
+        os_carrier_on(priv);
+        os_start_queue(priv);
+    }
+
+    priv->adapter->dbg.num_cmd_assoc_success++;
+    PRINTM(INFO, "ASSOC_RESP: Associated \n");
+
+    memcpy(wrqu.ap_addr.sa_data, Adapter->CurBssParams.bssid, ETH_ALEN);
+    wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function handles the command response of disassociate
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_disassociate(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    ENTER();
+
+    priv->adapter->dbg.num_cmd_deauth++;
+    MacEventDisconnected(priv);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of ad_hoc_start and
+ *  ad_hoc_join
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_ad_hoc(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 Command = wlan_le16_to_cpu(resp->Command);
+    u16 Result = wlan_le16_to_cpu(resp->Result);
+    HostCmd_DS_802_11_AD_HOC_RESULT *pAdHocResult;
+    union iwreq_data wrqu;
+    BSSDescriptor_t *pBSSDesc;
+
+    ENTER();
+
+    pAdHocResult = &resp->params.result;
+
+    pBSSDesc = Adapter->pAttemptedBSSDesc;
+
+    /*
+     * Join result code 0 --> SUCCESS
+     */
+    if (Result) {
+        PRINTM(INFO, "ADHOC_RESP Failed\n");
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            MacEventDisconnected(priv);
+        }
+
+        memset(&Adapter->CurBssParams.BSSDescriptor,
+               0x00, sizeof(Adapter->CurBssParams.BSSDescriptor));
+
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /* Send a Media Connected event, according to the Spec */
+    Adapter->MediaConnectStatus = WlanMediaStateConnected;
+    Adapter->LinkSpeed = MRVDRV_LINK_SPEED_11mbps;
+
+    if (Command == HostCmd_RET_802_11_AD_HOC_START) {
+        PRINTM(INFO, "ADHOC_S_RESP  %s\n", pBSSDesc->Ssid.Ssid);
+
+        /* Update the created network descriptor with the new BSSID */
+        memcpy(pBSSDesc->MacAddress,
+               pAdHocResult->BSSID, MRVDRV_ETH_ADDR_LEN);
+    } else {
+        /*
+         * Now the join cmd should be successful
+         * If BSSID has changed use SSID to compare instead of BSSID
+         */
+        PRINTM(INFO, "ADHOC_J_RESP  %s\n", pBSSDesc->Ssid.Ssid);
+
+        /* Make a copy of current BSSID descriptor, only needed for join since
+         *   the current descriptor is already being used for adhoc start
+         */
+        memmove(&Adapter->CurBssParams.BSSDescriptor,
+                pBSSDesc, sizeof(BSSDescriptor_t));
+    }
+
+    /* Set the BSSID from the joined/started descriptor */
+    memcpy(&Adapter->CurBssParams.bssid,
+           pBSSDesc->MacAddress, MRVDRV_ETH_ADDR_LEN);
+
+    /* Set the new SSID to current SSID */
+    memcpy(&Adapter->CurBssParams.ssid,
+           &pBSSDesc->Ssid, sizeof(WLAN_802_11_SSID));
+
+    memset(&wrqu, 0, sizeof(wrqu));
+    memcpy(wrqu.ap_addr.sa_data, Adapter->CurBssParams.bssid, ETH_ALEN);
+    wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+
+    PRINTM(INFO, "ADHOC_RESP: Channel = %d\n", Adapter->AdhocChannel);
+    PRINTM(INFO, "ADHOC_RESP: BSSID = %02x:%02x:%02x:%02x:%02x:%02x\n",
+           pAdHocResult->BSSID[0], pAdHocResult->BSSID[1],
+           pAdHocResult->BSSID[2], pAdHocResult->BSSID[3],
+           pAdHocResult->BSSID[4], pAdHocResult->BSSID[5]);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function handles the command response of ad_hoc_stop
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_ad_hoc_stop(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    ENTER();
+
+    MacEventDisconnected(priv);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+#ifdef REASSOCIATION
+/**
+ *  @brief This function handles re-association. it is triggered
+ *  by re-assoc timer.
+ *
+ *  @param data    A pointer to wlan_thread structure
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+int
+wlan_reassociation_thread(void *data)
+{
+    wlan_thread *thread = data;
+    wlan_private *priv = thread->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    wait_queue_t wait;
+    int i;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    wlan_activate_thread(thread);
+    init_waitqueue_entry(&wait, current);
+
+    for (;;) {
+        add_wait_queue(&thread->waitQ, &wait);
+        OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
+
+        PRINTM(INFO, "Reassoc: Thread sleeping...\n");
+
+        schedule();
+
+        OS_SET_THREAD_STATE(TASK_RUNNING);
+        remove_wait_queue(&thread->waitQ, &wait);
+
+        if (Adapter->SurpriseRemoved) {
+            break;
+        }
+
+        if (kthread_should_stop()) {
+            break;
+        }
+
+        PRINTM(INFO, "Reassoc: Thread waking up...\n");
+
+        if (Adapter->InfrastructureMode != Wlan802_11Infrastructure ||
+            Adapter->HardwareStatus != WlanHardwareStatusReady) {
+            PRINTM(MSG, "Reassoc: mode or hardware status is not correct\n");
+            continue;
+        }
+
+        /* The semaphore is used to avoid reassociation thread and 
+           wlan_set_scan/wlan_set_essid interrupting each other.
+           Reassociation should be disabled completely by application if 
+           wlan_set_user_scan_ioctl/wlan_set_wap is used.
+         */
+        if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+            PRINTM(WARN, "Acquire semaphore error, reassociation thread\n");
+            goto settimer;
+        }
+
+        if (Adapter->MediaConnectStatus != WlanMediaStateDisconnected) {
+            OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+            PRINTM(MSG, "Reassoc: Adapter->MediaConnectStatus is wrong\n");
+            continue;
+        }
+
+        PRINTM(INFO, "Reassoc: Required ESSID: %s\n",
+               Adapter->PreviousSSID.Ssid);
+
+        PRINTM(INFO, "Reassoc: Performing Active Scan @ %lu\n",
+               os_time_get());
+
+        if (Adapter->Prescan) {
+            SendSpecificSSIDScan(priv, &Adapter->PreviousSSID);
+        }
+
+        /* Try to find the specific SSID we were associated to first */
+        i = FindSSIDInList(Adapter,
+                           &Adapter->PreviousSSID,
+                           Adapter->PreviousBSSID,
+                           Adapter->InfrastructureMode);
+
+        if (i < 0) {
+            /* If the SSID could not be found, try just the SSID */
+            i = FindSSIDInList(Adapter,
+                               &Adapter->PreviousSSID,
+                               NULL, Adapter->InfrastructureMode);
+        }
+
+        if (i >= 0) {
+            if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled) {
+                ret = PrepareAndSendCommand(priv,
+                                            HostCmd_CMD_802_11_SET_WEP,
+                                            0, HostCmd_OPTION_WAITFORRSP,
+                                            OID_802_11_ADD_WEP, NULL);
+                if (ret)
+                    PRINTM(INFO, "Ressoc: Fail to set WEP KEY\n");
+            }
+            wlan_associate(priv, &Adapter->ScanTable[i]);
+        }
+
+        OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+
+      settimer:
+        if (Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+            PRINTM(INFO, "Reassoc: No AP found or assoc failed."
+                   "Restarting re-assoc Timer @ %lu\n", os_time_get());
+
+            Adapter->TimerIsSet = TRUE;
+            ModTimer(&Adapter->MrvDrvTimer, MRVDRV_TIMER_10S);
+        }
+    }
+
+    wlan_deactivate_thread(thread);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+#endif /* REASSOCIATION */
+
+int
+sendADHOCBSSIDQuery(wlan_private * priv)
+{
+    return PrepareAndSendCommand(priv,
+                                 HostCmd_CMD_802_11_IBSS_COALESCING_STATUS,
+                                 HostCmd_ACT_GET, 0, 0, NULL);
+}
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_join.h b/drivers/net/wireless/8686_wlan/wlan/wlan_join.h
new file mode 100644
index 0000000..f011e6a
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_join.h
@@ -0,0 +1,97 @@
+/** @file wlan_join.h
+ *
+ *  @brief Interface for the wlan infrastructure and adhoc join routines
+ *
+ *  Driver interface functions and type declarations for the join module
+ *    implemented in wlan_join.c.  Process all start/join requests for
+ *    both adhoc and infrastructure networks
+ *    
+ *  (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *     
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change Log:
+    01/11/06: Initial revision. Match new scan code, relocate related functions
+
+************************************************************/
+
+#ifndef _WLAN_JOIN_H
+#define _WLAN_JOIN_H
+
+//! Size of buffer allocated to store the association response from firmware
+#define MRVDRV_ASSOC_RSP_BUF_SIZE 500
+
+extern int wlan_cmd_802_11_authenticate(wlan_private * priv,
+                                        HostCmd_DS_COMMAND * cmd,
+                                        void *pdata_buf);
+extern int wlan_cmd_802_11_ad_hoc_join(wlan_private * priv,
+                                       HostCmd_DS_COMMAND * cmd,
+                                       void *pdata_buf);
+extern int wlan_cmd_802_11_ad_hoc_stop(wlan_private * priv,
+                                       HostCmd_DS_COMMAND * cmd);
+extern int wlan_cmd_802_11_ad_hoc_start(wlan_private * priv,
+                                        HostCmd_DS_COMMAND * cmd,
+                                        void *pssid);
+extern int wlan_cmd_802_11_deauthenticate(wlan_private * priv,
+                                          HostCmd_DS_COMMAND * cmd);
+extern int wlan_cmd_802_11_associate(wlan_private * priv,
+                                     HostCmd_DS_COMMAND * cmd,
+                                     void *pdata_buf);
+extern int wlan_cmd_append_reassoc_tlv(wlan_private * priv, u8 ** ppBuffer);
+
+extern int wlan_cmd_append_marvell_tlv(wlan_private * priv, u8 ** ppBuffer);
+
+extern int wlan_cmd_append_generic_ie(wlan_private * priv, u8 ** ppBuffer);
+
+extern int wlan_ret_802_11_authenticate(wlan_private * priv,
+                                        HostCmd_DS_COMMAND * resp);
+extern int wlan_ret_802_11_ad_hoc(wlan_private * priv,
+                                  HostCmd_DS_COMMAND * resp);
+extern int wlan_ret_802_11_ad_hoc_stop(wlan_private * priv,
+                                       HostCmd_DS_COMMAND * resp);
+extern int wlan_ret_802_11_disassociate(wlan_private * priv,
+                                        HostCmd_DS_COMMAND * resp);
+extern int wlan_ret_802_11_associate(wlan_private * priv,
+                                     HostCmd_DS_COMMAND * resp);
+
+extern int wlan_associate(wlan_private * priv, BSSDescriptor_t * pBSSDesc);
+
+extern int wlanidle_on(wlan_private * priv);
+extern int wlanidle_off(wlan_private * priv);
+
+extern int wlan_do_adhocstop_ioctl(wlan_private * priv);
+extern int wlan_reassociation_thread(void *data);
+
+extern int StartAdhocNetwork(wlan_private * priv,
+                             WLAN_802_11_SSID * AdhocSSID);
+extern int JoinAdhocNetwork(wlan_private * priv, BSSDescriptor_t * pBSSDesc);
+extern int StopAdhocNetwork(wlan_private * priv);
+
+extern int SendDeauthentication(wlan_private * priv);
+extern int wlan_send_deauth(wlan_private * priv);
+
+extern int wlan_do_adhocstop_ioctl(wlan_private * priv);
+extern int wlan_get_assoc_rsp_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_set_mrvl_tlv_ioctl(wlan_private * priv, struct iwreq *wrq);
+
+#ifdef __KERNEL__
+extern int wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
+                        struct sockaddr *awrq, char *extra);
+#endif
+
+extern int sendADHOCBSSIDQuery(wlan_private * priv);
+
+#endif
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_main.c b/drivers/net/wireless/8686_wlan/wlan/wlan_main.c
new file mode 100644
index 0000000..8a0868f
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_main.c
@@ -0,0 +1,1350 @@
+/** @file wlan_main.c
+  *  
+  * @brief This file contains the major functions in WLAN
+  * driver. It includes init, exit, open, close and main
+  * thread etc..
+  * 
+  * (c) Copyright © 2003-2007, Marvell International Ltd. 
+  *   
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/**
+  * @mainpage M-WLAN Linux Driver
+  *
+  * @section overview_sec Overview
+  *
+  * The M-WLAN is a Linux reference driver for Marvell
+  * 802.11 (a/b/g) WLAN chipset.
+  * 
+  * @section copyright_sec Copyright
+  *
+  * Copyright © Marvell International Ltd. and/or its affiliates, 2003-2007
+  *
+  */
+/********************************************************
+Change log:
+	09/30/05: Add Doxygen format comments
+	12/09/05: Add TX_QUEUE support	
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join functions.
+	01/12/06: Add TxLockFlag for UAPSD power save mode 
+	          and Proprietary Periodic sleep support
+********************************************************/
+
+#include	"include.h"
+//#include	"/usr/src/hufh/include/net/iw_handler.h" //hufh
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+#ifdef ENABLE_PM
+static struct pm_dev *wlan_pm_dev = NULL;
+#endif
+
+spinlock_t driver_lock = SPIN_LOCK_UNLOCKED;
+//raw_spinlock_t driver_lock = RAW_SPIN_LOCK_UNLOCKED(driver_lock);
+ulong driver_flags;
+
+#define WLAN_TX_PWR_DEFAULT		20      /*100mW */
+#define WLAN_TX_PWR_US_DEFAULT		20      /*100mW */
+#define WLAN_TX_PWR_JP_DEFAULT		16      /*50mW */
+#define WLAN_TX_PWR_FR_100MW		20      /*100mW */
+#define WLAN_TX_PWR_EMEA_DEFAULT	20      /*100mW */
+
+/* Format { Channel, Frequency (MHz), MaxTxPower } */
+/* Band: 'B/G', Region: USA FCC/Canada IC */
+static CHANNEL_FREQ_POWER channel_freq_power_US_BG[] = {
+    {1, 2412, WLAN_TX_PWR_US_DEFAULT},
+    {2, 2417, WLAN_TX_PWR_US_DEFAULT},
+    {3, 2422, WLAN_TX_PWR_US_DEFAULT},
+    {4, 2427, WLAN_TX_PWR_US_DEFAULT},
+    {5, 2432, WLAN_TX_PWR_US_DEFAULT},
+    {6, 2437, WLAN_TX_PWR_US_DEFAULT},
+    {7, 2442, WLAN_TX_PWR_US_DEFAULT},
+    {8, 2447, WLAN_TX_PWR_US_DEFAULT},
+    {9, 2452, WLAN_TX_PWR_US_DEFAULT},
+    {10, 2457, WLAN_TX_PWR_US_DEFAULT},
+    {11, 2462, WLAN_TX_PWR_US_DEFAULT}
+};
+
+/* Band: 'B/G', Region: Europe ETSI */
+static CHANNEL_FREQ_POWER channel_freq_power_EU_BG[] = {
+    {1, 2412, WLAN_TX_PWR_EMEA_DEFAULT},
+    {2, 2417, WLAN_TX_PWR_EMEA_DEFAULT},
+    {3, 2422, WLAN_TX_PWR_EMEA_DEFAULT},
+    {4, 2427, WLAN_TX_PWR_EMEA_DEFAULT},
+    {5, 2432, WLAN_TX_PWR_EMEA_DEFAULT},
+    {6, 2437, WLAN_TX_PWR_EMEA_DEFAULT},
+    {7, 2442, WLAN_TX_PWR_EMEA_DEFAULT},
+    {8, 2447, WLAN_TX_PWR_EMEA_DEFAULT},
+    {9, 2452, WLAN_TX_PWR_EMEA_DEFAULT},
+    {10, 2457, WLAN_TX_PWR_EMEA_DEFAULT},
+    {11, 2462, WLAN_TX_PWR_EMEA_DEFAULT},
+    {12, 2467, WLAN_TX_PWR_EMEA_DEFAULT},
+    {13, 2472, WLAN_TX_PWR_EMEA_DEFAULT}
+};
+
+/* Band: 'B/G', Region: Spain */
+static CHANNEL_FREQ_POWER channel_freq_power_SPN_BG[] = {
+    {10, 2457, WLAN_TX_PWR_DEFAULT},
+    {11, 2462, WLAN_TX_PWR_DEFAULT}
+};
+
+/* Band: 'B/G', Region: France */
+static CHANNEL_FREQ_POWER channel_freq_power_FR_BG[] = {
+    {10, 2457, WLAN_TX_PWR_FR_100MW},
+    {11, 2462, WLAN_TX_PWR_FR_100MW},
+    {12, 2467, WLAN_TX_PWR_FR_100MW},
+    {13, 2472, WLAN_TX_PWR_FR_100MW}
+};
+
+/* Band: 'B/G', Region: Japan */
+static CHANNEL_FREQ_POWER channel_freq_power_JPN41_BG[] = {
+    {1, 2412, WLAN_TX_PWR_JP_DEFAULT},
+    {2, 2417, WLAN_TX_PWR_JP_DEFAULT},
+    {3, 2422, WLAN_TX_PWR_JP_DEFAULT},
+    {4, 2427, WLAN_TX_PWR_JP_DEFAULT},
+    {5, 2432, WLAN_TX_PWR_JP_DEFAULT},
+    {6, 2437, WLAN_TX_PWR_JP_DEFAULT},
+    {7, 2442, WLAN_TX_PWR_JP_DEFAULT},
+    {8, 2447, WLAN_TX_PWR_JP_DEFAULT},
+    {9, 2452, WLAN_TX_PWR_JP_DEFAULT},
+    {10, 2457, WLAN_TX_PWR_JP_DEFAULT},
+    {11, 2462, WLAN_TX_PWR_JP_DEFAULT},
+    {12, 2467, WLAN_TX_PWR_JP_DEFAULT},
+    {13, 2472, WLAN_TX_PWR_JP_DEFAULT}
+};
+
+/* Band: 'B/G', Region: Japan */
+static CHANNEL_FREQ_POWER channel_freq_power_JPN40_BG[] = {
+    {14, 2484, WLAN_TX_PWR_JP_DEFAULT}
+};
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/* add by feng for thread conflict debug */
+int threadrunning = 0;
+
+/**
+ * the structure for channel, frequency and power
+ */
+typedef struct _region_cfp_table
+{
+    u8 region;
+    CHANNEL_FREQ_POWER *cfp_BG;
+    int cfp_no_BG;
+} region_cfp_table_t;
+
+/**
+ * the structure for the mapping between region and CFP
+ */
+region_cfp_table_t region_cfp_table[] = {
+    {0x10,                      /*US FCC */
+     channel_freq_power_US_BG,
+     sizeof(channel_freq_power_US_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x20,                      /*CANADA IC */
+     channel_freq_power_US_BG,
+     sizeof(channel_freq_power_US_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x30, /*EU*/ channel_freq_power_EU_BG,
+     sizeof(channel_freq_power_EU_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x31, /*SPAIN*/ channel_freq_power_SPN_BG,
+     sizeof(channel_freq_power_SPN_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x32, /*FRANCE*/ channel_freq_power_FR_BG,
+     sizeof(channel_freq_power_FR_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x40, /*JAPAN*/ channel_freq_power_JPN40_BG,
+     sizeof(channel_freq_power_JPN40_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x41, /*JAPAN*/ channel_freq_power_JPN41_BG,
+     sizeof(channel_freq_power_JPN41_BG) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+/*Add new region here */
+};
+
+/**
+ * the rates supported by the card
+ */
+u8 WlanDataRates[WLAN_SUPPORTED_RATES] =
+    { 0x02, 0x04, 0x0B, 0x16, 0x00, 0x0C, 0x12,
+    0x18, 0x24, 0x30, 0x48, 0x60, 0x6C, 0x00
+};
+
+/**
+ * the rates supported
+ */
+u8 SupportedRates[G_SUPPORTED_RATES] =
+    { 0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6c,
+0 };
+
+/**
+ * the rates supported for ad-hoc G mode
+ */
+u8 AdhocRates_G[G_SUPPORTED_RATES] =
+    { 0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6c,
+0 };
+
+/**
+ * the rates supported for ad-hoc B mode
+ */
+u8 AdhocRates_B[4] = { 0x82, 0x84, 0x8b, 0x96 };
+
+/**
+ * the global variable of a pointer to wlan_private
+ * structure variable
+ */
+wlan_private *wlanpriv = NULL;
+
+u32 DSFreqList[15] = {
+    0, 2412000, 2417000, 2422000, 2427000, 2432000, 2437000, 2442000,
+    2447000, 2452000, 2457000, 2462000, 2467000, 2472000, 2484000
+};
+
+/**
+ * the table to keep region code
+ */
+u16 RegionCodeToIndex[MRVDRV_MAX_REGION_CODE] =
+    { 0x10, 0x20, 0x30, 0x31, 0x32, 0x40, 0x41 };
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function opens the network device
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+static int
+wlan_open(struct net_device *dev)
+{
+    wlan_private *priv = (wlan_private *) dev->priv;
+    wlan_adapter *adapter = priv->adapter;
+
+    ENTER();
+
+    MODULE_GET;
+
+    priv->open = TRUE;
+
+    if (adapter->MediaConnectStatus == WlanMediaStateConnected)
+        os_carrier_on(priv);
+    else
+        os_carrier_off(priv);
+
+    os_start_queue(priv);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function closes the network device
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+static int
+wlan_close(struct net_device *dev)
+{
+    wlan_private *priv = dev->priv;
+
+    ENTER();
+
+    /* Flush all the packets upto the OS before stopping */
+    wlan_send_rxskbQ(priv);
+    os_stop_queue(priv);
+    os_carrier_off(priv);
+
+    MODULE_PUT;
+
+    priv->open = FALSE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+#ifdef ENABLE_PM
+
+/** 
+ *  @brief This function is a callback function. it is called by
+ *  kernel to enter or exit power saving mode.
+ *  
+ *  @param pmdev   A pointer to pm_dev
+ *  @param pmreq   pm_request_t
+ *  @param pmdata  A pointer to pmdata
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_pm_callback(struct pm_dev *pmdev, pm_request_t pmreq, void *pmdata)
+{
+    wlan_private *priv = wlanpriv;
+    wlan_adapter *Adapter = priv->adapter;
+    struct net_device *dev = priv->wlan_dev.netdev;
+    static BOOLEAN OS_Enable_DS = FALSE;
+
+    PRINTM(INFO, "WPRM_PM_CALLBACK: pmreq = %d.\n", pmreq);
+
+    switch (pmreq) {
+    case PM_SUSPEND:
+        PRINTM(INFO, "WPRM_PM_CALLBACK: enter PM_SUSPEND.\n");
+
+#ifdef WPRM_DRV
+        /* check WLAN_HOST_WAKEB */
+        if (wprm_wlan_host_wakeb_is_triggered()) {
+            PRINTM(MSG, "exit on GPIO-1 triggered.\n");
+            return WLAN_STATUS_FAILURE;
+        }
+#endif
+
+        /* in associated mode */
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            if ((Adapter->PSState != PS_STATE_SLEEP)
+                || !Adapter->bWakeupDevRequired || (Adapter->WakeupTries != 0)
+                ) {
+                PRINTM(INFO, "wlan_pm_callback: can't enter sleep mode\n");
+                return WLAN_STATUS_FAILURE;
+            } else {
+
+                /*
+                 * Detach the network interface
+                 * if the network is running
+                 */
+                if (netif_running(dev)) {
+                    netif_device_detach(dev);
+                    PRINTM(INFO, "netif_device_detach().\n");
+                }
+                /* Stop SDIO bus clock */
+                sbi_set_bus_clock(priv, FALSE);
+                sbi_suspend(priv);
+            }
+            break;
+        }
+
+        /* in non associated mode */
+
+        /*
+         * Detach the network interface 
+         * if the network is running
+         */
+        if (netif_running(dev))
+            netif_device_detach(dev);
+
+        /* 
+         * Storing and restoring of the regs be taken care 
+         * at the driver rest will be done at wlan driver
+         * this makes driver independent of the card
+         */
+        if (Adapter->IsDeepSleep == FALSE) {
+            SetDeepSleep(priv, TRUE);
+            OS_Enable_DS = TRUE;
+        }
+
+        sbi_suspend(priv);
+
+        break;
+
+    case PM_RESUME:
+        /* in associated mode */
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            if (Adapter->bWakeupDevRequired == FALSE) {
+                /* could never happen */
+                PRINTM(MSG, "wlan_pm_callback: serious error.\n");
+            } else {
+                /*
+                 * Bring the inteface up first
+                 * This case should not happen still ...
+                 */
+                sbi_resume(priv);
+
+                /*
+                 * Start SDIO bus clock
+                 */
+                sbi_set_bus_clock(priv, TRUE);
+                /*
+                 * Attach the network interface
+                 * if the network is running
+                 */
+                if (netif_running(dev)) {
+                    netif_device_attach(dev);
+                    PRINTM(INFO, "after netif_device_attach().\n");
+                }
+                PRINTM(INFO, "After netif attach, in associated mode.\n");
+            }
+            break;
+        }
+
+        /* in non associated mode */
+
+#ifdef WPRM_DRV
+        /* Background scan support */
+        WPRM_DRV_TRACING_PRINT();
+        /* check if WLAN_HOST_WAKEB triggered, turn on SDIO_CLK */
+        if (wprm_wlan_host_wakeb_is_triggered()) {      /* WLAN_HSOT_WAKEB is triggered */
+            if (sbi_set_bus_clock(priv, TRUE)) {
+                PRINTM(MSG,
+                       "wlan_pm_callback: in PM_RESUME, wlan sdio clock turn on fail\n");
+            }
+            WPRM_DRV_TRACING_PRINT();
+        }
+#endif
+        /*
+         * Bring the inteface up first 
+         * This case should not happen still ...
+         */
+
+        if (OS_Enable_DS == TRUE) {
+#ifdef WPRM_DRV
+            /* if need to wakeup FW, then trigger HOST_WLAN_WAKEB first */
+            wprm_trigger_host_wlan_wakeb(1);
+#endif
+        }
+
+        sbi_resume(priv);
+
+        if (OS_Enable_DS == TRUE) {
+            SetDeepSleep(priv, FALSE);
+            OS_Enable_DS = FALSE;
+        }
+
+        if (netif_running(dev))
+            netif_device_attach(dev);
+
+        PRINTM(INFO, "after netif attach, in NON associated mode.\n");
+        break;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+#endif /* ENABLE_PM */
+
+/** 
+ *  @brief This function handles packet transmission
+ *  
+ *  @param skb     A pointer to sk_buff structure
+ *  @param dev     A pointer to net_device structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+    int ret;
+    wlan_private *priv = dev->priv;
+
+    ENTER();
+
+    PRINTM(DATA, "Data <= kernel\n");
+
+    if (wlan_tx_packet(priv, skb)) {
+        /* Transmit failed */
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    } else {
+        /* Transmit succeeded */
+        if (!priv->adapter->wmm.enabled) {
+            if (priv->adapter->TxSkbNum >= MAX_NUM_IN_TX_Q) {
+                UpdateTransStart(dev);
+                os_stop_queue(priv);
+            }
+        }
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function handles the timeout of packet
+ *  transmission
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return 	   n/a
+ */
+static void
+wlan_tx_timeout(struct net_device *dev)
+{
+    wlan_private *priv = (wlan_private *) dev->priv;
+
+    ENTER();
+
+    PRINTM(DATA, "Tx timeout\n");
+    umd_dbg( "Tx timeout!!!!");
+
+    UpdateTransStart(dev);
+
+    priv->adapter->dbg.num_tx_timeout++;
+
+    priv->adapter->IntCounter++;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function returns the network statistics
+ *  
+ *  @param dev     A pointer to wlan_private structure
+ *  @return 	   A pointer to net_device_stats structure
+ */
+static struct net_device_stats *
+wlan_get_stats(struct net_device *dev)
+{
+    wlan_private *priv = (wlan_private *) dev->priv;
+
+    return &priv->stats;
+}
+
+/** 
+ *  @brief This function sets the MAC address to firmware.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param pRxPD   A pointer to RxPD structure of received packet
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_set_mac_address(struct net_device *dev, void *addr)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = (wlan_private *) dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    struct sockaddr *pHwAddr = (struct sockaddr *) addr;
+
+    ENTER();
+
+    memset(Adapter->CurrentAddr, 0, MRVDRV_ETH_ADDR_LEN);
+
+    /* dev->dev_addr is 8 bytes */
+    HEXDUMP("dev->dev_addr:", dev->dev_addr, ETH_ALEN);
+
+    HEXDUMP("addr:", pHwAddr->sa_data, ETH_ALEN);
+    memcpy(Adapter->CurrentAddr, pHwAddr->sa_data, ETH_ALEN);
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_MAC_ADDRESS,
+                                HostCmd_ACT_SET,
+                                HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    if (ret) {
+        PRINTM(INFO, "set mac address failed.\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    HEXDUMP("Adapter->MacAddr:", Adapter->CurrentAddr, ETH_ALEN);
+    memcpy(dev->dev_addr, Adapter->CurrentAddr, ETH_ALEN);
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function sets multicast addresses to firmware
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return 	   n/a
+ */
+static void
+wlan_set_multicast_list(struct net_device *dev)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int OldPacketFilter;
+
+    ENTER();
+
+    OldPacketFilter = Adapter->CurrentPacketFilter;
+
+    if (dev->flags & IFF_PROMISC) {
+        PRINTM(INFO, "Enable Promiscuous mode\n");
+        Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_PROMISCUOUS_ENABLE;
+        Adapter->CurrentPacketFilter &=
+            ~(HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE |
+              HostCmd_ACT_MAC_MULTICAST_ENABLE);
+    } else {
+        /* Multicast */
+        Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_PROMISCUOUS_ENABLE;
+
+        if (dev->flags & IFF_ALLMULTI || dev->mc_count >
+            MRVDRV_MAX_MULTICAST_LIST_SIZE) {
+            PRINTM(INFO, "Enabling All Multicast!\n");
+            Adapter->CurrentPacketFilter |=
+                HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;
+            Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_MULTICAST_ENABLE;
+        } else {
+            Adapter->CurrentPacketFilter &=
+                ~HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;
+
+            if (!dev->mc_count) {
+                PRINTM(INFO, "No multicast addresses - "
+                       "disabling multicast!\n");
+                Adapter->CurrentPacketFilter &=
+                    ~HostCmd_ACT_MAC_MULTICAST_ENABLE;
+            } else {
+                int i;
+
+                Adapter->CurrentPacketFilter |=
+                    HostCmd_ACT_MAC_MULTICAST_ENABLE;
+
+                Adapter->NumOfMulticastMACAddr =
+                    CopyMulticastAddrs(Adapter, dev);
+
+                PRINTM(INFO, "Multicast addresses: %d\n", dev->mc_count);
+
+                for (i = 0; i < dev->mc_count; i++) {
+                    PRINTM(INFO, "Multicast address %d:"
+                           "%x %x %x %x %x %x\n", i,
+                           Adapter->MulticastList[i][0],
+                           Adapter->MulticastList[i][1],
+                           Adapter->MulticastList[i][2],
+                           Adapter->MulticastList[i][3],
+                           Adapter->MulticastList[i][4],
+                           Adapter->MulticastList[i][5]);
+                }
+                /* set multicast addresses to firmware */
+                PrepareAndSendCommand(priv, HostCmd_CMD_MAC_MULTICAST_ADR,
+                                      HostCmd_ACT_GEN_SET, 0, 0, NULL);
+            }
+        }
+    }
+
+    if (Adapter->CurrentPacketFilter != OldPacketFilter) {
+        SetMacPacketFilter(priv);
+    }
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function pops rx_skb from the rx queue.
+ *  
+ *  @param RxSkbQ  A pointer to rx_skb queue
+ *  @return 	   A pointer to skb
+ */
+static struct sk_buff *
+wlan_pop_rx_skb(struct sk_buff *RxSkbQ)
+{
+    struct sk_buff *skb_data = NULL;
+
+    if (!list_empty((struct list_head *) RxSkbQ)) {
+        skb_data = RxSkbQ->next;
+        list_del((struct list_head *) RxSkbQ->next);
+    }
+
+    return skb_data;
+}
+
+/** 
+ *  @brief This function hanldes the major job in WLAN driver.
+ *  it handles the event generated by firmware, rx data received
+ *  from firmware and tx data sent from kernel.
+ *  
+ *  @param data    A pointer to wlan_thread structure
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+static int wlan_service_main_thread(void *data)
+{
+    wlan_thread *thread = data;
+    wlan_private *priv = thread->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    wait_queue_t wait;
+    u8 ireg = 0;
+    int ret;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    wlan_activate_thread(thread);
+
+    init_waitqueue_entry(&wait, current);
+
+    for (;;) {
+        add_wait_queue(&thread->waitQ, &wait);
+        OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
+
+        TX_DISABLE;
+
+        if ((Adapter->WakeupTries) ||
+            (Adapter->PSState == PS_STATE_SLEEP
+             && !Adapter->bWakeupDevRequired) ||
+            (!Adapter->IntCounter
+             && (priv->wlan_dev.dnld_sent || !Adapter->wmm.enabled ||
+                 Adapter->TxLockFlag || !os_queue_is_active(priv) ||
+                 wmm_lists_empty(priv))
+             && (priv->wlan_dev.dnld_sent || Adapter->TxLockFlag ||
+                 !Adapter->TxSkbNum)
+             && (priv->wlan_dev.dnld_sent || Adapter->CurCmd ||
+                 list_empty(&Adapter->CmdPendingQ))
+            )
+            ) {
+            umd_dbg("main-thread sleeping... "
+                   "WakeupReq=%s Conn=%s PS_Mode=%d PS_State=%d\n",
+                   (Adapter->bWakeupDevRequired) ? "Y" : "N",
+                   (Adapter->MediaConnectStatus) ? "Y" : "N",
+                   Adapter->PSMode, Adapter->PSState);
+
+            TX_RESTORE;
+
+		/* add by feng for thread debug */
+	    threadrunning = 0;
+
+            schedule();
+
+		/* add by feng for thread debug */
+	    threadrunning = 1;
+
+	    umd_dbg("");
+            umd_dbg("main-thread waking up: IntCnt=%d "
+                   "CurCmd=%s CmdPending=%s"
+                   " Connect=%s CurTxSkb=%s dnld_sent=%d",
+                   Adapter->IntCounter,
+                   (Adapter->CurCmd) ? "Y" : "N",
+                   list_empty(&Adapter->CmdPendingQ) ? "N" : "Y",
+                   (Adapter->MediaConnectStatus) ? "Y" : "N",
+                   (Adapter->CurrentTxSkb) ? "Y" : "N",
+                   priv->wlan_dev.dnld_sent);
+        } else {
+            TX_RESTORE;
+        }
+
+        OS_SET_THREAD_STATE(TASK_RUNNING);
+        remove_wait_queue(&thread->waitQ, &wait);
+
+        if (kthread_should_stop()
+            || Adapter->SurpriseRemoved) {
+           umd_dbg("main-thread: break from main thread: SurpriseRemoved=0x%x",
+                   Adapter->SurpriseRemoved);
+            break;
+        }
+
+	/* if some ISR wakes card up, need read card's INT reg to
+	   get the detail information */
+        if (Adapter->IntCounter) {
+            OS_INT_DISABLE;
+            Adapter->IntCounter = 0;
+            OS_INT_RESTORE;
+
+            if (sbi_get_int_status(priv, &ireg)) {
+                PRINTM(ERROR,
+                       "main-thread: reading HOST_INT_STATUS_REG failed\n");
+                continue;
+            }
+            OS_INT_DISABLE;
+            Adapter->HisRegCpy |= ireg;
+            OS_INT_RESTORE;
+            umd_dbg("INT: status = 0x%x", Adapter->HisRegCpy);
+        } else if (Adapter->bWakeupDevRequired
+                   && (Adapter->PSState == PS_STATE_SLEEP)
+            ) {
+            Adapter->WakeupTries++;
+            PRINTM(CMND,
+                   "Wakeup device... WakeupReq=%s Conn=%s PS_Mode=%d PS_State=%d\n",
+                   (Adapter->bWakeupDevRequired) ? "Y" : "N",
+                   (priv->adapter->MediaConnectStatus) ? "Y" : "N",
+                   priv->adapter->PSMode, priv->adapter->PSState);
+
+            /* Wake up device */
+            if (sbi_exit_deep_sleep(priv))
+                PRINTM(MSG, "main-thread: wakeup dev failed\n");
+            continue;
+        }
+
+        /* Command response? */
+        if (Adapter->HisRegCpy & HIS_CmdUpLdRdy) {
+            OS_INT_DISABLE;
+            Adapter->HisRegCpy &= ~HIS_CmdUpLdRdy;
+            OS_INT_RESTORE;
+
+            ret = wlan_process_rx_command(priv);
+		umd_dbg("ret for wlan_process_rx_command() is %d !!!", ret);
+        }
+
+        /* Any received data? */
+        if (Adapter->HisRegCpy & HIS_RxUpLdRdy) {
+            OS_INT_DISABLE;
+            Adapter->HisRegCpy &= ~HIS_RxUpLdRdy;
+            OS_INT_RESTORE;
+            wlan_send_rxskbQ(priv);
+        }
+
+        /* Any Card Event */
+        if (Adapter->HisRegCpy & HIS_CardEvent) {
+            OS_INT_DISABLE;
+            Adapter->HisRegCpy &= ~HIS_CardEvent;
+            OS_INT_RESTORE;
+
+            if (sbi_read_event_cause(priv)) {
+                PRINTM(ERROR, "main-thread: sbi_read_event_cause failed.\n");
+                umd_dbg( "main-thread: sbi_read_event_cause failed.\n");
+                continue;
+            }
+            ret = wlan_process_event(priv);
+		umd_dbg("ret for wlan_process_event() is %d !!!", ret);
+        }
+
+        /* Check if we need to confirm Sleep Request received previously */
+        if (Adapter->PSState == PS_STATE_PRE_SLEEP) {
+            if (!priv->wlan_dev.dnld_sent && !Adapter->CurCmd) {
+                ASSERT(Adapter->MediaConnectStatus ==
+                       WlanMediaStateConnected);
+                PSConfirmSleep(priv, (u16) Adapter->PSMode);
+            }
+        }
+
+        /* The PS state is changed during processing of Sleep Request event above */
+        if ((priv->adapter->PSState == PS_STATE_SLEEP)
+            || (priv->adapter->PSState == PS_STATE_PRE_SLEEP)
+            ) {
+            continue;
+        }
+
+        /* Execute the next command */
+        if (!priv->wlan_dev.dnld_sent && !Adapter->CurCmd) {
+            ExecuteNextCommand(priv);
+        }
+
+        if (Adapter->wmm.enabled) {
+            if (!wmm_lists_empty(priv) && os_queue_is_active(priv)) {
+                if ((Adapter->PSState == PS_STATE_FULL_POWER) ||
+                    (Adapter->sleep_period.period == 0)
+                    || (Adapter->TxLockFlag == FALSE))
+                    wmm_process_tx(priv);
+            }
+        } else {
+            if (!priv->wlan_dev.dnld_sent && (Adapter->TxLockFlag == FALSE)
+                && !list_empty((struct list_head *) &priv->adapter->TxSkbQ)) {
+                wlan_process_txqueue(priv);
+            }
+        }
+    }
+
+    wlan_deactivate_thread(thread);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ * @brief This function adds the card. it will probe the
+ * card, allocate the wlan_priv and initialize the device. 
+ *  
+ *  @param card    A pointer to card
+ *  @return 	   A pointer to wlan_private structure
+ */
+static wlan_private *
+wlan_add_card(void *card)
+{
+    struct net_device *dev = NULL;
+    wlan_private *priv = NULL;
+
+	umd_dbg("enter");
+
+    /* probe the card */
+    if (sbi_probe_card(card) < 0) {
+        PRINTM(MSG, "NO card found!\n");
+        return NULL;
+    }
+
+    /* Allocate an Ethernet device and register it */
+   if (!(dev = alloc_netdev(sizeof(wlan_private), "wlan%d", ether_setup))){
+        PRINTM(MSG, "Init ethernet device failed!\n");
+        return NULL;
+    }
+
+    priv = dev->priv;
+
+    /* allocate buffer for wlan_adapter */
+    if (!(priv->adapter = kmalloc(sizeof(wlan_adapter), GFP_KERNEL))) {
+        PRINTM(MSG, "Allocate buffer for wlan_adapter failed!\n");
+        goto err_kmalloc;
+    }
+
+    /* init wlan_adapter */
+    memset(priv->adapter, 0, sizeof(wlan_adapter));
+
+    priv->wlan_dev.netdev = dev;
+    priv->wlan_dev.card = card;
+    wlanpriv = priv;
+
+    //SET_MODULE_OWNER(dev);
+
+    /* Setup the OS Interface to our functions */
+    dev->open = wlan_open;
+    dev->hard_start_xmit = wlan_hard_start_xmit;
+    dev->stop = wlan_close;
+    dev->do_ioctl = wlan_do_ioctl;
+    dev->set_mac_address = wlan_set_mac_address;
+
+#define	WLAN_WATCHDOG_TIMEOUT	(2 * HZ)
+
+    dev->tx_timeout = wlan_tx_timeout;
+    dev->get_stats = wlan_get_stats;
+    dev->watchdog_timeo = WLAN_WATCHDOG_TIMEOUT;
+
+#ifdef	WIRELESS_EXT
+    //hufh dev->get_wireless_stats = wlan_get_wireless_stats;
+    dev->wireless_handlers = (struct iw_handler_def *) &wlan_handler_def;
+#endif
+#define NETIF_F_DYNALLOC 16
+    dev->features |= NETIF_F_DYNALLOC;
+    dev->flags |= IFF_BROADCAST | IFF_MULTICAST;
+    dev->set_multicast_list = wlan_set_multicast_list;
+
+#ifdef MFG_CMD_SUPPORT
+    /* Required for the mfg command */
+    init_waitqueue_head(&priv->adapter->mfg_cmd_q);
+#endif
+    init_waitqueue_head(&priv->adapter->ds_awake_q);
+
+#ifdef ENABLE_PM
+    if (!(wlan_pm_dev = pm_register(PM_UNKNOWN_DEV, 0, wlan_pm_callback)))
+        PRINTM(MSG, "Failed to register PM callback\n");
+#endif
+
+    INIT_LIST_HEAD(&priv->adapter->CmdFreeQ);
+    INIT_LIST_HEAD(&priv->adapter->CmdPendingQ);
+
+    umd_dbg("Starting kthread...");
+    priv->MainThread.priv = priv;
+    wlan_create_thread(wlan_service_main_thread,
+                       &priv->MainThread, "wlan_main_service");
+
+    ConfigureThreadPriority();
+
+#ifdef REASSOCIATION
+    priv->ReassocThread.priv = priv;
+    wlan_create_thread(wlan_reassociation_thread,
+                       &priv->ReassocThread, "wlan_reassoc_service");
+#endif /* REASSOCIATION */
+
+    /*
+     * Register the device. Fillup the private data structure with
+     * relevant information from the card and request for the required
+     * IRQ. 
+     */
+    if (sbi_register_dev(priv) < 0) {
+        PRINTM(FATAL, "Failed to register wlan device!\n");
+        goto err_registerdev;
+    }
+
+    /* Build MMC bus with Device connection for Intel FB */
+    SET_NETDEV_DEV(dev, priv->hotplug_device);
+
+    PRINTM(WARN, "%s: Marvell Wlan 802.11 Adapter "
+           "revision 0x%02X at IRQ %i\n", dev->name,
+           priv->adapter->chip_rev, dev->irq);
+
+    wlan_proc_entry(priv, dev);
+#ifdef PROC_DEBUG
+    wlan_debug_entry(priv, dev);
+#endif
+
+    /* Get the CIS Table */
+    sbi_get_cis_info(priv);
+
+	umd_dbg("succeed in get the cis info");
+
+    /* init FW and HW */
+    if (wlan_init_fw(priv)) {
+        PRINTM(FATAL, "Firmware Init Failed\n");
+        goto err_init_fw;
+    }
+	umd_dbg("succeed in init HW");
+
+    if (register_netdev(dev)) {
+        printk(KERN_ERR "Cannot register network device!\n");
+	// add by Feng
+	//unregister_netdev(dev);
+        goto err_init_fw;
+    }
+	umd_dbg("exit! priv = 0x%08x", priv);
+
+    return priv;
+
+  err_init_fw:
+    sbi_unregister_dev(priv);
+
+#ifdef PROC_DEBUG
+    wlan_debug_remove(priv);
+#endif
+    wlan_proc_remove(priv);
+
+  err_registerdev:
+    /* Stop the thread servicing the interrupts */
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    wlan_terminate_thread(&priv->MainThread);
+
+#ifdef REASSOCIATION
+    wake_up_interruptible(&priv->ReassocThread.waitQ);
+    wlan_terminate_thread(&priv->ReassocThread);
+#endif /* REASSOCIATION */
+
+  err_kmalloc:
+	// modified by Feng
+	free_netdev(dev);
+    wlan_free_adapter(priv);
+    wlanpriv = NULL;
+
+    LEAVE();
+    return NULL;
+}
+
+/** 
+ *  @brief This function removes the sdio function.
+ *  
+ *  @param func    A pointer to sdio_function 
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+static int
+wlan_remove_card(void *func)
+{
+    wlan_private *priv = wlanpriv;
+    wlan_adapter *Adapter;
+    struct net_device *dev;
+    union iwreq_data wrqu;
+
+    if (!priv) {
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    Adapter = priv->adapter;
+
+    if (!Adapter) {
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    dev = priv->wlan_dev.netdev;
+
+    wake_up_interruptible(&Adapter->ds_awake_q);
+
+    if (Adapter->CurCmd) {
+        PRINTM(INFO, "Wake up current cmdwait_q\n");
+        wake_up_interruptible(&Adapter->CurCmd->cmdwait_q);
+    }
+
+    Adapter->CurCmd = NULL;
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        wlan_clean_txrx(priv);
+        Adapter->MediaConnectStatus = WlanMediaStateDisconnected;
+    }
+    if (Adapter->PSMode == Wlan802_11PowerModeMAX_PSP) {
+        Adapter->PSMode = Wlan802_11PowerModeCAM;
+        PSWakeup(priv, HostCmd_OPTION_WAITFORRSP);
+    }
+    if (Adapter->IsDeepSleep == TRUE) {
+        Adapter->IsDeepSleep = FALSE;
+        sbi_exit_deep_sleep(priv);
+    }
+
+    memset(wrqu.ap_addr.sa_data, 0xaa, ETH_ALEN);
+    wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+
+    /* Disable interrupts on the card as we cannot handle them after RESET */
+    sbi_disable_host_int(priv);
+
+    PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RESET, 0, 0, 0, NULL);
+
+    os_sched_timeout(200);
+
+#ifdef ENABLE_PM
+    pm_unregister(wlan_pm_dev);
+#endif
+
+    /* Flush all the packets upto the OS before stopping */
+    wlan_send_rxskbQ(priv);
+    cleanup_txqueues(priv);
+    os_stop_queue(priv);
+    os_carrier_off(priv);
+
+    Adapter->SurpriseRemoved = TRUE;
+
+    /* Stop the thread servicing the interrupts */
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    //wlan_terminate_thread(&priv->MainThread);
+
+#ifdef REASSOCIATION
+    wake_up_interruptible(&priv->ReassocThread.waitQ);
+    //wlan_terminate_thread(&priv->ReassocThread);
+#endif /* REASSOCIATION */
+
+#ifdef PROC_DEBUG
+    wlan_debug_remove(priv);
+#endif
+    wlan_proc_remove(priv);
+
+    PRINTM(INFO, "unregester dev\n");
+    sbi_unregister_dev(priv);
+
+    PRINTM(INFO, "Free Adapter\n");
+    wlan_free_adapter(priv);
+
+    /* Last reference is our one */
+    PRINTM(INFO, "refcnt = %d\n", atomic_read(&dev->refcnt));
+
+    PRINTM(INFO, "netdev_finish_unregister: %s%s.\n", dev->name,
+           (dev->features & NETIF_F_DYNALLOC) ? "" : ", old style");
+
+    unregister_netdev(dev);
+
+    PRINTM(INFO, "Unregister finish\n");
+
+    priv->wlan_dev.netdev = NULL;
+    free_netdev(dev);
+    wlanpriv = NULL;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+/** 
+ *  @brief Cleanup TX queue
+ *  @param priv       pointer to wlan_private
+ *  @return 	      N/A
+*/
+void
+cleanup_txqueues(wlan_private * priv)
+{
+    struct sk_buff *delNode, *Q;
+
+    Q = &priv->adapter->TxSkbQ;
+    while (!list_empty((struct list_head *) Q)) {
+        delNode = Q->next;
+        list_del((struct list_head *) delNode);
+        kfree_skb(delNode);
+    }
+    priv->adapter->TxSkbNum = 0;
+}
+
+/** 
+ *  @brief handle TX Queue
+ *  @param priv       pointer to wlan_private
+ *  @return 	      N/A
+*/
+void
+wlan_process_txqueue(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    ulong flags;
+    struct sk_buff *Q;
+    OS_INTERRUPT_SAVE_AREA;
+    ENTER();
+    spin_lock_irqsave(&Adapter->CurrentTxLock, flags);
+    if (Adapter->TxSkbNum > 0) {
+        Q = &priv->adapter->TxSkbQ;
+        Adapter->CurrentTxSkb = Q->next;
+        list_del((struct list_head *) Adapter->CurrentTxSkb);
+        Adapter->TxSkbNum--;
+    }
+    spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+    if (Adapter->CurrentTxSkb) {
+        wlan_process_tx(priv);
+    }
+
+    LEAVE();
+}
+
+/**
+ * @brief This function sends the rx packets to the os from the skb queue
+ *
+ * @param priv	A pointer to wlan_private structure
+ * @return	n/a
+ */
+void
+wlan_send_rxskbQ(wlan_private * priv)
+{
+    struct sk_buff *skb;
+
+    ENTER();
+    if (priv->adapter) {
+        while ((skb = wlan_pop_rx_skb(&priv->adapter->RxSkbQ))) {
+            if (ProcessRxedPacket(priv, skb) == -ENOMEM)
+                break;
+        }
+    }
+    LEAVE();
+}
+
+/** 
+ *  @brief This function finds the CFP in 
+ *  region_cfp_table based on region and band parameter.
+ *  
+ *  @param region  The region code
+ *  @param band	   The band
+ *  @param cfp_no  A pointer to CFP number
+ *  @return 	   A pointer to CFP
+ */
+CHANNEL_FREQ_POWER *
+wlan_get_region_cfp_table(u8 region, u8 band, int *cfp_no)
+{
+    int i;
+
+    ENTER();
+
+    for (i = 0; i < sizeof(region_cfp_table) / sizeof(region_cfp_table_t);
+         i++) {
+        PRINTM(INFO, "region_cfp_table[i].region=%d\n",
+               region_cfp_table[i].region);
+        if (region_cfp_table[i].region == region) {
+            {
+                *cfp_no = region_cfp_table[i].cfp_no_BG;
+                LEAVE();
+                return region_cfp_table[i].cfp_BG;
+            }
+        }
+    }
+
+    LEAVE();
+    return NULL;
+}
+
+/** 
+ *  @brief This function sets region table. 
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param region  The region code
+ *  @param band	   The band
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_set_regiontable(wlan_private * priv, u8 region, u8 band)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i = 0;
+
+    CHANNEL_FREQ_POWER *cfp;
+    int cfp_no;
+
+    ENTER();
+
+    memset(Adapter->region_channel, 0, sizeof(Adapter->region_channel));
+
+    {
+        cfp = wlan_get_region_cfp_table(region, band, &cfp_no);
+        if (cfp != NULL) {
+            Adapter->region_channel[i].NrCFP = cfp_no;
+            Adapter->region_channel[i].CFP = cfp;
+        } else {
+            PRINTM(INFO, "wrong region code %#x in Band B-G\n", region);
+            return WLAN_STATUS_FAILURE;
+        }
+        Adapter->region_channel[i].Valid = TRUE;
+        Adapter->region_channel[i].Region = region;
+        Adapter->region_channel[i].Band = band;
+        i++;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the interrupt. it will change PS
+ *  state if applicable. it will wake up main_thread to handle
+ *  the interrupt event as well.
+ *  
+#ifdef PXA3XX
+ *  @param priv    A pointer to wlan_private structure
+#else // !PXA3XX
+ *  @param dev     A pointer to net_device structure
+#endif // PXA3XX
+ *  @return 	   n/a
+ */
+void
+wlan_interrupt(struct net_device *dev)
+{
+    wlan_private *priv = dev->priv;
+
+    //umd_dbg("enter");
+
+    priv->adapter->IntCounter++;
+
+    priv->adapter->WakeupTries = 0;
+
+    if (priv->adapter->PSState == PS_STATE_SLEEP) {
+        priv->adapter->PSState = PS_STATE_AWAKE;
+    }
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+    //umd_dbg("exit");
+}
+
+/** 
+ *  @brief This function initializes module.
+ *  
+ *  @param	   n/a    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_init_module(void)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (sbi_register(wlan_add_card, wlan_remove_card, NULL) == NULL) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function cleans module
+ *  
+ *  @param priv    n/a
+ *  @return 	   n/a
+ */
+void
+wlan_cleanup_module(void)
+{
+    ENTER();
+
+    sbi_unregister();
+
+    LEAVE();
+}
+
+module_init(wlan_init_module);
+module_exit(wlan_cleanup_module);
+
+MODULE_DESCRIPTION("M-WLAN Driver");
+MODULE_AUTHOR("Marvell International Ltd.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_proc.c b/drivers/net/wireless/8686_wlan/wlan/wlan_proc.c
new file mode 100644
index 0000000..687c61e
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_proc.c
@@ -0,0 +1,187 @@
+/** @file wlan_proc.c
+  * @brief This file contains functions for proc fin proc file.
+  * 
+  * (c) Copyright © 2003-2006, Marvell International Ltd. 
+  *
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	10/04/05: Add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	
+********************************************************/
+#include 	"include.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+static char *szModes[] = {
+    "Ad-hoc",
+    "Managed",
+    "Auto",
+    "Unknown"
+};
+
+static char *szStates[] = {
+    "Disconnected",
+    "Connected"
+};
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief proc read function
+ *
+ *  @param page	   pointer to buffer
+ *  @param start   read data starting position
+ *  @param offset  offset
+ *  @param count   counter 
+ *  @param eof     end of file flag
+ *  @param data    data to output
+ *  @return 	   number of output data
+ */
+static int
+wlan_proc_read(char *page, char **start, off_t offset,
+               int count, int *eof, void *data)
+{
+#ifdef CONFIG_PROC_FS
+    int i;
+    char *p = page;
+    struct net_device *netdev = data;
+    struct dev_mc_list *mcptr = netdev->mc_list;
+    char fmt[64];
+    wlan_private *priv = netdev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    ulong flags;
+#endif
+
+    if (offset != 0) {
+        *eof = 1;
+        goto exit;
+    }
+
+    get_version(Adapter, fmt, sizeof(fmt) - 1);
+
+    p += sprintf(p, "driver_name = " "\"wlan\"\n");
+    p += sprintf(p, "driver_version = %s", fmt);
+    p += sprintf(p, "\nInterfaceName=\"%s\"\n", netdev->name);
+    p += sprintf(p, "Mode=\"%s\"\n", szModes[Adapter->InfrastructureMode]);
+    p += sprintf(p, "State=\"%s\"\n", szStates[Adapter->MediaConnectStatus]);
+    p += sprintf(p, "MACAddress=\"%02x:%02x:%02x:%02x:%02x:%02x\"\n",
+                 netdev->dev_addr[0], netdev->dev_addr[1],
+                 netdev->dev_addr[2], netdev->dev_addr[3],
+                 netdev->dev_addr[4], netdev->dev_addr[5]);
+
+    p += sprintf(p, "MCCount=\"%d\"\n", netdev->mc_count);
+    p += sprintf(p, "ESSID=\"%s\"\n", (u8 *) Adapter->CurBssParams.ssid.Ssid);
+    p += sprintf(p, "Channel=\"%d\"\n", Adapter->CurBssParams.channel);
+    p += sprintf(p, "region_code = \"%02x\"\n", (u32) Adapter->RegionCode);
+
+    /*
+     * Put out the multicast list 
+     */
+    for (i = 0; i < netdev->mc_count; i++) {
+        p += sprintf(p,
+                     "MCAddr[%d]=\"%02x:%02x:%02x:%02x:%02x:%02x\"\n",
+                     i,
+                     mcptr->dmi_addr[0], mcptr->dmi_addr[1],
+                     mcptr->dmi_addr[2], mcptr->dmi_addr[3],
+                     mcptr->dmi_addr[4], mcptr->dmi_addr[5]);
+
+        mcptr = mcptr->next;
+    }
+    p += sprintf(p, "num_tx_bytes = %lu\n", priv->stats.tx_bytes);
+    p += sprintf(p, "num_rx_bytes = %lu\n", priv->stats.rx_bytes);
+    p += sprintf(p, "num_tx_pkts = %lu\n", priv->stats.tx_packets);
+    p += sprintf(p, "num_rx_pkts = %lu\n", priv->stats.rx_packets);
+    p += sprintf(p, "num_tx_pkts_dropped = %lu\n", priv->stats.tx_dropped);
+    p += sprintf(p, "num_rx_pkts_dropped = %lu\n", priv->stats.rx_dropped);
+    p += sprintf(p, "num_tx_pkts_err = %lu\n", priv->stats.tx_errors);
+    p += sprintf(p, "num_rx_pkts_err = %lu\n", priv->stats.rx_errors);
+    p += sprintf(p, "carrier %s\n",
+                 ((netif_carrier_ok(priv->wlan_dev.netdev)) ? "on" : "off"));
+    p += sprintf(p, "tx queue %s\n",
+                 ((netif_queue_stopped(priv->wlan_dev.netdev)) ? "stopped" :
+                  "started"));
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+    if (Adapter->CurCmd) {
+        HostCmd_DS_COMMAND *CmdPtr =
+            (HostCmd_DS_COMMAND *) Adapter->CurCmd->BufVirtualAddr;
+        p += sprintf(p, "CurCmd ID = 0x%x, 0x%x\n",
+                     wlan_cpu_to_le16(CmdPtr->Command),
+                     wlan_cpu_to_le16(*(u16 *) ((u8 *) CmdPtr + S_DS_GEN)));
+    } else {
+        p += sprintf(p, "CurCmd NULL\n");
+    }
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+  exit:
+    return (p - page);
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief create wlan proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @param dev     pointer net_device
+ *  @return 	   N/A
+ */
+void
+wlan_proc_entry(wlan_private * priv, struct net_device *dev)
+{
+
+#ifdef	CONFIG_PROC_FS
+    PRINTM(INFO, "Creating Proc Interface\n");
+
+    if (!priv->proc_entry) {
+        priv->proc_entry = proc_mkdir("wlan", init_net.proc_net);
+
+        if (priv->proc_entry) {
+            priv->proc_dev = create_proc_read_entry
+                ("info", 0, priv->proc_entry, wlan_proc_read, dev);
+        }
+    }
+#endif
+}
+
+/** 
+ *  @brief remove proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @return 	   N/A
+ */
+void
+wlan_proc_remove(wlan_private * priv)
+{
+#ifdef CONFIG_PROC_FS
+    if (priv->proc_entry) {
+        remove_proc_entry("info", priv->proc_entry);
+    }
+    remove_proc_entry("wlan", init_net.proc_net);
+#endif
+}
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_rx.c b/drivers/net/wireless/8686_wlan/wlan/wlan_rx.c
new file mode 100644
index 0000000..84fbe37
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_rx.c
@@ -0,0 +1,281 @@
+/** @file wlan_rx.c
+  * @brief This file contains the handling of RX in wlan
+  * driver.
+  * 
+  * (c) Copyright © 2003-2006, Marvell International Ltd.  
+  *   
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	09/28/05: Add Doxygen format comments
+	12/09/05: ADD Sliding window SNR/NF Average Calculation support
+	
+********************************************************/
+
+#include	"include.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+typedef struct
+{
+    u8 dest_addr[6];
+    u8 src_addr[6];
+    u16 h803_len;
+
+} __ATTRIB_PACK__ Eth803Hdr_t;
+
+typedef struct
+{
+    u8 llc_dsap;
+    u8 llc_ssap;
+    u8 llc_ctrl;
+    u8 snap_oui[3];
+    u16 snap_type;
+
+} __ATTRIB_PACK__ Rfc1042Hdr_t;
+
+typedef struct
+{
+    RxPD rx_pd;
+    Eth803Hdr_t eth803_hdr;
+    Rfc1042Hdr_t rfc1042_hdr;
+
+} __ATTRIB_PACK__ RxPacketHdr_t;
+
+typedef struct
+{
+    u8 dest_addr[6];
+    u8 src_addr[6];
+    u16 ethertype;
+
+} __ATTRIB_PACK__ EthII_Hdr_t;
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function computes the AvgSNR .
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   AvgSNR
+ */
+static u8
+wlan_getAvgSNR(wlan_private * priv)
+{
+    u8 i;
+    u16 temp = 0;
+    wlan_adapter *Adapter = priv->adapter;
+    if (Adapter->numSNRNF == 0)
+        return 0;
+    for (i = 0; i < Adapter->numSNRNF; i++)
+        temp += Adapter->rawSNR[i];
+    return (u8) (temp / Adapter->numSNRNF);
+
+}
+
+/** 
+ *  @brief This function computes the AvgNF
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   AvgNF
+ */
+static u8
+wlan_getAvgNF(wlan_private * priv)
+{
+    u8 i;
+    u16 temp = 0;
+    wlan_adapter *Adapter = priv->adapter;
+    if (Adapter->numSNRNF == 0)
+        return 0;
+    for (i = 0; i < Adapter->numSNRNF; i++)
+        temp += Adapter->rawNF[i];
+    return (u8) (temp / Adapter->numSNRNF);
+
+}
+
+/** 
+ *  @brief This function save the raw SNR/NF to our internel buffer
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param pRxPD   A pointer to RxPD structure of received packet
+ *  @return 	   n/a
+ */
+static void
+wlan_save_rawSNRNF(wlan_private * priv, RxPD * pRxPD)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    if (Adapter->numSNRNF < Adapter->data_avg_factor)
+        Adapter->numSNRNF++;
+    Adapter->rawSNR[Adapter->nextSNRNF] = pRxPD->SNR;
+    Adapter->rawNF[Adapter->nextSNRNF] = pRxPD->NF;
+    Adapter->nextSNRNF++;
+    if (Adapter->nextSNRNF >= Adapter->data_avg_factor)
+        Adapter->nextSNRNF = 0;
+    return;
+}
+
+/** 
+ *  @brief This function computes the RSSI in received packet.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param pRxPD   A pointer to RxPD structure of received packet
+ *  @return 	   n/a
+ */
+static void
+wlan_compute_rssi(wlan_private * priv, RxPD * pRxPD)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, "RxPD: SNR = %d, NF = %d\n", pRxPD->SNR, pRxPD->NF);
+
+    Adapter->SNR[TYPE_RXPD][TYPE_NOAVG] = pRxPD->SNR;
+    Adapter->NF[TYPE_RXPD][TYPE_NOAVG] = pRxPD->NF;
+    wlan_save_rawSNRNF(priv, pRxPD);
+
+    Adapter->RxPDAge = os_time_get();
+    Adapter->RxPDRate = pRxPD->RxRate;
+
+    Adapter->SNR[TYPE_RXPD][TYPE_AVG] = wlan_getAvgSNR(priv) * AVG_SCALE;
+    Adapter->NF[TYPE_RXPD][TYPE_AVG] = wlan_getAvgNF(priv) * AVG_SCALE;
+    PRINTM(INFO, "SNR-avg = %d, NF-avg = %d\n",
+           Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+           Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+
+    Adapter->RSSI[TYPE_RXPD][TYPE_NOAVG] =
+        CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_NOAVG],
+                 Adapter->NF[TYPE_RXPD][TYPE_NOAVG]);
+
+    Adapter->RSSI[TYPE_RXPD][TYPE_AVG] =
+        CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+                 Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+    LEAVE();
+}
+
+/********************************************************
+		Global functions
+********************************************************/
+
+/**
+ *  @brief This function processes received packet and forwards it
+ *  to kernel/upper layer
+ *  
+ *  @param priv    A pointer to wlan_private
+ *  @param skb     A pointer to skb which includes the received packet
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+ProcessRxedPacket(wlan_private * priv, struct sk_buff *skb)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    RxPacketHdr_t *pRxPkt;
+    RxPD *pRxPD;
+
+    int hdrChop;
+    EthII_Hdr_t *pEthHdr;
+
+    const u8 rfc1042_eth_hdr[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+
+    ENTER();
+
+    pRxPkt = (RxPacketHdr_t *) skb->data;
+    pRxPD = &pRxPkt->rx_pd;
+
+    DBG_HEXDUMP(DAT_D, "Rx", skb->data, MIN(skb->len, MAX_DATA_DUMP_LEN));
+
+    if (skb->len < (ETH_HLEN + 8 + sizeof(RxPD))) {
+        PRINTM(ERROR, "RX Error: FRAME RECEIVED WITH BAD LENGTH\n");
+        priv->stats.rx_length_errors++;
+        ret = WLAN_STATUS_SUCCESS;
+        kfree_skb(skb);
+        goto done;
+    }
+
+    PRINTM(INFO, "RX Data: skb->len - sizeof(RxPd) = %d - %d = %d\n",
+           skb->len, sizeof(RxPD), skb->len - sizeof(RxPD));
+
+    HEXDUMP("RX Data: Dest", pRxPkt->eth803_hdr.dest_addr,
+            sizeof(pRxPkt->eth803_hdr.dest_addr));
+    HEXDUMP("RX Data: Src", pRxPkt->eth803_hdr.src_addr,
+            sizeof(pRxPkt->eth803_hdr.src_addr));
+
+    if (memcmp(&pRxPkt->rfc1042_hdr,
+               rfc1042_eth_hdr, sizeof(rfc1042_eth_hdr)) == 0) {
+        /* 
+         *  Replace the 803 header and rfc1042 header (llc/snap) with an 
+         *    EthernetII header, keep the src/dst and snap_type (ethertype)
+         *
+         *  The firmware only passes up SNAP frames converting
+         *    all RX Data from 802.11 to 802.2/LLC/SNAP frames.
+         *
+         *  To create the Ethernet II, just move the src, dst address right
+         *    before the snap_type.
+         */
+        pEthHdr = (EthII_Hdr_t *)
+            ((u8 *) & pRxPkt->eth803_hdr
+             + sizeof(pRxPkt->eth803_hdr) + sizeof(pRxPkt->rfc1042_hdr)
+             - sizeof(pRxPkt->eth803_hdr.dest_addr)
+             - sizeof(pRxPkt->eth803_hdr.src_addr)
+             - sizeof(pRxPkt->rfc1042_hdr.snap_type));
+
+        memcpy(pEthHdr->src_addr, pRxPkt->eth803_hdr.src_addr,
+               sizeof(pEthHdr->src_addr));
+        memcpy(pEthHdr->dest_addr, pRxPkt->eth803_hdr.dest_addr,
+               sizeof(pEthHdr->dest_addr));
+
+        /* Chop off the RxPD + the excess memory from the 802.2/llc/snap header
+         *   that was removed 
+         */
+        hdrChop = (u8 *) pEthHdr - (u8 *) pRxPkt;
+    } else {
+        HEXDUMP("RX Data: LLC/SNAP",
+                (u8 *) & pRxPkt->rfc1042_hdr, sizeof(pRxPkt->rfc1042_hdr));
+
+        /* Chop off the RxPD */
+        hdrChop = (u8 *) & pRxPkt->eth803_hdr - (u8 *) pRxPkt;
+    }
+
+    /* Chop off the leading header bytes so the skb points to the start of 
+     *   either the reconstructed EthII frame or the 802.2/llc/snap frame
+     */
+    skb_pull(skb, hdrChop);
+
+    wlan_compute_rssi(priv, pRxPD);
+
+    if (os_upload_rx_packet(priv, skb)) {
+        PRINTM(ERROR, "RX Error: os_upload_rx_packet" " returns failure\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    priv->stats.rx_bytes += skb->len;
+    priv->stats.rx_packets++;
+
+    PRINTM(DATA, "Data => kernel\n");
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+
+    return (ret);
+}
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_scan.c b/drivers/net/wireless/8686_wlan/wlan/wlan_scan.c
new file mode 100644
index 0000000..18ea39c
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_scan.c
@@ -0,0 +1,2936 @@
+/** @file wlan_scan.c
+ *
+ *  @brief Functions implementing wlan scan IOCTL and firmware command APIs
+ *
+ *  IOCTL handlers as well as command preperation and response routines
+ *   for sending scan commands to the firmware.
+ *
+ *  (c) Copyright © 2003-2007, Marvell International Ltd.  
+ *   
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change Log:
+    01/11/06: Initial revision. New scan code, relocate related functions
+    01/19/06: Update specific scan routines to discard old results for adhoc
+    01/31/06: Add support for selectively enabling the FW Scan channel filter
+
+************************************************************/
+
+#include    "include.h"
+
+/********************************************************
+    Local Constants
+********************************************************/
+
+//! Approximate amount of data needed to pass a scan result back to iwlist
+#define MAX_SCAN_CELL_SIZE  (IW_EV_ADDR_LEN             \
+                             + MRVDRV_MAX_SSID_LENGTH   \
+                             + IW_EV_UINT_LEN           \
+                             + IW_EV_FREQ_LEN           \
+                             + IW_EV_QUAL_LEN           \
+                             + MRVDRV_MAX_SSID_LENGTH   \
+                             + IW_EV_PARAM_LEN          \
+                             + 40)      /* 40 for WPAIE */
+
+//! Memory needed to store a max sized Channel List TLV for a firmware scan
+#define CHAN_TLV_MAX_SIZE  (sizeof(MrvlIEtypesHeader_t)         \
+                            + (MRVDRV_MAX_CHANNELS_PER_SCAN     \
+                               * sizeof(ChanScanParamSet_t)))
+
+//! Memory needed to store a max number/size SSID TLV for a firmware scan
+#define SSID_TLV_MAX_SIZE  (1 * sizeof(MrvlIEtypes_SsIdParamSet_t))
+
+//! Maximum memory needed for a wlan_scan_cmd_config with all TLVs at max
+#define MAX_SCAN_CFG_ALLOC (sizeof(wlan_scan_cmd_config)        \
+                            + sizeof(MrvlIEtypes_NumProbes_t)   \
+                            + CHAN_TLV_MAX_SIZE                 \
+                            + SSID_TLV_MAX_SIZE)
+
+//! The maximum number of channels the firmware can scan per command
+#define MRVDRV_MAX_CHANNELS_PER_SCAN   14
+
+/**
+ * @brief Number of channels to scan per firmware scan command issuance.
+ *
+ *  Number restricted to prevent hitting the limit on the amount of scan data
+ *  returned in a single firmware scan command.
+ */
+#define MRVDRV_CHANNELS_PER_SCAN_CMD   4
+
+//! Macro to enable/disable SSID checking before storing a scan table
+#ifdef DISCARD_BAD_SSID
+#define CHECK_SSID_IS_VALID(x) ssid_valid(&bssidEntry.Ssid)
+#else
+#define CHECK_SSID_IS_VALID(x) TRUE
+#endif
+
+/********************************************************
+    Local Variables and Types
+********************************************************/
+
+/**
+ * @brief Interally used to send a configured scan cmd between driver routines
+ */
+typedef union
+{
+    wlan_scan_cmd_config config;        //!< Scan configuration (variable length)
+    u8 configAllocBuf[MAX_SCAN_CFG_ALLOC];      //!< Max allocated block
+} wlan_scan_cmd_config_tlv;
+
+/**
+ *  @brief Check if a scanned network compatible with the driver settings
+ *
+ *   WEP     WPA     WPA2    ad-hoc  encrypt                      Network
+ * enabled enabled  enabled   AES     mode   Privacy  WPA  WPA2  Compatible
+ *    0       0        0       0      NONE      0      0    0   yes No security
+ *    1       0        0       0      NONE      1      0    0   yes Static WEP
+ *    0       1        0       0       x        1x     1    x   yes WPA
+ *    0       0        1       0       x        1x     x    1   yes WPA2
+ *    0       0        0       1      NONE      1      0    0   yes Ad-hoc AES
+ *    0       0        0       0     !=NONE     1      0    0   yes Dynamic WEP
+ *
+ *
+ *  @param Adapter A pointer to wlan_adapter
+ *  @param index   Index in ScanTable to check against current driver settings
+ *  @param mode    Network mode: Infrastructure or IBSS
+ *
+ *  @return        Index in ScanTable, or error code if negative
+ */
+static int
+IsNetworkCompatible(wlan_adapter * Adapter, int index, int mode)
+{
+    ENTER();
+
+    if (Adapter->ScanTable[index].InfrastructureMode == mode) {
+        if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+            && !Adapter->SecInfo.WPAEnabled
+            && !Adapter->SecInfo.WPA2Enabled
+            && Adapter->ScanTable[index].wpa_supplicant.Wpa_ie[0] != WPA_IE
+            && Adapter->ScanTable[index].wpa2_supplicant.Wpa_ie[0] != WPA2_IE
+            && !Adapter->AdhocAESEnabled
+            && Adapter->SecInfo.EncryptionMode == CIPHER_NONE
+            && !Adapter->ScanTable[index].Privacy) {
+            /* no security */
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled
+                   && !Adapter->SecInfo.WPAEnabled
+                   && !Adapter->SecInfo.WPA2Enabled
+                   && !Adapter->AdhocAESEnabled
+                   && Adapter->ScanTable[index].Privacy) {
+            /* static WEP enabled */
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+                   && Adapter->SecInfo.WPAEnabled
+                   && !Adapter->SecInfo.WPA2Enabled
+                   && (Adapter->ScanTable[index].wpa_supplicant.Wpa_ie[0]
+                       == WPA_IE)
+                   && !Adapter->AdhocAESEnabled
+                   /* Privacy bit may NOT be set in some APs like LinkSys WRT54G
+                      && Adapter->ScanTable[index].Privacy */
+            ) {
+            /* WPA enabled */
+            PRINTM(INFO, "IsNetworkCompatible() WPA: index=%d wpa_ie=%#x "
+                   "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s EncMode=%#x "
+                   "privacy=%#x\n",
+                   index,
+                   Adapter->ScanTable[index].wpa_supplicant.Wpa_ie[0],
+                   Adapter->ScanTable[index].wpa2_supplicant.Wpa_ie[0],
+                   (Adapter->SecInfo.WEPStatus ==
+                    Wlan802_11WEPEnabled) ? "e" : "d",
+                   (Adapter->SecInfo.WPAEnabled) ? "e" : "d",
+                   (Adapter->SecInfo.WPA2Enabled) ? "e" : "d",
+                   Adapter->SecInfo.EncryptionMode,
+                   Adapter->ScanTable[index].Privacy);
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+                   && !Adapter->SecInfo.WPAEnabled
+                   && Adapter->SecInfo.WPA2Enabled
+                   && (Adapter->ScanTable[index].wpa2_supplicant.Wpa_ie[0]
+                       == WPA2_IE)
+                   && !Adapter->AdhocAESEnabled
+                   /* Privacy bit may NOT be set in some APs like LinkSys WRT54G
+                      && Adapter->ScanTable[index].Privacy */
+            ) {
+            /* WPA2 enabled */
+            PRINTM(INFO, "IsNetworkCompatible() WPA2: index=%d wpa_ie=%#x "
+                   "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s EncMode=%#x "
+                   "privacy=%#x\n",
+                   index,
+                   Adapter->ScanTable[index].wpa_supplicant.Wpa_ie[0],
+                   Adapter->ScanTable[index].wpa2_supplicant.Wpa_ie[0],
+                   (Adapter->SecInfo.WEPStatus ==
+                    Wlan802_11WEPEnabled) ? "e" : "d",
+                   (Adapter->SecInfo.WPAEnabled) ? "e" : "d",
+                   (Adapter->SecInfo.WPA2Enabled) ? "e" : "d",
+                   Adapter->SecInfo.EncryptionMode,
+                   Adapter->ScanTable[index].Privacy);
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+                   && !Adapter->SecInfo.WPAEnabled
+                   && !Adapter->SecInfo.WPA2Enabled
+                   && (Adapter->ScanTable[index].wpa_supplicant.Wpa_ie[0]
+                       != WPA_IE)
+                   && (Adapter->ScanTable[index].wpa2_supplicant.Wpa_ie[0]
+                       != WPA2_IE)
+                   && Adapter->AdhocAESEnabled
+                   && Adapter->SecInfo.EncryptionMode == CIPHER_NONE
+                   && Adapter->ScanTable[index].Privacy) {
+            /* Ad-hoc AES enabled */
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+                   && !Adapter->SecInfo.WPAEnabled
+                   && !Adapter->SecInfo.WPA2Enabled
+                   && (Adapter->ScanTable[index].wpa_supplicant.Wpa_ie[0]
+                       != WPA_IE)
+                   && (Adapter->ScanTable[index].wpa2_supplicant.Wpa_ie[0]
+                       != WPA2_IE)
+                   && !Adapter->AdhocAESEnabled
+                   && Adapter->SecInfo.EncryptionMode != CIPHER_NONE
+                   && Adapter->ScanTable[index].Privacy) {
+            /* dynamic WEP enabled */
+            PRINTM(INFO, "IsNetworkCompatible() dynamic WEP: index=%d "
+                   "wpa_ie=%#x wpa2_ie=%#x EncMode=%#x privacy=%#x\n",
+                   index,
+                   Adapter->ScanTable[index].wpa_supplicant.Wpa_ie[0],
+                   Adapter->ScanTable[index].wpa2_supplicant.Wpa_ie[0],
+                   Adapter->SecInfo.EncryptionMode,
+                   Adapter->ScanTable[index].Privacy);
+            LEAVE();
+            return index;
+        }
+
+        /* security doesn't match */
+        PRINTM(INFO, "IsNetworkCompatible() FAILED: index=%d wpa_ie=%#x "
+               "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s EncMode=%#x privacy=%#x\n",
+               index,
+               Adapter->ScanTable[index].wpa_supplicant.Wpa_ie[0],
+               Adapter->ScanTable[index].wpa2_supplicant.Wpa_ie[0],
+               (Adapter->SecInfo.WEPStatus ==
+                Wlan802_11WEPEnabled) ? "e" : "d",
+               (Adapter->SecInfo.WPAEnabled) ? "e" : "d",
+               (Adapter->SecInfo.WPA2Enabled) ? "e" : "d",
+               Adapter->SecInfo.EncryptionMode,
+               Adapter->ScanTable[index].Privacy);
+        LEAVE();
+        return -ECONNREFUSED;
+    }
+
+    /* mode doesn't match */
+    LEAVE();
+    return -ENETUNREACH;
+}
+
+/**
+ *  @brief This function validates a SSID as being able to be printed
+ *
+ *  @param pSsid   SSID structure to validate
+ *
+ *  @return        TRUE or FALSE
+ */
+static BOOLEAN
+ssid_valid(WLAN_802_11_SSID * pSsid)
+{
+    int ssidIdx;
+
+    for (ssidIdx = 0; ssidIdx < pSsid->SsidLength; ssidIdx++) {
+        if (!isprint(pSsid->Ssid[ssidIdx])) {
+            return FALSE;
+        }
+    }
+
+    return TRUE;
+}
+
+/**
+ *  @brief Post process the scan table after a new scan command has completed
+ *
+ *  Inspect each entry of the scan table and try to find an entry that
+ *    matches our current associated/joined network from the scan.  If
+ *    one is found, update the stored copy of the BSSDescriptor for our
+ *    current network.
+ *
+ *  Debug dump the current scan table contents if compiled accordingly.
+ *
+ *  @param priv   A pointer to wlan_private structure
+ *
+ *  @return       void
+ */
+static void
+wlan_scan_process_results(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int foundCurrent;
+    int i;
+
+    foundCurrent = FALSE;
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        /* try to find the current BSSID in the new scan list */
+        for (i = 0; i < Adapter->NumInScanTable; i++) {
+            if (!SSIDcmp(&Adapter->ScanTable[i].Ssid,
+                         &Adapter->CurBssParams.ssid) &&
+                !memcmp(Adapter->CurBssParams.bssid,
+                        Adapter->ScanTable[i].MacAddress,
+                        MRVDRV_ETH_ADDR_LEN)) {
+                foundCurrent = TRUE;
+            }
+        }
+
+        if (foundCurrent) {
+            /* Make a copy of current BSSID descriptor */
+            memcpy(&Adapter->CurBssParams.BSSDescriptor,
+                   &Adapter->ScanTable[i],
+                   sizeof(Adapter->CurBssParams.BSSDescriptor));
+        }
+    }
+
+    for (i = 0; i < Adapter->NumInScanTable; i++) {
+        PRINTM(INFO, "Scan:(%02d) %02x:%02x:%02x:%02x:%02x:%02x, "
+               "RSSI[%03d], SSID[%s]\n",
+               i,
+               Adapter->ScanTable[i].MacAddress[0],
+               Adapter->ScanTable[i].MacAddress[1],
+               Adapter->ScanTable[i].MacAddress[2],
+               Adapter->ScanTable[i].MacAddress[3],
+               Adapter->ScanTable[i].MacAddress[4],
+               Adapter->ScanTable[i].MacAddress[5],
+               (s32) Adapter->ScanTable[i].Rssi,
+               Adapter->ScanTable[i].Ssid.Ssid);
+    }
+}
+
+/**
+ *  @brief Create a channel list for the driver to scan based on region info
+ *
+ *  Use the driver region/band information to construct a comprehensive list
+ *    of channels to scan.  This routine is used for any scan that is not
+ *    provided a specific channel list to scan.
+ *
+ *  @param priv          A pointer to wlan_private structure
+ *  @param scanChanList  Output parameter: Resulting channel list to scan
+ *  @param filteredScan  Flag indicating whether or not a BSSID or SSID filter
+ *                       is being sent in the command to firmware.  Used to 
+ *                       increase the number of channels sent in a scan
+ *                       command and to disable the firmware channel scan
+ *                       filter.
+ *
+ *  @return              void
+ */
+static void
+wlan_scan_create_channel_list(wlan_private * priv,
+                              ChanScanParamSet_t * scanChanList,
+                              BOOLEAN filteredScan)
+{
+
+    wlan_adapter *Adapter = priv->adapter;
+    REGION_CHANNEL *scanRegion;
+    CHANNEL_FREQ_POWER *cfp;
+    int rgnIdx;
+    int chanIdx;
+    int nextChan;
+    u8 scanType;
+
+    chanIdx = 0;
+
+    /* Set the default scan type to the user specified type, will later
+     *   be changed to passive on a per channel basis if restricted by
+     *   regulatory requirements (11d or 11h)
+     */
+    scanType = Adapter->ScanType;
+
+    for (rgnIdx = 0; rgnIdx < NELEMENTS(Adapter->region_channel); rgnIdx++) {
+        if (wlan_get_state_11d(priv) == ENABLE_11D &&
+            Adapter->MediaConnectStatus != WlanMediaStateConnected) {
+            /* Scan all the supported chan for the first scan */
+            if (!Adapter->universal_channel[rgnIdx].Valid)
+                continue;
+            scanRegion = &Adapter->universal_channel[rgnIdx];
+
+            /* clear the parsed_region_chan for the first scan */
+            memset(&Adapter->parsed_region_chan, 0x00,
+                   sizeof(Adapter->parsed_region_chan));
+        } else {
+            if (!Adapter->region_channel[rgnIdx].Valid)
+                continue;
+            scanRegion = &Adapter->region_channel[rgnIdx];
+        }
+
+        for (nextChan = 0;
+             nextChan < scanRegion->NrCFP; nextChan++, chanIdx++) {
+
+            cfp = scanRegion->CFP + nextChan;
+
+            if (wlan_get_state_11d(priv) == ENABLE_11D) {
+                scanType =
+                    wlan_get_scan_type_11d(cfp->Channel,
+                                           &Adapter->parsed_region_chan);
+            }
+
+            switch (scanRegion->Band) {
+            case BAND_B:
+            case BAND_G:
+            default:
+                scanChanList[chanIdx].RadioType = HostCmd_SCAN_RADIO_TYPE_BG;
+                break;
+            }
+
+            if (scanType == HostCmd_SCAN_TYPE_PASSIVE) {
+                scanChanList[chanIdx].MaxScanTime =
+                    wlan_cpu_to_le16(Adapter->PassiveScanTime);
+                scanChanList[chanIdx].ChanScanMode.PassiveScan = TRUE;
+            } else {
+                scanChanList[chanIdx].MaxScanTime =
+                    wlan_cpu_to_le16(Adapter->ActiveScanTime);
+                scanChanList[chanIdx].ChanScanMode.PassiveScan = FALSE;
+            }
+
+            scanChanList[chanIdx].ChanNumber = cfp->Channel;
+
+            if (filteredScan) {
+                scanChanList[chanIdx].MaxScanTime =
+                    wlan_cpu_to_le16(Adapter->SpecificScanTime);
+                scanChanList[chanIdx].ChanScanMode.DisableChanFilt = TRUE;
+            }
+        }
+    }
+}
+
+/**
+ *  @brief Construct a wlan_scan_cmd_config structure to use in issue scan cmds
+ *
+ *  Application layer or other functions can invoke wlan_scan_networks
+ *    with a scan configuration supplied in a wlan_ioctl_user_scan_cfg struct.
+ *    This structure is used as the basis of one or many wlan_scan_cmd_config
+ *    commands that are sent to the command processing module and sent to
+ *    firmware.
+ *
+ *  Create a wlan_scan_cmd_config based on the following user supplied
+ *    parameters (if present):
+ *             - SSID filter
+ *             - BSSID filter
+ *             - Number of Probes to be sent
+ *             - Channel list
+ *
+ *  If the SSID or BSSID filter is not present, disable/clear the filter.
+ *  If the number of probes is not set, use the adapter default setting
+ *  Qualify the channel
+ *
+ *  @param priv             A pointer to wlan_private structure
+ *  @param pUserScanIn      NULL or pointer to scan configuration parameters
+ *  @param pScanCfgOut      Output parameter: Resulting scan configuration
+ *  @param ppChanTlvOut     Output parameter: Pointer to the start of the
+ *                          channel TLV portion of the output scan config
+ *  @param pScanChanList    Output parameter: Pointer to the resulting channel
+ *                          list to scan
+ *  @param pMaxChanPerScan  Output parameter: Number of channels to scan for
+ *                          each issuance of the firmware scan command
+ *  @param pFilteredScan    Output parameter: Flag indicating whether or not
+ *                          a BSSID or SSID filter is being sent in the
+ *                          command to firmware.  Used to increase the number
+ *                          of channels sent in a scan command and to 
+ *                          disable the firmware channel scan filter.
+ *  @param pScanCurrentOnly Output parameter: Flag indicating whether or not
+ *                          we are only scanning our current active channel
+ *
+ *  @return                 void
+ */
+static void
+wlan_scan_setup_scan_config(wlan_private * priv,
+                            const wlan_ioctl_user_scan_cfg * pUserScanIn,
+                            wlan_scan_cmd_config * pScanCfgOut,
+                            MrvlIEtypes_ChanListParamSet_t ** ppChanTlvOut,
+                            ChanScanParamSet_t * pScanChanList,
+                            int *pMaxChanPerScan,
+                            BOOLEAN * pFilteredScan,
+                            BOOLEAN * pScanCurrentOnly)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    const u8 zeroMac[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
+    MrvlIEtypes_NumProbes_t *pNumProbesTlv;
+    MrvlIEtypes_SsIdParamSet_t *pSsidTlv;
+    u8 *pTlvPos;
+    u16 numProbes;
+    u16 ssidLen;
+    int chanIdx;
+    int scanType;
+    int scanDur;
+    int channel;
+    int radioType;
+
+    /* The tlvBufferLen is calculated for each scan command.  The TLVs added
+     *   in this routine will be preserved since the routine that sends
+     *   the command will append channelTLVs at *ppChanTlvOut.  The difference
+     *   between the *ppChanTlvOut and the tlvBuffer start will be used
+     *   to calculate the size of anything we add in this routine.
+     */
+    pScanCfgOut->tlvBufferLen = 0;
+
+    /* Running tlv pointer.  Assigned to ppChanTlvOut at end of function
+     *  so later routines know where channels can be added to the command buf
+     */
+    pTlvPos = pScanCfgOut->tlvBuffer;
+
+    /*
+     * Set the initial scan paramters for progressive scanning.  If a specific
+     *   BSSID or SSID is used, the number of channels in the scan command
+     *   will be increased to the absolute maximum
+     */
+    *pMaxChanPerScan = MRVDRV_CHANNELS_PER_SCAN_CMD;
+
+    /* Initialize the scan as un-filtered by firmware, set to TRUE below if
+     *   a SSID or BSSID filter is sent in the command
+     */
+    *pFilteredScan = FALSE;
+
+    /* Initialize the scan as not being only on the current channel.  If
+     *   the channel list is customized, only contains one channel, and
+     *   is the active channel, this is set true and data flow is not halted.
+     */
+    *pScanCurrentOnly = FALSE;
+
+    if (pUserScanIn) {
+
+        /* Set the bss type scan filter, use Adapter setting if unset */
+        pScanCfgOut->bssType = (pUserScanIn->bssType ? pUserScanIn->bssType :
+                                Adapter->ScanMode);
+
+        /* Set the number of probes to send, use Adapter setting if unset */
+        numProbes = (pUserScanIn->numProbes ? pUserScanIn->numProbes :
+                     Adapter->ScanProbes);
+
+        /*
+         * Set the BSSID filter to the incoming configuration,
+         *   if non-zero.  If not set, it will remain disabled (all zeros).
+         */
+        memcpy(pScanCfgOut->specificBSSID,
+               pUserScanIn->specificBSSID,
+               sizeof(pScanCfgOut->specificBSSID));
+
+        ssidLen = strlen(pUserScanIn->specificSSID);
+
+        if (ssidLen) {
+            pSsidTlv = (MrvlIEtypes_SsIdParamSet_t *) pScanCfgOut->tlvBuffer;
+            pSsidTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_SSID);
+            pSsidTlv->Header.Len = wlan_cpu_to_le16(ssidLen);
+            memcpy(pSsidTlv->SsId, pUserScanIn->specificSSID, ssidLen);
+            pTlvPos += sizeof(pSsidTlv->Header) + ssidLen;
+        }
+
+        /*
+         *  The default number of channels sent in the command is low to
+         *    ensure the response buffer from the firmware does not truncate
+         *    scan results.  That is not an issue with an SSID or BSSID
+         *    filter applied to the scan results in the firmware.
+         */
+        if (ssidLen || (memcmp(pScanCfgOut->specificBSSID,
+                               &zeroMac, sizeof(zeroMac)) != 0)) {
+            *pMaxChanPerScan = MRVDRV_MAX_CHANNELS_PER_SCAN;
+            *pFilteredScan = TRUE;
+        }
+    } else {
+        pScanCfgOut->bssType = Adapter->ScanMode;
+        numProbes = Adapter->ScanProbes;
+    }
+
+    /* If the input config or adapter has the number of Probes set, add tlv */
+    if (numProbes) {
+        pNumProbesTlv = (MrvlIEtypes_NumProbes_t *) pTlvPos;
+        pNumProbesTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_NUMPROBES);
+        pNumProbesTlv->Header.Len = sizeof(pNumProbesTlv->NumProbes);
+        pNumProbesTlv->NumProbes = wlan_cpu_to_le16(numProbes);
+
+        pTlvPos += sizeof(pNumProbesTlv->Header) + pNumProbesTlv->Header.Len;
+
+        pNumProbesTlv->Header.Len =
+            wlan_cpu_to_le16(pNumProbesTlv->Header.Len);
+    }
+
+    /*
+     * Set the output for the channel TLV to the address in the tlv buffer
+     *   past any TLVs that were added in this fuction (SSID, numProbes).
+     *   Channel TLVs will be added past this for each scan command, preserving
+     *   the TLVs that were previously added.
+     */
+    *ppChanTlvOut = (MrvlIEtypes_ChanListParamSet_t *) pTlvPos;
+
+    if (pUserScanIn && pUserScanIn->chanList[0].chanNumber) {
+
+        PRINTM(INFO, "Scan: Using supplied channel list\n");
+
+        for (chanIdx = 0;
+             chanIdx < WLAN_IOCTL_USER_SCAN_CHAN_MAX
+             && pUserScanIn->chanList[chanIdx].chanNumber; chanIdx++) {
+
+            channel = pUserScanIn->chanList[chanIdx].chanNumber;
+            (pScanChanList + chanIdx)->ChanNumber = channel;
+
+            radioType = pUserScanIn->chanList[chanIdx].radioType;
+            (pScanChanList + chanIdx)->RadioType = radioType;
+
+            scanType = pUserScanIn->chanList[chanIdx].scanType;
+
+            if (scanType == HostCmd_SCAN_TYPE_PASSIVE) {
+                (pScanChanList + chanIdx)->ChanScanMode.PassiveScan = TRUE;
+            } else {
+                (pScanChanList + chanIdx)->ChanScanMode.PassiveScan = FALSE;
+            }
+
+            if (pUserScanIn->chanList[chanIdx].scanTime) {
+                scanDur = pUserScanIn->chanList[chanIdx].scanTime;
+            } else {
+                if (scanType == HostCmd_SCAN_TYPE_PASSIVE) {
+                    scanDur = Adapter->PassiveScanTime;
+                } else if (*pFilteredScan) {
+                    scanDur = Adapter->SpecificScanTime;
+                } else {
+                    scanDur = Adapter->ActiveScanTime;
+                }
+            }
+
+            (pScanChanList + chanIdx)->MinScanTime =
+                wlan_cpu_to_le16(scanDur);
+            (pScanChanList + chanIdx)->MaxScanTime =
+                wlan_cpu_to_le16(scanDur);
+        }
+
+        /* Check if we are only scanning the current channel */
+        if ((chanIdx == 1) && (pUserScanIn->chanList[0].chanNumber
+                               == priv->adapter->CurBssParams.channel)) {
+            *pScanCurrentOnly = TRUE;
+            PRINTM(INFO, "Scan: Scanning current channel only");
+        }
+
+    } else {
+        PRINTM(INFO, "Scan: Creating full region channel list\n");
+        wlan_scan_create_channel_list(priv, pScanChanList, *pFilteredScan);
+    }
+}
+
+/**
+ *  @brief Construct and send multiple scan config commands to the firmware
+ *
+ *  Previous routines have created a wlan_scan_cmd_config with any requested
+ *   TLVs.  This function splits the channel TLV into maxChanPerScan lists
+ *   and sends the portion of the channel TLV along with the other TLVs
+ *   to the wlan_cmd routines for execution in the firmware.
+ *
+ *  @param priv            A pointer to wlan_private structure
+ *  @param maxChanPerScan  Maximum number channels to be included in each
+ *                         scan command sent to firmware
+ *  @param filteredScan    Flag indicating whether or not a BSSID or SSID
+ *                         filter is being used for the firmware command
+ *                         scan command sent to firmware
+ *  @param pScanCfgOut     Scan configuration used for this scan.
+ *  @param pChanTlvOut     Pointer in the pScanCfgOut where the channel TLV
+ *                         should start.  This is past any other TLVs that
+ *                         must be sent down in each firmware command.
+ *  @param pScanChanList   List of channels to scan in maxChanPerScan segments
+ *
+ *  @return                WLAN_STATUS_SUCCESS or error return otherwise
+ */
+static int
+wlan_scan_channel_list(wlan_private * priv,
+                       int maxChanPerScan,
+                       BOOLEAN filteredScan,
+                       wlan_scan_cmd_config * pScanCfgOut,
+                       MrvlIEtypes_ChanListParamSet_t * pChanTlvOut,
+                       ChanScanParamSet_t * pScanChanList)
+{
+    ChanScanParamSet_t *pTmpChan;
+    ChanScanParamSet_t *pStartChan;
+    u8 scanBand;
+    int doneEarly;
+    int tlvIdx;
+    int totalscantime;
+    int ret;
+
+    ENTER();
+
+    if (pScanCfgOut == 0 || pChanTlvOut == 0 || pScanChanList == 0) {
+        PRINTM(INFO, "Scan: Null detect: %p, %p, %p\n",
+               pScanCfgOut, pChanTlvOut, pScanChanList);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+
+    pChanTlvOut->Header.Type = wlan_cpu_to_le16(TLV_TYPE_CHANLIST);
+
+    /* Set the temp channel struct pointer to the start of the desired list */
+    pTmpChan = pScanChanList;
+
+    /* Loop through the desired channel list, sending a new firmware scan
+     *   commands for each maxChanPerScan channels (or for 1,6,11 individually
+     *   if configured accordingly)
+     */
+    while (pTmpChan->ChanNumber) {
+
+        tlvIdx = 0;
+        totalscantime = 0;
+        pChanTlvOut->Header.Len = 0;
+        scanBand = pTmpChan->RadioType;
+        pStartChan = pTmpChan;
+        doneEarly = FALSE;
+
+        /* Construct the Channel TLV for the scan command.  Continue to
+         *  insert channel TLVs until:
+         *    - the tlvIdx hits the maximum configured per scan command
+         *    - the next channel to insert is 0 (end of desired channel list)
+         *    - doneEarly is set (controlling individual scanning of 1,6,11)
+         */
+        while (tlvIdx < maxChanPerScan && pTmpChan->ChanNumber && !doneEarly) {
+
+            PRINTM(INFO, "Scan: Chan(%3d), Radio(%d), Mode(%d,%d), Dur(%d)\n",
+                   pTmpChan->ChanNumber,
+                   pTmpChan->RadioType,
+                   pTmpChan->ChanScanMode.PassiveScan,
+                   pTmpChan->ChanScanMode.DisableChanFilt,
+                   pTmpChan->MaxScanTime);
+
+            /* Copy the current channel TLV to the command being prepared */
+            memcpy(pChanTlvOut->ChanScanParam + tlvIdx,
+                   pTmpChan, sizeof(pChanTlvOut->ChanScanParam));
+
+            /* Increment the TLV header length by the size appended */
+            pChanTlvOut->Header.Len += sizeof(pChanTlvOut->ChanScanParam);
+
+            /*
+             *  The tlv buffer length is set to the number of bytes of the
+             *    between the channel tlv pointer and the start of the
+             *    tlv buffer.  This compensates for any TLVs that were appended
+             *    before the channel list.
+             */
+            pScanCfgOut->tlvBufferLen = ((u8 *) pChanTlvOut
+                                         - pScanCfgOut->tlvBuffer);
+
+            /*  Add the size of the channel tlv header and the data length */
+            pScanCfgOut->tlvBufferLen += (sizeof(pChanTlvOut->Header)
+                                          + pChanTlvOut->Header.Len);
+
+            /* Increment the index to the channel tlv we are constructing */
+            tlvIdx++;
+
+            /* Count the total scan time per command */
+            totalscantime += pTmpChan->MaxScanTime;
+
+            doneEarly = FALSE;
+
+            /* Stop the loop if the *current* channel is in the 1,6,11 set
+             *   and we are not filtering on a BSSID or SSID.
+             */
+            if (!filteredScan && (pTmpChan->ChanNumber == 1
+                                  || pTmpChan->ChanNumber == 6
+                                  || pTmpChan->ChanNumber == 11)) {
+                doneEarly = TRUE;
+            }
+
+            /* Increment the tmp pointer to the next channel to be scanned */
+            pTmpChan++;
+
+            /* Stop the loop if the *next* channel is in the 1,6,11 set.
+             *  This will cause it to be the only channel scanned on the next
+             *  interation
+             */
+            if (!filteredScan && (pTmpChan->ChanNumber == 1
+                                  || pTmpChan->ChanNumber == 6
+                                  || pTmpChan->ChanNumber == 11)) {
+                doneEarly = TRUE;
+            }
+        }
+
+        /* The total scan time should be less than scan command timeout value */
+        if (totalscantime > MRVDRV_MAX_TOTAL_SCAN_TIME) {
+            PRINTM(MSG,
+                   "Total scan time %d ms is over limit (%d ms), scan skipped\n",
+                   totalscantime, MRVDRV_MAX_TOTAL_SCAN_TIME);
+            ret = WLAN_STATUS_FAILURE;
+            break;
+        }
+
+        pChanTlvOut->Header.Len = wlan_cpu_to_le16(pChanTlvOut->Header.Len);
+
+        /* Send the scan command to the firmware with the specified cfg */
+        ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SCAN, 0,
+                                    HostCmd_OPTION_WAITFORRSP, 0,
+                                    pScanCfgOut);
+    }
+
+    LEAVE();
+
+    if (ret) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Internal function used to start a scan based on an input config
+ *
+ *  Use the input user scan configuration information when provided in
+ *    order to send the appropriate scan commands to firmware to populate or
+ *    update the internal driver scan table
+ *
+ *  @param priv          A pointer to wlan_private structure
+ *  @param pUserScanIn   Pointer to the input configuration for the requested
+ *                       scan.
+ *
+ *  @return              WLAN_STATUS_SUCCESS or < 0 if error
+ */
+static int
+wlan_scan_networks(wlan_private * priv,
+                   const wlan_ioctl_user_scan_cfg * pUserScanIn)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    MrvlIEtypes_ChanListParamSet_t *pChanTlvOut;
+
+    ChanScanParamSet_t scanChanList[WLAN_IOCTL_USER_SCAN_CHAN_MAX];
+    wlan_scan_cmd_config_tlv scanCfgOut;
+    BOOLEAN keepPreviousScan;
+    BOOLEAN filteredScan;
+    BOOLEAN scanCurrentChanOnly;
+    int maxChanPerScan;
+    int ret;
+    BOOLEAN bBgScan;
+
+    ENTER();
+
+    memset(scanChanList, 0x00, sizeof(scanChanList));
+    memset(&scanCfgOut, 0x00, sizeof(scanCfgOut));
+
+    keepPreviousScan = FALSE;
+
+    wlan_scan_setup_scan_config(priv,
+                                pUserScanIn,
+                                &scanCfgOut.config,
+                                &pChanTlvOut,
+                                scanChanList,
+                                &maxChanPerScan,
+                                &filteredScan, &scanCurrentChanOnly);
+
+    if (pUserScanIn) {
+        keepPreviousScan = pUserScanIn->keepPreviousScan;
+    }
+
+    if (keepPreviousScan == FALSE) {
+        memset(Adapter->ScanTable, 0x00,
+               sizeof(BSSDescriptor_t) * MRVDRV_MAX_BSSID_LIST);
+        Adapter->NumInScanTable = 0;
+        Adapter->pBeaconBufEnd = Adapter->beaconBuffer;
+    }
+
+    /* Keep the data path active if we are only scanning our current channel */
+    if (!scanCurrentChanOnly) {
+        os_stop_queue(priv);
+        os_carrier_off(priv);
+    }
+
+    bBgScan = priv->adapter->bgScanConfig->Enable;
+    if (priv->adapter->bgScanConfig->Enable == TRUE) {
+        wlan_bg_scan_enable(priv, FALSE);
+    }
+
+    ret = wlan_scan_channel_list(priv,
+                                 maxChanPerScan,
+                                 filteredScan,
+                                 &scanCfgOut.config,
+                                 pChanTlvOut, scanChanList);
+
+    /*  Process the resulting scan table:
+     *    - Remove any bad ssids
+     *    - Update our current BSS information from scan data
+     */
+    wlan_scan_process_results(priv);
+
+    if (bBgScan == TRUE) {
+        wlan_bg_scan_enable(priv, TRUE);
+    }
+
+    os_carrier_on(priv);
+    os_start_queue(priv);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Create a brief scan resp to relay basic BSS info to the app layer
+ *
+ *  When the beacon/probe response has not been buffered, use the fixed field
+ *    information available to provide a minimum response for the application
+ *    ioctl retrieval routines.
+ *
+ *  @param ppBuffer  Output parameter: Buffer used to create basic scan rsp
+ *  @param pBssDesc  Pointer to a BSS entry in the scan table to create
+ *                   scan response from for delivery to the application layer
+ *
+ *  @return          void
+ */
+static void
+wlan_scan_create_brief_scan_table(u8 ** ppBuffer, BSSDescriptor_t * pBssDesc)
+{
+    u8 *pTmpBuf = *ppBuffer;
+    u8 tmpSSIDHdr[2];
+
+    if (copy_to_user
+        (pTmpBuf, pBssDesc->TimeStamp, sizeof(pBssDesc->TimeStamp))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += sizeof(pBssDesc->TimeStamp);
+
+    if (copy_to_user(pTmpBuf, &pBssDesc->BeaconPeriod,
+                     sizeof(pBssDesc->BeaconPeriod))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += sizeof(pBssDesc->BeaconPeriod);
+
+    if (copy_to_user(pTmpBuf, &pBssDesc->Cap, sizeof(pBssDesc->Cap))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += sizeof(pBssDesc->Cap);
+
+    tmpSSIDHdr[0] = 0;          /* Element ID for SSID is zero */
+    tmpSSIDHdr[1] = pBssDesc->Ssid.SsidLength;
+    if (copy_to_user(pTmpBuf, tmpSSIDHdr, sizeof(tmpSSIDHdr))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += sizeof(tmpSSIDHdr);
+
+    if (copy_to_user(pTmpBuf, pBssDesc->Ssid.Ssid, pBssDesc->Ssid.SsidLength)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += pBssDesc->Ssid.SsidLength;
+
+    *ppBuffer = pTmpBuf;
+}
+
+/**
+ *  @brief Inspect the scan response buffer for pointers to expected TLVs
+ *
+ *  TLVs can be included at the end of the scan response BSS information.
+ *    Parse the data in the buffer for pointers to TLVs that can potentially
+ *    be passed back in the response
+ *
+ *  @param pTlv        Pointer to the start of the TLV buffer to parse
+ *  @param tlvBufSize  Size of the TLV buffer
+ *  @param pTsfTlv     Output parameter: Pointer to the TSF TLV if found
+ *
+ *  @return            void
+ */
+static void
+wlan_ret_802_11_scan_get_tlv_ptrs(MrvlIEtypes_Data_t * pTlv,
+                                  int tlvBufSize,
+                                  MrvlIEtypes_TsfTimestamp_t ** pTsfTlv)
+{
+    MrvlIEtypes_Data_t *pCurrentTlv;
+    int tlvBufLeft;
+    u16 tlvType;
+    u16 tlvLen;
+
+    pCurrentTlv = pTlv;
+    tlvBufLeft = tlvBufSize;
+    *pTsfTlv = NULL;
+
+    PRINTM(INFO, "SCAN_RESP: tlvBufSize = %d\n", tlvBufSize);
+    HEXDUMP("SCAN_RESP: TLV Buf", (u8 *) pTlv, tlvBufSize);
+
+    while (tlvBufLeft >= sizeof(MrvlIEtypesHeader_t)) {
+        tlvType = wlan_le16_to_cpu(pCurrentTlv->Header.Type);
+        tlvLen = wlan_le16_to_cpu(pCurrentTlv->Header.Len);
+
+        switch (tlvType) {
+        case TLV_TYPE_TSFTIMESTAMP:
+            *pTsfTlv = (MrvlIEtypes_TsfTimestamp_t *) pCurrentTlv;
+            break;
+
+        default:
+            PRINTM(INFO, "SCAN_RESP: Unhandled TLV = %d\n", tlvType);
+            /* Give up, this seems corrupted */
+            return;
+        }                       /* switch */
+
+        tlvBufLeft -= (sizeof(pTlv->Header) + tlvLen);
+        pCurrentTlv = (MrvlIEtypes_Data_t *) (pCurrentTlv->Data + tlvLen);
+    }                           /* while */
+}
+
+/**
+ *  @brief Interpret a BSS scan response returned from the firmware
+ *
+ *  Parse the various fixed fields and IEs passed back for a a BSS probe
+ *   response or beacon from the scan command.  Record information as needed
+ *   in the scan table BSSDescriptor_t for that entry.
+ *
+ *  @param pBSSIDEntry  Output parameter: Pointer to the BSS Entry
+ *
+ *  @return             WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+InterpretBSSDescriptionWithIE(BSSDescriptor_t * pBSSEntry,
+                              u8 ** pBeaconInfo, int *bytesLeft)
+{
+    IEEEtypes_ElementId_e elemID;
+    IEEEtypes_FhParamSet_t *pFH;
+    IEEEtypes_DsParamSet_t *pDS;
+    IEEEtypes_CfParamSet_t *pCF;
+    IEEEtypes_IbssParamSet_t *pIbss;
+    IEEEtypes_CapInfo_t *pCap;
+    WLAN_802_11_FIXED_IEs fixedIE;
+    u8 *pCurrentPtr;
+    u8 *pRate;
+    u8 elemLen;
+    u8 bytesToCopy;
+    u8 rateSize;
+    u16 beaconSize;
+    BOOLEAN foundDataRateIE;
+    int bytesLeftForCurrentBeacon;
+
+    PWPA_SUPPLICANT pwpa_supplicant;
+    PWPA_SUPPLICANT pwpa2_supplicant;
+    IE_WPA *pIe;
+    const u8 oui01[4] = { 0x00, 0x50, 0xf2, 0x01 };
+    const u8 oui02[4] = { 0x00, 0x50, 0xf2, 0x02 };
+    u8 wmmIeLen;
+
+    IEEEtypes_CountryInfoSet_t *pcountryinfo;
+
+    ENTER();
+
+    foundDataRateIE = FALSE;
+    rateSize = 0;
+    beaconSize = 0;
+
+    if (*bytesLeft >= sizeof(beaconSize)) {
+        /* Extract & convert beacon size from the command buffer */
+        memcpy(&beaconSize, *pBeaconInfo, sizeof(beaconSize));
+        beaconSize = wlan_le16_to_cpu(beaconSize);
+        *bytesLeft -= sizeof(beaconSize);
+        *pBeaconInfo += sizeof(beaconSize);
+    }
+
+    if (beaconSize == 0 || beaconSize > *bytesLeft) {
+
+        *pBeaconInfo += *bytesLeft;
+        *bytesLeft = 0;
+
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /* Initialize the current working beacon pointer for this BSS iteration */
+    pCurrentPtr = *pBeaconInfo;
+
+    /* Advance the return beacon pointer past the current beacon */
+    *pBeaconInfo += beaconSize;
+    *bytesLeft -= beaconSize;
+
+    bytesLeftForCurrentBeacon = beaconSize;
+
+    pwpa_supplicant = &pBSSEntry->wpa_supplicant;
+    pwpa2_supplicant = &pBSSEntry->wpa2_supplicant;
+
+    memcpy(pBSSEntry->MacAddress, pCurrentPtr, MRVDRV_ETH_ADDR_LEN);
+    PRINTM(INFO, "InterpretIE: AP MAC Addr-%x:%x:%x:%x:%x:%x\n",
+           pBSSEntry->MacAddress[0], pBSSEntry->MacAddress[1],
+           pBSSEntry->MacAddress[2], pBSSEntry->MacAddress[3],
+           pBSSEntry->MacAddress[4], pBSSEntry->MacAddress[5]);
+
+    pCurrentPtr += MRVDRV_ETH_ADDR_LEN;
+    bytesLeftForCurrentBeacon -= MRVDRV_ETH_ADDR_LEN;
+
+    if (bytesLeftForCurrentBeacon < 12) {
+        PRINTM(INFO, "InterpretIE: Not enough bytes left\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /*
+     * next 4 fields are RSSI, time stamp, beacon interval,
+     *   and capability information
+     */
+
+    /* RSSI is 1 byte long */
+    pBSSEntry->Rssi = wlan_le32_to_cpu((LONG) (*pCurrentPtr));
+    PRINTM(INFO, "InterpretIE: RSSI=%02X\n", *pCurrentPtr);
+    pCurrentPtr += 1;
+    bytesLeftForCurrentBeacon -= 1;
+
+    /*
+     *  The RSSI is not part of the beacon/probe response.  After we have
+     *    advanced pCurrentPtr past the RSSI field, save the remaining
+     *    data for use at the application layer
+     */
+    pBSSEntry->pBeaconBuf = pCurrentPtr;
+    pBSSEntry->beaconBufSize = bytesLeftForCurrentBeacon;
+
+    /* time stamp is 8 bytes long */
+    memcpy(fixedIE.Timestamp, pCurrentPtr, 8);
+    memcpy(pBSSEntry->TimeStamp, pCurrentPtr, 8);
+    pCurrentPtr += 8;
+    bytesLeftForCurrentBeacon -= 8;
+
+    /* beacon interval is 2 bytes long */
+    memcpy(&fixedIE.BeaconInterval, pCurrentPtr, 2);
+    pBSSEntry->BeaconPeriod = wlan_le16_to_cpu(fixedIE.BeaconInterval);
+    pCurrentPtr += 2;
+    bytesLeftForCurrentBeacon -= 2;
+
+    /* capability information is 2 bytes long */
+    memcpy(&fixedIE.Capabilities, pCurrentPtr, 2);
+    PRINTM(INFO, "InterpretIE: fixedIE.Capabilities=0x%X\n",
+           fixedIE.Capabilities);
+    fixedIE.Capabilities = wlan_le16_to_cpu(fixedIE.Capabilities);
+    pCap = (IEEEtypes_CapInfo_t *) & fixedIE.Capabilities;
+    memcpy(&pBSSEntry->Cap, pCap, sizeof(IEEEtypes_CapInfo_t));
+    pCurrentPtr += 2;
+    bytesLeftForCurrentBeacon -= 2;
+
+    /* rest of the current buffer are IE's */
+    PRINTM(INFO, "InterpretIE: IELength for this AP = %d\n",
+           bytesLeftForCurrentBeacon);
+
+    HEXDUMP("InterpretIE: IE info", (u8 *) pCurrentPtr,
+            bytesLeftForCurrentBeacon);
+
+    if (pCap->Privacy) {
+        PRINTM(INFO, "InterpretIE: AP WEP enabled\n");
+        pBSSEntry->Privacy = Wlan802_11PrivFilter8021xWEP;
+    } else {
+        pBSSEntry->Privacy = Wlan802_11PrivFilterAcceptAll;
+    }
+
+    if (pCap->Ibss == 1) {
+        pBSSEntry->InfrastructureMode = Wlan802_11IBSS;
+    } else {
+        pBSSEntry->InfrastructureMode = Wlan802_11Infrastructure;
+    }
+
+    /* process variable IE */
+    while (bytesLeftForCurrentBeacon >= 2) {
+        elemID = (IEEEtypes_ElementId_e) (*((u8 *) pCurrentPtr));
+        elemLen = *((u8 *) pCurrentPtr + 1);
+
+        if (bytesLeftForCurrentBeacon < elemLen) {
+            PRINTM(INFO, "InterpretIE: Error in processing IE, "
+                   "bytes left < IE length\n");
+            bytesLeftForCurrentBeacon = 0;
+            continue;
+        }
+
+        switch (elemID) {
+
+        case SSID:
+            pBSSEntry->Ssid.SsidLength = elemLen;
+            memcpy(pBSSEntry->Ssid.Ssid, (pCurrentPtr + 2), elemLen);
+            PRINTM(INFO, "Ssid: %32s", pBSSEntry->Ssid.Ssid);
+            break;
+
+        case SUPPORTED_RATES:
+            memcpy(pBSSEntry->DataRates, (pCurrentPtr + 2), elemLen);
+            memmove(pBSSEntry->SupportedRates, (pCurrentPtr + 2), elemLen);
+            rateSize = elemLen;
+            foundDataRateIE = TRUE;
+            break;
+
+        case EXTRA_IE:
+            PRINTM(INFO, "InterpretIE: EXTRA_IE Found!\n");
+            pBSSEntry->extra_ie = 1;
+            break;
+
+        case FH_PARAM_SET:
+            pFH = (IEEEtypes_FhParamSet_t *) pCurrentPtr;
+            pBSSEntry->NetworkTypeInUse = Wlan802_11FH;
+            memmove(&pBSSEntry->PhyParamSet.FhParamSet, pFH,
+                    sizeof(IEEEtypes_FhParamSet_t));
+            pBSSEntry->PhyParamSet.FhParamSet.DwellTime
+                =
+                wlan_le16_to_cpu(pBSSEntry->PhyParamSet.FhParamSet.DwellTime);
+            break;
+
+        case DS_PARAM_SET:
+            pDS = (IEEEtypes_DsParamSet_t *) pCurrentPtr;
+
+            pBSSEntry->NetworkTypeInUse = Wlan802_11DS;
+            pBSSEntry->Channel = pDS->CurrentChan;
+
+            memcpy(&pBSSEntry->PhyParamSet.DsParamSet, pDS,
+                   sizeof(IEEEtypes_DsParamSet_t));
+            break;
+
+        case CF_PARAM_SET:
+            pCF = (IEEEtypes_CfParamSet_t *) pCurrentPtr;
+
+            memcpy(&pBSSEntry->SsParamSet.CfParamSet, pCF,
+                   sizeof(IEEEtypes_CfParamSet_t));
+            break;
+
+        case IBSS_PARAM_SET:
+            pIbss = (IEEEtypes_IbssParamSet_t *) pCurrentPtr;
+            pBSSEntry->ATIMWindow = wlan_le32_to_cpu(pIbss->AtimWindow);
+
+            memmove(&pBSSEntry->SsParamSet.IbssParamSet, pIbss,
+                    sizeof(IEEEtypes_IbssParamSet_t));
+
+            pBSSEntry->SsParamSet.IbssParamSet.AtimWindow
+                =
+                wlan_le16_to_cpu(pBSSEntry->SsParamSet.IbssParamSet.
+                                 AtimWindow);
+            break;
+
+            /* Handle Country Info IE */
+        case COUNTRY_INFO:
+            pcountryinfo = (IEEEtypes_CountryInfoSet_t *) pCurrentPtr;
+
+            if (pcountryinfo->Len < sizeof(pcountryinfo->CountryCode)
+                || pcountryinfo->Len > 254) {
+                PRINTM(INFO, "InterpretIE: 11D- Err "
+                       "CountryInfo len =%d min=%d max=254\n",
+                       pcountryinfo->Len, sizeof(pcountryinfo->CountryCode));
+                LEAVE();
+                return WLAN_STATUS_FAILURE;
+            }
+
+            memcpy(&pBSSEntry->CountryInfo,
+                   pcountryinfo, pcountryinfo->Len + 2);
+            HEXDUMP("InterpretIE: 11D- CountryInfo:",
+                    (u8 *) pcountryinfo, (u32) (pcountryinfo->Len + 2));
+            break;
+
+        case EXTENDED_SUPPORTED_RATES:
+            /*
+             * only process extended supported rate
+             * if data rate is already found.
+             * data rate IE should come before
+             * extended supported rate IE
+             */
+            if (foundDataRateIE) {
+                if ((elemLen + rateSize) > WLAN_SUPPORTED_RATES) {
+                    bytesToCopy = (WLAN_SUPPORTED_RATES - rateSize);
+                } else {
+                    bytesToCopy = elemLen;
+                }
+
+                pRate = (u8 *) pBSSEntry->DataRates;
+                pRate += rateSize;
+                memmove(pRate, (pCurrentPtr + 2), bytesToCopy);
+
+                pRate = (u8 *) pBSSEntry->SupportedRates;
+
+                pRate += rateSize;
+                memmove(pRate, (pCurrentPtr + 2), bytesToCopy);
+            }
+            break;
+
+        case VENDOR_SPECIFIC_221:
+#define IE_ID_LEN_FIELDS_BYTES 2
+            pIe = (IE_WPA *) pCurrentPtr;
+
+            if (!memcmp(pIe->oui, oui01, sizeof(oui01))) {
+                pwpa_supplicant->Wpa_ie_len
+                    = MIN(elemLen + IE_ID_LEN_FIELDS_BYTES,
+                          sizeof(pwpa_supplicant->Wpa_ie));
+                memcpy(pwpa_supplicant->Wpa_ie,
+                       pCurrentPtr, pwpa_supplicant->Wpa_ie_len);
+                HEXDUMP("InterpretIE: Resp WPA_IE",
+                        pwpa_supplicant->Wpa_ie, elemLen);
+            } else if (!memcmp(pIe->oui, oui02, sizeof(oui02))) {
+
+                wmmIeLen = pIe->Len + IE_ID_LEN_FIELDS_BYTES;
+                if (wmmIeLen == sizeof(WMM_PARAMETER_IE)
+                    || wmmIeLen == sizeof(WMM_INFO_IE)) {
+                    /* Only accept and copy the WMM IE if it matches
+                     *  the size expected for the WMM Info IE or the
+                     *  WMM Parameter IE.
+                     */
+                    memcpy((u8 *) & pBSSEntry->wmmIE, pCurrentPtr, wmmIeLen);
+                    HEXDUMP("InterpretIE: Resp WMM_IE",
+                            (u8 *) & pBSSEntry->wmmIE, wmmIeLen);
+                }
+            }
+            break;
+        case WPA2_IE:
+            pIe = (IE_WPA *) pCurrentPtr;
+            pwpa2_supplicant->Wpa_ie_len
+                = MIN(elemLen + IE_ID_LEN_FIELDS_BYTES,
+                      sizeof(pwpa2_supplicant->Wpa_ie));
+            memcpy(pwpa2_supplicant->Wpa_ie,
+                   pCurrentPtr, pwpa2_supplicant->Wpa_ie_len);
+
+            HEXDUMP("InterpretIE: Resp WPA2_IE",
+                    pwpa2_supplicant->Wpa_ie, elemLen);
+            break;
+        case TIM:
+            break;
+
+        case CHALLENGE_TEXT:
+            break;
+        }
+
+        pCurrentPtr += elemLen + 2;
+
+        /* need to account for IE ID and IE Len */
+        bytesLeftForCurrentBeacon -= (elemLen + 2);
+
+    }                           /* while (bytesLeftForCurrentBeacon > 2) */
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Compare two SSIDs
+ *
+ *  @param ssid1    A pointer to ssid to compare
+ *  @param ssid2    A pointer to ssid to compare
+ *
+ *  @return         0--ssid is same, otherwise is different
+ */
+int
+SSIDcmp(WLAN_802_11_SSID * ssid1, WLAN_802_11_SSID * ssid2)
+{
+    if (!ssid1 || !ssid2)
+        return -1;
+
+    if (ssid1->SsidLength != ssid2->SsidLength)
+        return -1;
+
+    return memcmp(ssid1->Ssid, ssid2->Ssid, ssid1->SsidLength);
+}
+
+/**
+ *  @brief This function finds a specific compatible BSSID in the scan list
+ *
+ *  @param Adapter  A pointer to wlan_adapter
+ *  @param bssid    BSSID to find in the scan list
+ *  @param mode     Network mode: Infrastructure or IBSS
+ *
+ *  @return         index in BSSID list, or error return code (< 0)
+ */
+int
+FindBSSIDInList(wlan_adapter * Adapter, u8 * bssid, int mode)
+{
+    int ret = -ENETUNREACH;
+    int i;
+
+    if (!bssid)
+        return -EFAULT;
+
+    PRINTM(INFO, "FindBSSID: Num of BSSIDs = %d\n", Adapter->NumInScanTable);
+
+    /* Look through the scan table for a compatible match. The ret return
+     *   variable will be equal to the index in the scan table (greater
+     *   than zero) if the network is compatible.  The loop will continue
+     *   past a matched bssid that is not compatible in case there is an
+     *   AP with multiple SSIDs assigned to the same BSSID
+     */
+    for (i = 0; ret < 0 && i < Adapter->NumInScanTable; i++) {
+        if (!memcmp(Adapter->ScanTable[i].MacAddress, bssid, ETH_ALEN)) {
+            switch (mode) {
+            case Wlan802_11Infrastructure:
+            case Wlan802_11IBSS:
+                ret = IsNetworkCompatible(Adapter, i, mode);
+                break;
+            default:
+                ret = i;
+                break;
+            }
+        }
+    }
+
+    return ret;
+}
+
+/**
+ *  @brief This function finds ssid in ssid list.
+ *
+ *  @param Adapter  A pointer to wlan_adapter
+ *  @param ssid     SSID to find in the list
+ *  @param bssid    BSSID to qualify the SSID selection (if provided)
+ *  @param mode     Network mode: Infrastructure or IBSS
+ *
+ *  @return         index in BSSID list
+ */
+int
+FindSSIDInList(wlan_adapter * Adapter,
+               WLAN_802_11_SSID * ssid, u8 * bssid, int mode)
+{
+    int net = -ENETUNREACH;
+    u8 bestrssi = 0;
+    int i;
+    int j;
+
+    PRINTM(INFO, "Num of Entries in Table = %d\n", Adapter->NumInScanTable);
+
+    for (i = 0; i < Adapter->NumInScanTable; i++) {
+        if (!SSIDcmp(&Adapter->ScanTable[i].Ssid, ssid) &&
+            (!bssid ||
+             !memcmp(Adapter->ScanTable[i].MacAddress, bssid, ETH_ALEN))) {
+            switch (mode) {
+            case Wlan802_11Infrastructure:
+            case Wlan802_11IBSS:
+                j = IsNetworkCompatible(Adapter, i, mode);
+
+                if (j >= 0) {
+                    if (bssid) {
+                        return i;
+                    }
+
+                    if (SCAN_RSSI(Adapter->ScanTable[i].Rssi)
+                        > bestrssi) {
+                        bestrssi = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+                        net = i;
+                    }
+                } else {
+                    if (net == -ENETUNREACH) {
+                        net = j;
+                    }
+                }
+                break;
+            case Wlan802_11AutoUnknown:
+            default:
+                if (SCAN_RSSI(Adapter->ScanTable[i].Rssi)
+                    > bestrssi) {
+                    bestrssi = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+                    net = i;
+                }
+                break;
+            }
+        }
+    }
+
+    return net;
+}
+
+/**
+ *  @brief This function finds the best SSID in the Scan List
+ *
+ *  Search the scan table for the best SSID that also matches the current
+ *   adapter network preference (infrastructure or adhoc)
+ *
+ *  @param Adapter  A pointer to wlan_adapter
+ *
+ *  @return         index in BSSID list
+ */
+int
+FindBestSSIDInList(wlan_adapter * Adapter)
+{
+    int mode = Adapter->InfrastructureMode;
+    int bestnet = -ENETUNREACH;
+    u8 bestrssi = 0;
+    int i;
+
+    ENTER();
+
+    PRINTM(INFO, "Num of BSSIDs = %d\n", Adapter->NumInScanTable);
+
+    for (i = 0; i < Adapter->NumInScanTable; i++) {
+        switch (mode) {
+        case Wlan802_11Infrastructure:
+        case Wlan802_11IBSS:
+            if (IsNetworkCompatible(Adapter, i, mode) >= 0) {
+                if (SCAN_RSSI(Adapter->ScanTable[i].Rssi) > bestrssi) {
+                    bestrssi = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+                    bestnet = i;
+                }
+            }
+            break;
+        case Wlan802_11AutoUnknown:
+        default:
+            if (SCAN_RSSI(Adapter->ScanTable[i].Rssi) > bestrssi) {
+                bestrssi = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+                bestnet = i;
+            }
+            break;
+        }
+    }
+
+    LEAVE();
+    return bestnet;
+}
+
+/**
+ *  @brief Find the AP with specific ssid in the scan list
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param pSSID        A pointer to AP's ssid
+ *
+ *  @return             WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int
+FindBestNetworkSsid(wlan_private * priv, WLAN_802_11_SSID * pSSID)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    BSSDescriptor_t *pReqBSSID;
+    int i;
+
+    ENTER();
+
+    memset(pSSID, 0, sizeof(WLAN_802_11_SSID));
+
+    wlan_scan_networks(priv, NULL);
+
+    i = FindBestSSIDInList(Adapter);
+
+    if (i >= 0) {
+
+        pReqBSSID = &Adapter->ScanTable[i];
+        memcpy(pSSID, &pReqBSSID->Ssid, sizeof(WLAN_802_11_SSID));
+
+        /* Make sure we are in the right mode */
+        if (Adapter->InfrastructureMode == Wlan802_11AutoUnknown) {
+            Adapter->InfrastructureMode = pReqBSSID->InfrastructureMode;
+
+            ret = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_802_11_SNMP_MIB,
+                                        HostCmd_ACT_SET,
+                                        HostCmd_OPTION_WAITFORRSP,
+                                        OID_802_11_INFRASTRUCTURE_MODE, NULL);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+        }
+    }
+
+    if (!pSSID->SsidLength) {
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Convert radio type scan paramter to a band config used in join cmd
+ *
+ *  @param scanBand  Scan parameter indicating the band used for a channel
+ *                   in a scan command.
+ *
+ *  @return          Band type conversion of scanBand used in join/assoc cmds
+ *
+ */
+u8
+wlan_scan_radio_to_band(u8 scanBand)
+{
+    u8 retBand = BAND_G;
+
+    switch (scanBand) {
+    case HostCmd_SCAN_RADIO_TYPE_BG:
+    default:
+        retBand = BAND_G;
+        break;
+    }
+
+    return retBand;
+}
+
+/**
+ *  @brief Delete a specific indexed entry from the scan table.
+ *
+ *  Delete the scan table entry indexed by tableIdx.  Compact the remaining
+ *    entries and adjust any buffering of beacon/probe response data
+ *    if needed.
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param tableIdx   Scan table entry index to delete from the table
+ *
+ *  @return           void
+ *
+ *  @pre              tableIdx must be an index to a valid entry
+ */
+static void
+wlan_scan_delete_table_entry(wlan_private * priv, int tableIdx)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int delIdx;
+    uint beaconBufAdj;
+    u8 *pBeaconBuf;
+
+    /* Shift the saved beacon buffer data for the scan table back over the
+     *   entry being removed.  Update the end of buffer pointer.  Save the 
+     *   deleted buffer allocation size for pointer adjustments for entries
+     *   compacted after the deleted index.
+     */
+    beaconBufAdj = Adapter->ScanTable[tableIdx].beaconBufSizeMax;
+
+    PRINTM(INFO, "Scan: Delete Entry %d, beacon buffer removal = %d bytes\n",
+           tableIdx, beaconBufAdj);
+
+    /* Check if the table entry had storage allocated for its beacon */
+    if (beaconBufAdj) {
+        pBeaconBuf = Adapter->ScanTable[tableIdx].pBeaconBuf;
+
+        /* Remove the entry's buffer space, decrement the table end pointer
+         *   by the amount we are removing 
+         */
+        Adapter->pBeaconBufEnd -= beaconBufAdj;
+
+        PRINTM(INFO,
+               "Scan: Delete Entry %d, compact data: %p <- %p (sz = %d)\n",
+               tableIdx,
+               pBeaconBuf,
+               pBeaconBuf + beaconBufAdj,
+               Adapter->pBeaconBufEnd - pBeaconBuf);
+
+        /* Compact data storage.  Copy all data after the deleted entry's
+         *   end address (pBeaconBuf + beaconBufAdj) back to the original
+         *   start address (pBeaconBuf).
+         *
+         * Scan table entries affected by the move will have their entry
+         *   pointer adjusted below.
+         *
+         * Use memmove since the dest/src memory regions overlap.
+         */
+        memmove(pBeaconBuf,
+                pBeaconBuf + beaconBufAdj,
+                Adapter->pBeaconBufEnd - pBeaconBuf);
+    }
+
+    PRINTM(INFO, "Scan: Delete Entry %d, NumInScanTable = %d\n",
+           tableIdx, Adapter->NumInScanTable);
+
+    /* Shift all of the entries after the tableIdx back by one, compacting
+     *   the table and removing the requested entry
+     */
+    for (delIdx = tableIdx; (delIdx + 1) < Adapter->NumInScanTable; delIdx++) {
+        /* Copy the next entry over this one */
+        memcpy(Adapter->ScanTable + delIdx,
+               Adapter->ScanTable + delIdx + 1, sizeof(BSSDescriptor_t));
+
+        /* Adjust this entry's pointer to its beacon buffer based on the 
+         *   removed/compacted entry from the deleted index.  Don't decrement
+         *   if the buffer pointer is NULL (no data stored for this entry).
+         */
+        if (Adapter->ScanTable[delIdx].pBeaconBuf) {
+            Adapter->ScanTable[delIdx].pBeaconBuf -= beaconBufAdj;
+        }
+    }
+
+    /* The last entry is invalid now that it has been deleted or moved back */
+    memset(Adapter->ScanTable + Adapter->NumInScanTable - 1,
+           0x00, sizeof(BSSDescriptor_t));
+
+    Adapter->NumInScanTable--;
+}
+
+/**
+ *  @brief Find the first entry in the scan table that matches the given SSID
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param pReqSSID   Pointer to an SSID struct to use in finding an SSID
+ *                    match in the scan table
+ *
+ *  @return           -1 if not found, else index of the found entry
+ *
+ */
+static int
+wlan_scan_find_entry_by_ssid(wlan_private * priv, WLAN_802_11_SSID * pReqSSID)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int retval;
+    int tableIdx;
+
+    retval = -1;
+    tableIdx = 0;
+
+    /* Iterate through the scan table, exit the loop if a match for the
+     *   SSID is found or if the end of the table has been reached 
+     */
+    while ((retval < 0) && (tableIdx < Adapter->NumInScanTable)) {
+        if (SSIDcmp(&Adapter->ScanTable[tableIdx].Ssid, pReqSSID) == 0) {
+            retval = tableIdx;
+        } else {
+            tableIdx++;
+        }
+    }
+
+    return retval;
+}
+
+/**
+ *  @brief Delete all occurrences of a given SSID from the scan table
+ *
+ *  Iterate through the scan table and delete all entries that match a given
+ *    SSID.  Compact the remaining scan table entries.
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param pDelSSID   Pointer to an SSID struct to use in deleting all
+ *                    matching SSIDs from the scan table
+ *
+ *  @return           WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ *
+ */
+static int
+wlan_scan_delete_ssid_table_entry(wlan_private * priv,
+                                  WLAN_802_11_SSID * pDelSSID)
+{
+    int tableIdx;
+    int retval = WLAN_STATUS_FAILURE;
+
+    ENTER();
+
+    PRINTM(INFO, "Scan: Delete Ssid Entry: %-32s\n", pDelSSID->Ssid);
+
+    /* If the requested SSID is found in the table, delete it.  Then keep
+     *   searching the table for multiple entires for the SSID until no
+     *   more are found 
+     */
+    while ((tableIdx = wlan_scan_find_entry_by_ssid(priv, pDelSSID)) >= 0) {
+        PRINTM(INFO, "Scan: Delete Ssid Entry: Found Idx = %d\n", tableIdx);
+        retval = WLAN_STATUS_SUCCESS;
+        wlan_scan_delete_table_entry(priv, tableIdx);
+    }
+
+    LEAVE();
+
+    return retval;
+}
+
+/**
+ *  @brief Scan Network
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param vwrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_scan(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    union iwreq_data wrqu;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+#ifdef REASSOCIATION
+    if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+        PRINTM(WARN, "Acquire semaphore error, wlan_set_scan\n");
+        return -EBUSY;
+    }
+#endif
+    if (!wlan_scan_networks(priv, NULL)) {
+        memset(&wrqu, 0, sizeof(union iwreq_data));
+        wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu, NULL);
+    }
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+
+    if (Adapter->SurpriseRemoved)
+        return WLAN_STATUS_FAILURE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Send a scan command for all available channels filtered on a spec
+ *
+ *  @param priv             A pointer to wlan_private structure
+ *  @param pRequestedSSID   A pointer to AP's ssid
+ *
+ *  @return                WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+int
+SendSpecificSSIDScan(wlan_private * priv, WLAN_802_11_SSID * pRequestedSSID)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_user_scan_cfg scanCfg;
+
+    ENTER();
+
+    if (pRequestedSSID == NULL) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    wlan_scan_delete_ssid_table_entry(priv, pRequestedSSID);
+
+    memset(&scanCfg, 0x00, sizeof(scanCfg));
+
+    memcpy(scanCfg.specificSSID, pRequestedSSID->Ssid,
+           pRequestedSSID->SsidLength);
+    scanCfg.keepPreviousScan = TRUE;
+
+    wlan_scan_networks(priv, &scanCfg);
+
+    if (Adapter->SurpriseRemoved)
+        return WLAN_STATUS_FAILURE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief scan an AP with specific BSSID
+ *
+ *  @param priv             A pointer to wlan_private structure
+ *  @param bssid            A pointer to AP's bssid
+ *
+ *  @return          WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+int
+SendSpecificBSSIDScan(wlan_private * priv, u8 * bssid)
+{
+    wlan_ioctl_user_scan_cfg scanCfg;
+
+    ENTER();
+
+    if (bssid == NULL) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    memset(&scanCfg, 0x00, sizeof(scanCfg));
+    memcpy(scanCfg.specificBSSID, bssid, sizeof(scanCfg.specificBSSID));
+    scanCfg.keepPreviousScan = TRUE;
+
+    wlan_scan_networks(priv, &scanCfg);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief  Retrieve the scan table entries via wireless tools IOCTL call
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_scan(struct net_device *dev, struct iw_request_info *info,
+              struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    char *current_ev = extra;
+    char *end_buf = extra + IW_SCAN_MAX_DATA;
+    CHANNEL_FREQ_POWER *cfp;
+    BSSDescriptor_t *pScanTable;
+    char *current_val;          /* For rates */
+    struct iw_event iwe;        /* Temporary buffer */
+    int i;
+    int j;
+    int rate;
+
+    u8 buf[16 + 256 * 2];
+    u8 *ptr;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected)
+        PRINTM(INFO, "Current Ssid: %32s\n", Adapter->CurBssParams.ssid.Ssid);
+
+    PRINTM(INFO, "Scan: Get: NumInScanTable = %d\n", Adapter->NumInScanTable);
+
+#if WIRELESS_EXT > 13
+    /* The old API using SIOCGIWAPLIST had a hard limit of IW_MAX_AP.
+     * The new API using SIOCGIWSCAN is only limited by buffer size
+     * WE-14 -> WE-16 the buffer is limited to IW_SCAN_MAX_DATA bytes
+     * which is 4096.
+     */
+    for (i = 0; i < Adapter->NumInScanTable; i++) {
+        if ((current_ev + MAX_SCAN_CELL_SIZE) >= end_buf) {
+            PRINTM(INFO, "i=%d break out: current_ev=%p end_buf=%p "
+                   "MAX_SCAN_CELL_SIZE=%d\n",
+                   i, current_ev, end_buf, MAX_SCAN_CELL_SIZE);
+            break;
+        }
+
+        pScanTable = &Adapter->ScanTable[i];
+
+        PRINTM(INFO, "i=%d  Ssid: %32s\n", i, pScanTable->Ssid.Ssid);
+
+        cfp =
+            find_cfp_by_band_and_channel(Adapter, 0,
+                                         (u16) pScanTable->Channel);
+        if (!cfp) {
+            PRINTM(INFO, "Invalid channel number %d\n", pScanTable->Channel);
+            continue;
+        }
+
+        if (ssid_valid(&Adapter->ScanTable[i].Ssid) == FALSE) {
+            continue;
+        }
+
+        /* First entry *MUST* be the AP MAC address */
+        iwe.cmd = SIOCGIWAP;
+        iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+        memcpy(iwe.u.ap_addr.sa_data,
+               &Adapter->ScanTable[i].MacAddress, ETH_ALEN);
+
+        iwe.len = IW_EV_ADDR_LEN;
+        current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, iwe.len);
+
+        //Add the ESSID
+        iwe.u.data.length = Adapter->ScanTable[i].Ssid.SsidLength;
+
+        if (iwe.u.data.length > 32) {
+            iwe.u.data.length = 32;
+        }
+
+        iwe.cmd = SIOCGIWESSID;
+        iwe.u.data.flags = 1;
+        iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+        current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe,
+                                          Adapter->ScanTable[i].Ssid.Ssid);
+
+        //Add mode
+        iwe.cmd = SIOCGIWMODE;
+        iwe.u.mode = Adapter->ScanTable[i].InfrastructureMode + 1;
+        iwe.len = IW_EV_UINT_LEN;
+        current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, iwe.len);
+
+        //frequency
+        iwe.cmd = SIOCGIWFREQ;
+        iwe.u.freq.m = (long) cfp->Freq * 100000;
+        iwe.u.freq.e = 1;
+        iwe.len = IW_EV_FREQ_LEN;
+        current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, iwe.len);
+
+        /* Add quality statistics */
+        iwe.cmd = IWEVQUAL;
+        iwe.u.qual.level = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+        iwe.u.qual.qual = 0;
+        if (Adapter->NF[TYPE_BEACON][TYPE_NOAVG] == 0) {
+            iwe.u.qual.noise = MRVDRV_NF_DEFAULT_SCAN_VALUE;
+        } else {
+            iwe.u.qual.noise = CAL_NF(Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+        }
+        if ((Adapter->InfrastructureMode == Wlan802_11IBSS) &&
+            !SSIDcmp(&Adapter->CurBssParams.ssid, &Adapter->ScanTable[i].Ssid)
+            && Adapter->AdhocCreate) {
+            ret = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_802_11_RSSI,
+                                        0, HostCmd_OPTION_WAITFORRSP, 0,
+                                        NULL);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+            iwe.u.qual.level =
+                CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+                         Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+        }
+
+        iwe.len = IW_EV_QUAL_LEN;
+        current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, iwe.len);
+
+        /* Add encryption capability */
+        iwe.cmd = SIOCGIWENCODE;
+        if (Adapter->ScanTable[i].Privacy) {
+            iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+        } else {
+            iwe.u.data.flags = IW_ENCODE_DISABLED;
+        }
+        iwe.u.data.length = 0;
+        iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+        current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe,
+                                          Adapter->ScanTable->Ssid.Ssid);
+
+        current_val = current_ev + IW_EV_LCP_LEN;
+
+        iwe.cmd = SIOCGIWRATE;
+
+        iwe.u.bitrate.fixed = 0;
+        iwe.u.bitrate.disabled = 0;
+        iwe.u.bitrate.value = 0;
+
+        /* Bit rate given in 500 kb/s units (+ 0x80) */
+        for (j = 0; j < sizeof(Adapter->ScanTable[i].SupportedRates); j++) {
+            if (Adapter->ScanTable[i].SupportedRates[j] == 0) {
+                break;
+            }
+            rate = (Adapter->ScanTable[i].SupportedRates[j] & 0x7F) * 500000;
+            if (rate > iwe.u.bitrate.value) {
+                iwe.u.bitrate.value = rate;
+            }
+
+            iwe.u.bitrate.value = (Adapter->ScanTable[i].SupportedRates[j]
+                                   & 0x7f) * 500000;
+            iwe.len = IW_EV_PARAM_LEN;
+            current_ev =
+                iwe_stream_add_value(current_ev, current_val, end_buf, &iwe,
+                                     iwe.len);
+
+        }
+        if ((Adapter->ScanTable[i].InfrastructureMode == Wlan802_11IBSS) &&
+            !SSIDcmp(&Adapter->CurBssParams.ssid, &Adapter->ScanTable[i].Ssid)
+            && Adapter->AdhocCreate) {
+            iwe.u.bitrate.value = 22 * 500000;
+        }
+        iwe.len = IW_EV_PARAM_LEN;
+        current_ev = iwe_stream_add_value(current_ev, current_val, end_buf,
+                                          &iwe, iwe.len);
+
+        /* Add new value to event */
+        current_val = current_ev + IW_EV_LCP_LEN;
+
+        if (Adapter->ScanTable[i].wpa2_supplicant.Wpa_ie[0] == WPA2_IE) {
+            memset(&iwe, 0, sizeof(iwe));
+            memset(buf, 0, sizeof(buf));
+            ptr = buf;
+            ptr += sprintf(ptr, "rsn_ie=");
+
+            for (j = 0;
+                 j < Adapter->ScanTable[i].wpa2_supplicant.Wpa_ie_len; j++) {
+                ptr += sprintf(ptr, "%02x", (Adapter->ScanTable[i]
+                                             .wpa2_supplicant.Wpa_ie[j]));
+            }
+            iwe.u.data.length = strlen(buf);
+
+            PRINTM(INFO, "iwe.u.data.length %d\n", iwe.u.data.length);
+            PRINTM(INFO, "WPA2 BUF: %s \n", buf);
+
+            iwe.cmd = IWEVCUSTOM;
+            iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+            current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+        }
+        if (Adapter->ScanTable[i].wpa_supplicant.Wpa_ie[0] == WPA_IE) {
+            memset(&iwe, 0, sizeof(iwe));
+            memset(buf, 0, sizeof(buf));
+            ptr = buf;
+            ptr += sprintf(ptr, "wpa_ie=");
+
+            for (j = 0;
+                 j < Adapter->ScanTable[i].wpa_supplicant.Wpa_ie_len; j++) {
+                ptr += sprintf(ptr, "%02x",
+                               Adapter->ScanTable[i].wpa_supplicant.
+                               Wpa_ie[j]);
+            }
+            iwe.u.data.length = strlen(buf);
+
+            PRINTM(INFO, "iwe.u.data.length %d\n", iwe.u.data.length);
+            PRINTM(INFO, "WPA BUF: %s \n", buf);
+
+            iwe.cmd = IWEVCUSTOM;
+            iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+            current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+        }
+
+#if WIRELESS_EXT > 14
+
+        if (Adapter->ScanTable[i].extra_ie != 0) {
+            memset(&iwe, 0, sizeof(iwe));
+            memset(buf, 0, sizeof(buf));
+            ptr = buf;
+            ptr += sprintf(ptr, "extra_ie");
+            iwe.u.data.length = strlen(buf);
+
+            PRINTM(INFO, "iwe.u.data.length %d\n", iwe.u.data.length);
+            PRINTM(INFO, "BUF: %s \n", buf);
+
+            iwe.cmd = IWEVCUSTOM;
+            iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+            current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+        }
+#endif
+
+        current_val = current_ev + IW_EV_LCP_LEN;
+
+        /*
+         * Check if we added any event
+         */
+        if ((current_val - current_ev) > IW_EV_LCP_LEN)
+            current_ev = current_val;
+    }
+
+    dwrq->length = (current_ev - extra);
+    dwrq->flags = 0;
+
+    LEAVE();
+#endif
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Retrieve the scan response/beacon table
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_scan_table_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter;
+    BSSDescriptor_t *pBssInfo;
+    wlan_ioctl_get_scan_table_info *pRspInfo;
+    wlan_ioctl_get_scan_table_entry *pRspEntry;
+    wlan_ioctl_get_scan_table_entry tmpRspEntry;
+    int retcode;
+    int retlen;
+    int spaceNeeded;
+    int spaceLeft;
+    u8 *pCurrent;
+    u8 *pBufferEnd;
+    u32 scanStart;
+    u32 numScansDone;
+    int variableSize;
+
+    const int fixedSize = (sizeof(tmpRspEntry.fixedFieldLength)
+                           + sizeof(tmpRspEntry.fixedFields)
+                           + sizeof(tmpRspEntry.bssInfoLength));
+
+    retlen = 0;
+
+    if (copy_from_user(&scanStart,
+                       wrq->u.data.pointer, sizeof(scanStart)) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "GetScanTable: copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+
+        PRINTM(INFO, "GetScanTable: scanStart req = %d\n", scanStart);
+        PRINTM(INFO, "GetScanTable: length avail = %d\n", wrq->u.data.length);
+
+        Adapter = priv->adapter;
+
+        numScansDone = 0;
+
+        pRspInfo = (wlan_ioctl_get_scan_table_info *) wrq->u.data.pointer;
+        pCurrent = pRspInfo->scan_table_entry_buffer;
+        pBufferEnd = wrq->u.data.pointer + wrq->u.data.length - 1;
+        spaceLeft = pBufferEnd - pCurrent;
+
+        while (spaceLeft &&
+               scanStart + numScansDone < Adapter->NumInScanTable) {
+
+            pBssInfo = &Adapter->ScanTable[scanStart + numScansDone];
+
+            /* The variable size returned is the stored beacon size */
+            variableSize = pBssInfo->beaconBufSize;
+
+            /* If we stored a beacon and its size was zero, set the variable
+             *  size return value to the size of the brief scan response 
+             *  wlan_scan_create_brief_scan_table creates.  Also used if 
+             *  we are not configured to store beacons in the first place
+             */
+            if (variableSize == 0) {
+                variableSize = pBssInfo->Ssid.SsidLength + 2;
+                variableSize += (sizeof(pBssInfo->BeaconPeriod)
+                                 + sizeof(pBssInfo->TimeStamp)
+                                 + sizeof(pBssInfo->Cap));
+            }
+
+            spaceNeeded = fixedSize + variableSize;
+            spaceLeft = pBufferEnd - pCurrent;
+
+            PRINTM(INFO, "GetScanTable: bss[%d], need(%d), left(%d)\n",
+                   scanStart + numScansDone, spaceNeeded, spaceLeft);
+
+            if (spaceNeeded >= spaceLeft) {
+                spaceLeft = 0;
+            } else {
+
+                PRINTM(INFO, "GetScanTable: bss[%d] = "
+                       "%02x:%02x:%02x:%02x:%02x:%02x\n",
+                       scanStart + numScansDone,
+                       pBssInfo->MacAddress[0], pBssInfo->MacAddress[1],
+                       pBssInfo->MacAddress[2], pBssInfo->MacAddress[3],
+                       pBssInfo->MacAddress[4], pBssInfo->MacAddress[5]);
+
+                tmpRspEntry.fixedFieldLength = sizeof(pRspEntry->fixedFields);
+
+                memcpy(tmpRspEntry.fixedFields.bssid,
+                       pBssInfo->MacAddress,
+                       sizeof(pRspEntry->fixedFields.bssid));
+
+                tmpRspEntry.fixedFields.rssi = pBssInfo->Rssi;
+                tmpRspEntry.fixedFields.channel = pBssInfo->Channel;
+                tmpRspEntry.fixedFields.networkTSF = pBssInfo->networkTSF;
+                tmpRspEntry.bssInfoLength = variableSize;
+
+                /*
+                 *  Copy fixed fields to user space
+                 */
+                if (copy_to_user(pCurrent, &tmpRspEntry, fixedSize)) {
+                    PRINTM(INFO, "Copy to user failed\n");
+                    return -EFAULT;
+                }
+
+                pCurrent += fixedSize;
+
+                if (pBssInfo->pBeaconBuf) {
+                    /*
+                     *  Copy variable length elements to user space
+                     */
+                    if (copy_to_user(pCurrent, pBssInfo->pBeaconBuf,
+                                     pBssInfo->beaconBufSize)) {
+                        PRINTM(INFO, "Copy to user failed\n");
+                        return -EFAULT;
+                    }
+
+                    pCurrent += pBssInfo->beaconBufSize;
+                } else {
+                    wlan_scan_create_brief_scan_table(&pCurrent, pBssInfo);
+                }
+
+                numScansDone++;
+
+            }                   /* else */
+
+        }                       /* while (spaceLeft && ... ) */
+
+        pRspInfo->scanNumber = numScansDone;
+        retlen = pCurrent - (u8 *) wrq->u.data.pointer;
+
+        retcode = WLAN_STATUS_SUCCESS;
+    }
+
+    wrq->u.data.length = retlen;
+
+    return retcode;
+}
+
+/**
+ *  @brief Private IOCTL entry to perform an app configured immediate scan
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure containing the
+ *                      wlan_ioctl_user_scan_cfg requesting this scan
+ *
+ *  @return             0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_set_user_scan_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_user_scan_cfg scanReq;
+    int retcode;
+    union iwreq_data wrqu;
+
+    if (copy_from_user(&scanReq,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length, sizeof(scanReq))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "SetUserScan: copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        retcode = wlan_scan_networks(priv, &scanReq);
+
+        memset(&wrqu, 0x00, sizeof(union iwreq_data));
+        wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu, NULL);
+    }
+
+    return retcode;
+}
+
+/**
+ *  @brief Prepare a scan command to be sent to the firmware
+ *
+ *  Use the wlan_scan_cmd_config sent to the command processing module in
+ *   the PrepareAndSendCommand to configure a HostCmd_DS_802_11_SCAN command
+ *   struct to send to firmware.
+ *
+ *  The fixed fields specifying the BSS type and BSSID filters as well as a
+ *   variable number/length of TLVs are sent in the command to firmware.
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param cmd        A pointer to HostCmd_DS_COMMAND structure to be sent to
+ *                    firmware with the HostCmd_DS_801_11_SCAN structure
+ *  @param pdata_buf  Void pointer cast of a wlan_scan_cmd_config struct used
+ *                    to set the fields/TLVs for the command sent to firmware
+ *
+ *  @return           WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ *
+ *  @sa wlan_scan_create_channel_list
+ */
+int
+wlan_cmd_802_11_scan(wlan_private * priv,
+                     HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    HostCmd_DS_802_11_SCAN *pScan = &cmd->params.scan;
+    wlan_scan_cmd_config *pScanCfg;
+
+    ENTER();
+
+    pScanCfg = (wlan_scan_cmd_config *) pdata_buf;
+
+    /* Set fixed field variables in scan command */
+    pScan->BSSType = pScanCfg->bssType;
+    memcpy(pScan->BSSID, pScanCfg->specificBSSID, sizeof(pScan->BSSID));
+    memcpy(pScan->TlvBuffer, pScanCfg->tlvBuffer, pScanCfg->tlvBufferLen);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SCAN);
+
+    /* Size is equal to the sizeof(fixed portions) + the TLV len + header */
+    cmd->Size = wlan_cpu_to_le16(sizeof(pScan->BSSType)
+                                 + sizeof(pScan->BSSID)
+                                 + pScanCfg->tlvBufferLen + S_DS_GEN);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Store a beacon or probe response for a BSS returned in the scan
+ *  
+ *  Store a new scan response or an update for a previous scan response.  New
+ *    entries need to verify that they do not exceed the total amount of 
+ *    memory allocated for the table.
+
+ *  Replacement entries need to take into consideration the amount of space 
+ *    currently allocated for the beacon/probe response and adjust the entry
+ *    as needed.  
+ *
+ *  A small amount of extra pad (SCAN_BEACON_ENTRY_PAD) is generally reserved
+ *    for an entry in case it is a beacon since a probe response for the
+ *    network will by larger per the standard.  This helps to reduce the 
+ *    amount of memory copying to fit a new probe response into an entry 
+ *    already occupied by a network's previously stored beacon.
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param beaconIdx  Index in the scan table to store this entry; may be
+ *                    replacing an older duplicate entry for this BSS
+ *  @param numInTable Number of entries currently in the table
+ *  @param pNewBeacon Pointer to the new beacon/probe response to save
+ *
+ *  @return           void
+ */
+void
+wlan_ret_802_11_scan_store_beacon(wlan_private * priv,
+                                  int beaconIdx,
+                                  int numInTable,
+                                  BSSDescriptor_t * pNewBeacon)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u8 *pBcnStore;
+    int newBcnSize;
+    int oldBcnSize;
+    int bcnSpace;
+    int adjIdx;
+
+    if (Adapter->ScanTable[beaconIdx].pBeaconBuf != NULL) {
+
+        newBcnSize = pNewBeacon->beaconBufSize;
+        oldBcnSize = Adapter->ScanTable[beaconIdx].beaconBufSize;
+        bcnSpace = Adapter->ScanTable[beaconIdx].beaconBufSizeMax;
+        pBcnStore = Adapter->ScanTable[beaconIdx].pBeaconBuf;
+
+        /* Set the max to be the same as current entry unless changed below */
+        pNewBeacon->beaconBufSizeMax = bcnSpace;
+
+        if (newBcnSize == oldBcnSize) {
+            /*
+             * Beacon is the same size as the previous entry.
+             *   Replace the previous contents with the scan result
+             */
+            memcpy(pBcnStore,
+                   pNewBeacon->pBeaconBuf, pNewBeacon->beaconBufSize);
+
+        } else if (newBcnSize <= bcnSpace) {
+            /*
+             * New beacon size will fit in the amount of space
+             *   we have previously allocated for it
+             */
+
+            /* Copy the new beacon buffer entry over the old one */
+            memcpy(pBcnStore, pNewBeacon->pBeaconBuf, newBcnSize);
+
+            /* If the old beacon size was less than the maximum
+             *  we had alloted for the entry, and the new entry
+             *  is even smaller, reset the max size to the old beacon
+             *  entry and compress the storage space (leaving a new
+             *  pad space of (oldBcnSize - newBcnSize).
+             */
+            if (oldBcnSize < bcnSpace && newBcnSize != bcnSpace) {
+                /*
+                 * Old Beacon size is smaller than the alloted storage size.
+                 *   Shrink the alloted storage space.
+                 */
+                PRINTM(INFO, "AppControl: Smaller Duplicate Beacon (%d), "
+                       "old = %d, new = %d, space = %d, left = %d\n",
+                       beaconIdx, oldBcnSize, newBcnSize, bcnSpace,
+                       (sizeof(Adapter->beaconBuffer) -
+                        (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+
+                /* memmove (since the memory overlaps) the data
+                 *  after the beacon we just stored to the end of
+                 *  the current beacon.  This cleans up any unused
+                 *  space the old larger beacon was using in the buffer
+                 */
+                memmove(pBcnStore + oldBcnSize,
+                        pBcnStore + bcnSpace,
+                        Adapter->pBeaconBufEnd - (pBcnStore + bcnSpace));
+
+                /* Decrement the end pointer by the difference between
+                 *  the old larger size and the new smaller size since
+                 *  we are using less space due to the new beacon being
+                 *  smaller
+                 */
+                Adapter->pBeaconBufEnd -= (bcnSpace - oldBcnSize);
+
+                /* Set the maximum storage size to the old beacon size */
+                pNewBeacon->beaconBufSizeMax = oldBcnSize;
+
+                /* Adjust beacon buffer pointers that are past the current */
+                for (adjIdx = 0; adjIdx < numInTable; adjIdx++) {
+                    if (Adapter->ScanTable[adjIdx].pBeaconBuf > pBcnStore) {
+                        Adapter->ScanTable[adjIdx].pBeaconBuf
+                            -= (bcnSpace - oldBcnSize);
+                    }
+                }
+            }
+        } else if (Adapter->pBeaconBufEnd + (newBcnSize - bcnSpace)
+                   < (Adapter->beaconBuffer + sizeof(Adapter->beaconBuffer))) {
+            /*
+             * Beacon is larger than space previously allocated (bcnSpace)
+             *   and there is enough space left in the beaconBuffer to store
+             *   the additional data
+             */
+            PRINTM(INFO, "AppControl: Larger Duplicate Beacon (%d), "
+                   "old = %d, new = %d, space = %d, left = %d\n",
+                   beaconIdx, oldBcnSize, newBcnSize, bcnSpace,
+                   (sizeof(Adapter->beaconBuffer) -
+                    (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+
+            /* memmove (since the memory overlaps) the data
+             *  after the beacon we just stored to the end of
+             *  the current beacon.  This moves the data for
+             *  the beacons after this further in memory to
+             *  make space for the new larger beacon we are
+             *  about to copy in.
+             */
+            memmove(pBcnStore + newBcnSize,
+                    pBcnStore + bcnSpace,
+                    Adapter->pBeaconBufEnd - (pBcnStore + bcnSpace));
+
+            /* Copy the new beacon buffer entry over the old one */
+            memcpy(pBcnStore, pNewBeacon->pBeaconBuf, newBcnSize);
+
+            /* Move the beacon end pointer by the amount of new
+             *  beacon data we are adding
+             */
+            Adapter->pBeaconBufEnd += (newBcnSize - bcnSpace);
+
+            /* This entry is bigger than the alloted max space
+             *  previously reserved.  Increase the max space to
+             *  be equal to the new beacon size
+             */
+            pNewBeacon->beaconBufSizeMax = newBcnSize;
+
+            /* Adjust beacon buffer pointers that are past the current */
+            for (adjIdx = 0; adjIdx < numInTable; adjIdx++) {
+                if (Adapter->ScanTable[adjIdx].pBeaconBuf > pBcnStore) {
+                    Adapter->ScanTable[adjIdx].pBeaconBuf
+                        += (newBcnSize - bcnSpace);
+                }
+            }
+        } else {
+            /*
+             * Beacon is larger than the previously allocated space, but
+             *   there is not enough free space to store the additional data
+             */
+            PRINTM(INFO,
+                   "AppControl: Failed: Larger Duplicate Beacon (%d),"
+                   " old = %d, new = %d, space = %d, left = %d\n",
+                   beaconIdx, oldBcnSize, newBcnSize, bcnSpace,
+                   (sizeof(Adapter->beaconBuffer) -
+                    (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+
+            /* Storage failure, keep old beacon intact */
+            pNewBeacon->beaconBufSize = oldBcnSize;
+        }
+
+        /* Point the new entry to its permanent storage space */
+        pNewBeacon->pBeaconBuf = pBcnStore;
+
+    } else {
+        /* No existing beacon data exists for this entry, check to see
+         *   if we can fit it in the remaining space
+         */
+        if (Adapter->pBeaconBufEnd + pNewBeacon->beaconBufSize +
+            SCAN_BEACON_ENTRY_PAD < (Adapter->beaconBuffer +
+                                     sizeof(Adapter->beaconBuffer))) {
+
+            /* Copy the beacon buffer data from the local entry to the
+             *   adapter dev struct buffer space used to store the raw
+             *   beacon data for each entry in the scan table
+             */
+            memcpy(Adapter->pBeaconBufEnd, pNewBeacon->pBeaconBuf,
+                   pNewBeacon->beaconBufSize);
+
+            /* Update the beacon ptr to point to the table save area */
+            pNewBeacon->pBeaconBuf = Adapter->pBeaconBufEnd;
+            pNewBeacon->beaconBufSizeMax = (pNewBeacon->beaconBufSize
+                                            + SCAN_BEACON_ENTRY_PAD);
+
+            /* Increment the end pointer by the size reserved */
+            Adapter->pBeaconBufEnd += pNewBeacon->beaconBufSizeMax;
+
+            PRINTM(INFO, "AppControl: Beacon[%02d] sz=%03d,"
+                   " used = %04d, left = %04d\n",
+                   beaconIdx,
+                   pNewBeacon->beaconBufSize,
+                   (Adapter->pBeaconBufEnd - Adapter->beaconBuffer),
+                   (sizeof(Adapter->beaconBuffer) -
+                    (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+        } else {
+            /*
+             * No space for new beacon
+             */
+            PRINTM(INFO, "AppControl: No space beacon (%d): "
+                   "%02x:%02x:%02x:%02x:%02x:%02x; sz=%03d, left=%03d\n",
+                   beaconIdx,
+                   pNewBeacon->MacAddress[0], pNewBeacon->MacAddress[1],
+                   pNewBeacon->MacAddress[2], pNewBeacon->MacAddress[3],
+                   pNewBeacon->MacAddress[4], pNewBeacon->MacAddress[5],
+                   pNewBeacon->beaconBufSize,
+                   (sizeof(Adapter->beaconBuffer) -
+                    (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+
+            /* Storage failure; clear storage records for this bcn */
+            pNewBeacon->pBeaconBuf = NULL;
+            pNewBeacon->beaconBufSize = 0;
+            pNewBeacon->beaconBufSizeMax = 0;
+        }
+    }
+}
+
+/**
+ *  @brief This function handles the command response of scan
+ *
+ *   The response buffer for the scan command has the following
+ *      memory layout:
+ *
+ *     .-----------------------------------------------------------.
+ *     |  Header (4 * sizeof(u16)):  Standard command response hdr |
+ *     .-----------------------------------------------------------.
+ *     |  BufSize (u16) : sizeof the BSS Description data          |
+ *     .-----------------------------------------------------------.
+ *     |  NumOfSet (u8) : Number of BSS Descs returned             |
+ *     .-----------------------------------------------------------.
+ *     |  BSSDescription data (variable, size given in BufSize)    |
+ *     .-----------------------------------------------------------.
+ *     |  TLV data (variable, size calculated using Header->Size,  |
+ *     |            BufSize and sizeof the fixed fields above)     |
+ *     .-----------------------------------------------------------.
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_scan(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_SCAN_RSP *pScan;
+    BSSDescriptor_t newBssEntry;
+    MrvlIEtypes_Data_t *pTlv;
+    MrvlIEtypes_TsfTimestamp_t *pTsfTlv;
+    u8 *pBssInfo;
+    u16 scanRespSize;
+    int bytesLeft;
+    int numInTable;
+    int bssIdx;
+    int idx;
+    int tlvBufSize;
+    u64 tsfVal;
+
+    ENTER();
+
+    if (resp->Command == HostCmd_RET_802_11_BG_SCAN_QUERY) {
+        pScan = &resp->params.bgscanqueryresp.scanresp;
+    } else {
+        pScan = &resp->params.scanresp;
+    }
+
+    if (pScan->NumberOfSets > MRVDRV_MAX_BSSID_LIST) {
+        PRINTM(INFO, "SCAN_RESP: Invalid number of AP returned (%d)!!\n",
+               pScan->NumberOfSets);
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    bytesLeft = wlan_le16_to_cpu(pScan->BSSDescriptSize);
+    PRINTM(INFO, "SCAN_RESP: BSSDescriptSize %d\n", bytesLeft);
+
+    scanRespSize = wlan_le16_to_cpu(resp->Size);
+    PRINTM(CMND, "SCAN_RESP: returned %d APs before parsing\n",
+           pScan->NumberOfSets);
+
+    numInTable = Adapter->NumInScanTable;
+    pBssInfo = pScan->BssDescAndTlvBuffer;
+
+    /* The size of the TLV buffer is equal to the entire command response
+     *   size (scanRespSize) minus the fixed fields (sizeof()'s), the
+     *   BSS Descriptions (BSSDescriptSize as bytesLef) and the command
+     *   response header (S_DS_GEN)
+     */
+    tlvBufSize = scanRespSize - (bytesLeft + sizeof(pScan->BSSDescriptSize)
+                                 + sizeof(pScan->NumberOfSets)
+                                 + S_DS_GEN);
+
+    pTlv = (MrvlIEtypes_Data_t *) (pScan->BssDescAndTlvBuffer + bytesLeft);
+
+    /* Search the TLV buffer space in the scan response for any valid TLVs */
+    wlan_ret_802_11_scan_get_tlv_ptrs(pTlv, tlvBufSize, &pTsfTlv);
+
+    /*
+     *  Process each scan response returned (pScan->NumberOfSets).  Save
+     *    the information in the newBssEntry and then insert into the
+     *    driver scan table either as an update to an existing entry
+     *    or as an addition at the end of the table
+     */
+    for (idx = 0; idx < pScan->NumberOfSets && bytesLeft; idx++) {
+        /* Zero out the newBssEntry we are about to store info in */
+        memset(&newBssEntry, 0x00, sizeof(newBssEntry));
+
+        /* Process the data fields and IEs returned for this BSS */
+        if ((InterpretBSSDescriptionWithIE(&newBssEntry,
+                                           &pBssInfo,
+                                           &bytesLeft) == WLAN_STATUS_SUCCESS)
+            && CHECK_SSID_IS_VALID(&newBssEntry.Ssid)) {
+
+            PRINTM(INFO, "SCAN_RESP: BSSID = %02x:%02x:%02x:%02x:%02x:%02x\n",
+                   newBssEntry.MacAddress[0], newBssEntry.MacAddress[1],
+                   newBssEntry.MacAddress[2], newBssEntry.MacAddress[3],
+                   newBssEntry.MacAddress[4], newBssEntry.MacAddress[5]);
+
+            /*
+             * Search the scan table for the same bssid
+             */
+            for (bssIdx = 0; bssIdx < numInTable; bssIdx++) {
+                if (memcmp(newBssEntry.MacAddress,
+                           Adapter->ScanTable[bssIdx].MacAddress,
+                           sizeof(newBssEntry.MacAddress)) == 0) {
+                    /*
+                     * If the SSID matches as well, it is a duplicate of
+                     *   this entry.  Keep the bssIdx set to this
+                     *   entry so we replace the old contents in the table
+                     */
+                    if ((newBssEntry.Ssid.SsidLength ==
+                         Adapter->ScanTable[bssIdx].Ssid.SsidLength)
+                        && (memcmp(newBssEntry.Ssid.Ssid,
+                                   Adapter->ScanTable[bssIdx].Ssid.Ssid,
+                                   newBssEntry.Ssid.SsidLength) == 0)) {
+                        PRINTM(INFO, "SCAN_RESP: Duplicate of index: %d\n",
+                               bssIdx);
+                        break;
+                    }
+                }
+            }
+            /*
+             * If the bssIdx is equal to the number of entries in the table,
+             *   the new entry was not a duplicate; append it to the scan
+             *   table
+             */
+            if (bssIdx == numInTable) {
+                /* Range check the bssIdx, keep it limited to the last entry */
+                if (bssIdx == MRVDRV_MAX_BSSID_LIST) {
+                    bssIdx--;
+                } else {
+                    numInTable++;
+                }
+            }
+
+            /*
+             * Save the beacon/probe response returned for later application
+             *   retrieval.  Duplicate beacon/probe responses are updated if
+             *   possible
+             */
+            wlan_ret_802_11_scan_store_beacon(priv,
+                                              bssIdx,
+                                              numInTable, &newBssEntry);
+            /*
+             * If the TSF TLV was appended to the scan results, save the
+             *   this entries TSF value in the networkTSF field.  The
+             *   networkTSF is the firmware's TSF value at the time the
+             *   beacon or probe response was received.
+             */
+            if (pTsfTlv) {
+                memcpy(&tsfVal, &pTsfTlv->tsfTable[idx], sizeof(tsfVal));
+                tsfVal = wlan_le64_to_cpu(tsfVal);
+
+                memcpy(&newBssEntry.networkTSF,
+                       &tsfVal, sizeof(newBssEntry.networkTSF));
+            }
+
+            /* Copy the locally created newBssEntry to the scan table */
+            memcpy(&Adapter->ScanTable[bssIdx],
+                   &newBssEntry, sizeof(Adapter->ScanTable[bssIdx]));
+
+        } else {
+
+            /* Error parsing/interpreting the scan response, skipped */
+            PRINTM(INFO, "SCAN_RESP: "
+                   "InterpretBSSDescriptionWithIE returned ERROR\n");
+        }
+    }
+
+    PRINTM(CMND, "SCAN_RESP: Scanned %2d APs, %d valid, %d total\n",
+           pScan->NumberOfSets, numInTable - Adapter->NumInScanTable,
+           numInTable);
+
+    /* Update the total number of BSSIDs in the scan table */
+    Adapter->NumInScanTable = numInTable;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief scan network with specific ssid
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param req          A pointer to ifreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_extscan_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    WLAN_802_11_SSID Ext_Scan_SSID;
+    wlan_ioctl_user_scan_cfg scanCfg;
+    union iwreq_data wrqu;
+
+    ENTER();
+
+    if (copy_from_user(&Ext_Scan_SSID, req->ifr_data, sizeof(Ext_Scan_SSID))) {
+        PRINTM(INFO, "copy of SSID for ext scan from user failed \n");
+        LEAVE();
+        return -EFAULT;
+    }
+#ifdef REASSOCIATION
+    if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+        PRINTM(WARN, "Acquire semaphore error, wlan_extscan_ioctl\n");
+        return -EBUSY;
+    }
+#endif
+
+    memset(&scanCfg, 0x00, sizeof(scanCfg));
+
+    memcpy(scanCfg.specificSSID, Ext_Scan_SSID.Ssid,
+           Ext_Scan_SSID.SsidLength);
+
+    wlan_scan_networks(priv, &scanCfg);
+
+    memset(&wrqu, 0, sizeof(union iwreq_data));
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu, NULL);
+
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+
+    if (Adapter->SurpriseRemoved)
+        return WLAN_STATUS_FAILURE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function sends BG_SCAN query command to firmware.
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sendBgScanQueryCmd(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    /* Clear the previous scan result */
+    memset(Adapter->ScanTable, 0x00,
+           sizeof(BSSDescriptor_t) * MRVDRV_MAX_BSSID_LIST);
+    Adapter->NumInScanTable = 0;
+    Adapter->pBeaconBufEnd = Adapter->beaconBuffer;
+    return PrepareAndSendCommand(priv, HostCmd_CMD_802_11_BG_SCAN_QUERY,
+                                 0, 0, 0, NULL);
+}
+
+/**
+ *  @brief Enable/Disable BG Scan
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param enable       TRUE-enable, FALSE-disable
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_bg_scan_enable(wlan_private * priv, BOOLEAN enable)
+{
+    int ret;
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_BG_SCAN_CONFIG,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, &enable);
+    return ret;
+}
+
+/**
+ *  @brief config BGSCAN parameter
+
+ *  @param priv         A pointer to wlan_private structure
+ *  @param req          A pointer to ifreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_do_bg_scan_config_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 action;
+    u8 *buf;
+
+    ENTER();
+
+    action = *((u8 *) req->ifr_data + SKIP_CMDNUM + SKIP_SIZE);
+    PRINTM(INFO, "Action = %d\n", action);
+
+    switch (action) {
+    case HostCmd_ACT_GEN_GET:
+        buf = kmalloc(Adapter->bgScanConfigSize + SKIP_SIZE, GFP_KERNEL);
+        if (!buf) {
+            PRINTM(MSG, "kmalloc no memory !!\n");
+            return -ENOMEM;
+        }
+        memcpy(buf, &Adapter->bgScanConfigSize, SKIP_SIZE);
+        memcpy(buf + SKIP_TYPE_SIZE, Adapter->bgScanConfig,
+               Adapter->bgScanConfigSize);
+
+        if (copy_to_user(req->ifr_data, buf,
+                         Adapter->bgScanConfigSize + SKIP_SIZE)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            kfree(buf);
+            return -EFAULT;
+        }
+
+        kfree(buf);
+
+        break;
+    case HostCmd_ACT_GEN_SET:
+        Adapter->bgScanConfigSize = *(u16 *) (req->ifr_data + SKIP_CMDNUM);
+        PRINTM(INFO, "bgscanConfigSize = %d\n", Adapter->bgScanConfigSize);
+
+        if (Adapter->bgScanConfig)
+            kfree(Adapter->bgScanConfig);
+
+        if (!(Adapter->bgScanConfig =
+              kmalloc(Adapter->bgScanConfigSize, GFP_KERNEL))) {
+            PRINTM(MSG, "kmalloc no memory !!\n");
+            Adapter->bgScanConfigSize = 0;
+            return -ENOMEM;
+        }
+
+        HEXDUMP("treq", req->ifr_data + SKIP_CMDNUM + SKIP_SIZE,
+                Adapter->bgScanConfigSize);
+
+        if (copy_from_user(Adapter->bgScanConfig, req->ifr_data +
+                           SKIP_CMDNUM + SKIP_SIZE,
+                           Adapter->bgScanConfigSize)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        break;
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/**
+ *  @brief This function prepares command of bg_scan_config.
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf    A pointer to data buffer
+ *
+ *  @return             WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_bg_scan_config(wlan_private * priv,
+                               HostCmd_DS_COMMAND * cmd,
+                               int cmd_action, void *pdata_buf)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgcfg = &cmd->params.bgscancfg;
+    BOOLEAN enable = *((BOOLEAN *) pdata_buf);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_CONFIG);
+    cmd->Size =
+        wlan_cpu_to_le16((priv->adapter->bgScanConfigSize) + S_DS_GEN);
+
+    Adapter->bgScanConfig->Enable = enable;
+
+    memcpy(bgcfg, Adapter->bgScanConfig, Adapter->bgScanConfigSize);
+
+    bgcfg->Action = wlan_cpu_to_le16(bgcfg->Action);
+    bgcfg->ScanInterval = wlan_cpu_to_le32(bgcfg->ScanInterval);
+    bgcfg->StoreCondition = wlan_cpu_to_le32(bgcfg->StoreCondition);
+    bgcfg->ReportConditions = wlan_cpu_to_le32(bgcfg->ReportConditions);
+    bgcfg->MaxScanResults = wlan_cpu_to_le16(bgcfg->MaxScanResults);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of bg_scan_query.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param cmd      A pointer to HostCmd_DS_COMMAND structure
+ *
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_bg_scan_query(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    HostCmd_DS_802_11_BG_SCAN_QUERY *bgquery = &cmd->params.bgscanquery;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_QUERY);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_BG_SCAN_QUERY) + S_DS_GEN);
+
+    bgquery->Flush = 1;
+
+    return WLAN_STATUS_SUCCESS;
+}
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_scan.h b/drivers/net/wireless/8686_wlan/wlan/wlan_scan.h
new file mode 100644
index 0000000..6033ae7
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_scan.h
@@ -0,0 +1,366 @@
+/** @file wlan_scan.h
+ *
+ *  @brief Interface for the wlan network scan routines
+ *
+ *  Driver interface functions and type declarations for the scan module
+ *    implemented in wlan_scan.c.
+ *
+ *  (c) Copyright © 2003-2006, Marvell International Ltd.  
+ *   
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change Log:
+    01/11/06: Initial revision. New scan code, relocate related functions
+
+************************************************************/
+
+#ifndef _WLAN_SCAN_H
+#define _WLAN_SCAN_H
+
+/**
+ *  @brief Maximum number of channels that can be sent in a setuserscan ioctl
+ *
+ *  @sa wlan_ioctl_user_scan_cfg
+ */
+#define WLAN_IOCTL_USER_SCAN_CHAN_MAX  50
+
+//! Infrastructure BSS scan type in wlan_scan_cmd_config
+#define WLAN_SCAN_BSS_TYPE_BSS         1
+
+//! Adhoc BSS scan type in wlan_scan_cmd_config
+#define WLAN_SCAN_BSS_TYPE_IBSS        2
+
+//! Adhoc or Infrastructure BSS scan type in wlan_scan_cmd_config, no filter
+#define WLAN_SCAN_BSS_TYPE_ANY         3
+
+/** @brief Maximum buffer space for beacons retrieved from scan responses
+ *    4000 has successfully stored up to 40 beacons
+ *    6000 has successfully stored the max scan results (max 64)
+ */
+#define MAX_SCAN_BEACON_BUFFER         6000
+
+/**
+ * @brief Buffer pad space for newly allocated beacons/probe responses
+ *
+ * Beacons are typically 6 bytes longer than an equivalent probe response.
+ *  For each scan response stored, allocate an extra byte pad at the end to
+ *  allow easy expansion to store a beacon in the same memory a probe reponse
+ *  previously contained
+ */
+#define SCAN_BEACON_ENTRY_PAD          6
+
+//! Scan time specified in the channel TLV for each channel for passive scans
+#define MRVDRV_PASSIVE_SCAN_CHAN_TIME  100
+
+//! Scan time specified in the channel TLV for each channel for active scans
+#define MRVDRV_ACTIVE_SCAN_CHAN_TIME   100
+
+//! Scan time specified in the channel TLV for each channel for specific scans
+#define MRVDRV_SPECIFIC_SCAN_CHAN_TIME 100
+
+//! Max passive scan time for each channel in milliseconds
+#define MRVDRV_MAX_PASSIVE_SCAN_CHAN_TIME   2000
+
+//! Max active scan time for each channel in milliseconds 
+#define MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME    500
+
+/**
+ * Max total scan time in milliseconds
+ * The total scan time should be less than scan command timeout value (10s)
+ */
+#define MRVDRV_MAX_TOTAL_SCAN_TIME     (MRVDRV_TIMER_10S - MRVDRV_TIMER_1S)
+
+/**
+ * @brief Structure used internally in the wlan driver to configure a scan.
+ *
+ * Sent to the command processing module to configure the firmware
+ *   scan command prepared by wlan_cmd_802_11_scan.
+ *
+ * @sa wlan_scan_networks
+ *
+ */
+typedef struct
+{
+    /**
+     *  @brief BSS Type to be sent in the firmware command
+     *
+     *  Field can be used to restrict the types of networks returned in the
+     *    scan.  Valid settings are:
+     *
+     *   - WLAN_SCAN_BSS_TYPE_BSS  (infrastructure)
+     *   - WLAN_SCAN_BSS_TYPE_IBSS (adhoc)
+     *   - WLAN_SCAN_BSS_TYPE_ANY  (unrestricted, adhoc and infrastructure)
+     */
+    u8 bssType;
+
+    /**
+     *  @brief Specific BSSID used to filter scan results in the firmware
+     */
+    u8 specificBSSID[MRVDRV_ETH_ADDR_LEN];
+
+    /**
+     *  @brief Length of TLVs sent in command starting at tlvBuffer
+     */
+    int tlvBufferLen;
+
+    /**
+     *  @brief SSID TLV(s) and ChanList TLVs to be sent in the firmware command
+     *
+     *  @sa TLV_TYPE_CHANLIST, MrvlIEtypes_ChanListParamSet_t
+     *  @sa TLV_TYPE_SSID, MrvlIEtypes_SsIdParamSet_t
+     */
+    u8 tlvBuffer[1];            //!< SSID TLV(s) and ChanList TLVs are stored here
+} wlan_scan_cmd_config;
+
+/**
+ *  @brief IOCTL channel sub-structure sent in wlan_ioctl_user_scan_cfg
+ *
+ *  Multiple instances of this structure are included in the IOCTL command
+ *   to configure a instance of a scan on the specific channel.
+ */
+typedef struct
+{
+    u8 chanNumber;              //!< Channel Number to scan
+    u8 radioType;               //!< Radio type: 'B/G' Band = 0, 'A' Band = 1
+    u8 scanType;                //!< Scan type: Active = 0, Passive = 1
+    u8 reserved;
+    u16 scanTime;               //!< Scan duration in milliseconds; if 0 default used
+} __ATTRIB_PACK__ wlan_ioctl_user_scan_chan;
+
+/**
+ *  @brief IOCTL input structure to configure an immediate scan cmd to firmware
+ *
+ *  Used in the setuserscan (WLAN_SET_USER_SCAN) private ioctl.  Specifies
+ *   a number of parameters to be used in general for the scan as well
+ *   as a channel list (wlan_ioctl_user_scan_chan) for each scan period
+ *   desired.
+ *
+ *  @sa wlan_set_user_scan_ioctl
+ */
+typedef struct
+{
+
+    /**
+     *  @brief Flag set to keep the previous scan table intact
+     *
+     *  If set, the scan results will accumulate, replacing any previous
+     *   matched entries for a BSS with the new scan data
+     */
+    u8 keepPreviousScan;        //!< Do not erase the existing scan results
+
+    /**
+     *  @brief BSS Type to be sent in the firmware command
+     *
+     *  Field can be used to restrict the types of networks returned in the
+     *    scan.  Valid settings are:
+     *
+     *   - WLAN_SCAN_BSS_TYPE_BSS  (infrastructure)
+     *   - WLAN_SCAN_BSS_TYPE_IBSS (adhoc)
+     *   - WLAN_SCAN_BSS_TYPE_ANY  (unrestricted, adhoc and infrastructure)
+     */
+    u8 bssType;
+
+    /**
+     *  @brief Configure the number of probe requests for active chan scans
+     */
+    u8 numProbes;
+
+    /**
+     *  @brief BSSID filter sent in the firmware command to limit the results
+     */
+    u8 specificBSSID[MRVDRV_ETH_ADDR_LEN];
+
+    /**
+     *  @brief SSID filter sent in the firmware command to limit the results
+     */
+    char specificSSID[MRVDRV_MAX_SSID_LENGTH + 1];
+
+    /**
+     *  @brief Variable number (fixed maximum) of channels to scan up
+     */
+    wlan_ioctl_user_scan_chan chanList[WLAN_IOCTL_USER_SCAN_CHAN_MAX];
+} __ATTRIB_PACK__ wlan_ioctl_user_scan_cfg;
+
+/**
+ *  @brief Sub-structure passed in wlan_ioctl_get_scan_table_entry for each BSS
+ *
+ *  Fixed field information returned for the scan response in the IOCTL
+ *    response.
+ */
+typedef struct
+{
+    u8 bssid[6];                //!< BSSID of this network
+    u8 channel;                 //!< Channel this beacon/probe response was detected
+    u8 rssi;                    //!< RSSI for the received packet
+    u64 networkTSF;             //!< TSF value from the firmware at packet reception
+} __ATTRIB_PACK__ wlan_ioctl_get_scan_table_fixed;
+
+/**
+ *  @brief Structure passed in the wlan_ioctl_get_scan_table_info for each
+ *         BSS returned in the WLAN_GET_SCAN_RESP IOCTL
+ *
+ *  @sa wlan_get_scan_table_ioctl
+ */
+typedef struct
+{
+
+    /**
+     *  @brief Fixed field length included in the response.
+     *
+     *  Length value is included so future fixed fields can be added to the
+     *   response without breaking backwards compatibility.  Use the length
+     *   to find the offset for the bssInfoLength field, not a sizeof() calc.
+     */
+    u32 fixedFieldLength;
+
+    /**
+     *  @brief Always present, fixed length data fields for the BSS
+     */
+    wlan_ioctl_get_scan_table_fixed fixedFields;
+
+    /**
+     *  @brief Length of the BSS Information (probe resp or beacon) that
+     *         follows starting at bssInfoBuffer
+     */
+    u32 bssInfoLength;
+
+    /**
+     *  @brief Probe response or beacon scanned for the BSS.
+     *
+     *  Field layout:
+     *   - TSF              8 octets
+     *   - Beacon Interval  2 octets
+     *   - Capability Info  2 octets
+     *
+     *   - IEEE Infomation Elements; variable number & length per 802.11 spec
+     */
+    u8 bssInfoBuffer[1];
+} __ATTRIB_PACK__ wlan_ioctl_get_scan_table_entry;
+
+/**
+ *  @brief WLAN_GET_SCAN_RESP private IOCTL struct to retrieve the scan table
+ *
+ *  @sa wlan_get_scan_table_ioctl
+ */
+typedef struct
+{
+
+    /**
+     *  - Zero based scan entry to start retrieval in command request
+     *  - Number of scans entires returned in command response
+     */
+    u32 scanNumber;
+
+     /**
+      * Buffer marker for multiple wlan_ioctl_get_scan_table_entry structures.
+      *   Each struct is padded to the nearest 32 bit boundary.
+      */
+    u8 scan_table_entry_buffer[1];
+
+} __ATTRIB_PACK__ wlan_ioctl_get_scan_table_info;
+
+/**
+ *  @brief Structure used to store information for each beacon/probe response
+ */
+typedef struct
+{
+    WLAN_802_11_MAC_ADDRESS MacAddress;
+
+    WLAN_802_11_SSID Ssid;
+
+    /* WEP encryption requirement */
+    u32 Privacy;
+
+    /* receive signal strength in dBm */
+    WLAN_802_11_RSSI Rssi;
+
+    u32 Channel;
+
+    u16 BeaconPeriod;
+
+    u32 ATIMWindow;
+
+    WLAN_802_11_NETWORK_TYPE NetworkTypeInUse;
+    WLAN_802_11_NETWORK_INFRASTRUCTURE InfrastructureMode;
+    WLAN_802_11_RATES SupportedRates;
+    WMM_PARAMETER_IE wmmIE;
+
+    int extra_ie;
+
+    u8 TimeStamp[8];            //!< TSF value included in the beacon/probe response
+    IEEEtypes_PhyParamSet_t PhyParamSet;
+    IEEEtypes_SsParamSet_t SsParamSet;
+    IEEEtypes_CapInfo_t Cap;
+    u8 DataRates[WLAN_SUPPORTED_RATES];
+
+    u64 networkTSF;             //!< TSF timestamp from the current firmware TSF
+
+    IEEEtypes_CountryInfoFullSet_t CountryInfo;
+
+    WPA_SUPPLICANT wpa_supplicant;
+    WPA_SUPPLICANT wpa2_supplicant;
+
+    u8 *pBeaconBuf;             //!< Pointer to the returned scan response
+    uint beaconBufSize;         //!< Length of the stored scan response
+    uint beaconBufSizeMax;      //!< Max allocated size for updated scan response
+
+} BSSDescriptor_t;
+
+extern int SSIDcmp(WLAN_802_11_SSID * ssid1, WLAN_802_11_SSID * ssid2);
+extern int FindSSIDInList(wlan_adapter * Adapter,
+                          WLAN_802_11_SSID * ssid, u8 * bssid, int mode);
+extern int FindBestSSIDInList(wlan_adapter * Adapter);
+extern int FindBSSIDInList(wlan_adapter * Adapter, u8 * bssid, int mode);
+
+extern int FindBestNetworkSsid(wlan_private * priv, WLAN_802_11_SSID * pSSID);
+
+extern int SendSpecificSSIDScan(wlan_private * priv,
+                                WLAN_802_11_SSID * pRequestedSSID);
+extern int SendSpecificBSSIDScan(wlan_private * priv, u8 * bssid);
+
+extern u8 wlan_scan_radio_to_band(u8 scanBand);
+
+extern int wlan_get_scan_table_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_set_user_scan_ioctl(wlan_private * priv, struct iwreq *wrq);
+
+extern int wlan_associate(wlan_private * priv, BSSDescriptor_t * pBSSDesc);
+
+extern int wlan_cmd_802_11_scan(wlan_private * priv,
+                                HostCmd_DS_COMMAND * cmd, void *pdata_buf);
+
+extern int wlan_ret_802_11_scan(wlan_private * priv,
+                                HostCmd_DS_COMMAND * resp);
+
+extern int wlan_extscan_ioctl(wlan_private * priv, struct ifreq *req);
+
+extern int sendBgScanQueryCmd(wlan_private * priv);
+extern int wlan_bg_scan_enable(wlan_private * priv, BOOLEAN enable);
+extern int wlan_do_bg_scan_config_ioctl(wlan_private * priv,
+                                        struct ifreq *req);
+extern int wlan_cmd_802_11_bg_scan_config(wlan_private * priv,
+                                          HostCmd_DS_COMMAND * cmd,
+                                          int cmd_action, void *pdata_buf);
+extern int wlan_cmd_802_11_bg_scan_query(wlan_private * priv,
+                                         HostCmd_DS_COMMAND * cmd);
+
+#ifdef __KERNEL__
+extern int wlan_get_scan(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_point *dwrq, char *extra);
+extern int wlan_set_scan(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_param *vwrq, char *extra);
+#endif
+
+#endif /* _WLAN_SCAN_H */
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_tx.c b/drivers/net/wireless/8686_wlan/wlan/wlan_tx.c
new file mode 100644
index 0000000..68e6fd4
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_tx.c
@@ -0,0 +1,321 @@
+/** @file wlan_tx.c
+  * @brief This file contains the handling of TX in wlan
+  * driver.
+  *    
+  *  (c) Copyright © 2003-2006, Marvell International Ltd.  
+  *   
+  *  This software file (the "File") is distributed by Marvell International 
+  *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  *  (the "License").  You may use, redistribute and/or modify this File in 
+  *  accordance with the terms and conditions of the License, a copy of which 
+  *  is available along with the File in the gpl.txt file or by writing to 
+  *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  *  this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	09/28/05: Add Doxygen format comments
+	12/13/05: Add Proprietary periodic sleep support
+	01/05/06: Add kernel 2.6.x support	
+	04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+********************************************************/
+
+#include	"include.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+static int
+timeval_diff_in_ms(const struct timeval *pTv1, const struct timeval *pTv2)
+{
+    int diff_ms;
+
+    diff_ms = (pTv1->tv_sec - pTv2->tv_sec) * 1000;
+    diff_ms += (pTv1->tv_usec - pTv2->tv_usec) / 1000;
+
+    return diff_ms;
+}
+
+/** 
+ *  @brief This function processes a single packet and sends
+ *  to IF layer
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param skb     A pointer to skb which includes TX packet
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+SendSinglePacket(wlan_private * priv, struct sk_buff *skb)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    TxPD LocalTxPD;
+    TxPD *pLocalTxPD = &LocalTxPD;
+    u8 *ptr = priv->adapter->TmpTxBuf;
+    struct timeval in_tv;
+    struct timeval out_tv;
+    int queue_delay;
+
+    ENTER();
+
+    if (!skb->len || (skb->len > MRVDRV_ETH_TX_PACKET_BUFFER_SIZE)) {
+        PRINTM(ERROR, "Tx Error: Bad skb length %d : %d\n",
+               skb->len, MRVDRV_ETH_TX_PACKET_BUFFER_SIZE);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    memset(pLocalTxPD, 0, sizeof(TxPD));
+
+    pLocalTxPD->TxPacketLength = skb->len;
+
+    if (Adapter->wmm.enabled) {
+        /* 
+         * original skb->priority has been overwritten 
+         * by wmm_map_and_add_skb()
+         */
+        pLocalTxPD->Priority = (u8) skb->priority;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
+        skb_get_timestamp(skb, &in_tv);
+#else
+        memcpy(&in_tv, &skb->stamp, sizeof(in_tv));
+#endif
+        do_gettimeofday(&out_tv);
+
+        /* Queue delay is passed as a uint8 in units of 2ms (ms shifted by 1).
+         *   Min value (other than 0) is therefore 2ms, max is 510ms.
+         */
+        queue_delay = timeval_diff_in_ms(&out_tv, &in_tv) >> 1;
+
+        /* Pass max value if queue_delay is beyond the uint8 range */
+        pLocalTxPD->PktDelay_2ms = MIN(queue_delay, 0xFF);
+
+        PRINTM(INFO, "WMM: Pkt Delay: %d ms\n",
+               pLocalTxPD->PktDelay_2ms << 1);
+    }
+    if (Adapter->PSState != PS_STATE_FULL_POWER) {
+        if (TRUE == CheckLastPacketIndication(priv)) {
+            Adapter->TxLockFlag = TRUE;
+            pLocalTxPD->PowerMgmt = MRVDRV_TxPD_POWER_MGMT_LAST_PACKET;
+        }
+    }
+    /* offset of actual data */
+    pLocalTxPD->TxPacketLocation = sizeof(TxPD);
+
+    /* TxCtrl set by user or default */
+    pLocalTxPD->TxControl = Adapter->PktTxCtrl;
+
+    memcpy(pLocalTxPD->TxDestAddrHigh, skb->data, MRVDRV_ETH_ADDR_LEN);
+
+    ptr += SDIO_HEADER_LEN;
+    memcpy(ptr, pLocalTxPD, sizeof(TxPD));
+
+    ptr += sizeof(TxPD);
+
+    memcpy(ptr, skb->data, skb->len);
+
+    ret = sbi_host_to_card(priv, MVMS_DAT,
+                           priv->adapter->TmpTxBuf, skb->len + sizeof(TxPD));
+
+    if (ret) {
+        PRINTM(ERROR, "Tx Error: sbi_host_to_card failed: 0x%X\n", ret);
+        Adapter->dbg.num_tx_host_to_card_failure++;
+        goto done;
+    }
+
+    PRINTM(DATA, "Data => FW\n");
+    DBG_HEXDUMP(DAT_D, "Tx", ptr - sizeof(TxPD),
+                MIN(skb->len + sizeof(TxPD), MAX_DATA_DUMP_LEN));
+
+  done:
+    if (!ret) {
+        priv->stats.tx_packets++;
+        priv->stats.tx_bytes += skb->len;
+    } else {
+        priv->stats.tx_dropped++;
+        priv->stats.tx_errors++;
+    }
+
+    /* need to be freed in all cases */
+    os_free_tx_packet(priv);
+
+    LEAVE();
+    return ret;
+}
+
+/********************************************************
+		Global functions
+********************************************************/
+
+/** 
+ *  @brief This function checks the conditions and sends packet to IF
+ *  layer if everything is ok.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+void
+wlan_process_tx(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    if (priv->wlan_dev.dnld_sent) {
+        PRINTM(MSG, "TX Error: dnld_sent = %d, not sending\n",
+               priv->wlan_dev.dnld_sent);
+        goto done;
+    }
+
+    SendSinglePacket(priv, Adapter->CurrentTxSkb);
+
+    OS_INT_DISABLE;
+    priv->adapter->HisRegCpy &= ~HIS_TxDnLdRdy;
+    OS_INT_RESTORE;
+
+  done:
+    LEAVE();
+}
+
+/** 
+ *  @brief This function queues the packet received from
+ *  kernel/upper layer and wake up the main thread to handle it.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+  * @param skb     A pointer to skb which includes TX packet
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_tx_packet(wlan_private * priv, struct sk_buff *skb)
+{
+    ulong flags;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    umd_dbg("will wakeup main thread to tx packet, len = %d", skb->len);
+    HEXDUMP("TX Data", skb->data, MIN(skb->len, 100));
+
+	/* modified by feng */
+    spin_lock_irqsave(&Adapter->CurrentTxLock, flags);
+    if (Adapter->wmm.enabled) {
+        wmm_map_and_add_skb(priv, skb);
+        //wake_up_interruptible(&priv->MainThread.waitQ);
+    } else {
+        Adapter->TxSkbNum++;
+        list_add_tail((struct list_head *) skb,
+                      (struct list_head *) &priv->adapter->TxSkbQ);
+        //wake_up_interruptible(&priv->MainThread.waitQ);
+    }
+
+	if (threadrunning)
+		umd_dbg("No need to wakeup main thread, already runnig");
+	else
+		wake_up_interruptible(&priv->MainThread.waitQ);
+
+    spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+
+    return ret;
+}
+
+/** 
+ *  @brief This function tells firmware to send a NULL data packet.
+ *  
+ *  @param priv     A pointer to wlan_private structure
+ *  @param pwr_mgmt indicate if power management bit should be 0 or 1
+ *  @return 	    n/a
+ */
+int
+SendNullPacket(wlan_private * priv, u8 pwr_mgmt)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    TxPD txpd;
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 *ptr = priv->adapter->TmpTxBuf;
+
+    ENTER();
+
+    if (priv->adapter->SurpriseRemoved == TRUE) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (priv->adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    memset(&txpd, 0, sizeof(TxPD));
+
+    txpd.TxControl = Adapter->PktTxCtrl;
+    txpd.PowerMgmt = pwr_mgmt;
+    txpd.TxPacketLocation = sizeof(TxPD);
+
+    ptr += SDIO_HEADER_LEN;
+    memcpy(ptr, &txpd, sizeof(TxPD));
+
+    ret = sbi_host_to_card(priv, MVMS_DAT,
+                           priv->adapter->TmpTxBuf, sizeof(TxPD));
+
+    if (ret != 0) {
+        PRINTM(ERROR, "TX Error: SendNullPacket failed!\n");
+        Adapter->dbg.num_tx_host_to_card_failure++;
+        goto done;
+    }
+    PRINTM(DATA, "Null data => FW\n");
+    DBG_HEXDUMP(DAT_D, "Tx", ptr, sizeof(TxPD));
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function check if we need send last packet indication.
+ *  
+ *  @param priv     A pointer to wlan_private structure
+ *
+ *  @return 	   TRUE or FALSE
+ */
+BOOLEAN
+CheckLastPacketIndication(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    BOOLEAN ret = FALSE;
+    BOOLEAN prop_ps = TRUE;
+
+    ENTER();
+
+    if (Adapter->sleep_period.period == 0 || Adapter->gen_null_pkg == FALSE     /* for UPSD certification tests */
+        )
+        goto done;
+    if (Adapter->wmm.enabled) {
+        if (wmm_lists_empty(priv)) {
+            if (((Adapter->CurBssParams.wmm_uapsd_enabled == TRUE) &&
+                 (Adapter->wmm.qosinfo != 0)) || prop_ps)
+                ret = TRUE;
+        }
+        goto done;
+    }
+    if (!Adapter->TxSkbNum)
+        ret = TRUE;
+  done:
+
+    LEAVE();
+    return ret;
+}
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_types.h b/drivers/net/wireless/8686_wlan/wlan/wlan_types.h
new file mode 100644
index 0000000..8210e3d
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_types.h
@@ -0,0 +1,1040 @@
+/** @file wlan_types.h
+ *  @brief This header file contains definition for global types
+ *
+ *  (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change log:
+	10/11/05: add Doxygen format comments 
+	01/11/06: Add IEEE Association response type. Add TSF TLV information.
+	01/31/06: Add support to selectively enabe the FW Scan channel filter
+	04/10/06: Add power_adapt_cfg_ext command
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	05/03/06: Add auto_tx hostcmd
+************************************************************/
+
+#ifndef _WLAN_TYPES_
+#define _WLAN_TYPES_
+
+#ifndef __KERNEL__
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed long s32;
+typedef unsigned long u32;
+
+typedef signed long long s64;
+typedef unsigned long long u64;
+
+typedef u32 dma_addr_t;
+typedef u32 dma64_addr_t;
+
+/* Dma addresses are 32-bits wide.  */
+#ifndef __ATTRIB_ALIGN__
+#define __ATTRIB_ALIGN__ __attribute__((aligned(4)))
+#endif
+
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__ __attribute__ ((packed))
+#endif
+#endif
+
+typedef long LONG;
+typedef unsigned long long ULONGLONG;
+typedef u32 WLAN_OID;
+
+#define MRVDRV_MAX_MULTICAST_LIST_SIZE		32
+#define MRVDRV_MAX_CHANNEL_SIZE			14
+#define MRVDRV_ETH_ADDR_LEN                      6
+
+#define MRVDRV_MAX_SSID_LENGTH			32
+#define MRVDRV_MAX_BSS_DESCRIPTS		16
+
+#define MRVL_KEY_BUFFER_SIZE_IN_BYTE  		16
+#define MRVL_MAX_KEY_WPA_KEY_LENGTH     	32
+
+#define HOSTCMD_SUPPORTED_RATES G_SUPPORTED_RATES
+
+#define	BAND_B			(0x01)
+#define	BAND_G			(0x02)
+#define ALL_802_11_BANDS	(BAND_B | BAND_G)
+
+#define B_SUPPORTED_RATES			8
+#define G_SUPPORTED_RATES			14
+
+#define	WLAN_SUPPORTED_RATES			14
+#define WLAN_MAX_SSID_LENGTH			32
+
+#define	MAX_POWER_ADAPT_GROUP		5
+
+typedef u8 WLAN_802_11_RATES[WLAN_SUPPORTED_RATES];     // Set of 8 data rates
+typedef u8 WLAN_802_11_MAC_ADDRESS[ETH_ALEN];
+
+typedef enum _WLAN_802_11_NETWORK_TYPE
+{
+    Wlan802_11FH,
+    Wlan802_11DS,
+    Wlan802_11NetworkTypeMax    // not a real type, 
+        //defined as an upper bound
+} WLAN_802_11_NETWORK_TYPE, *PWLAN_802_11_NETWORK_TYPE;
+
+typedef enum _WLAN_802_11_NETWORK_INFRASTRUCTURE
+{
+    Wlan802_11IBSS,
+    Wlan802_11Infrastructure,
+    Wlan802_11AutoUnknown,
+    Wlan802_11InfrastructureMax // Not a real value, 
+        // defined as upper bound
+} WLAN_802_11_NETWORK_INFRASTRUCTURE, *PWLAN_802_11_NETWORK_INFRASTRUCTURE;
+
+/** IEEE Type definitions  */
+typedef enum _IEEEtypes_ElementId_e
+{
+    SSID = 0,
+    SUPPORTED_RATES,
+    FH_PARAM_SET,
+    DS_PARAM_SET,
+    CF_PARAM_SET,
+    TIM,
+    IBSS_PARAM_SET,
+    COUNTRY_INFO = 7,
+
+    CHALLENGE_TEXT = 16,
+
+    EXTENDED_SUPPORTED_RATES = 50,
+
+    VENDOR_SPECIFIC_221 = 221,
+    WMM_IE = VENDOR_SPECIFIC_221,
+
+    WPA_IE = VENDOR_SPECIFIC_221,
+    WPA2_IE = 48,
+
+    EXTRA_IE = 133,
+} __ATTRIB_PACK__ IEEEtypes_ElementId_e;
+
+#define WMM_OUI_TYPE  2
+
+#define CAPINFO_MASK    (~( W_BIT_15 | W_BIT_14 |               \
+                            W_BIT_12 | W_BIT_11 | W_BIT_9) )
+
+typedef struct _IEEEtypes_CapInfo_t
+{
+    u8 Ess:1;
+    u8 Ibss:1;
+    u8 CfPollable:1;
+    u8 CfPollRqst:1;
+    u8 Privacy:1;
+    u8 ShortPreamble:1;
+    u8 Pbcc:1;
+    u8 ChanAgility:1;
+    u8 SpectrumMgmt:1;
+    u8 Rsrvd3:1;
+    u8 ShortSlotTime:1;
+    u8 Apsd:1;
+    u8 Rsvrd2:1;
+    u8 DSSSOFDM:1;
+    u8 Rsrvd1:2;
+} __ATTRIB_PACK__ IEEEtypes_CapInfo_t;
+
+/** IEEEtypes_CfParamSet_t */
+typedef struct _IEEEtypes_CfParamSet_t
+{
+    u8 ElementId;
+    u8 Len;
+    u8 CfpCnt;
+    u8 CfpPeriod;
+    u16 CfpMaxDuration;
+    u16 CfpDurationRemaining;
+} __ATTRIB_PACK__ IEEEtypes_CfParamSet_t;
+
+typedef struct IEEEtypes_IbssParamSet_t
+{
+    u8 ElementId;
+    u8 Len;
+    u16 AtimWindow;
+} __ATTRIB_PACK__ IEEEtypes_IbssParamSet_t;
+
+/** IEEEtypes_SsParamSet_t */
+typedef union _IEEEtypes_SsParamSet_t
+{
+    IEEEtypes_CfParamSet_t CfParamSet;
+    IEEEtypes_IbssParamSet_t IbssParamSet;
+} __ATTRIB_PACK__ IEEEtypes_SsParamSet_t;
+
+/** IEEEtypes_FhParamSet_t */
+typedef struct _IEEEtypes_FhParamSet_t
+{
+    u8 ElementId;
+    u8 Len;
+    u16 DwellTime;
+    u8 HopSet;
+    u8 HopPattern;
+    u8 HopIndex;
+} __ATTRIB_PACK__ IEEEtypes_FhParamSet_t;
+
+typedef struct _IEEEtypes_DsParamSet_t
+{
+    u8 ElementId;
+    u8 Len;
+    u8 CurrentChan;
+} __ATTRIB_PACK__ IEEEtypes_DsParamSet_t;
+
+/** IEEEtypes_DsParamSet_t */
+typedef union IEEEtypes_PhyParamSet_t
+{
+    IEEEtypes_FhParamSet_t FhParamSet;
+    IEEEtypes_DsParamSet_t DsParamSet;
+} __ATTRIB_PACK__ IEEEtypes_PhyParamSet_t;
+
+typedef u16 IEEEtypes_AId_t;
+typedef u16 IEEEtypes_StatusCode_t;
+
+typedef struct
+{
+    IEEEtypes_CapInfo_t Capability;
+    IEEEtypes_StatusCode_t StatusCode;
+    IEEEtypes_AId_t AId;
+    u8 IEBuffer[1];
+} __ATTRIB_PACK__ IEEEtypes_AssocRsp_t;
+
+/** TLV  type ID definition */
+#define PROPRIETARY_TLV_BASE_ID		0x0100
+
+/* Terminating TLV Type */
+#define MRVL_TERMINATE_TLV_ID		0xffff
+
+#define TLV_TYPE_SSID				0x0000
+#define TLV_TYPE_RATES				0x0001
+#define TLV_TYPE_PHY_FH				0x0002
+#define TLV_TYPE_PHY_DS				0x0003
+#define TLV_TYPE_CF				    0x0004
+#define TLV_TYPE_IBSS				0x0006
+
+#define TLV_TYPE_DOMAIN				0x0007
+
+#define TLV_TYPE_POWER_CAPABILITY	0x0021
+
+#define TLV_TYPE_KEY_MATERIAL       (PROPRIETARY_TLV_BASE_ID + 0)
+#define TLV_TYPE_CHANLIST           (PROPRIETARY_TLV_BASE_ID + 1)
+#define TLV_TYPE_NUMPROBES          (PROPRIETARY_TLV_BASE_ID + 2)
+#define TLV_TYPE_RSSI_LOW           (PROPRIETARY_TLV_BASE_ID + 4)
+#define TLV_TYPE_SNR_LOW            (PROPRIETARY_TLV_BASE_ID + 5)
+#define TLV_TYPE_FAILCOUNT          (PROPRIETARY_TLV_BASE_ID + 6)
+#define TLV_TYPE_BCNMISS            (PROPRIETARY_TLV_BASE_ID + 7)
+#define TLV_TYPE_LED_GPIO           (PROPRIETARY_TLV_BASE_ID + 8)
+#define TLV_TYPE_LEDBEHAVIOR        (PROPRIETARY_TLV_BASE_ID + 9)
+#define TLV_TYPE_PASSTHROUGH        (PROPRIETARY_TLV_BASE_ID + 10)
+#define TLV_TYPE_REASSOCAP          (PROPRIETARY_TLV_BASE_ID + 11)
+#define TLV_TYPE_POWER_TBL_2_4GHZ   (PROPRIETARY_TLV_BASE_ID + 12)
+#define TLV_TYPE_POWER_TBL_5GHZ     (PROPRIETARY_TLV_BASE_ID + 13)
+#define TLV_TYPE_BCASTPROBE	    (PROPRIETARY_TLV_BASE_ID + 14)
+#define TLV_TYPE_NUMSSID_PROBE	    (PROPRIETARY_TLV_BASE_ID + 15)
+#define TLV_TYPE_WMMQSTATUS   	    (PROPRIETARY_TLV_BASE_ID + 16)
+#define TLV_TYPE_CRYPTO_DATA	    (PROPRIETARY_TLV_BASE_ID + 17)
+#define TLV_TYPE_WILDCARDSSID	    (PROPRIETARY_TLV_BASE_ID + 18)
+#define TLV_TYPE_TSFTIMESTAMP	    (PROPRIETARY_TLV_BASE_ID + 19)
+#define TLV_TYPE_POWERADAPTCFGEXT   (PROPRIETARY_TLV_BASE_ID + 20)
+#define TLV_TYPE_RSSI_HIGH          (PROPRIETARY_TLV_BASE_ID + 22)
+#define TLV_TYPE_SNR_HIGH           (PROPRIETARY_TLV_BASE_ID + 23)
+#define TLV_TYPE_AUTO_TX	    (PROPRIETARY_TLV_BASE_ID + 24)
+
+/** TLV related data structures*/
+/** MrvlIEtypesHeader_t */
+typedef struct _MrvlIEtypesHeader
+{
+    u16 Type;
+    u16 Len;
+} __ATTRIB_PACK__ MrvlIEtypesHeader_t;
+
+/** MrvlIEtypes_Data_t */
+typedef struct _MrvlIEtypes_Data_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 Data[1];
+} __ATTRIB_PACK__ MrvlIEtypes_Data_t;
+
+/** MrvlIEtypes_RatesParamSet_t */
+typedef struct _MrvlIEtypes_RatesParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 Rates[1];
+} __ATTRIB_PACK__ MrvlIEtypes_RatesParamSet_t;
+
+/** MrvlIEtypes_SsIdParamSet_t */
+typedef struct _MrvlIEtypes_SsIdParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 SsId[1];
+} __ATTRIB_PACK__ MrvlIEtypes_SsIdParamSet_t;
+
+/** MrvlIEtypes_WildCardSsIdParamSet_t */
+typedef struct _MrvlIEtypes_WildCardSsIdParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 MaxSsidLength;
+    u8 SsId[1];
+} __ATTRIB_PACK__ MrvlIEtypes_WildCardSsIdParamSet_t;
+
+/** ChanScanMode_t */
+typedef struct
+{
+    u8 PassiveScan:1;
+    u8 DisableChanFilt:1;
+    u8 Reserved_2_7:6;
+} __ATTRIB_PACK__ ChanScanMode_t;
+
+/** ChanScanParamSet_t */
+typedef struct _ChanScanParamSet_t
+{
+    u8 RadioType;
+    u8 ChanNumber;
+    ChanScanMode_t ChanScanMode;
+    u16 MinScanTime;
+    u16 MaxScanTime;
+} __ATTRIB_PACK__ ChanScanParamSet_t;
+
+/** MrvlIEtypes_ChanListParamSet_t */
+typedef struct _MrvlIEtypes_ChanListParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    ChanScanParamSet_t ChanScanParam[1];
+} __ATTRIB_PACK__ MrvlIEtypes_ChanListParamSet_t;
+
+/** CfParamSet_t */
+typedef struct _CfParamSet_t
+{
+    u8 CfpCnt;
+    u8 CfpPeriod;
+    u16 CfpMaxDuration;
+    u16 CfpDurationRemaining;
+} __ATTRIB_PACK__ CfParamSet_t;
+
+/** IbssParamSet_t */
+typedef struct _IbssParamSet_t
+{
+    u16 AtimWindow;
+} __ATTRIB_PACK__ IbssParamSet_t;
+
+/** MrvlIEtypes_SsParamSet_t */
+typedef struct _MrvlIEtypes_SsParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    union
+    {
+        CfParamSet_t CfParamSet[1];
+        IbssParamSet_t IbssParamSet[1];
+    } cf_ibss;
+} __ATTRIB_PACK__ MrvlIEtypes_SsParamSet_t;
+
+/** FhParamSet_t */
+typedef struct _FhParamSet_t
+{
+    u16 DwellTime;
+    u8 HopSet;
+    u8 HopPattern;
+    u8 HopIndex;
+} __ATTRIB_PACK__ FhParamSet_t;
+
+/** DsParamSet_t */
+typedef struct _DsParamSet_t
+{
+    u8 CurrentChan;
+} __ATTRIB_PACK__ DsParamSet_t;
+
+/** MrvlIEtypes_PhyParamSet_t */
+typedef struct _MrvlIEtypes_PhyParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    union
+    {
+        FhParamSet_t FhParamSet[1];
+        DsParamSet_t DsParamSet[1];
+    } fh_ds;
+} __ATTRIB_PACK__ MrvlIEtypes_PhyParamSet_t;
+
+/** MrvlIEtypes_ReassocAp_t */
+typedef struct _MrvlIEtypes_ReassocAp_t
+{
+    MrvlIEtypesHeader_t Header;
+    WLAN_802_11_MAC_ADDRESS currentAp;
+
+} __ATTRIB_PACK__ MrvlIEtypes_ReassocAp_t;
+
+/** MrvlIEtypes_RsnParamSet_t */
+typedef struct _MrvlIEtypes_RsnParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 RsnIE[1];
+} __ATTRIB_PACK__ MrvlIEtypes_RsnParamSet_t;
+
+/** MrvlIEtypes_WmmParamSet_t */
+typedef struct _MrvlIEtypes_WmmParamSet_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 WmmIE[1];
+} __ATTRIB_PACK__ MrvlIEtypes_WmmParamSet_t;
+
+typedef struct
+{
+    MrvlIEtypesHeader_t Header;
+    u8 QueueIndex;
+    u8 Disabled;
+    u8 TriggeredPS;
+    u8 FlowDirection;
+    u8 FlowRequired;
+    u8 FlowCreated;
+    u32 MediumTime;
+} __ATTRIB_PACK__ MrvlIEtypes_WmmQueueStatus_t;
+
+typedef struct
+{
+    MrvlIEtypesHeader_t Header;
+    u64 tsfTable[1];
+} __ATTRIB_PACK__ MrvlIEtypes_TsfTimestamp_t;
+
+/**  Local Power Capability */
+typedef struct _MrvlIEtypes_PowerCapability_t
+{
+    MrvlIEtypesHeader_t Header;
+    s8 MinPower;
+    s8 MaxPower;
+} __ATTRIB_PACK__ MrvlIEtypes_PowerCapability_t;
+
+/** MrvlIEtypes_RssiParamSet_t */
+typedef struct _MrvlIEtypes_RssiThreshold_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 RSSIValue;
+    u8 RSSIFreq;
+} __ATTRIB_PACK__ MrvlIEtypes_RssiParamSet_t;
+
+/** MrvlIEtypes_SnrThreshold_t */
+typedef struct _MrvlIEtypes_SnrThreshold_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 SNRValue;
+    u8 SNRFreq;
+} __ATTRIB_PACK__ MrvlIEtypes_SnrThreshold_t;
+
+/** MrvlIEtypes_FailureCount_t */
+typedef struct _MrvlIEtypes_FailureCount_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 FailValue;
+    u8 FailFreq;
+} __ATTRIB_PACK__ MrvlIEtypes_FailureCount_t;
+
+/** MrvlIEtypes_BeaconsMissed_t */
+typedef struct _MrvlIEtypes_BeaconsMissed_t
+{
+    MrvlIEtypesHeader_t Header;
+    u8 BeaconMissed;
+    u8 Reserved;
+} __ATTRIB_PACK__ MrvlIEtypes_BeaconsMissed_t;
+
+/** MrvlIEtypes_NumProbes_t */
+typedef struct _MrvlIEtypes_NumProbes_t
+{
+    MrvlIEtypesHeader_t Header;
+    u16 NumProbes;
+} __ATTRIB_PACK__ MrvlIEtypes_NumProbes_t;
+
+/** MrvlIEtypes_BcastProbe_t */
+typedef struct _MrvlIEtypes_BcastProbe_t
+{
+    MrvlIEtypesHeader_t Header;
+    u16 BcastProbe;
+} __ATTRIB_PACK__ MrvlIEtypes_BcastProbe_t;
+
+/** MrvlIEtypes_NumSSIDProbe_t */
+typedef struct _MrvlIEtypes_NumSSIDProbe_t
+{
+    MrvlIEtypesHeader_t Header;
+    u16 NumSSIDProbe;
+} __ATTRIB_PACK__ MrvlIEtypes_NumSSIDProbe_t;
+
+typedef struct
+{
+    u8 Led;
+    u8 Pin;
+} __ATTRIB_PACK__ Led_Pin;
+
+/** MrvlIEtypes_LedGpio_t */
+typedef struct _MrvlIEtypes_LedGpio_t
+{
+    MrvlIEtypesHeader_t Header;
+    Led_Pin LedPin[1];
+} __ATTRIB_PACK__ MrvlIEtypes_LedGpio_t;
+
+typedef struct _PA_Group_t
+{
+    u16 PowerAdaptLevel;
+    u16 RateBitmap;
+    u32 Reserved;
+} __ATTRIB_PACK__ PA_Group_t;
+
+/** MrvlIEtypes_PA_Group_t */
+typedef struct _MrvlIEtypes_PowerAdapt_Group_t
+{
+    MrvlIEtypesHeader_t Header;
+    PA_Group_t PA_Group[MAX_POWER_ADAPT_GROUP];
+} __ATTRIB_PACK__ MrvlIEtypes_PowerAdapt_Group_t;
+
+typedef struct _AutoTx_MacFrame_t
+{
+    u16 Interval;               /* in seconds */
+    u8 Priority;                /* User Priority: 0~7, ignored if non-WMM */
+    u8 Reserved;                /* set to 0 */
+    u16 FrameLen;               /* Length of MAC frame payload */
+    u8 DestMacAddr[ETH_ALEN];
+    u8 SrcMacAddr[ETH_ALEN];
+    u8 Payload[];
+} __ATTRIB_PACK__ AutoTx_MacFrame_t;
+
+/** MrvlIEtypes_PA_Group_t */
+typedef struct _MrvlIEtypes_AutoTx_t
+{
+    MrvlIEtypesHeader_t Header;
+    AutoTx_MacFrame_t AutoTx_MacFrame;
+} __ATTRIB_PACK__ MrvlIEtypes_AutoTx_t;
+
+#define MRVDRV_MAX_SUBBAND_802_11D		83
+#define COUNTRY_CODE_LEN			3
+/** Data structure for Country IE*/
+typedef struct _IEEEtypes_SubbandSet
+{
+    u8 FirstChan;
+    u8 NoOfChan;
+    u8 MaxTxPwr;
+} __ATTRIB_PACK__ IEEEtypes_SubbandSet_t;
+
+typedef struct _IEEEtypes_CountryInfoSet
+{
+    u8 ElementId;
+    u8 Len;
+    u8 CountryCode[COUNTRY_CODE_LEN];
+    IEEEtypes_SubbandSet_t Subband[1];
+} __ATTRIB_PACK__ IEEEtypes_CountryInfoSet_t;
+
+typedef struct _IEEEtypes_CountryInfoFullSet
+{
+    u8 ElementId;
+    u8 Len;
+    u8 CountryCode[COUNTRY_CODE_LEN];
+    IEEEtypes_SubbandSet_t Subband[MRVDRV_MAX_SUBBAND_802_11D];
+} __ATTRIB_PACK__ IEEEtypes_CountryInfoFullSet_t;
+
+typedef struct _MrvlIEtypes_DomainParamSet
+{
+    MrvlIEtypesHeader_t Header;
+    u8 CountryCode[COUNTRY_CODE_LEN];
+    IEEEtypes_SubbandSet_t Subband[1];
+} __ATTRIB_PACK__ MrvlIEtypes_DomainParamSet_t;
+
+/** enum of WMM AC_QUEUES */
+#define  MAX_AC_QUEUES 4
+typedef enum
+{
+    AC_PRIO_BK,
+    AC_PRIO_BE,
+    AC_PRIO_VI,
+    AC_PRIO_VO
+} __ATTRIB_PACK__ wlan_wmm_ac_e;
+
+/** Size of a TSPEC.  Used to allocate necessary buffer space in commands */
+#define WMM_TSPEC_SIZE              63
+
+/** Extra IE bytes allocated in messages for appended IEs after a TSPEC */
+#define WMM_ADDTS_EXTRA_IE_BYTES    256
+
+/** Extra TLV bytes allocated in messages for configuring WMM Queues */
+#define WMM_QUEUE_CONFIG_EXTRA_TLV_BYTES 64
+
+/** wlan_ioctl_wmm_para_ie */
+typedef struct
+{
+
+    /** type */
+    u8 Type;
+
+    /** action */
+    u16 Action;
+
+    /** WMM Parameter IE */
+    u8 Para_IE[26];
+
+} __ATTRIB_PACK__ wlan_ioctl_wmm_para_ie;
+
+/** wlan_ioctl_wmm_ack_policy */
+typedef struct
+{
+    u8 Type;
+
+    /** 0-ACT_GET, 1-ACT_SET */
+    u16 Action;
+
+    /** 0-AC_BE, 1-AC_BK, 2-AC_VI, 3-AC_VO */
+    u8 AC;
+
+    /** 0-WMM_ACK_POLICY_IMM_ACK, 1-WMM_ACK_POLICY_NO_ACK */
+    u8 AckPolicy;
+
+} __ATTRIB_PACK__ wlan_ioctl_wmm_ack_policy;
+
+/** data structure of WMM QoS information */
+typedef struct
+{
+    u8 ParaSetCount:4;
+    u8 Reserved:3;
+    u8 QosUAPSD:1;
+} __ATTRIB_PACK__ WMM_QoS_INFO;
+
+typedef struct
+{
+    u8 AIFSN:4;
+    u8 ACM:1;
+    u8 ACI:2;
+    u8 Reserved:1;
+} __ATTRIB_PACK__ WMM_ACI_AIFSN;
+
+/**  data structure of WMM ECW */
+typedef struct
+{
+    u8 ECW_Min:4;
+    u8 ECW_Max:4;
+} __ATTRIB_PACK__ WMM_ECW;
+
+/** data structure of WMM AC parameters  */
+typedef struct
+{
+    WMM_ACI_AIFSN ACI_AIFSN;
+    WMM_ECW ECW;
+    u16 Txop_Limit;
+} __ATTRIB_PACK__ WMM_AC_PARAS;
+
+/** data structure of WMM Info IE  */
+typedef struct
+{
+    /** 221 */
+    u8 ElementId;
+    /** 7 */
+    u8 Length;
+    /** 00:50:f2 (hex) */
+    u8 Oui[3];
+    /** 2 */
+    u8 OuiType;
+    /** 0 */
+    u8 OuiSubtype;
+    /** 1 */
+    u8 Version;
+
+    WMM_QoS_INFO QoSInfo;
+
+} __ATTRIB_PACK__ WMM_INFO_IE;
+
+/** data structure of WMM parameter IE  */
+typedef struct
+{
+    /** 221 */
+    u8 ElementId;
+    /** 24 */
+    u8 Length;
+    /** 00:50:f2 (hex) */
+    u8 Oui[3];
+    /** 2 */
+    u8 OuiType;
+    /** 1 */
+    u8 OuiSubtype;
+    /** 1 */
+    u8 Version;
+
+    WMM_QoS_INFO QoSInfo;
+    u8 Reserved;
+
+    /** AC Parameters Record AC_BE */
+    WMM_AC_PARAS AC_Paras_BE;
+    /** AC Parameters Record AC_BK */
+    WMM_AC_PARAS AC_Paras_BK;
+    /** AC Parameters Record AC_VI */
+    WMM_AC_PARAS AC_Paras_VI;
+    /** AC Parameters Record AC_VO */
+    WMM_AC_PARAS AC_Paras_VO;
+} __ATTRIB_PACK__ WMM_PARAMETER_IE;
+
+/** struct of command of WMM ack policy*/
+typedef struct
+{
+    /** 0 - ACT_GET,
+        1 - ACT_SET */
+    u16 Action;
+
+    /** 0 - AC_BE
+        1 - AC_BK
+        2 - AC_VI
+        3 - AC_VO */
+    u8 AC;
+
+    /** 0 - WMM_ACK_POLICY_IMM_ACK
+        1 - WMM_ACK_POLICY_NO_ACK */
+    u8 AckPolicy;
+} __ATTRIB_PACK__ HostCmd_DS_WMM_ACK_POLICY;
+
+/**
+ *  @brief Firmware command structure to retrieve the firmware WMM status.
+ *
+ *  Used to retrieve the status of each WMM AC Queue in TLV 
+ *    format (MrvlIEtypes_WmmQueueStatus_t) as well as the current WMM
+ *    parameter IE advertised by the AP.  
+ *  
+ *  Used in response to a MACREG_INT_CODE_WMM_STATUS_CHANGE event signalling
+ *    a QOS change on one of the ACs or a change in the WMM Parameter in
+ *    the Beacon.
+ *
+ *  TLV based command, byte arrays used for max sizing purpose. There are no 
+ *    arguments sent in the command, the TLVs are returned by the firmware.
+ */
+typedef struct
+{
+    u8 queueStatusTlv[sizeof(MrvlIEtypes_WmmQueueStatus_t) * MAX_AC_QUEUES];
+    u8 wmmParamTlv[sizeof(WMM_PARAMETER_IE) + 2];
+
+}
+__ATTRIB_PACK__ HostCmd_DS_WMM_GET_STATUS;
+
+typedef struct
+{
+    u16 PacketAC;
+} __ATTRIB_PACK__ HostCmd_DS_WMM_PRIO_PKT_AVAIL;
+
+/**
+ *  @brief Enumeration for the command result from an ADDTS or DELTS command 
+ */
+typedef enum
+{
+    TSPEC_RESULT_SUCCESS = 0,
+    TSPEC_RESULT_EXEC_FAILURE = 1,
+    TSPEC_RESULT_TIMEOUT = 2,
+    TSPEC_RESULT_DATA_INVALID = 3,
+
+} __ATTRIB_PACK__ wlan_wmm_tspec_result_e;
+
+/**
+ *  @brief IOCTL structure to send an ADDTS request and retrieve the response.
+ *
+ *  IOCTL structure from the application layer relayed to firmware to 
+ *    instigate an ADDTS management frame with an appropriate TSPEC IE as well
+ *    as any additional IEs appended in the ADDTS Action frame.
+ *
+ *  @sa wlan_wmm_addts_req_ioctl
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;
+    u32 timeout_ms;
+
+    u8 ieeeStatusCode;
+
+    u8 tspecData[WMM_TSPEC_SIZE];
+
+    u8 addtsExtraIEBuf[WMM_ADDTS_EXTRA_IE_BYTES];
+
+} __ATTRIB_PACK__ wlan_ioctl_wmm_addts_req_t;
+
+/**
+ *  @brief IOCTL structure to send a DELTS request.
+ *
+ *  IOCTL structure from the application layer relayed to firmware to 
+ *    instigate an DELTS management frame with an appropriate TSPEC IE.
+ *
+ *  @sa wlan_wmm_delts_req_ioctl
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;      //!< Firmware execution result
+
+    u8 ieeeReasonCode;          //!< IEEE reason code sent, unused for WMM 
+
+    u8 tspecData[WMM_TSPEC_SIZE];       //!< TSPEC to send in the DELTS
+
+} __ATTRIB_PACK__ wlan_ioctl_wmm_delts_req_t;
+
+/**
+ *  @brief Internal command structure used in executing an ADDTS command.
+ *
+ *  Relay information between the IOCTL layer and the firmware command and 
+ *    command response procedures.
+ *
+ *  @sa wlan_wmm_addts_req_ioctl
+ *  @sa wlan_cmd_wmm_addts_req
+ *  @sa wlan_cmdresp_wmm_addts_req
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;
+    u32 timeout_ms;
+
+    u8 dialogToken;
+    u8 ieeeStatusCode;
+
+    int tspecDataLen;
+    u8 tspecData[WMM_TSPEC_SIZE];
+    u8 addtsExtraIEBuf[WMM_ADDTS_EXTRA_IE_BYTES];
+
+} wlan_cmd_wmm_addts_req_t;
+
+/**
+ *  @brief Internal command structure used in executing an DELTS command.
+ *
+ *  Relay information between the IOCTL layer and the firmware command and 
+ *    command response procedures.
+ *
+ *  @sa wlan_wmm_delts_req_ioctl
+ *  @sa wlan_cmd_wmm_delts_req
+ *  @sa wlan_cmdresp_wmm_delts_req
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;
+
+    u8 dialogToken;
+
+    u8 ieeeReasonCode;
+
+    int tspecDataLen;
+    u8 tspecData[WMM_TSPEC_SIZE];
+
+} wlan_cmd_wmm_delts_req_t;
+
+/**
+ *  @brief Command structure for the HostCmd_CMD_WMM_ADDTS_REQ firmware command
+ *
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;
+    u32 timeout_ms;
+
+    u8 dialogToken;
+    u8 ieeeStatusCode;
+    u8 tspecData[WMM_TSPEC_SIZE];
+    u8 addtsExtraIEBuf[WMM_ADDTS_EXTRA_IE_BYTES];
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_ADDTS_REQ;
+
+/**
+ *  @brief Command structure for the HostCmd_CMD_WMM_DELTS_REQ firmware command
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;
+    u8 dialogToken;
+    u8 ieeeReasonCode;
+    u8 tspecData[WMM_TSPEC_SIZE];
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_DELTS_REQ;
+
+/**
+ *  @brief Enumeration for the action field in the Queue configure command
+ */
+typedef enum
+{
+    WMM_QUEUE_CONFIG_ACTION_GET = 0,
+    WMM_QUEUE_CONFIG_ACTION_SET = 1,
+    WMM_QUEUE_CONFIG_ACTION_DEFAULT = 2,
+
+    WMM_QUEUE_CONFIG_ACTION_MAX
+} __ATTRIB_PACK__ wlan_wmm_queue_config_action_e;
+
+/**
+ *  @brief Command structure for the HostCmd_CMD_WMM_QUEUE_CONFIG firmware cmd
+ *
+ *  Set/Get/Default the Queue parameters for a specific AC in the firmware.
+ *
+ */
+typedef struct
+{
+    wlan_wmm_queue_config_action_e action;      //!< Set, Get, or Default
+    wlan_wmm_ac_e accessCategory;       //!< AC_BK(0) to AC_VO(3)
+
+    /** @brief MSDU lifetime expiry per 802.11e
+     *
+     *   - Ignored if 0 on a set command 
+     *   - Set to the 802.11e specified 500 TUs when defaulted
+     */
+    u16 msduLifetimeExpiry;
+
+    u8 tlvBuffer[WMM_QUEUE_CONFIG_EXTRA_TLV_BYTES];     //!< Not supported yet
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_QUEUE_CONFIG;
+
+/**
+ *  @brief Internal command structure used in executing a queue config command.
+ *
+ *  Relay information between the IOCTL layer and the firmware command and 
+ *    command response procedures.
+ *
+ *  @sa wlan_wmm_queue_config_ioctl
+ *  @sa wlan_cmd_wmm_queue_config
+ *  @sa wlan_cmdresp_wmm_queue_config
+ */
+typedef struct
+{
+    wlan_wmm_queue_config_action_e action;      //!< Set, Get, or Default
+    wlan_wmm_ac_e accessCategory;       //!< AC_BK(0) to AC_VO(3)
+    u16 msduLifetimeExpiry;     //!< lifetime expiry in TUs
+
+    int tlvBufLen;              //!< Not supported yet
+    u8 tlvBuffer[WMM_QUEUE_CONFIG_EXTRA_TLV_BYTES];     //!< Not supported yet
+
+} wlan_cmd_wmm_queue_config_t;
+
+/**
+ *  @brief IOCTL structure to configure a specific AC Queue's parameters
+ *
+ *  IOCTL structure from the application layer relayed to firmware to 
+ *    get, set, or default the WMM AC queue parameters.
+ *
+ *  - msduLifetimeExpiry is ignored if set to 0 on a set command
+ *
+ *  @sa wlan_wmm_queue_config_ioctl
+ */
+typedef struct
+{
+    wlan_wmm_queue_config_action_e action;      //!< Set, Get, or Default
+    wlan_wmm_ac_e accessCategory;       //!< AC_BK(0) to AC_VO(3)
+    u16 msduLifetimeExpiry;     //!< lifetime expiry in TUs
+
+    u8 supportedRates[10];      //!< Not supported yet
+
+} __ATTRIB_PACK__ wlan_ioctl_wmm_queue_config_t;
+
+/**
+ *   @brief Enumeration for the action field in the queue stats command
+ */
+typedef enum
+{
+    WMM_STATS_ACTION_START = 0,
+    WMM_STATS_ACTION_STOP = 1,
+    WMM_STATS_ACTION_GET_CLR = 2,
+
+    WMM_STATS_ACTION_MAX
+} __ATTRIB_PACK__ wlan_wmm_stats_action_e;
+
+/** Number of bins in the histogram for the HostCmd_DS_WMM_QUEUE_STATS */
+#define WMM_STATS_PKTS_HIST_BINS  7
+
+/**
+ *  @brief Command structure for the HostCmd_CMD_WMM_QUEUE_STATS firmware cmd
+ *
+ *  Turn statistical collection on/off for a given AC or retrieve the 
+ *    accumulated stats for an AC and clear them in the firmware.
+ */
+typedef struct
+{
+    wlan_wmm_stats_action_e action;     //!< Start, Stop, or Get 
+    wlan_wmm_ac_e accessCategory;       //!< AC_BK(0) to AC_VO(3)
+
+    u16 pktCount;               //!< Number of successful packets transmitted
+    u16 pktLoss;                //!< Packets lost; not included in pktCount
+    u32 avgQueueDelay;          //!< Average Queue delay in microseconds
+    u32 avgTxDelay;             //!< Average Transmission delay in microseconds
+    u32 usedTime;               //!< Calculated medium time 
+
+    /** @brief Queue Delay Histogram; number of packets per queue delay range
+     * 
+     *  [0] -  0ms <= delay < 5ms
+     *  [1] -  5ms <= delay < 10ms
+     *  [2] - 10ms <= delay < 20ms
+     *  [3] - 20ms <= delay < 30ms
+     *  [4] - 30ms <= delay < 40ms
+     *  [5] - 40ms <= delay < 50ms
+     *  [6] - 50ms <= delay < msduLifetime (TUs)
+     */
+    u16 delayHistogram[WMM_STATS_PKTS_HIST_BINS];
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_QUEUE_STATS;
+
+/**
+ *  @brief IOCTL structure to start, stop, and get statistics for a WMM AC
+ *
+ *  IOCTL structure from the application layer relayed to firmware to 
+ *    start or stop statistical collection for a given AC.  Also used to 
+ *    retrieve and clear the collected stats on a given AC.
+ *
+ *  @sa wlan_wmm_queue_stats_ioctl
+ */
+typedef struct
+{
+    wlan_wmm_stats_action_e action;     //!< Start, Stop, or Get 
+    wlan_wmm_ac_e accessCategory;       //!< AC_BK(0) to AC_VO(3)
+    u16 pktCount;               //!< Number of successful packets transmitted  
+    u16 pktLoss;                //!< Packets lost; not included in pktCount    
+    u32 avgQueueDelay;          //!< Average Queue delay in microseconds
+    u32 avgTxDelay;             //!< Average Transmission delay in microseconds
+    u32 usedTime;               //!< Calculated medium time 
+
+    /** @brief Queue Delay Histogram; number of packets per queue delay range
+     * 
+     *  [0] -  0ms <= delay < 5ms
+     *  [1] -  5ms <= delay < 10ms
+     *  [2] - 10ms <= delay < 20ms
+     *  [3] - 20ms <= delay < 30ms
+     *  [4] - 30ms <= delay < 40ms
+     *  [5] - 40ms <= delay < 50ms
+     *  [6] - 50ms <= delay < msduLifetime (TUs)
+     */
+    u16 delayHistogram[WMM_STATS_PKTS_HIST_BINS];
+} __ATTRIB_PACK__ wlan_ioctl_wmm_queue_stats_t;
+
+/** 
+ *  @brief IOCTL sub structure for a specific WMM AC Status
+ */
+typedef struct
+{
+    u8 wmmACM;
+    u8 flowRequired;
+    u8 flowCreated;
+    u8 disabled;
+} __ATTRIB_PACK__ wlan_ioctl_wmm_queue_status_ac_t;
+
+/**
+ *  @brief IOCTL structure to retrieve the WMM AC Queue status
+ *
+ *  IOCTL structure from the application layer to retrieve:
+ *     - ACM bit setting for the AC
+ *     - Firmware status (flow required, flow created, flow disabled)
+ *
+ *  @sa wlan_wmm_queue_status_ioctl
+ */
+typedef struct
+{
+    wlan_ioctl_wmm_queue_status_ac_t acStatus[MAX_AC_QUEUES];
+} __ATTRIB_PACK__ wlan_ioctl_wmm_queue_status_t;
+
+/** Firmware status for a specific AC */
+typedef struct
+{
+    u8 Disabled;
+    u8 FlowRequired;
+    u8 FlowCreated;
+} WMM_AC_STATUS;
+
+#endif /* _WLAN_TYPES_ */
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_version.h b/drivers/net/wireless/8686_wlan/wlan/wlan_version.h
new file mode 100644
index 0000000..5d1ae59
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_version.h
@@ -0,0 +1,32 @@
+/** @file wlan_version.h
+  * @brief This file contains wlan driver version number.
+  * 
+  * (c) Copyright © 2003-2006, Marvell International Ltd. 
+  *
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	10/04/05: Add Doxygen format comments
+	
+********************************************************/
+#include "../release_version.h"
+
+const char driver_version[] =
+    "sd8686-%s-" DRIVER_RELEASE_VERSION "-(" "FP" FPNUM ")"
+#ifdef	DEBUG_LEVEL2
+    "-dbg"
+#endif
+    " ";
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_wext.c b/drivers/net/wireless/8686_wlan/wlan/wlan_wext.c
new file mode 100644
index 0000000..efd11de
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_wext.c
@@ -0,0 +1,6959 @@
+/** @file  wlan_wext.c 
+  * @brief This file contains ioctl functions
+  * 
+  * (c) Copyright © 2003-2007, Marvell International Ltd. 
+  *
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	10/10/05: Add Doxygen format comments
+	12/23/05: Modify FindBSSIDInList to search entire table for
+	          duplicate BSSIDs when earlier matches are not compatible
+	12/26/05: Remove errant memcpy in wlanidle_off; overwriting stack space
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join functions.
+	          Update statics/externs.  Move forward decl. from wlan_decl.h
+	04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+	04/10/06: Add hostcmd generic API
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	05/04/06: Add IBSS coalescing related new iwpriv command
+	10/23/06: Validate setbcnavg/setdataavg command parameters and
+	          return error if out of range
+********************************************************/
+
+#include	"include.h"
+
+#include	"wlan_version.h"
+
+#define GETLOG_BUFSIZE  512
+
+#define MAX_SCAN_CELL_SIZE      (IW_EV_ADDR_LEN + \
+				MRVDRV_MAX_SSID_LENGTH + \
+				IW_EV_UINT_LEN + IW_EV_FREQ_LEN + \
+				IW_EV_QUAL_LEN + MRVDRV_MAX_SSID_LENGTH + \
+				IW_EV_PARAM_LEN + 40)   /* 40 for WPAIE */
+
+#define WAIT_FOR_SCAN_RRESULT_MAX_TIME (10 * HZ)
+
+typedef struct _ioctl_cmd
+{
+    int cmd;
+    int subcmd;
+    BOOLEAN fixsize;
+} ioctl_cmd;
+
+static ioctl_cmd Commands_Allowed_In_DeepSleep[] = {
+    {.cmd = WLANDEEPSLEEP,.subcmd = 0,.fixsize = FALSE},
+    {.cmd = WLAN_SETNONE_GETWORDCHAR,.subcmd = WLANVERSION,.fixsize = FALSE},
+    {.cmd = WLAN_SETINT_GETINT,.subcmd = WLANSDIOCLOCK,.fixsize = TRUE},
+#ifdef DEBUG_LEVEL1
+    {.cmd = WLAN_SET_GET_SIXTEEN_INT,.subcmd = WLAN_DRV_DBG,.fixsize = FALSE},
+#endif
+};
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/********************************************************
+		Global Variables
+********************************************************/
+#ifdef DEBUG_LEVEL1
+#ifdef DEBUG_LEVEL2
+#define	DEFAULT_DEBUG_MASK	(0xffffffff & ~DBG_EVENT)
+#else
+#define DEFAULT_DEBUG_MASK	(DBG_MSG | DBG_FATAL)
+#endif
+u32 drvdbg = DEFAULT_DEBUG_MASK;
+u32 ifdbg = 0;
+#endif
+
+/********************************************************
+		Local Functions
+********************************************************/
+static int wlan_set_rate(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_param *vwrq, char *extra);
+static int wlan_get_rate(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_param *vwrq, char *extra);
+
+static int wlan_get_essid(struct net_device *dev,
+                          struct iw_request_info *info, struct iw_point *dwrq,
+                          char *extra);
+
+static int wlan_set_freq(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_freq *fwrq, char *extra);
+static int wlan_get_freq(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_freq *fwrq, char *extra);
+
+static int wlan_set_mode(struct net_device *dev, struct iw_request_info *info,
+                         u32 * uwrq, char *extra);
+static int wlan_get_mode(struct net_device *dev, struct iw_request_info *info,
+                         u32 * uwrq, char *extra);
+
+static int wlan_set_encode(struct net_device *dev,
+                           struct iw_request_info *info,
+                           struct iw_point *dwrq, char *extra);
+static int wlan_get_encode(struct net_device *dev,
+                           struct iw_request_info *info,
+                           struct iw_point *dwrq, u8 * extra);
+
+static int wlan_set_txpow(struct net_device *dev,
+                          struct iw_request_info *info, struct iw_param *vwrq,
+                          char *extra);
+static int wlan_get_txpow(struct net_device *dev,
+                          struct iw_request_info *info, struct iw_param *vwrq,
+                          char *extra);
+
+static int wlan_set_coalescing_ioctl(wlan_private * priv, struct iwreq *wrq);
+
+/** 
+ *  @brief This function checks if the commans is allowed
+ *  in deepsleep/hostsleep mode or not.
+ * 
+ *  @param req	       A pointer to ifreq structure 
+ *  @param cmd         the command ID
+ *  @return 	   TRUE or FALSE
+ */
+static BOOLEAN
+Is_Command_Allowed_In_Sleep(struct ifreq *req, int cmd,
+                            ioctl_cmd * allowed_cmds, int count)
+{
+    int subcmd = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+    int i;
+
+    for (i = 0; i < count; i++) {
+        if (cmd == allowed_cmds[i].cmd) {
+            if (allowed_cmds[i].subcmd == 0)
+                return TRUE;
+            if (allowed_cmds[i].fixsize == TRUE)
+                subcmd = (int) req->ifr_data;
+            else
+                subcmd = wrq->u.data.flags;
+            if (allowed_cmds[i].subcmd == subcmd)
+                return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+/** 
+ *  @brief This function checks if the commans is allowed.
+ * 
+ *  @param priv		A pointer to wlan_private structure
+ *  @return		TRUE or FALSE
+ */
+BOOLEAN
+Is_Command_Allowed(wlan_private * priv)
+{
+    BOOLEAN ret = TRUE;
+
+    if ((priv->adapter->IsDeepSleep == TRUE)) {
+        PRINTM(INFO, "IOCTLS called when station is in DeepSleep\n");
+        ret = FALSE;
+    }
+
+    return ret;
+}
+
+/** 
+ *  @brief Find a character in a string.
+ *   
+ *  @param s	   A pointer to string
+ *  @param c	   Character to be located 
+ *  @param dlen    the length of string
+ *  @return 	   A pointer to the first occurrence of c in string, or NULL if c is not found.
+ */
+static void *
+wlan_memchr(void *s, int c, int n)
+{
+    const u8 *p = s;
+
+    while (n-- != 0) {
+        if ((u8) c == *p++) {
+            return (void *) (p - 1);
+        }
+    }
+    return NULL;
+}
+
+#if WIRELESS_EXT > 14
+/** 
+ *  @brief Convert mw value to dbm value
+ *   
+ *  @param mw	   the value of mw
+ *  @return 	   the value of dbm
+ */
+static int
+mw_to_dbm(int mw)
+{
+    if (mw < 2)
+        return 0;
+    else if (mw < 3)
+        return 3;
+    else if (mw < 4)
+        return 5;
+    else if (mw < 6)
+        return 7;
+    else if (mw < 7)
+        return 8;
+    else if (mw < 8)
+        return 9;
+    else if (mw < 10)
+        return 10;
+    else if (mw < 13)
+        return 11;
+    else if (mw < 16)
+        return 12;
+    else if (mw < 20)
+        return 13;
+    else if (mw < 25)
+        return 14;
+    else if (mw < 32)
+        return 15;
+    else if (mw < 40)
+        return 16;
+    else if (mw < 50)
+        return 17;
+    else if (mw < 63)
+        return 18;
+    else if (mw < 79)
+        return 19;
+    else if (mw < 100)
+        return 20;
+    else
+        return 21;
+}
+#endif
+
+/** 
+ *  @brief Find the channel frequency power info with specific channel
+ *   
+ *  @param adapter 	A pointer to wlan_adapter structure
+ *  @param band		it can be BAND_A, BAND_G or BAND_B
+ *  @param channel      the channel for looking	
+ *  @return 	   	A pointer to CHANNEL_FREQ_POWER structure or NULL if not find.
+ */
+CHANNEL_FREQ_POWER *
+find_cfp_by_band_and_channel(wlan_adapter * adapter, u8 band, u16 channel)
+{
+    CHANNEL_FREQ_POWER *cfp = NULL;
+    REGION_CHANNEL *rc;
+    int count = sizeof(adapter->region_channel) /
+        sizeof(adapter->region_channel[0]);
+    int i, j;
+
+    for (j = 0; !cfp && (j < count); j++) {
+        rc = &adapter->region_channel[j];
+
+        if (adapter->State11D.Enable11D == ENABLE_11D) {
+            rc = &adapter->universal_channel[j];
+        }
+        if (!rc->Valid || !rc->CFP)
+            continue;
+        if (rc->Band != band)
+            continue;
+        for (i = 0; i < rc->NrCFP; i++) {
+            if (rc->CFP[i].Channel == channel) {
+                cfp = &rc->CFP[i];
+                break;
+            }
+        }
+    }
+
+    if (!cfp && channel)
+        PRINTM(INFO, "find_cfp_by_band_and_channel(): cannot find "
+               "cfp by band %d & channel %d\n", band, channel);
+
+    return cfp;
+}
+
+/** 
+ *  @brief Find the channel frequency power info with specific frequency
+ *   
+ *  @param adapter 	A pointer to wlan_adapter structure
+ *  @param band		it can be BAND_A, BAND_G or BAND_B
+ *  @param freq	        the frequency for looking	
+ *  @return 	   	A pointer to CHANNEL_FREQ_POWER structure or NULL if not find.
+ */
+static CHANNEL_FREQ_POWER *
+find_cfp_by_band_and_freq(wlan_adapter * adapter, u8 band, u32 freq)
+{
+    CHANNEL_FREQ_POWER *cfp = NULL;
+    REGION_CHANNEL *rc;
+    int count = sizeof(adapter->region_channel) /
+        sizeof(adapter->region_channel[0]);
+    int i, j;
+
+    for (j = 0; !cfp && (j < count); j++) {
+        rc = &adapter->region_channel[j];
+
+        if (adapter->State11D.Enable11D == ENABLE_11D) {
+            rc = &adapter->universal_channel[j];
+        }
+
+        if (!rc->Valid || !rc->CFP)
+            continue;
+        if (rc->Band != band)
+            continue;
+        for (i = 0; i < rc->NrCFP; i++) {
+            if (rc->CFP[i].Freq == freq) {
+                cfp = &rc->CFP[i];
+                break;
+            }
+        }
+    }
+
+    if (!cfp && freq)
+        PRINTM(INFO, "find_cfp_by_band_and_freql(): cannot find cfp by "
+               "band %d & freq %d\n", band, freq);
+
+    return cfp;
+}
+
+#ifdef MFG_CMD_SUPPORT
+/** 
+ *  @brief Manufacturing command ioctl function
+ *   
+ *  @param priv 	A pointer to wlan_private structure
+ *  @param userdata	A pointer to user buf
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+static int
+wlan_mfg_command(wlan_private * priv, void *userdata)
+{
+    PkHeader *pkHdr;
+    int len, ret;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    // creating the cmdbuf
+    if (Adapter->mfg_cmd == NULL) {
+        PRINTM(INFO, "Creating cmdbuf\n");
+        if (!
+            (Adapter->mfg_cmd =
+             kmalloc(MRVDRV_SIZE_OF_CMD_BUFFER, GFP_KERNEL))) {
+            PRINTM(INFO, "kmalloc failed!\n");
+            return WLAN_STATUS_FAILURE;
+        }
+        Adapter->mfg_cmd_len = MRVDRV_SIZE_OF_CMD_BUFFER;
+    }
+    // get PktHdr from userdata
+    if (copy_from_user(Adapter->mfg_cmd, userdata, sizeof(PkHeader))) {
+        PRINTM(INFO, "copy from user failed :PktHdr\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto mfg_exit;
+    }
+    // get the size
+    pkHdr = (PkHeader *) Adapter->mfg_cmd;
+    len = pkHdr->len;
+
+    PRINTM(INFO, "cmdlen = %d\n", (u32) len);
+
+    while (len >= Adapter->mfg_cmd_len) {
+        kfree(Adapter->mfg_cmd);
+
+        if (!(Adapter->mfg_cmd = kmalloc(len + 256, GFP_KERNEL))) {
+            PRINTM(INFO, "kmalloc failed!\n");
+            return WLAN_STATUS_FAILURE;
+        }
+
+        Adapter->mfg_cmd_len = len + 256;
+    }
+
+    // get the whole command from user
+    if (copy_from_user(Adapter->mfg_cmd, userdata, len)) {
+        PRINTM(INFO, "copy from user failed :PktHdr\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto mfg_exit;
+    }
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_MFG_COMMAND,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    if (ret) {
+        goto mfg_exit;
+    }
+    // copy it back to user
+    if (Adapter->mfg_cmd_resp_len > 0) {
+        if (copy_to_user(userdata, Adapter->mfg_cmd, len)) {
+            PRINTM(INFO, "copy to user failed \n");
+            ret = WLAN_STATUS_FAILURE;
+        }
+    }
+
+  mfg_exit:
+    kfree(Adapter->mfg_cmd);
+    Adapter->mfg_cmd = NULL;
+    Adapter->mfg_cmd_len = 0;
+    LEAVE();
+    return ret;
+}
+#endif
+
+/** 
+ *  @brief Check if Rate Auto
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @return 	   		TRUE/FALSE
+ */
+BOOLEAN
+Is_Rate_Auto(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i;
+    int ratenum = 0;
+    int bitsize = 0;
+    bitsize = sizeof(Adapter->RateBitmap) * 8;
+    for (i = 0; i < bitsize; i++) {
+        if (Adapter->RateBitmap & (1 << i))
+            ratenum++;
+        if (ratenum > 1)
+            break;
+    }
+    if (ratenum > 1)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+/** 
+ *  @brief Covert Rate Bitmap to Rate index
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @return 	   		TRUE/FALSE
+ */
+int
+GetRateIndex(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int bitsize = sizeof(Adapter->RateBitmap) * 8;
+    int i;
+    for (i = 0; i < bitsize; i++) {
+        if (Adapter->RateBitmap & (1 << i))
+            return i;
+    }
+    return 0;
+}
+
+/** 
+ *  @brief Update Current Channel 
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+static int
+UpdateCurrentChannel(wlan_private * priv)
+{
+    int ret;
+
+    /*
+     ** the channel in f/w could be out of sync, get the current channel
+     */
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RF_CHANNEL,
+                                HostCmd_OPT_802_11_RF_CHANNEL_GET,
+                                HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    PRINTM(INFO, "Current Channel = %d\n",
+           priv->adapter->CurBssParams.channel);
+
+    return ret;
+}
+
+/** 
+ *  @brief Set Current Channel 
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @param channel		The channel to be set. 
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+static int
+SetCurrentChannel(wlan_private * priv, int channel)
+{
+    PRINTM(INFO, "Set Channel = %d\n", channel);
+
+    /* 
+     **  Current channel is not set to AdhocChannel requested, set channel
+     */
+    return (PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RF_CHANNEL,
+                                  HostCmd_OPT_802_11_RF_CHANNEL_SET,
+                                  HostCmd_OPTION_WAITFORRSP, 0, &channel));
+}
+
+/** 
+ *  @brief Change Adhoc Channel
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @param channel		The channel to be set. 
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+static int
+ChangeAdhocChannel(wlan_private * priv, int channel)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    Adapter->AdhocChannel = channel;
+
+    UpdateCurrentChannel(priv);
+
+    if (Adapter->CurBssParams.channel == Adapter->AdhocChannel) {
+        /* AdhocChannel is set to the current Channel already */
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    PRINTM(INFO, "Updating Channel from %d to %d\n",
+           Adapter->CurBssParams.channel, Adapter->AdhocChannel);
+
+    SetCurrentChannel(priv, Adapter->AdhocChannel);
+
+    UpdateCurrentChannel(priv);
+
+    if (Adapter->CurBssParams.channel != Adapter->AdhocChannel) {
+        PRINTM(INFO, "Failed to updated Channel to %d, channel = %d\n",
+               Adapter->AdhocChannel, Adapter->CurBssParams.channel);
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        int i;
+        WLAN_802_11_SSID curAdhocSsid;
+
+        PRINTM(INFO, "Channel Changed while in an IBSS\n");
+
+        /* Copy the current ssid */
+        memcpy(&curAdhocSsid, &Adapter->CurBssParams.ssid,
+               sizeof(WLAN_802_11_SSID));
+
+        /* Exit Adhoc mode */
+        PRINTM(INFO, "In ChangeAdhocChannel(): Sending Adhoc Stop\n");
+        ret = StopAdhocNetwork(priv);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+
+        /* Scan for the network */
+        SendSpecificSSIDScan(priv, &curAdhocSsid);
+
+        // find out the BSSID that matches the current SSID 
+        i = FindSSIDInList(Adapter, &curAdhocSsid, NULL, Wlan802_11IBSS);
+
+        if (i >= 0) {
+            PRINTM(INFO, "SSID found at %d in List," "so join\n", i);
+            JoinAdhocNetwork(priv, &Adapter->ScanTable[i]);
+        } else {
+            // else send START command
+            PRINTM(INFO, "SSID not found in list, "
+                   "so creating adhoc with ssid = %s\n", curAdhocSsid.Ssid);
+            StartAdhocNetwork(priv, &curAdhocSsid);
+        }                       // end of else (START command)
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set WPA key
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_encode_wpa(struct net_device *dev,
+                    struct iw_request_info *info,
+                    struct iw_point *dwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    PWLAN_802_11_KEY pKey;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    pKey = (PWLAN_802_11_KEY) extra;
+
+    HEXDUMP("Key buffer: ", extra, dwrq->length);
+
+    // current driver only supports key length of up to 32 bytes
+    if (pKey->KeyLength > MRVL_MAX_WPA_KEY_LENGTH) {
+        PRINTM(INFO, " Error in key length \n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_KEY_MATERIAL,
+                                HostCmd_ACT_SET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                KEY_INFO_ENABLED, pKey);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/*
+ *  iwconfig ethX key on:	WEPEnabled;
+ *  iwconfig ethX key off:	WEPDisabled;
+ *  iwconfig ethX key [x]:	CurrentWepKeyIndex = x; WEPEnabled;
+ *  iwconfig ethX key [x] kstr:	WepKey[x] = kstr;
+ *  iwconfig ethX key kstr:	WepKey[CurrentWepKeyIndex] = kstr;
+ *
+ *  all:			Send command SET_WEP;
+ 				SetMacPacketFilter;
+ */
+
+/** 
+ *  @brief Set WEP key
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_encode_nonwpa(struct net_device *dev,
+                       struct iw_request_info *info,
+                       struct iw_point *dwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    MRVL_WEP_KEY *pWep;
+    WLAN_802_11_SSID ssid;
+    int index, PrevAuthMode;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (Adapter->CurrentWepKeyIndex >= MRVL_NUM_WEP_KEY)
+        Adapter->CurrentWepKeyIndex = 0;
+    pWep = &Adapter->WepKey[Adapter->CurrentWepKeyIndex];
+    PrevAuthMode = Adapter->SecInfo.AuthenticationMode;
+
+    index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
+
+    if (index >= 4) {
+        PRINTM(INFO, "Key index #%d out of range.\n", index + 1);
+        return -EINVAL;
+    }
+
+    PRINTM(INFO, "Flags=0x%x, Length=%d Index=%d CurrentWepKeyIndex=%d\n",
+           dwrq->flags, dwrq->length, index, Adapter->CurrentWepKeyIndex);
+
+    if (dwrq->length > 0) {
+        /* iwconfig ethX key [n] xxxxxxxxxxx 
+         * Key has been provided by the user 
+         */
+
+        /*
+         * Check the size of the key 
+         */
+
+        if (dwrq->length > MAX_KEY_SIZE) {
+            return -EINVAL;
+        }
+
+        /*
+         * Check the index (none -> use current) 
+         */
+
+        if (index < 0 || index > 3)     //invalid index or no index
+            index = Adapter->CurrentWepKeyIndex;
+        else                    //index is given & valid
+            pWep = &Adapter->WepKey[index];
+
+        /*
+         * Check if the key is not marked as invalid 
+         */
+        if (!(dwrq->flags & IW_ENCODE_NOKEY)) {
+            /* Cleanup */
+            memset(pWep, 0, sizeof(MRVL_WEP_KEY));
+
+            /* Copy the key in the driver */
+            memcpy(pWep->KeyMaterial, extra, dwrq->length);
+
+            /* Set the length */
+            if (dwrq->length > MIN_KEY_SIZE) {
+                pWep->KeyLength = MAX_KEY_SIZE;
+            } else {
+                if (dwrq->length > 0) {
+                    pWep->KeyLength = MIN_KEY_SIZE;
+                } else {
+                    /* Disable the key */
+                    pWep->KeyLength = 0;
+                }
+            }
+            pWep->KeyIndex = index;
+
+            if (Adapter->SecInfo.WEPStatus != Wlan802_11WEPEnabled) {
+                /*
+                 * The status is set as Key Absent 
+                 * so as to make sure we display the 
+                 * keys when iwlist ethX key is 
+                 * used - MPS 
+                 */
+
+                Adapter->SecInfo.WEPStatus = Wlan802_11WEPKeyAbsent;
+            }
+
+            PRINTM(INFO, "KeyIndex=%u KeyLength=%u\n",
+                   pWep->KeyIndex, pWep->KeyLength);
+            HEXDUMP("WepKey", (u8 *) pWep->KeyMaterial, pWep->KeyLength);
+        }
+    } else {
+        /*
+         * No key provided so it is either enable key, 
+         * on or off */
+        if (dwrq->flags & IW_ENCODE_DISABLED) {
+            PRINTM(INFO, "*** iwconfig ethX key off ***\n");
+
+            Adapter->SecInfo.WEPStatus = Wlan802_11WEPDisabled;
+            if (Adapter->SecInfo.AuthenticationMode ==
+                Wlan802_11AuthModeShared)
+                Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+        } else {
+            /* iwconfig ethX key [n]
+             * iwconfig ethX key on 
+             * Do we want to just set the transmit key index ? 
+             */
+
+            if (index < 0 || index > 3) {
+                PRINTM(INFO, "*** iwconfig ethX key on ***\n");
+                index = Adapter->CurrentWepKeyIndex;
+            } else {
+                PRINTM(INFO, "*** iwconfig ethX key [x=%d] ***\n", index);
+                Adapter->CurrentWepKeyIndex = index;
+            }
+
+            /* Copy the required key as the current key */
+            pWep = &Adapter->WepKey[index];
+
+            if (!pWep->KeyLength) {
+                PRINTM(INFO, "Key not set,so cannot enable it\n");
+                return -EPERM;
+            }
+
+            Adapter->SecInfo.WEPStatus = Wlan802_11WEPEnabled;
+
+            HEXDUMP("KeyMaterial", (u8 *) pWep->KeyMaterial, pWep->KeyLength);
+        }
+    }
+
+    if (pWep->KeyLength) {
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_SET_WEP,
+                                    0, HostCmd_OPTION_WAITFORRSP,
+                                    OID_802_11_ADD_WEP, NULL);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    }
+
+    if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled) {
+        Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_WEP_ENABLE;
+    } else {
+        Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_WEP_ENABLE;
+    }
+
+    SetMacPacketFilter(priv);
+
+    if (dwrq->flags & IW_ENCODE_RESTRICTED) {
+        /* iwconfig ethX restricted key [1] */
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeShared;
+        PRINTM(INFO, "Auth mode restricted!\n");
+    } else if (dwrq->flags & IW_ENCODE_OPEN) {
+        /* iwconfig ethX key [2] open */
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+        PRINTM(INFO, "Auth mode open!\n");
+    }
+
+    /*
+     * If authentication mode changed - de-authenticate, set authentication
+     * method and re-associate if we were previously associated.
+     */
+    if (Adapter->SecInfo.AuthenticationMode != PrevAuthMode) {
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected &&
+            Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+
+            /* keep a copy of the ssid associated with */
+            memcpy(&ssid, &Adapter->CurBssParams.ssid, sizeof(ssid));
+
+            /*
+             * De-authenticate from AP 
+             */
+
+            ret = SendDeauthentication(priv);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+
+        } else {
+            /* reset ssid */
+            memset(&ssid, 0, sizeof(ssid));
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set RX Antenna
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param Mode			RF antenna mode
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+SetRxAntenna(wlan_private * priv, int Mode)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    if (Mode != RF_ANTENNA_1 && Mode != RF_ANTENNA_2
+        && Mode != RF_ANTENNA_AUTO) {
+        return -EINVAL;
+    }
+
+    Adapter->RxAntennaMode = Mode;
+
+    PRINTM(INFO, "SET RX Antenna Mode to 0x%04x\n", Adapter->RxAntennaMode);
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RF_ANTENNA,
+                                HostCmd_ACT_SET_RX, HostCmd_OPTION_WAITFORRSP,
+                                0, &Adapter->RxAntennaMode);
+    return ret;
+}
+
+/** 
+ *  @brief Set TX Antenna
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param Mode			RF antenna mode
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+SetTxAntenna(wlan_private * priv, int Mode)
+{
+    int ret = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    if ((Mode != RF_ANTENNA_1) && (Mode != RF_ANTENNA_2)
+        && (Mode != RF_ANTENNA_AUTO)) {
+        return -EINVAL;
+    }
+
+    Adapter->TxAntennaMode = Mode;
+
+    PRINTM(INFO, "SET TX Antenna Mode to 0x%04x\n", Adapter->TxAntennaMode);
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RF_ANTENNA,
+                                HostCmd_ACT_SET_TX, HostCmd_OPTION_WAITFORRSP,
+                                0, &Adapter->TxAntennaMode);
+
+    return ret;
+}
+
+/** 
+ *  @brief Get RX Antenna
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param buf			A pointer to recieve antenna mode
+ *  @return 	   		length of buf 
+ */
+static int
+GetRxAntenna(wlan_private * priv, char *buf)
+{
+    int ret = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    // clear it, so we will know if the value 
+    // returned below is correct or not.
+    Adapter->RxAntennaMode = 0;
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RF_ANTENNA,
+                                HostCmd_ACT_GET_RX, HostCmd_OPTION_WAITFORRSP,
+                                0, NULL);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    PRINTM(INFO, "Get Rx Antenna Mode:0x%04x\n", Adapter->RxAntennaMode);
+
+    LEAVE();
+
+    return sprintf(buf, "0x%04x", Adapter->RxAntennaMode) + 1;
+}
+
+/** 
+ *  @brief Get TX Antenna
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param buf			A pointer to recieve antenna mode
+ *  @return 	   		length of buf 
+ */
+static int
+GetTxAntenna(wlan_private * priv, char *buf)
+{
+    int ret = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    // clear it, so we will know if the value 
+    // returned below is correct or not.
+    Adapter->TxAntennaMode = 0;
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RF_ANTENNA,
+                                HostCmd_ACT_GET_TX, HostCmd_OPTION_WAITFORRSP,
+                                0, NULL);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    PRINTM(INFO, "Get Tx Antenna Mode:0x%04x\n", Adapter->TxAntennaMode);
+
+    LEAVE();
+
+    return sprintf(buf, "0x%04x", Adapter->TxAntennaMode) + 1;
+}
+
+/** 
+ *  @brief Set Radio On/OFF
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @option 			Radio Option
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+static int
+wlan_radio_ioctl(wlan_private * priv, u8 option)
+{
+    int ret = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->RadioOn != option) {
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            PRINTM(MSG, "Cannot turn radio off in connected state.\n");
+            LEAVE();
+            return -EINVAL;
+        }
+
+        PRINTM(INFO, "Switching %s the Radio\n", option ? "On" : "Off");
+        Adapter->RadioOn = option;
+
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_RADIO_CONTROL,
+                                    HostCmd_ACT_GEN_SET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, NULL);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+#ifdef REASSOCIATION
+/** 
+ *  @brief Set Auto Reassociation On
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+static int
+reassociation_on(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    Adapter->Reassoc_on = TRUE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Auto Reassociation Off
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+static int
+reassociation_off(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->TimerIsSet == TRUE) {
+        CancelTimer(&Adapter->MrvDrvTimer);
+        Adapter->TimerIsSet = FALSE;
+    }
+
+    Adapter->Reassoc_on = FALSE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+#endif /* REASSOCIATION */
+
+/** 
+ *  @brief Set Region
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param region_code		region code
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+static int
+wlan_set_region(wlan_private * priv, u16 region_code)
+{
+    int i;
+
+    ENTER();
+
+    for (i = 0; i < MRVDRV_MAX_REGION_CODE; i++) {
+        // use the region code to search for the index
+        if (region_code == RegionCodeToIndex[i]) {
+            priv->adapter->RegionTableIndex = (u16) i;
+            priv->adapter->RegionCode = region_code;
+            break;
+        }
+    }
+
+    // if it's unidentified region code
+    if (i >= MRVDRV_MAX_REGION_CODE) {
+        PRINTM(INFO, "Region Code not identified\n");
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    if (wlan_set_regiontable(priv, priv->adapter->RegionCode, 0)) {
+        LEAVE();
+        return -EINVAL;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Copy Rates
+ *   
+ *  @param dest                 A pointer to Dest Buf
+ *  @param src		        A pointer to Src Buf
+ *  @param len                  The len of Src Buf
+ *  @return 	   	        Number of Rates copyed 
+ */
+static inline int
+CopyRates(u8 * dest, int pos, u8 * src, int len)
+{
+    int i;
+
+    for (i = 0; i < len && src[i]; i++, pos++) {
+        if (pos >= sizeof(WLAN_802_11_RATES))
+            break;
+        dest[pos] = src[i];
+    }
+
+    return pos;
+}
+
+/** 
+ *  @brief Get active data rates
+ *   
+ *  @param Adapter              A pointer to wlan_adapter structure
+ *  @param rate		        The buf to return the active rates
+ *  @return 	   	        The number of Rates
+ */
+static int
+get_active_data_rates(wlan_adapter * Adapter, WLAN_802_11_RATES rates)
+{
+    int k = 0;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus != WlanMediaStateConnected) {
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+            //Infra. mode
+            PRINTM(INFO, "Infra\n");
+            k = CopyRates(rates, k, SupportedRates, sizeof(SupportedRates));
+        } else {
+            //ad-hoc mode
+            PRINTM(INFO, "Adhoc G\n");
+            k = CopyRates(rates, k, AdhocRates_G, sizeof(AdhocRates_G));
+        }
+    } else {
+        k = CopyRates(rates, 0, Adapter->CurBssParams.DataRates,
+                      Adapter->CurBssParams.NumOfRates);
+    }
+
+    LEAVE();
+
+    return k;
+}
+
+/** 
+ *  @brief Get/Set Firmware wakeup method
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_txcontrol(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data;
+    ENTER();
+
+    if ((int) wrq->u.data.length == 0) {
+        if (copy_to_user
+            (wrq->u.data.pointer, &Adapter->PktTxCtrl, sizeof(u32))) {
+            PRINTM(MSG, "copy_to_user failed!\n");
+            return -EFAULT;
+        }
+    } else {
+        if ((int) wrq->u.data.length > 1) {
+            PRINTM(MSG, "ioctl too many args!\n");
+            return -EFAULT;
+        }
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        Adapter->PktTxCtrl = (u32) data;
+    }
+
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Enable/Disable atim uapsd null package generation
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_null_pkg_gen(wlan_private * priv, struct iwreq *wrq)
+{
+    int data;
+    wlan_adapter *Adapter = priv->adapter;
+    int *val;
+
+    ENTER();
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    PRINTM(INFO, "Enable UAPSD NULL PKG: %s\n",
+           (data == CMD_ENABLED) ? "Enable" : "Disable");
+    switch (data) {
+    case CMD_ENABLED:
+        Adapter->gen_null_pkg = TRUE;
+        break;
+    case CMD_DISABLED:
+        Adapter->gen_null_pkg = FALSE;
+        break;
+    default:
+        break;
+    }
+
+    data = (Adapter->gen_null_pkg == TRUE) ? CMD_ENABLED : CMD_DISABLED;
+    val = (int *) wrq->u.name;
+    *val = data;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set NULL Package generation interval
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_null_pkt_interval(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data;
+    ENTER();
+
+    if ((int) wrq->u.data.length == 0) {
+        data = Adapter->NullPktInterval;
+
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(MSG, "copy_to_user failed!\n");
+            return -EFAULT;
+        }
+    } else {
+        if ((int) wrq->u.data.length > 1) {
+            PRINTM(MSG, "ioctl too many args!\n");
+            return -EFAULT;
+        }
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        Adapter->NullPktInterval = data;
+    }
+
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Adhoc awake period 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_adhoc_awake_period(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data;
+    ENTER();
+
+    if ((int) wrq->u.data.length == 0) {
+        data = Adapter->AdhocAwakePeriod;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(MSG, "copy_to_user failed!\n");
+            return -EFAULT;
+        }
+    } else {
+        if ((int) wrq->u.data.length > 1) {
+            PRINTM(MSG, "ioctl too many args!\n");
+            return -EFAULT;
+        }
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+#define AWAKE_PERIOD_MIN 1
+#define AWAKE_PERIOD_MAX 31
+#define DISABLE_AWAKE_PERIOD 0xff
+        if ((((data & 0xff) >= AWAKE_PERIOD_MIN) &&
+             ((data & 0xff) <= AWAKE_PERIOD_MAX)) ||
+            ((data & 0xff) == DISABLE_AWAKE_PERIOD))
+            Adapter->AdhocAwakePeriod = (u16) data;
+        else {
+            PRINTM(INFO,
+                   "Invalid parameter, AdhocAwakePeriod not changed.\n");
+            return -EINVAL;
+
+        }
+    }
+    wrq->u.data.length = 1;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set LDO config
+ *  @param priv			A pointer to wlan_private structure
+ *  @param wrq			A pointer to wrq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_ldo_config(wlan_private * priv, struct iwreq *wrq)
+{
+    HostCmd_DS_802_11_LDO_CONFIG ldocfg;
+    int data = 0;
+    u16 action;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0) {
+        action = HostCmd_ACT_GEN_GET;
+    } else if (wrq->u.data.length > 1) {
+        PRINTM(MSG, "ioctl too many args!\n");
+        ret = -EFAULT;
+        goto ldoexit;
+    } else {
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+            goto ldoexit;
+        }
+        if (data != LDO_INTERNAL && data != LDO_EXTERNAL) {
+            PRINTM(MSG, "Invalid parameter, LDO config not changed.\n");
+            ret = -EFAULT;
+            goto ldoexit;
+        }
+        action = HostCmd_ACT_GEN_SET;
+    }
+    ldocfg.Action = action;
+    ldocfg.PMSource = (u16) data;
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_LDO_CONFIG,
+                                action, HostCmd_OPTION_WAITFORRSP,
+                                0, (void *) &ldocfg);
+
+    if (!ret && action == HostCmd_ACT_GEN_GET) {
+        data = (int) ldocfg.PMSource;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+            goto ldoexit;
+        }
+        wrq->u.data.length = 1;
+    }
+
+  ldoexit:
+    LEAVE();
+    return ret;
+}
+
+#ifdef DEBUG_LEVEL1
+/** 
+ *  @brief Get/Set the bit mask of driver debug message control
+ *  @param priv			A pointer to wlan_private structure
+ *  @param wrq			A pointer to wrq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_drv_dbg(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[4];
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0) {
+        data[0] = drvdbg;
+        data[1] = ifdbg;
+        /* Return the current driver debug bit masks */
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 2)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+            goto drvdbgexit;
+        }
+        wrq->u.data.length = 2;
+    } else if (wrq->u.data.length < 3) {
+        /* Get the driver debug bit masks */
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+            goto drvdbgexit;
+        }
+        drvdbg = data[0];
+        if (wrq->u.data.length == 2)
+            ifdbg = data[1];
+    } else {
+        PRINTM(INFO, "Invalid parameter number\n");
+        goto drvdbgexit;
+    }
+
+    printk(KERN_ALERT "drvdbg = 0x%x\n", drvdbg);
+#ifdef DEBUG_LEVEL2
+    printk(KERN_ALERT "INFO  (%08x) %s\n", DBG_INFO,
+           (drvdbg & DBG_INFO) ? "X" : "");
+    printk(KERN_ALERT "WARN  (%08x) %s\n", DBG_WARN,
+           (drvdbg & DBG_WARN) ? "X" : "");
+    printk(KERN_ALERT "ENTRY (%08x) %s\n", DBG_ENTRY,
+           (drvdbg & DBG_ENTRY) ? "X" : "");
+#endif
+    printk(KERN_ALERT "FW_D  (%08x) %s\n", DBG_FW_D,
+           (drvdbg & DBG_FW_D) ? "X" : "");
+    printk(KERN_ALERT "CMD_D (%08x) %s\n", DBG_CMD_D,
+           (drvdbg & DBG_CMD_D) ? "X" : "");
+    printk(KERN_ALERT "DAT_D (%08x) %s\n", DBG_DAT_D,
+           (drvdbg & DBG_DAT_D) ? "X" : "");
+    printk(KERN_ALERT "INTR  (%08x) %s\n", DBG_INTR,
+           (drvdbg & DBG_INTR) ? "X" : "");
+    printk(KERN_ALERT "EVENT (%08x) %s\n", DBG_EVENT,
+           (drvdbg & DBG_EVENT) ? "X" : "");
+    printk(KERN_ALERT "CMND  (%08x) %s\n", DBG_CMND,
+           (drvdbg & DBG_CMND) ? "X" : "");
+    printk(KERN_ALERT "DATA  (%08x) %s\n", DBG_DATA,
+           (drvdbg & DBG_DATA) ? "X" : "");
+    printk(KERN_ALERT "ERROR (%08x) %s\n", DBG_ERROR,
+           (drvdbg & DBG_ERROR) ? "X" : "");
+    printk(KERN_ALERT "FATAL (%08x) %s\n", DBG_FATAL,
+           (drvdbg & DBG_FATAL) ? "X" : "");
+    printk(KERN_ALERT "MSG   (%08x) %s\n", DBG_MSG,
+           (drvdbg & DBG_MSG) ? "X" : "");
+    printk(KERN_ALERT "ifdbg = 0x%x\n", ifdbg);
+    printk(KERN_ALERT "IF_D  (%08x) %s\n", DBG_IF_D,
+           (ifdbg & DBG_IF_D) ? "X" : "");
+
+  drvdbgexit:
+    LEAVE();
+    return ret;
+}
+#endif
+
+/** 
+ *  @brief Commit handler: called after a bunch of SET operations
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_config_commit(struct net_device *dev,
+                   struct iw_request_info *info, char *cwrq, char *extra)
+{
+    ENTER();
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get protocol name 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_name(struct net_device *dev, struct iw_request_info *info,
+              char *cwrq, char *extra)
+{
+    const char *cp;
+    char comm[6] = { "COMM-" };
+    char mrvl[6] = { "MRVL-" };
+    int cnt;
+
+    ENTER();
+
+    strcpy(cwrq, mrvl);
+
+    cp = strstr(driver_version, comm);
+    if (cp == driver_version)   //skip leading "COMM-"
+        cp = driver_version + strlen(comm);
+    else
+        cp = driver_version;
+
+    cnt = strlen(mrvl);
+    cwrq += cnt;
+    while (cnt < 16 && (*cp != '-')) {
+        *cwrq++ = toupper(*cp++);
+        cnt++;
+    }
+    *cwrq = '\0';
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get frequency
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param fwrq 		A pointer to iw_freq structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_freq(struct net_device *dev, struct iw_request_info *info,
+              struct iw_freq *fwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    CHANNEL_FREQ_POWER *cfp;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    cfp = find_cfp_by_band_and_channel(Adapter, 0,
+                                       (u16) Adapter->CurBssParams.channel);
+
+    if (!cfp) {
+        if (Adapter->CurBssParams.channel)
+            PRINTM(INFO, "Invalid channel=%d\n",
+                   Adapter->CurBssParams.channel);
+        return -EINVAL;
+    }
+
+    fwrq->m = (long) cfp->Freq * 100000;
+    fwrq->e = 1;
+
+    PRINTM(INFO, "freq=%u\n", fwrq->m);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get current BSSID
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param awrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
+             struct sockaddr *awrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        memcpy(awrq->sa_data, Adapter->CurBssParams.bssid, ETH_ALEN);
+    } else {
+        memset(awrq->sa_data, 0, ETH_ALEN);
+    }
+    awrq->sa_family = ARPHRD_ETHER;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Adapter Node Name
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_nick(struct net_device *dev, struct iw_request_info *info,
+              struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /*
+     * Check the size of the string 
+     */
+
+    if (dwrq->length > 16) {
+        return -E2BIG;
+    }
+
+    memset(Adapter->nodeName, 0, sizeof(Adapter->nodeName));
+    memcpy(Adapter->nodeName, extra, dwrq->length);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Adapter Node Name
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_nick(struct net_device *dev, struct iw_request_info *info,
+              struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /*
+     * Get the Nick Name saved 
+     */
+
+    strncpy(extra, Adapter->nodeName, 16);
+
+    extra[16] = '\0';
+
+    /*
+     * If none, we may want to get the one that was set 
+     */
+
+    /*
+     * Push it out ! 
+     */
+    //hufh dwrq->length = strlen(extra) + 1;
+    dwrq->length = strlen(extra);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set RTS threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
+             struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int rthr = vwrq->value;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (vwrq->disabled) {
+        Adapter->RTSThsd = rthr = MRVDRV_RTS_MAX_VALUE;
+    } else {
+        if (rthr < MRVDRV_RTS_MIN_VALUE || rthr > MRVDRV_RTS_MAX_VALUE)
+            return -EINVAL;
+        Adapter->RTSThsd = rthr;
+    }
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                                HostCmd_ACT_SET, HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11_RTS_THRESHOLD, &rthr);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get RTS threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
+             struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    Adapter->RTSThsd = 0;
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                                HostCmd_ACT_GET, HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11_RTS_THRESHOLD, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    vwrq->value = Adapter->RTSThsd;
+    vwrq->disabled = ((vwrq->value < MRVDRV_RTS_MIN_VALUE)
+                      || (vwrq->value > MRVDRV_RTS_MAX_VALUE));
+    vwrq->fixed = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Fragment threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_frag(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    int fthr = vwrq->value;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (vwrq->disabled) {
+        Adapter->FragThsd = fthr = MRVDRV_FRAG_MAX_VALUE;
+    } else {
+        if (fthr < MRVDRV_FRAG_MIN_VALUE || fthr > MRVDRV_FRAG_MAX_VALUE)
+            return -EINVAL;
+        Adapter->FragThsd = fthr;
+    }
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                                HostCmd_ACT_SET, HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11_FRAGMENTATION_THRESHOLD, &fthr);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get Fragment threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_frag(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    Adapter->FragThsd = 0;
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_SNMP_MIB, HostCmd_ACT_GET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11_FRAGMENTATION_THRESHOLD, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    vwrq->value = Adapter->FragThsd;
+    vwrq->disabled = ((vwrq->value < MRVDRV_FRAG_MIN_VALUE)
+                      || (vwrq->value > MRVDRV_FRAG_MAX_VALUE));
+    vwrq->fixed = 1;
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get Wlan Mode
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_mode(struct net_device *dev,
+              struct iw_request_info *info, u32 * uwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *adapter = priv->adapter;
+
+    ENTER();
+
+    switch (adapter->InfrastructureMode) {
+    case Wlan802_11IBSS:
+        *uwrq = IW_MODE_ADHOC;
+        break;
+
+    case Wlan802_11Infrastructure:
+        *uwrq = IW_MODE_INFRA;
+        break;
+
+    default:
+    case Wlan802_11AutoUnknown:
+        *uwrq = IW_MODE_AUTO;
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Encryption key
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_encode(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_point *dwrq, u8 * extra)
+{
+
+    wlan_private *priv = dev->priv;
+    wlan_adapter *adapter = priv->adapter;
+    int index = (dwrq->flags & IW_ENCODE_INDEX);
+
+    ENTER();
+
+    PRINTM(INFO, "flags=0x%x index=%d length=%d CurrentWepKeyIndex=%d\n",
+           dwrq->flags, index, dwrq->length, adapter->CurrentWepKeyIndex);
+    if (index < 0 || index > 4) {
+        PRINTM(INFO, "Key index #%d out of range.\n", index);
+        LEAVE();
+        return -EINVAL;
+    }
+    if (adapter->CurrentWepKeyIndex >= MRVL_NUM_WEP_KEY)
+        adapter->CurrentWepKeyIndex = 0;
+    dwrq->flags = 0;
+
+    /*
+     * Check encryption mode 
+     */
+
+    switch (adapter->SecInfo.AuthenticationMode) {
+    case Wlan802_11AuthModeOpen:
+        dwrq->flags = IW_ENCODE_OPEN;
+        break;
+
+    case Wlan802_11AuthModeShared:
+    case Wlan802_11AuthModeNetworkEAP:
+        dwrq->flags = IW_ENCODE_RESTRICTED;
+        break;
+    default:
+        dwrq->flags = IW_ENCODE_DISABLED | IW_ENCODE_OPEN;
+        break;
+    }
+
+    if ((adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled)
+        || (adapter->SecInfo.WEPStatus == Wlan802_11WEPKeyAbsent)
+        || adapter->SecInfo.WPAEnabled || adapter->SecInfo.WPA2Enabled) {
+        dwrq->flags &= ~IW_ENCODE_DISABLED;
+    } else {
+        dwrq->flags |= IW_ENCODE_DISABLED;
+    }
+
+    memset(extra, 0, 16);
+
+    if (!index) {
+        /* Handle current key request   */
+        if ((adapter->WepKey[adapter->CurrentWepKeyIndex].KeyLength) &&
+            (adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled)) {
+            index = adapter->WepKey[adapter->CurrentWepKeyIndex].KeyIndex;
+            memcpy(extra, adapter->WepKey[index].KeyMaterial,
+                   adapter->WepKey[index].KeyLength);
+            dwrq->length = adapter->WepKey[index].KeyLength;
+            /* return current key */
+            dwrq->flags |= (index + 1);
+            /* return WEP enabled */
+            dwrq->flags &= ~IW_ENCODE_DISABLED;
+        } else if ((adapter->SecInfo.WPAEnabled)
+                   || (adapter->SecInfo.WPA2Enabled)
+            ) {
+            /* return WPA enabled */
+            dwrq->flags &= ~IW_ENCODE_DISABLED;
+        } else {
+            dwrq->flags |= IW_ENCODE_DISABLED;
+        }
+    } else {
+        /* Handle specific key requests */
+        index--;
+        if (adapter->WepKey[index].KeyLength) {
+            memcpy(extra, adapter->WepKey[index].KeyMaterial,
+                   adapter->WepKey[index].KeyLength);
+            dwrq->length = adapter->WepKey[index].KeyLength;
+            /* return current key */
+            dwrq->flags |= (index + 1);
+            /* return WEP enabled */
+            dwrq->flags &= ~IW_ENCODE_DISABLED;
+        } else if ((adapter->SecInfo.WPAEnabled)
+                   || (adapter->SecInfo.WPA2Enabled)
+            ) {
+            /* return WPA enabled */
+            dwrq->flags &= ~IW_ENCODE_DISABLED;
+        } else {
+            dwrq->flags |= IW_ENCODE_DISABLED;
+        }
+    }
+
+    dwrq->flags |= IW_ENCODE_NOKEY;
+
+    PRINTM(INFO, "Key:%02x:%02x:%02x:%02x:%02x:%02x KeyLen=%d\n",
+           extra[0], extra[1], extra[2],
+           extra[3], extra[4], extra[5], dwrq->length);
+
+    if (adapter->EncryptionStatus == Wlan802_11Encryption2Enabled
+        && !dwrq->length) {
+        dwrq->length = MAX_KEY_SIZE;
+    }
+
+    PRINTM(INFO, "Return flags=0x%x\n", dwrq->flags);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get TX Power
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_txpow(struct net_device *dev,
+               struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_RF_TX_POWER,
+                                HostCmd_ACT_GEN_GET,
+                                HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    PRINTM(INFO, "TXPOWER GET %d dbm.\n", Adapter->TxPowerLevel);
+    vwrq->value = Adapter->TxPowerLevel;
+    vwrq->fixed = 1;
+    if (Adapter->RadioOn) {
+        vwrq->disabled = 0;
+        vwrq->flags = IW_TXPOW_DBM;
+    } else {
+        vwrq->disabled = 1;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set TX Retry Count
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_retry(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (vwrq->flags == IW_RETRY_LIMIT) {
+        /* The MAC has a 4-bit Total_Tx_Count register
+           Total_Tx_Count = 1 + Tx_Retry_Count */
+#define TX_RETRY_MIN 0
+#define TX_RETRY_MAX 14
+        if (vwrq->value < TX_RETRY_MIN || vwrq->value > TX_RETRY_MAX)
+            return -EINVAL;
+
+        /* Adding 1 to convert retry count to try count */
+        adapter->TxRetryCount = vwrq->value + 1;
+
+        ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                                    HostCmd_ACT_SET,
+                                    HostCmd_OPTION_WAITFORRSP,
+                                    OID_802_11_TX_RETRYCOUNT, NULL);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    } else {
+        return -EOPNOTSUPP;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get TX Retry Count
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_retry(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    Adapter->TxRetryCount = 0;
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_SNMP_MIB, HostCmd_ACT_GET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11_TX_RETRYCOUNT, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+    vwrq->disabled = 0;
+    if (!vwrq->flags) {
+        vwrq->flags = IW_RETRY_LIMIT;
+        /* Subtract 1 to convert try count to retry count */
+        vwrq->value = Adapter->TxRetryCount - 1;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Sort Channels
+ *   
+ *  @param freq 		A pointer to iw_freq structure
+ *  @param num		        number of Channels
+ *  @return 	   		NA
+ */
+static inline void
+sort_channels(struct iw_freq *freq, int num)
+{
+    int i, j;
+    struct iw_freq temp;
+
+    for (i = 0; i < num; i++)
+        for (j = i + 1; j < num; j++)
+            if (freq[i].i > freq[j].i) {
+                temp.i = freq[i].i;
+                temp.m = freq[i].m;
+
+                freq[i].i = freq[j].i;
+                freq[i].m = freq[j].m;
+
+                freq[j].i = temp.i;
+                freq[j].m = temp.m;
+            }
+}
+
+/* data rate listing
+	MULTI_BANDS:
+		abg		a	b	b/g
+   Infra 	G(12)		A(8)	B(4)	G(12)
+   Adhoc 	A+B(12)		A(8)	B(4)	B(4)
+
+	non-MULTI_BANDS:
+		   		 	b	b/g
+   Infra 	     		    	B(4)	G(12)
+   Adhoc 	      		    	B(4)	B(4)
+ */
+/** 
+ *  @brief Get Range Info
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_range(struct net_device *dev, struct iw_request_info *info,
+               struct iw_point *dwrq, char *extra)
+{
+    int i, j;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    struct iw_range *range = (struct iw_range *) extra;
+    CHANNEL_FREQ_POWER *cfp;
+    WLAN_802_11_RATES rates;
+
+    ENTER();
+
+    dwrq->length = sizeof(struct iw_range);
+    memset(range, 0, sizeof(struct iw_range));
+
+    range->min_nwid = 0;
+    range->max_nwid = 0;
+
+    memset(rates, 0, sizeof(rates));
+    range->num_bitrates = get_active_data_rates(Adapter, rates);
+    if (range->num_bitrates > sizeof(rates))
+        range->num_bitrates = sizeof(rates);
+
+    for (i = 0; i < MIN(range->num_bitrates, IW_MAX_BITRATES) && rates[i];
+         i++) {
+        range->bitrate[i] = (rates[i] & 0x7f) * 500000;
+    }
+    range->num_bitrates = i;
+    PRINTM(INFO, "IW_MAX_BITRATES=%d num_bitrates=%d\n", IW_MAX_BITRATES,
+           range->num_bitrates);
+
+    range->num_frequency = 0;
+    if (wlan_get_state_11d(priv) == ENABLE_11D &&
+        Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        u8 chan_no;
+        u8 band;
+
+        parsed_region_chan_11d_t *parsed_region_chan =
+            &Adapter->parsed_region_chan;
+
+        if (parsed_region_chan == NULL) {
+            PRINTM(INFO, "11D:parsed_region_chan is NULL\n");
+            LEAVE();
+            return 0;
+        }
+        band = parsed_region_chan->band;
+        PRINTM(INFO, "band=%d NoOfChan=%d\n", band,
+               parsed_region_chan->NoOfChan);
+
+        for (i = 0; (range->num_frequency < IW_MAX_FREQUENCIES)
+             && (i < parsed_region_chan->NoOfChan); i++) {
+            chan_no = parsed_region_chan->chanPwr[i].chan;
+            PRINTM(INFO, "chan_no=%d\n", chan_no);
+            range->freq[range->num_frequency].i = (long) chan_no;
+            range->freq[range->num_frequency].m =
+                (long) chan_2_freq(chan_no, band) * 100000;
+            range->freq[range->num_frequency].e = 1;
+            range->num_frequency++;
+        }
+    } else {
+        for (j = 0; (range->num_frequency < IW_MAX_FREQUENCIES)
+             && (j < sizeof(Adapter->region_channel)
+                 / sizeof(Adapter->region_channel[0])); j++) {
+            cfp = Adapter->region_channel[j].CFP;
+            for (i = 0; (range->num_frequency < IW_MAX_FREQUENCIES)
+                 && Adapter->region_channel[j].Valid
+                 && cfp && (i < Adapter->region_channel[j].NrCFP); i++) {
+                range->freq[range->num_frequency].i = (long) cfp->Channel;
+                range->freq[range->num_frequency].m =
+                    (long) cfp->Freq * 100000;
+                range->freq[range->num_frequency].e = 1;
+                cfp++;
+                range->num_frequency++;
+            }
+        }
+    }
+
+    PRINTM(INFO, "IW_MAX_FREQUENCIES=%d num_frequency=%d\n",
+           IW_MAX_FREQUENCIES, range->num_frequency);
+
+    range->num_channels = range->num_frequency;
+
+    sort_channels(&range->freq[0], range->num_frequency);
+
+    /*
+     * Set an indication of the max TCP throughput in bit/s that we can
+     * expect using this interface 
+     */
+    if (i > 2)
+        range->throughput = 5000 * 1000;
+    else
+        range->throughput = 1500 * 1000;
+
+    range->min_rts = MRVDRV_RTS_MIN_VALUE;
+    range->max_rts = MRVDRV_RTS_MAX_VALUE;
+    range->min_frag = MRVDRV_FRAG_MIN_VALUE;
+    range->max_frag = MRVDRV_FRAG_MAX_VALUE;
+
+    range->encoding_size[0] = 5;
+    range->encoding_size[1] = 13;
+    range->num_encoding_sizes = 2;
+    range->max_encoding_tokens = 4;
+
+    range->min_pmp = 1000000;
+    range->max_pmp = 120000000;
+    range->min_pmt = 1000;
+    range->max_pmt = 1000000;
+    range->pmp_flags = IW_POWER_PERIOD;
+    range->pmt_flags = IW_POWER_TIMEOUT;
+    range->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_ALL_R;
+
+    /*
+     * Minimum version we recommend 
+     */
+    range->we_version_source = 15;
+
+    /*
+     * Version we are compiled with 
+     */
+    range->we_version_compiled = WIRELESS_EXT;
+
+    range->retry_capa = IW_RETRY_LIMIT;
+    range->retry_flags = IW_RETRY_LIMIT | IW_RETRY_MAX;
+
+    range->min_retry = TX_RETRY_MIN;
+    range->max_retry = TX_RETRY_MAX;
+
+    /*
+     * Set the qual, level and noise range values 
+     */
+    /*
+     * need to put the right values here 
+     */
+    range->max_qual.qual = 10;
+    range->max_qual.level = 0;
+    range->max_qual.noise = 0;
+    range->sensitivity = 0;
+
+    /*
+     * Setup the supported power level ranges 
+     */
+    memset(range->txpower, 0, sizeof(range->txpower));
+    range->txpower[0] = Adapter->MinTxPowerLevel;
+    range->txpower[1] = Adapter->MaxTxPowerLevel;
+    range->num_txpower = 2;
+    range->txpower_capa = IW_TXPOW_DBM | IW_TXPOW_RANGE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Set power management 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_power(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    /* PS is currently supported only in Infrastructure Mode 
+     * Remove this check if it is to be supported in IBSS mode also 
+     */
+
+    if (vwrq->disabled) {
+        Adapter->PSMode = Wlan802_11PowerModeCAM;
+        if (Adapter->PSState != PS_STATE_FULL_POWER) {
+            PSWakeup(priv, HostCmd_OPTION_WAITFORRSP);
+        }
+
+        return 0;
+    }
+
+    if ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {
+        PRINTM(INFO, "Setting power timeout command is not supported\n");
+        return -EINVAL;
+    } else if ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_PERIOD) {
+        PRINTM(INFO, "Setting power period command is not supported\n");
+        return -EINVAL;
+    }
+
+    if (Adapter->PSMode != Wlan802_11PowerModeCAM) {
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    Adapter->PSMode = Wlan802_11PowerModeMAX_PSP;
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        PSSleep(priv, HostCmd_OPTION_WAITFORRSP);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Get power management 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_power(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int mode;
+
+    ENTER();
+
+    mode = Adapter->PSMode;
+
+    if ((vwrq->disabled = (mode == Wlan802_11PowerModeCAM))
+        || Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    vwrq->value = 0;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Set sensitivity threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_sens(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    ENTER();
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Get sensitivity threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_FAILURE
+ */
+static int
+wlan_get_sens(struct net_device *dev,
+              struct iw_request_info *info, struct iw_param *vwrq,
+              char *extra)
+{
+    ENTER();
+    LEAVE();
+    return WLAN_STATUS_FAILURE;
+}
+
+#if (WIRELESS_EXT >= 18)
+/** 
+ *  @brief  Set IE 
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_gen_ie(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_param *dwrq, char *extra)
+{
+    /*
+     ** Functionality to be added later
+     */
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Get IE 
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_gen_ie(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_point *dwrq, char *extra)
+{
+    /*
+     ** Functionality to be added later
+     */
+    return WLAN_STATUS_SUCCESS;
+}
+#endif
+
+/** 
+ *  @brief  Append/Reset IE buffer. 
+ *   
+ *  Pass an opaque block of data, expected to be IEEE IEs, to the driver 
+ *    for eventual passthrough to the firmware in an associate/join 
+ *    (and potentially start) command.
+ *
+ *  Data is appended to an existing buffer and then wrapped in a passthrough
+ *    TLV in the command API to the firmware.  The firmware treats the data
+ *    as a transparent passthrough to the transmitted management frame.
+ *
+ *  @param dev          A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure    
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_gen_ie_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    /* If the passed length is zero, reset the buffer */
+    if (wrq->u.data.length == 0) {
+        Adapter->genIeBufferLen = 0;
+    } else {
+        /* 
+         * Verify that the passed length is not larger than the available 
+         *   space remaining in the buffer
+         */
+        if (wrq->u.data.length <
+            (sizeof(Adapter->genIeBuffer) - Adapter->genIeBufferLen)) {
+            /* Append the passed data to the end of the genIeBuffer */
+            if (copy_from_user(Adapter->genIeBuffer + Adapter->genIeBufferLen,
+                               wrq->u.data.pointer, wrq->u.data.length)) {
+                PRINTM(INFO, "Copy from user failed\n");
+                return -EFAULT;
+            }
+
+            /* Increment the stored buffer length by the size passed */
+            Adapter->genIeBufferLen += wrq->u.data.length;
+        } else {
+            /* Passed data does not fit in the remaining buffer space */
+            ret = WLAN_STATUS_FAILURE;
+        }
+    }
+
+    /* Return 0 for success, -1 for error case */
+    return ret;
+}
+
+/** 
+ *  @brief  Get IE buffer from driver 
+ *   
+ *  Used to pass an opaque block of data, expected to be IEEE IEs,
+ *    back to the application.  Currently the data block passed
+ *    back to the application is the saved association response retrieved 
+ *    from the firmware.
+ *
+ *  @param priv          A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure    
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_gen_ie_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int copySize = 0;
+    wlan_adapter *Adapter = priv->adapter;
+    IEEEtypes_AssocRsp_t *pAssocRsp;
+
+    pAssocRsp = (IEEEtypes_AssocRsp_t *) Adapter->assocRspBuffer;
+
+    /*
+     * Set the amount to copy back to the application as the minimum of the 
+     *       available IE data or the buffer provided by the application
+     */
+    copySize = (Adapter->assocRspSize - sizeof(pAssocRsp->Capability) -
+                -sizeof(pAssocRsp->StatusCode) - sizeof(pAssocRsp->AId));
+    copySize = MIN(copySize, wrq->u.data.length);
+
+    /* Copy the IEEE TLVs in the assoc response back to the application */
+    if (copy_to_user
+        (wrq->u.data.pointer, (u8 *) pAssocRsp->IEBuffer, copySize)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    /* Returned copy length */
+    wrq->u.data.length = copySize;
+
+    /* No error on return */
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Set Reassociate Info
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param wrq          A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+wlan_reassociate_ioctl(struct net_device *dev, struct iwreq *wrq)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_reassociation_info reassocInfo;
+    u8 zeroMac[] = { 0, 0, 0, 0, 0, 0 };
+    struct sockaddr bssidSockAddr;
+    struct iw_point dwrq;
+
+    int attemptBSSID = 0;
+    int attemptSSID = 0;
+    int retcode = 0;
+
+    ENTER();
+
+    Adapter->reassocAttempt = TRUE;
+
+    /* Fail if the data passed is not what we expect */
+    if (wrq->u.data.length != sizeof(reassocInfo)) {
+        retcode = -EINVAL;
+    } else if (copy_from_user(&reassocInfo, wrq->u.data.pointer,
+                              sizeof(reassocInfo)) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "Reassoc: copy from user failed\n");
+        retcode = -EFAULT;
+    } else {
+        /*
+         **  Copy the passed CurrentBSSID into the driver adapter structure.
+         **    This is later used in a TLV in the associate command to 
+         **    trigger the reassociation in firmware.
+         */
+        memcpy(Adapter->reassocCurrentAp, reassocInfo.CurrentBSSID,
+               sizeof(Adapter->reassocCurrentAp));
+
+        /* Check if the desired BSSID is non-zero */
+        if (memcmp(reassocInfo.DesiredBSSID, zeroMac, sizeof(zeroMac)) != 0) {
+            /* Set a flag for later processing */
+            attemptBSSID = TRUE;
+        }
+
+        /* Check if the desired SSID is set */
+        if (reassocInfo.DesiredSSID[0]) {
+            /* Make sure there is a null at the end of the SSID string */
+            reassocInfo.DesiredSSID[sizeof(reassocInfo.DesiredSSID) - 1] = 0;
+
+            /* Set a flag for later processing */
+            attemptSSID = TRUE;
+        }
+
+        /* 
+         **  Debug prints
+         */
+        PRINTM(INFO, "Reassoc: BSSID(%d), SSID(%d)\n",
+               attemptBSSID, attemptSSID);
+        PRINTM(INFO, "Reassoc: CBSSID(%02x:%02x:%02x:%02x:%02x:%02x)\n",
+               reassocInfo.CurrentBSSID[0],
+               reassocInfo.CurrentBSSID[1],
+               reassocInfo.CurrentBSSID[2],
+               reassocInfo.CurrentBSSID[3],
+               reassocInfo.CurrentBSSID[4], reassocInfo.CurrentBSSID[5]);
+        PRINTM(INFO, "Reassoc: DBSSID(%02x:%02x:%02x:%02x:%02x:%02x)\n",
+               reassocInfo.DesiredBSSID[0],
+               reassocInfo.DesiredBSSID[1],
+               reassocInfo.DesiredBSSID[2],
+               reassocInfo.DesiredBSSID[3],
+               reassocInfo.DesiredBSSID[4], reassocInfo.DesiredBSSID[5]);
+        PRINTM(INFO, "Reassoc: DSSID = %s\n", reassocInfo.DesiredSSID);
+
+        /*
+         **  If a BSSID was provided in the reassociation request, attempt
+         **    to reassociate to it first 
+         */
+        if (attemptBSSID) {
+            memset(bssidSockAddr.sa_data, 0x00,
+                   sizeof(bssidSockAddr.sa_data));
+            memcpy(bssidSockAddr.sa_data, reassocInfo.DesiredBSSID,
+                   sizeof(bssidSockAddr.sa_data));
+            bssidSockAddr.sa_family = ARPHRD_ETHER;
+
+            /* Attempt to reassociate to the BSSID passed */
+            retcode = wlan_set_wap(dev, NULL, &bssidSockAddr, NULL);
+        }
+
+        /*
+         **  If a SSID was provided, and either the BSSID failed or a BSSID
+         **    was not provided, attemtp to reassociate to the SSID
+         */
+        if (attemptSSID && (retcode != 0 || !attemptBSSID)) {
+            reassocInfo.DesiredSSID[sizeof(reassocInfo.DesiredSSID) - 1] = 0;
+            dwrq.length = strlen(reassocInfo.DesiredSSID) + 1;
+            dwrq.flags = 1;     /* set for a specific association */
+
+            /* Attempt to reassociate to the SSID passed */
+            retcode = wlan_set_essid(dev, NULL, &dwrq,
+                                     reassocInfo.DesiredSSID);
+        }
+
+        /* Reset the adapter control flag and current AP to zero */
+        memset(Adapter->reassocCurrentAp, 0x00,
+               sizeof(Adapter->reassocCurrentAp));
+        Adapter->reassocAttempt = FALSE;
+    }
+
+    return retcode;
+}
+
+/*
+ * iwconfig settable callbacks 
+ */
+static const iw_handler wlan_handler[] = {
+    (iw_handler) wlan_config_commit,    /* SIOCSIWCOMMIT */
+    (iw_handler) wlan_get_name, /* SIOCGIWNAME */
+    (iw_handler) NULL,          /* SIOCSIWNWID */
+    (iw_handler) NULL,          /* SIOCGIWNWID */
+    (iw_handler) wlan_set_freq, /* SIOCSIWFREQ */
+    (iw_handler) wlan_get_freq, /* SIOCGIWFREQ */
+    (iw_handler) wlan_set_mode, /* SIOCSIWMODE */
+    (iw_handler) wlan_get_mode, /* SIOCGIWMODE */
+    (iw_handler) wlan_set_sens, /* SIOCSIWSENS */
+    (iw_handler) wlan_get_sens, /* SIOCGIWSENS */
+    (iw_handler) NULL,          /* SIOCSIWRANGE */
+    (iw_handler) wlan_get_range,        /* SIOCGIWRANGE */
+    (iw_handler) NULL,          /* SIOCSIWPRIV */
+    (iw_handler) NULL,          /* SIOCGIWPRIV */
+    (iw_handler) NULL,          /* SIOCSIWSTATS */
+    (iw_handler) NULL,          /* SIOCGIWSTATS */
+#if WIRELESS_EXT > 15
+    iw_handler_set_spy,         /* SIOCSIWSPY */
+    iw_handler_get_spy,         /* SIOCGIWSPY */
+    iw_handler_set_thrspy,      /* SIOCSIWTHRSPY */
+    iw_handler_get_thrspy,      /* SIOCGIWTHRSPY */
+#else /* WIRELESS_EXT > 15 */
+#ifdef WIRELESS_SPY
+    (iw_handler) wlan_set_spy,  /* SIOCSIWSPY */
+    (iw_handler) wlan_get_spy,  /* SIOCGIWSPY */
+#else /* WIRELESS_SPY */
+    (iw_handler) NULL,          /* SIOCSIWSPY */
+    (iw_handler) NULL,          /* SIOCGIWSPY */
+#endif /* WIRELESS_SPY */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) NULL,          /* -- hole -- */
+#endif /* WIRELESS_EXT > 15 */
+    (iw_handler) wlan_set_wap,  /* SIOCSIWAP */
+    (iw_handler) wlan_get_wap,  /* SIOCGIWAP */
+    (iw_handler) NULL,          /* -- hole -- */
+    //(iw_handler) wlan_get_aplist,         /* SIOCGIWAPLIST */
+    NULL,                       /* SIOCGIWAPLIST */
+#if WIRELESS_EXT > 13
+    (iw_handler) wlan_set_scan, /* SIOCSIWSCAN */
+    (iw_handler) wlan_get_scan, /* SIOCGIWSCAN */
+#else /* WIRELESS_EXT > 13 */
+    (iw_handler) NULL,          /* SIOCSIWSCAN */
+    (iw_handler) NULL,          /* SIOCGIWSCAN */
+#endif /* WIRELESS_EXT > 13 */
+    (iw_handler) wlan_set_essid,        /* SIOCSIWESSID */
+    (iw_handler) wlan_get_essid,        /* SIOCGIWESSID */
+    (iw_handler) wlan_set_nick, /* SIOCSIWNICKN */
+    (iw_handler) wlan_get_nick, /* SIOCGIWNICKN */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) wlan_set_rate, /* SIOCSIWRATE */
+    (iw_handler) wlan_get_rate, /* SIOCGIWRATE */
+    (iw_handler) wlan_set_rts,  /* SIOCSIWRTS */
+    (iw_handler) wlan_get_rts,  /* SIOCGIWRTS */
+    (iw_handler) wlan_set_frag, /* SIOCSIWFRAG */
+    (iw_handler) wlan_get_frag, /* SIOCGIWFRAG */
+    (iw_handler) wlan_set_txpow,        /* SIOCSIWTXPOW */
+    (iw_handler) wlan_get_txpow,        /* SIOCGIWTXPOW */
+    (iw_handler) wlan_set_retry,        /* SIOCSIWRETRY */
+    (iw_handler) wlan_get_retry,        /* SIOCGIWRETRY */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) wlan_get_encode,       /* SIOCGIWENCODE */
+    (iw_handler) wlan_set_power,        /* SIOCSIWPOWER */
+    (iw_handler) wlan_get_power,        /* SIOCGIWPOWER */
+#if (WIRELESS_EXT >= 18)
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) wlan_set_gen_ie,       /* SIOCSIWGENIE */
+    (iw_handler) wlan_get_gen_ie,       /* SIOCGIWGENIE */
+    (iw_handler) NULL,			/* SIOCSIWAUTH  */
+    (iw_handler) NULL,			/* SIOCGIWAUTH  */
+    (iw_handler) NULL,			/* SIOCSIWENCODEEXT */
+    (iw_handler) NULL,			/* SIOCGIWENCODEEXT */
+#endif /* WIRELESSS_EXT >= 18 */
+};
+
+/*
+ * iwpriv settable callbacks 
+ */
+
+static const iw_handler wlan_private_handler[] = {
+    NULL,                       /* SIOCIWFIRSTPRIV */
+};
+
+static const struct iw_priv_args wlan_private_args[] = {
+    /*
+     * { cmd, set_args, get_args, name } 
+     */
+    {
+     WLANEXTSCAN,
+     IW_PRIV_TYPE_INT,
+     IW_PRIV_TYPE_CHAR | 2,
+     "extscan"},
+    {
+     WLANHOSTCMD,
+     IW_PRIV_TYPE_BYTE | 2047,
+     IW_PRIV_TYPE_BYTE | 2047,
+     "hostcmd"},
+    {
+     WLANARPFILTER,
+     IW_PRIV_TYPE_BYTE | 2047,
+     IW_PRIV_TYPE_BYTE | 2047,
+     "arpfilter"},
+    {
+     WLANREGRDWR,
+     IW_PRIV_TYPE_CHAR | 256,
+     IW_PRIV_TYPE_CHAR | 256,
+     "regrdwr"},
+    {
+     WLANCMD52RDWR,
+     IW_PRIV_TYPE_BYTE | 7,
+     IW_PRIV_TYPE_BYTE | 7,
+     "sdcmd52rw"},
+    {
+     WLANCMD53RDWR,
+     IW_PRIV_TYPE_CHAR | 32,
+     IW_PRIV_TYPE_CHAR | 32,
+     "sdcmd53rw"},
+    {
+     WLAN_SETCONF_GETCONF,
+     IW_PRIV_TYPE_BYTE | 1280,
+     IW_PRIV_TYPE_BYTE | 1280,
+     "setgetconf"},
+    {
+     WLANCISDUMP,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_BYTE | 512,
+     "getcis"},
+
+    {
+     WLANSCAN_TYPE,
+     IW_PRIV_TYPE_CHAR | 8,
+     IW_PRIV_TYPE_CHAR | 8,
+     "scantype"},
+
+    {
+     WLAN_SETINT_GETINT,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     ""},
+    {
+     WLANNF,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getNF"},
+    {
+     WLANRSSI,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getRSSI"},
+    {
+     WLANBGSCAN,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "bgscan"},
+    {
+     WLANENABLE11D,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "enable11d"},
+    {
+     WLANADHOCGRATE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "adhocgrate"},
+    {
+     WLANSDIOCLOCK,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "sdioclock"},
+    {
+     WLANWMM_ENABLE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "wmm"},
+    {
+     WLANNULLGEN,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "uapsdnullgen"},
+
+    {
+     WLAN_SUBCMD_SET_PRESCAN,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "prescan"},
+    {
+     WLANADHOCCSET,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "setcoalescing"},
+    {
+     WLAN_SETONEINT_GETONEINT,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     ""},
+    {
+     WLAN_WMM_QOSINFO,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "wmm_qosinfo"},
+    {
+     WLAN_LISTENINTRVL,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "lolisteninter"},
+    {
+     WLAN_FW_WAKEUP_METHOD,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "fwwakeupmethod"},
+    {
+     WLAN_TXCONTROL,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "txcontrol"},
+    {
+     WLAN_NULLPKTINTERVAL,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "psnullinterval"},
+    {
+     WLAN_ADHOC_AWAKE_PERIOD,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "adhocawakepd"},
+    {
+     WLAN_LDO,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "ldocfg"},
+    /* Using iwpriv sub-command feature */
+    {
+     WLAN_SETONEINT_GETNONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     ""},
+
+    {
+     WLAN_SUBCMD_SETRXANTENNA,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setrxant"},
+    {
+     WLAN_SUBCMD_SETTXANTENNA,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "settxant"},
+    {
+     WLANSETAUTHALG,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "authalgs",
+     },
+    {
+     WLANSETENCRYPTIONMODE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "encryptionmode",
+     },
+    {
+     WLANSETREGION,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setregioncode"},
+    {
+     WLAN_SET_LISTEN_INTERVAL,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setlisteninter"},
+    {
+     WLAN_SET_MULTIPLE_DTIM,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setmultipledtim"},
+    {
+     WLANSETBCNAVG,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setbcnavg"},
+    {
+     WLANSETDATAAVG,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setdataavg"},
+    {
+     WLAN_SETNONE_GETONEINT,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     ""},
+    {
+     WLANGETREGION,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getregioncode"},
+    {
+     WLAN_GET_LISTEN_INTERVAL,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getlisteninter"},
+    {
+     WLAN_GET_MULTIPLE_DTIM,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getmultipledtim"},
+    {
+     WLAN_GET_TX_RATE,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "gettxrate"},
+    {
+     WLANGETBCNAVG,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getbcnavg"},
+    {
+     WLANGETDATAAVG,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getdataavg"},
+    {
+     WLAN_SETNONE_GETTWELVE_CHAR,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     ""},
+    {
+     WLAN_SUBCMD_GETRXANTENNA,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     "getrxant"},
+    {
+     WLAN_SUBCMD_GETTXANTENNA,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     "gettxant"},
+    {
+     WLAN_GET_TSF,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     "gettsf"},
+    {
+     WLANDEEPSLEEP,
+     IW_PRIV_TYPE_CHAR | 1,
+     IW_PRIV_TYPE_CHAR | 6,
+     "deepsleep"},
+    {
+     WLANHOSTSLEEPCFG,
+     IW_PRIV_TYPE_CHAR | 31,
+     IW_PRIV_TYPE_NONE,
+     "hostsleepcfg"},
+    {
+     WLAN_SETNONE_GETNONE,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     ""},
+    {
+     WLANDEAUTH,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "deauth"},
+    {
+     WLANADHOCSTOP,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "adhocstop"},
+    {
+     WLANRADIOON,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "radioon"},
+    {
+     WLANRADIOOFF,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "radiooff"},
+    {
+     WLANREMOVEADHOCAES,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "rmaeskey"},
+#ifdef REASSOCIATION
+    {
+     WLANREASSOCIATIONAUTO,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "reasso-on"},
+    {
+     WLANREASSOCIATIONUSER,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "reasso-off"},
+#endif /* REASSOCIATION */
+    {
+     WLANWLANIDLEON,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "wlanidle-on"},
+    {
+     WLANWLANIDLEOFF,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "wlanidle-off"},
+    {
+     WLAN_SET64CHAR_GET64CHAR,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     ""},
+    {
+     WLANSLEEPPARAMS,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "sleepparams"},
+
+    {
+     WLAN_BCA_TIMESHARE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "bca-ts"},
+    {
+     WLANSCAN_MODE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "scanmode"},
+    {
+     WLAN_GET_ADHOC_STATUS,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "getadhocstatus"},
+    {
+     WLAN_SET_GEN_IE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "setgenie"},
+    {
+     WLAN_GET_GEN_IE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "getgenie"},
+    {
+     WLAN_REASSOCIATE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "reassociate"},
+    {
+     WLAN_WMM_QUEUE_STATUS,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "qstatus"},
+    {
+     WLAN_SETWORDCHAR_GETNONE,
+     IW_PRIV_TYPE_CHAR | 32,
+     IW_PRIV_TYPE_NONE,
+     ""},
+    {
+     WLANSETADHOCAES,
+     IW_PRIV_TYPE_CHAR | 32,
+     IW_PRIV_TYPE_NONE,
+     "setaeskey"},
+    {
+     WLAN_SETNONE_GETWORDCHAR,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 128,
+     ""},
+    {
+     WLANGETADHOCAES,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 128,
+     "getaeskey"},
+    {
+     WLANVERSION,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 128,
+     "version"},
+    {
+     WLANSETWPAIE,
+     IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | 24,
+     IW_PRIV_TYPE_NONE,
+     "setwpaie"},
+    {
+     WLANGETLOG,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | GETLOG_BUFSIZE,
+     "getlog"},
+    {
+     WLAN_SET_GET_SIXTEEN_INT,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     ""},
+    {
+     WLAN_TPCCFG,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "tpccfg"},
+    {
+     WLAN_AUTO_FREQ_SET,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "setafc"},
+    {
+     WLAN_AUTO_FREQ_GET,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "getafc"},
+    {
+     WLAN_SCANPROBES,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "scanprobes"},
+    {
+     WLAN_LED_GPIO_CTRL,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "ledgpio"},
+    {
+     WLAN_SLEEP_PERIOD,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "sleeppd"},
+    {
+     WLAN_ADAPT_RATESET,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "rateadapt"},
+
+    {
+     WLAN_INACTIVITY_TIMEOUT,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "inactivityto"},
+    {
+     WLANSNR,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "getSNR"},
+    {
+     WLAN_GET_RATE,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "getrate"},
+    {
+     WLAN_GET_RXINFO,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "getrxinfo"},
+    {
+     WLAN_SET_ATIM_WINDOW,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "atimwindow"},
+    {
+     WLAN_BEACON_INTERVAL,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "bcninterval"},
+    {
+     WLAN_SCAN_TIME,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "scantime"},
+    {
+     WLANHSCFG,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "hscfg"},
+#ifdef DEBUG_LEVEL1
+    {
+     WLAN_DRV_DBG,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "drvdbg"},
+#endif
+    {
+     WLAN_SET_GET_2K,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     ""},
+
+    {
+     WLAN_SET_USER_SCAN,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "setuserscan"},
+    {
+     WLAN_GET_SCAN_TABLE,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "getscantable"},
+    {
+     WLAN_SET_MRVL_TLV,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "setmrvltlv"},
+    {
+     WLAN_GET_ASSOC_RSP,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "getassocrsp"},
+    {
+     WLAN_ADDTS_REQ,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "addts"},
+    {
+     WLAN_DELTS_REQ,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "delts"},
+    {
+     WLAN_QUEUE_CONFIG,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "qconfig"},
+    {
+     WLAN_QUEUE_STATS,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "qstats"},
+};
+
+struct iw_handler_def wlan_handler_def = {
+  num_standard:sizeof(wlan_handler) / sizeof(iw_handler),
+  num_private:sizeof(wlan_private_handler) / sizeof(iw_handler),
+  num_private_args:sizeof(wlan_private_args) /
+        sizeof(struct iw_priv_args),
+  standard:(iw_handler *) wlan_handler,
+  private:(iw_handler *) wlan_private_handler,
+  private_args:(struct iw_priv_args *) wlan_private_args,
+  get_wireless_stats:(struct iw_statistics *) wlan_get_wireless_stats,//added by hufh
+};
+
+/** 
+ *  @brief wlan hostcmd ioctl handler
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param req		        A pointer to ifreq structure
+ *  @param cmd			command 
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_hostcmd_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+    u8 *tempResponseBuffer;
+    CmdCtrlNode *pCmdNode;
+    HostCmd_DS_GEN *pCmdPtr;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    u16 wait_option = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    if ((wrq->u.data.pointer == NULL) || (wrq->u.data.length < S_DS_GEN)) {
+        PRINTM(INFO,
+               "wlan_hostcmd_ioctl() corrupt data: pointer=%p, length=%d\n",
+               wrq->u.data.pointer, wrq->u.data.length);
+        return -EFAULT;
+    }
+
+    /*
+     * Get a free command control node 
+     */
+    if (!(pCmdNode = GetFreeCmdCtrlNode(priv))) {
+        PRINTM(INFO, "Failed GetFreeCmdCtrlNode\n");
+        return -ENOMEM;
+    }
+
+    if (!
+        (tempResponseBuffer =
+         kmalloc(MRVDRV_SIZE_OF_CMD_BUFFER, GFP_KERNEL))) {
+        PRINTM(INFO, "ERROR: Failed to allocate response buffer!\n");
+        CleanupAndInsertCmd(priv, pCmdNode);
+        return -ENOMEM;
+    }
+
+    wait_option |= HostCmd_OPTION_WAITFORRSP;
+
+    SetCmdCtrlNode(priv, pCmdNode, 0, wait_option, NULL);
+    init_waitqueue_head(&pCmdNode->cmdwait_q);
+
+    pCmdPtr = (HostCmd_DS_GEN *) pCmdNode->BufVirtualAddr;
+
+    /*
+     * Copy the whole command into the command buffer 
+     */
+    if (copy_from_user(pCmdPtr, wrq->u.data.pointer, wrq->u.data.length)) {
+        PRINTM(INFO, "Copy from user failed\n");
+        kfree(tempResponseBuffer);
+        CleanupAndInsertCmd(priv, pCmdNode);
+        return -EFAULT;
+    }
+
+    if (pCmdPtr->Size < S_DS_GEN) {
+        PRINTM(INFO, "wlan_hostcmd_ioctl() invalid cmd size: Size=%d\n",
+               pCmdPtr->Size);
+        kfree(tempResponseBuffer);
+        CleanupAndInsertCmd(priv, pCmdNode);
+        return -EFAULT;
+    }
+
+    pCmdNode->pdata_buf = tempResponseBuffer;
+    pCmdNode->CmdFlags |= CMD_F_HOSTCMD;
+
+    pCmdPtr->SeqNum = ++priv->adapter->SeqNum;
+    pCmdPtr->Result = 0;
+
+    PRINTM(INFO, "HOSTCMD Command: 0x%04x Size: %d SeqNum: %d\n",
+           pCmdPtr->Command, pCmdPtr->Size, pCmdPtr->SeqNum);
+    HEXDUMP("Command Data", (u8 *) (pCmdPtr), MIN(32, pCmdPtr->Size));
+    PRINTM(INFO, "Copying data from : (user)0x%p -> 0x%p(driver)\n",
+           req->ifr_data, pCmdPtr);
+
+    pCmdNode->CmdWaitQWoken = FALSE;
+    QueueCmd(Adapter, pCmdNode, TRUE);
+
+	umd_dbg("will wake main thread");    
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+    if (wait_option & HostCmd_OPTION_WAITFORRSP) {
+        /* Sleep until response is generated by FW */
+        wait_event_interruptible(pCmdNode->cmdwait_q,
+                                 pCmdNode->CmdWaitQWoken);
+    }
+
+    /* Copy the response back to user space */
+    pCmdPtr = (HostCmd_DS_GEN *) tempResponseBuffer;
+
+    if (copy_to_user(wrq->u.data.pointer, tempResponseBuffer, pCmdPtr->Size))
+        PRINTM(INFO, "ERROR: copy_to_user failed!\n");
+    wrq->u.data.length = pCmdPtr->Size;
+    kfree(tempResponseBuffer);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief wlan arpfilter ioctl handler
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param req		        A pointer to ifreq structure
+ *  @param cmd			command 
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_arpfilter_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+    wlan_private *priv = dev->priv;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+    MrvlIEtypesHeader_t hdr;
+
+    ENTER();
+
+    if ((wrq->u.data.pointer == NULL)
+        || (wrq->u.data.length < sizeof(MrvlIEtypesHeader_t))
+        || (wrq->u.data.length > sizeof(Adapter->ArpFilter))) {
+        PRINTM(INFO,
+               "wlan_arpfilter_ioctl() corrupt data: pointer=%p, length=%d\n",
+               wrq->u.data.pointer, wrq->u.data.length);
+        return -EFAULT;
+    }
+
+    if (copy_from_user(&hdr, wrq->u.data.pointer, sizeof(hdr))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    if (hdr.Len == 0) {
+        Adapter->ArpFilterSize = 0;
+        memset(Adapter->ArpFilter, 0, sizeof(Adapter->ArpFilter));
+    } else {
+        Adapter->ArpFilterSize = wrq->u.data.length;
+
+        PRINTM(INFO, "Copying data from : (user)0x%p -> 0x%p(driver)\n",
+               wrq->u.data.pointer, Adapter->ArpFilter);
+        if (copy_from_user(Adapter->ArpFilter, wrq->u.data.pointer,
+                           Adapter->ArpFilterSize)) {
+            Adapter->ArpFilterSize = 0;
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        HEXDUMP("ArpFilter", Adapter->ArpFilter, Adapter->ArpFilterSize);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Rx Info 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success
+ */
+static int
+wlan_get_rxinfo(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data[2];
+    ENTER();
+    data[0] = Adapter->SNR[TYPE_RXPD][TYPE_NOAVG];
+    data[1] = Adapter->RxPDRate;
+    if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 2)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+    wrq->u.data.length = 2;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get SNR 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_snr(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    int data[4];
+
+    ENTER();
+    memset(data, 0, sizeof(data));
+    if (wrq->u.data.length) {
+        if (copy_from_user
+            (data, wrq->u.data.pointer,
+             MIN(wrq->u.data.length, 4) * sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+    }
+    if ((wrq->u.data.length == 0) || (data[0] == 0) || (data[0] == 1)) {
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            ret = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_802_11_RSSI,
+                                        0, HostCmd_OPTION_WAITFORRSP,
+                                        0, NULL);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+        }
+    }
+
+    if (wrq->u.data.length == 0) {
+        data[0] = Adapter->SNR[TYPE_BEACON][TYPE_NOAVG];
+        data[1] = Adapter->SNR[TYPE_BEACON][TYPE_AVG];
+        if ((jiffies - Adapter->RxPDAge) > HZ)  //data expired after 1 second
+            data[2] = 0;
+        else
+            data[2] = Adapter->SNR[TYPE_RXPD][TYPE_NOAVG];
+        data[3] = Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE;
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 4)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = 4;
+    } else if (data[0] == 0) {
+        data[0] = Adapter->SNR[TYPE_BEACON][TYPE_NOAVG];
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    } else if (data[0] == 1) {
+        data[0] = Adapter->SNR[TYPE_BEACON][TYPE_AVG];
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    } else if (data[0] == 2) {
+        if ((jiffies - Adapter->RxPDAge) > HZ)  //data expired after 1 second
+            data[0] = 0;
+        else
+            data[0] = Adapter->SNR[TYPE_RXPD][TYPE_NOAVG];
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    } else if (data[0] == 3) {
+        data[0] = Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE;
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    } else {
+        return -ENOTSUPP;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set scan time
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wreq		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_scan_time(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[3] = { 0, 0, 0 };
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.length > 0 && wrq->u.data.length <= 3) {
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        PRINTM(INFO,
+               "WLAN SET Scan Time: Specific %d, Active %d, Passive %d\n",
+               data[0], data[1], data[2]);
+        if (data[0]) {
+            if (data[0] > MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME) {
+                PRINTM(MSG,
+                       "Invalid parameter, max specific scan time is %d ms\n",
+                       MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME);
+                return -EINVAL;
+            }
+            Adapter->SpecificScanTime = data[0];
+        }
+        if (data[1]) {
+            if (data[1] > MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME) {
+                PRINTM(MSG,
+                       "Invalid parameter, max active scan time is %d ms\n",
+                       MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME);
+                return -EINVAL;
+            }
+            Adapter->ActiveScanTime = data[1];
+        }
+        if (data[2]) {
+            if (data[2] > MRVDRV_MAX_PASSIVE_SCAN_CHAN_TIME) {
+                PRINTM(MSG,
+                       "Invalid parameter, max passive scan time is %d ms\n",
+                       MRVDRV_MAX_PASSIVE_SCAN_CHAN_TIME);
+                return -EINVAL;
+            }
+            Adapter->PassiveScanTime = data[2];
+        }
+    }
+
+    data[0] = Adapter->SpecificScanTime;
+    data[1] = Adapter->ActiveScanTime;
+    data[2] = Adapter->PassiveScanTime;
+    wrq->u.data.length = 3;
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Adhoc beacon Interval 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_beacon_interval(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[2];
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.length > 0) {
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        PRINTM(INFO, "WLAN SET BEACON INTERVAL: %d\n", data[0]);
+        if ((data[0] > MRVDRV_MAX_BEACON_INTERVAL) ||
+            (data[0] < MRVDRV_MIN_BEACON_INTERVAL))
+            return -ENOTSUPP;
+        Adapter->BeaconPeriod = data[0];
+    }
+    data[0] = Adapter->BeaconPeriod;
+    wrq->u.data.length = 1;
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        data[1] = Adapter->CurBssParams.BSSDescriptor.BeaconPeriod;
+        wrq->u.data.length = 2;
+    }
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Adhoc ATIM Window 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_ATIM_Window(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[2];
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.length > 0) {
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        PRINTM(INFO, "WLAN SET ATIM WINDOW: %d\n", data[0]);
+        Adapter->AtimWindow = data[0];
+        Adapter->AtimWindow = MIN(Adapter->AtimWindow, 50);
+    }
+    data[0] = Adapter->AtimWindow;
+    wrq->u.data.length = 1;
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        data[1] = Adapter->CurBssParams.BSSDescriptor.ATIMWindow;
+        wrq->u.data.length = 2;
+    }
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get RSSI 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_rssi(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    int temp;
+    int data = 0;
+    int *val;
+
+    ENTER();
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    if ((data == 0) || (data == 1)) {
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_RSSI,
+                                    0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    }
+
+    switch (data) {
+    case 0:
+
+        temp = CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_NOAVG],
+                        Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+        break;
+    case 1:
+        temp = CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_AVG],
+                        Adapter->NF[TYPE_BEACON][TYPE_AVG]);
+        break;
+    case 2:
+        if ((jiffies - Adapter->RxPDAge) > HZ)  //data expired after 1 second
+            temp = 0;
+        else
+            temp = CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_NOAVG],
+                            Adapter->NF[TYPE_RXPD][TYPE_NOAVG]);
+        break;
+    case 3:
+        temp = CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+                        Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+        break;
+    default:
+        return -ENOTSUPP;
+    }
+    val = (int *) wrq->u.name;
+    *val = temp;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get NF
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure 
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_nf(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    int temp;
+    int data = 0;
+    int *val;
+
+    ENTER();
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    if ((data == 0) || (data == 1)) {
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_RSSI,
+                                    0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    }
+
+    switch (data) {
+    case 0:
+        temp = Adapter->NF[TYPE_BEACON][TYPE_NOAVG];
+        break;
+    case 1:
+        temp = Adapter->NF[TYPE_BEACON][TYPE_AVG];
+        break;
+    case 2:
+        if ((jiffies - Adapter->RxPDAge) > HZ)  //data expired after 1 second
+            temp = 0;
+        else
+            temp = Adapter->NF[TYPE_RXPD][TYPE_NOAVG];
+        break;
+    case 3:
+        temp = Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE;
+        break;
+    default:
+        return -ENOTSUPP;
+    }
+
+    temp = CAL_NF(temp);
+
+    PRINTM(INFO, "***temp = %d\n", temp);
+    val = (int *) wrq->u.name;
+    *val = temp;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Remove AES key
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_remove_aes(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    WLAN_802_11_KEY key;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->InfrastructureMode != Wlan802_11IBSS ||
+        Adapter->MediaConnectStatus == WlanMediaStateConnected)
+        return -EOPNOTSUPP;
+
+    Adapter->AdhocAESEnabled = FALSE;
+
+    memset(&key, 0, sizeof(WLAN_802_11_KEY));
+    PRINTM(INFO, "WPA2: DISABLE AES_KEY\n");
+    key.KeyLength = WPA_AES_KEY_LEN;
+    key.KeyIndex = 0x40000000;
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_KEY_MATERIAL,
+                                HostCmd_ACT_SET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                !(KEY_INFO_ENABLED), &key);
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief Get Support Rates
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_getrate_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    WLAN_802_11_RATES rates;
+    int rate[sizeof(rates)];
+    int i;
+
+    ENTER();
+
+    memset(rates, 0, sizeof(rates));
+    memset(rate, 0, sizeof(rate));
+    wrq->u.data.length = get_active_data_rates(Adapter, rates);
+    if (wrq->u.data.length > sizeof(rates))
+        wrq->u.data.length = sizeof(rates);
+
+    for (i = 0; i < wrq->u.data.length; i++) {
+        rates[i] &= ~0x80;
+        rate[i] = rates[i];
+    }
+
+    if (copy_to_user
+        (wrq->u.data.pointer, rate, wrq->u.data.length * sizeof(int))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get TxRate
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_txrate_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int *pdata;
+    struct iwreq *wrq = (struct iwreq *) req;
+    int ret = WLAN_STATUS_SUCCESS;
+    ENTER();
+    Adapter->TxRate = 0;
+    PRINTM(INFO, "wlan_get_txrate_ioctl\n");
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,
+                                HostCmd_ACT_GET, HostCmd_OPTION_WAITFORRSP,
+                                0, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+    pdata = (int *) wrq->u.name;
+    *pdata = (int) Adapter->TxRate;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Adhoc Status
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_adhoc_status_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    char status[64];
+    wlan_adapter *Adapter = priv->adapter;
+
+    memset(status, 0, sizeof(status));
+
+    switch (Adapter->InfrastructureMode) {
+    case Wlan802_11IBSS:
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            if (Adapter->AdhocCreate == TRUE)
+                memcpy(&status, "AdhocStarted", sizeof(status));
+            else
+                memcpy(&status, "AdhocJoined", sizeof(status));
+        } else {
+            memcpy(&status, "AdhocIdle", sizeof(status));
+        }
+        break;
+    case Wlan802_11Infrastructure:
+        memcpy(&status, "InfraMode", sizeof(status));
+        break;
+    default:
+        memcpy(&status, "AutoUnknownMode", sizeof(status));
+        break;
+    }
+
+    PRINTM(INFO, "Status = %s\n", status);
+    wrq->u.data.length = strlen(status) + 1;
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &status, wrq->u.data.length))
+            return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Driver Version
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_version_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int len;
+    char buf[128];
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    get_version(priv->adapter, buf, sizeof(buf) - 1);
+
+    len = strlen(buf);
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, buf, len)) {
+            PRINTM(INFO, "CopyToUser failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = len;
+    }
+
+    PRINTM(INFO, "wlan version: %s\n", buf);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Read/Write adapter registers
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_regrdwr_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_ioctl_regrdwr regrdwr;
+    wlan_offset_value offval;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (copy_from_user(&regrdwr, req->ifr_data, sizeof(regrdwr))) {
+        PRINTM(INFO,
+               "copy of regrdwr for wlan_regrdwr_ioctl from user failed \n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    if (regrdwr.WhichReg == REG_EEPROM) {
+        PRINTM(MSG, "Inside RDEEPROM\n");
+        Adapter->pRdeeprom =
+            (char *) kmalloc((regrdwr.NOB + sizeof(regrdwr)), GFP_KERNEL);
+        if (!Adapter->pRdeeprom)
+            return -ENOMEM;
+        memcpy(Adapter->pRdeeprom, &regrdwr, sizeof(regrdwr));
+        /* +14 is for Action, Offset, and NOB in 
+         * response */
+        PRINTM(INFO, "Action:%d Offset: %x NOB: %02x\n",
+               regrdwr.Action, regrdwr.Offset, regrdwr.NOB);
+
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_EEPROM_ACCESS,
+                                    regrdwr.Action, HostCmd_OPTION_WAITFORRSP,
+                                    0, &regrdwr);
+
+        if (ret) {
+            if (Adapter->pRdeeprom)
+                kfree(Adapter->pRdeeprom);
+            LEAVE();
+            return ret;
+        }
+
+        mdelay(10);
+
+        /*
+         * Return the result back to the user 
+         */
+
+        if (regrdwr.Action == HostCmd_ACT_GEN_READ) {
+            if (copy_to_user
+                (req->ifr_data, Adapter->pRdeeprom,
+                 sizeof(regrdwr) + regrdwr.NOB)) {
+                if (Adapter->pRdeeprom)
+                    kfree(Adapter->pRdeeprom);
+                PRINTM(INFO,
+                       "copy of regrdwr for wlan_regrdwr_ioctl to user failed \n");
+                LEAVE();
+                return -EFAULT;
+            }
+        }
+
+        if (Adapter->pRdeeprom)
+            kfree(Adapter->pRdeeprom);
+
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    offval.offset = regrdwr.Offset;
+    offval.value = (regrdwr.Action) ? regrdwr.Value : 0x00;
+
+    PRINTM(INFO, "RegAccess: %02x Action:%d "
+           "Offset: %04x Value: %04x\n",
+           regrdwr.WhichReg, regrdwr.Action, offval.offset, offval.value);
+
+    /*
+     * regrdwr.WhichReg should contain the command that
+     * corresponds to which register access is to be 
+     * performed HostCmd_CMD_MAC_REG_ACCESS 0x0019
+     * HostCmd_CMD_BBP_REG_ACCESS 0x001a 
+     * HostCmd_CMD_RF_REG_ACCESS 0x001b 
+     */
+    ret = PrepareAndSendCommand(priv, regrdwr.WhichReg,
+                                regrdwr.Action, HostCmd_OPTION_WAITFORRSP,
+                                0, &offval);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    mdelay(10);
+
+    /*
+     * Return the result back to the user 
+     */
+    regrdwr.Value = Adapter->OffsetValue.value;
+    if (regrdwr.Action == HostCmd_ACT_GEN_READ) {
+        if (copy_to_user(req->ifr_data, &regrdwr, sizeof(regrdwr))) {
+            PRINTM(INFO,
+                   "copy of regrdwr for wlan_regrdwr_ioctl to user failed \n");
+            LEAVE();
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Cmd52 read/write register
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_cmd52rdwr_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    u8 buf[7];
+    u8 rw, func, dat = 0xff;
+    u32 reg;
+
+    ENTER();
+
+    if (copy_from_user(buf, req->ifr_data, sizeof(buf))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    rw = buf[0];
+    func = buf[1];
+    reg = buf[5];
+    reg = (reg << 8) + buf[4];
+    reg = (reg << 8) + buf[3];
+    reg = (reg << 8) + buf[2];
+
+    if (rw != 0)
+        dat = buf[6];
+
+    PRINTM(INFO, "rw=%d func=%d reg=0x%08X dat=0x%02X\n", rw, func, reg, dat);
+
+    if (rw == 0) {
+        if (sbi_read_ioreg(priv, reg, &dat) < 0) {
+            PRINTM(INFO, "sdio_read_ioreg: reading register 0x%X failed\n",
+                   reg);
+            dat = 0xff;
+        }
+    } else {
+        if (sbi_write_ioreg(priv, reg, dat) < 0) {
+            PRINTM(INFO, "sdio_read_ioreg: writing register 0x%X failed\n",
+                   reg);
+            dat = 0xff;
+        }
+    }
+    if (copy_to_user(req->ifr_data, &dat, sizeof(dat))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Cmd53 read/write register
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_cmd53rdwr_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    return -EINVAL;
+}
+
+/** 
+ *  @brief Convert ascii string to Hex integer
+ *     
+ *  @param d                    A pointer to integer buf
+ *  @param s			A pointer to ascii string 
+ *  @param dlen			the length o fascii string
+ *  @return 	   	        number of integer  
+ */
+static int
+ascii2hex(u8 * d, char *s, u32 dlen)
+{
+    int i;
+    u8 n;
+
+    memset(d, 0x00, dlen);
+
+    for (i = 0; i < dlen * 2; i++) {
+        if ((s[i] >= 48) && (s[i] <= 57))
+            n = s[i] - 48;
+        else if ((s[i] >= 65) && (s[i] <= 70))
+            n = s[i] - 55;
+        else if ((s[i] >= 97) && (s[i] <= 102))
+            n = s[i] - 87;
+        else
+            break;
+        if ((i % 2) == 0)
+            n = n * 16;
+        d[i / 2] += n;
+    }
+
+    return i;
+}
+
+/** 
+ *  @brief Set adhoc aes key
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_setadhocaes_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    u8 key_ascii[32];
+    u8 key_hex[16];
+    int ret = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+
+    WLAN_802_11_KEY key;
+
+    ENTER();
+
+    if (Adapter->InfrastructureMode != Wlan802_11IBSS)
+        return -EOPNOTSUPP;
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected)
+        return -EOPNOTSUPP;
+
+    if (copy_from_user(key_ascii, wrq->u.data.pointer, sizeof(key_ascii))) {
+        PRINTM(INFO, "wlan_setadhocaes_ioctl copy from user failed \n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    Adapter->AdhocAESEnabled = TRUE;
+    ascii2hex(key_hex, key_ascii, sizeof(key_hex));
+
+    HEXDUMP("wlan_setadhocaes_ioctl", key_hex, sizeof(key_hex));
+
+    PRINTM(INFO, "WPA2: ENABLE AES_KEY\n");
+    key.KeyLength = WPA_AES_KEY_LEN;
+    key.KeyIndex = 0x40000000;
+    memcpy(key.KeyMaterial, key_hex, key.KeyLength);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_KEY_MATERIAL,
+                                HostCmd_ACT_SET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                KEY_INFO_ENABLED, &key);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get adhoc aes key   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_getadhocaes_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    u8 *tmp;
+    u8 key_ascii[33];
+    u8 key_hex[16];
+    int i, ret = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+    WLAN_802_11_KEY key;
+
+    ENTER();
+
+    memset(key_hex, 0x00, sizeof(key_hex));
+
+    PRINTM(INFO, "WPA2: ENABLE AES_KEY\n");
+    key.KeyLength = WPA_AES_KEY_LEN;
+    key.KeyIndex = 0x40000000;
+    memcpy(key.KeyMaterial, key_hex, key.KeyLength);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_KEY_MATERIAL,
+                                HostCmd_ACT_GET,
+                                HostCmd_OPTION_WAITFORRSP,
+                                KEY_INFO_ENABLED, &key);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    memcpy(key_hex, Adapter->aeskey.KeyParamSet.Key, sizeof(key_hex));
+
+    HEXDUMP("wlan_getadhocaes_ioctl", key_hex, sizeof(key_hex));
+
+    wrq->u.data.length = sizeof(key_ascii) + 1;
+
+    memset(key_ascii, 0x00, sizeof(key_ascii));
+    tmp = key_ascii;
+
+    for (i = 0; i < sizeof(key_hex); i++)
+        tmp += sprintf(tmp, "%02x", key_hex[i]);
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &key_ascii, sizeof(key_ascii))) {
+            PRINTM(INFO, "copy_to_user failed\n");
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set/Get WPA IE   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_setwpaie_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length) {
+        if (wrq->u.data.length > sizeof(Adapter->Wpa_ie)) {
+            PRINTM(INFO, "failed to copy WPA IE, too big \n");
+            return -EFAULT;
+        }
+        if (copy_from_user(Adapter->Wpa_ie, wrq->u.data.pointer,
+                           wrq->u.data.length)) {
+            PRINTM(INFO, "failed to copy WPA IE \n");
+            return -EFAULT;
+        }
+        Adapter->Wpa_ie_len = wrq->u.data.length;
+        PRINTM(INFO, "Set Wpa_ie_len=%d IE=%#x\n", Adapter->Wpa_ie_len,
+               Adapter->Wpa_ie[0]);
+        HEXDUMP("Wpa_ie", Adapter->Wpa_ie, Adapter->Wpa_ie_len);
+        if (Adapter->Wpa_ie[0] == WPA_IE)
+            Adapter->SecInfo.WPAEnabled = TRUE;
+        else if (Adapter->Wpa_ie[0] == WPA2_IE)
+            Adapter->SecInfo.WPA2Enabled = TRUE;
+        else {
+            Adapter->SecInfo.WPAEnabled = FALSE;
+            Adapter->SecInfo.WPA2Enabled = FALSE;
+        }
+    } else {
+        memset(Adapter->Wpa_ie, 0, sizeof(Adapter->Wpa_ie));
+        Adapter->Wpa_ie_len = wrq->u.data.length;
+        PRINTM(INFO, "Reset Wpa_ie_len=%d IE=%#x\n", Adapter->Wpa_ie_len,
+               Adapter->Wpa_ie[0]);
+        Adapter->SecInfo.WPAEnabled = FALSE;
+        Adapter->SecInfo.WPA2Enabled = FALSE;
+    }
+
+    // enable/disable RSN in firmware if WPA is enabled/disabled
+    // depending on variable Adapter->SecInfo.WPAEnabled is set or not
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_ENABLE_RSN,
+                                HostCmd_ACT_SET, HostCmd_OPTION_WAITFORRSP,
+                                0, NULL);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set Auto Prescan
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_subcmd_setprescan_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int data;
+    wlan_adapter *Adapter = priv->adapter;
+    int *val;
+
+    ENTER();
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    PRINTM(INFO, "WLAN_SUBCMD_SET_PRESCAN %d\n", data);
+    switch (data) {
+    case CMD_ENABLED:
+        Adapter->Prescan = TRUE;
+        break;
+    case CMD_DISABLED:
+        Adapter->Prescan = FALSE;
+        break;
+    default:
+        break;
+    }
+
+    data = Adapter->Prescan;
+    val = (int *) wrq->u.name;
+    *val = data;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set multiple dtim
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_multiple_dtim_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    struct iwreq *wrq = (struct iwreq *) req;
+    u32 mdtim;
+    int idata;
+    int ret = -EINVAL;
+
+    ENTER();
+
+    idata = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    mdtim = (u32) idata;
+    if (((mdtim >= MRVDRV_MIN_MULTIPLE_DTIM) &&
+         (mdtim <= MRVDRV_MAX_MULTIPLE_DTIM))
+        || (mdtim == MRVDRV_IGNORE_MULTIPLE_DTIM)) {
+        priv->adapter->MultipleDtim = mdtim;
+        ret = WLAN_STATUS_SUCCESS;
+    }
+    if (ret)
+        PRINTM(INFO, "Invalid parameter, MultipleDtim not changed.\n");
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set authentication mode
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_setauthalg_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int alg;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.flags == 0) {
+        //from iwpriv subcmd
+        alg = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    } else {
+        //from wpa_supplicant subcmd
+        if (copy_from_user(&alg, wrq->u.data.pointer, sizeof(alg))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+    }
+
+    PRINTM(INFO, "auth alg is %#x\n", alg);
+
+    switch (alg) {
+    case AUTH_ALG_SHARED_KEY:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeShared;
+        break;
+    case AUTH_ALG_NETWORK_EAP:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeNetworkEAP;
+        break;
+    case AUTH_ALG_OPEN_SYSTEM:
+    default:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Encryption mode
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_setencryptionmode_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int mode;
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    if (wrq->u.data.flags == 0) {
+        //from iwpriv subcmd
+        mode = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    } else {
+        //from wpa_supplicant subcmd
+        if (copy_from_user(&mode, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+    }
+    PRINTM(INFO, "encryption mode is %#x\n", mode);
+    priv->adapter->SecInfo.EncryptionMode = mode;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Rx antenna
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_subcmd_getrxantenna_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int len;
+    char buf[8];
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    PRINTM(INFO, "WLAN_SUBCMD_GETRXANTENNA\n");
+    len = GetRxAntenna(priv, buf);
+
+    wrq->u.data.length = len;
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &buf, len)) {
+            PRINTM(INFO, "CopyToUser failed\n");
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Tx antenna
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_subcmd_gettxantenna_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int len;
+    char buf[8];
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    PRINTM(INFO, "WLAN_SUBCMD_GETTXANTENNA\n");
+    len = GetTxAntenna(priv, buf);
+
+    wrq->u.data.length = len;
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &buf, len)) {
+            PRINTM(INFO, "CopyToUser failed\n");
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get the MAC TSF value from the firmware
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure containing buffer
+ *                      space to store a TSF value retrieved from the firmware
+ *
+ *  @return             0 if successful; IOCTL error code otherwise
+ */
+static int
+wlan_get_tsf_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    u64 tsfVal = 0;
+    int ret;
+
+    ENTER();
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_GET_TSF,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, &tsfVal);
+
+    PRINTM(INFO, "IOCTL: Get TSF = 0x%016llx\n", tsfVal);
+
+    if (ret != WLAN_STATUS_SUCCESS) {
+        PRINTM(INFO, "IOCTL: Get TSF; Command exec failed\n");
+        ret = -EFAULT;
+    } else {
+        if (copy_to_user(wrq->u.data.pointer,
+                         &tsfVal,
+                         MIN(wrq->u.data.length, sizeof(tsfVal))) != 0) {
+
+            PRINTM(INFO, "IOCTL: Get TSF; Copy to user failed\n");
+            ret = -EFAULT;
+        } else {
+            ret = 0;
+        }
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set DeepSleep mode
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_deepsleep_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    char status[128];
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        PRINTM(MSG, "Cannot enter Deep Sleep mode in connected state.\n");
+        return -EINVAL;
+    }
+
+    if (*(char *) req->ifr_data == '0') {
+        PRINTM(INFO, "Exit Deep Sleep Mode.\n");
+        sprintf(status, "setting to off ");
+        SetDeepSleep(priv, FALSE);
+    } else if (*(char *) req->ifr_data == '1') {
+        PRINTM(INFO, "Enter Deep Sleep Mode.\n");
+        sprintf(status, "setting to on ");
+        SetDeepSleep(priv, TRUE);
+    } else if (*(char *) req->ifr_data == '2') {
+        PRINTM(INFO, "Get Deep Sleep Mode.\n");
+        if (Adapter->IsDeepSleep == TRUE) {
+            sprintf(status, "on ");
+        } else {
+            sprintf(status, "off ");
+        }
+    } else {
+        PRINTM(INFO, "unknown option = %d\n", *(u8 *) req->ifr_data);
+        return -EINVAL;
+    }
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &status, strlen(status)))
+            return -EFAULT;
+        wrq->u.data.length = strlen(status);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Config hostsleep parameter
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_hostsleepcfg_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    char buf[32];
+    int ret = WLAN_STATUS_SUCCESS;
+    int gpio, gap;
+
+    memset(buf, 0, sizeof(buf));
+    if (copy_from_user(buf, wrq->u.data.pointer,
+                       MIN(sizeof(buf) - 1, wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+    buf[sizeof(buf) - 1] = 0;
+
+    if (sscanf(buf, "%x %x %x", &Adapter->HSCfg.conditions, &gpio, &gap) != 3) {
+        PRINTM(MSG, "Invalid parameters\n");
+        return -EINVAL;
+    }
+
+    if (Adapter->HSCfg.conditions != HOST_SLEEP_CFG_CANCEL) {
+        Adapter->HSCfg.gpio = (u8) gpio;
+        Adapter->HSCfg.gap = (u8) gap;
+    }
+
+    PRINTM(INFO, "hostsleepcfg: cond=%#x gpio=%#x gap=%#x\n",
+           Adapter->HSCfg.conditions, Adapter->HSCfg.gpio,
+           Adapter->HSCfg.gap);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_HOST_SLEEP_CFG,
+                                0, HostCmd_OPTION_WAITFORRSP, 0,
+                                &Adapter->HSCfg);
+
+    return ret;
+}
+
+/** 
+ *  @brief Config Host Sleep parameters
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wreq		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_hscfg_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u32 data[3] = { -1, 0xff, 0xff };
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length >= 1 && wrq->u.data.length <= 3) {
+        if (copy_from_user
+            (data, wrq->u.data.pointer,
+             sizeof(data[0]) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+        PRINTM(INFO,
+               "wlan_hscfg_ioctl: data[0]=%#08x, data[1]=%#02x, data[2]=%#02x\n",
+               data[0], data[1], data[2]);
+    }
+
+    Adapter->HSCfg.conditions = data[0];
+    if (Adapter->HSCfg.conditions != HOST_SLEEP_CFG_CANCEL) {
+        if (wrq->u.data.length == 2) {
+            Adapter->HSCfg.gpio = (u8) data[1];
+        } else if (wrq->u.data.length == 3) {
+            Adapter->HSCfg.gpio = (u8) data[1];
+            Adapter->HSCfg.gap = (u8) data[2];
+        }
+    }
+
+    PRINTM(INFO, "hscfg: cond=%#x gpio=%#x gap=%#x\n",
+           Adapter->HSCfg.conditions, Adapter->HSCfg.gpio,
+           Adapter->HSCfg.gap);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_HOST_SLEEP_CFG,
+                                0, HostCmd_OPTION_WAITFORRSP, 0,
+                                &Adapter->HSCfg);
+
+    data[0] = Adapter->HSCfg.conditions;
+    data[1] = Adapter->HSCfg.gpio;
+    data[2] = Adapter->HSCfg.gap;
+    wrq->u.data.length = 3;
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set Cal data ext
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_caldata_ext_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    HostCmd_DS_802_11_CAL_DATA_EXT *pCalData = NULL;
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 action;
+
+    ENTER();
+
+    if (!
+        (pCalData =
+         kmalloc(sizeof(HostCmd_DS_802_11_CAL_DATA_EXT), GFP_KERNEL))) {
+        PRINTM(INFO, "Allocate memory failed\n");
+        ret = -ENOMEM;
+        goto calexit;
+    }
+    memset(pCalData, 0, sizeof(HostCmd_DS_802_11_CAL_DATA_EXT));
+
+    if (copy_from_user(pCalData, req->ifr_data + SKIP_CMDNUM,
+                       sizeof(HostCmd_DS_802_11_CAL_DATA_EXT))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        kfree(pCalData);
+        ret = -EFAULT;
+        goto calexit;
+    }
+
+    action = (pCalData->Action == HostCmd_ACT_GEN_SET) ?
+        HostCmd_ACT_GEN_SET : HostCmd_ACT_GEN_GET;
+
+    HEXDUMP("Cal data ext", (u8 *) pCalData,
+            sizeof(HostCmd_DS_802_11_CAL_DATA_EXT));
+
+    PRINTM(INFO, "CalData Action = 0x%0X\n", action);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_CAL_DATA_EXT,
+                                action,
+                                HostCmd_OPTION_WAITFORRSP, 0, pCalData);
+
+    if (!ret && action == HostCmd_ACT_GEN_GET) {
+        if (copy_to_user(req->ifr_data + SKIP_CMDNUM, pCalData,
+                         sizeof(HostCmd_DS_802_11_CAL_DATA_EXT))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+    }
+
+    kfree(pCalData);
+  calexit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set sleep period 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_sleep_period(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    int data;
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_SLEEP_PERIOD sleeppd;
+
+    ENTER();
+
+    if (wrq->u.data.length > 1)
+        return -ENOTSUPP;
+
+    memset(&sleeppd, 0, sizeof(sleeppd));
+    memset(&Adapter->sleep_period, 0, sizeof(SleepPeriod));
+
+    if (wrq->u.data.length == 0) {
+        sleeppd.Action = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+    } else {
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        /* sleep period is 0 or 10~60 in milliseconds */
+#define MIN_SLEEP_PERIOD		10
+#define MAX_SLEEP_PERIOD		60
+#define SLEEP_PERIOD_RESERVED_FF	0xFF
+        if ((data <= MAX_SLEEP_PERIOD && data >= MIN_SLEEP_PERIOD) ||
+            (data == 0)
+            || (data == SLEEP_PERIOD_RESERVED_FF)       /* for UPSD certification tests */
+            ) {
+            sleeppd.Action = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+            sleeppd.Period = data;
+        } else
+            return -EINVAL;
+    }
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SLEEP_PERIOD,
+                                0, HostCmd_OPTION_WAITFORRSP,
+                                0, (void *) &sleeppd);
+
+    data = (int) Adapter->sleep_period.period;
+    if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set adapt rate 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_adapt_rateset(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+    int data[4];
+    int rateindex;
+
+    ENTER();
+    memset(data, 0, sizeof(data));
+    if (!wrq->u.data.length) {
+        PRINTM(INFO, "Get ADAPT RATE SET\n");
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_RATE_ADAPT_RATESET,
+                                    HostCmd_ACT_GEN_GET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, NULL);
+        data[0] = Adapter->HWRateDropMode;
+        data[2] = Adapter->Threshold;
+        data[3] = Adapter->FinalRate;
+        wrq->u.data.length = 4;
+        data[1] = Adapter->RateBitmap;
+        if (copy_to_user
+            (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+
+    } else {
+        PRINTM(INFO, "Set ADAPT RATE SET\n");
+        if (wrq->u.data.length > 4)
+            return -EINVAL;
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        if (data[0] > HW_SINGLE_RATE_DROP)
+            return -EINVAL;
+        Adapter->HWRateDropMode = data[0];
+        Adapter->Threshold = data[2];
+        Adapter->FinalRate = data[3];
+        Adapter->RateBitmap = data[1];
+        Adapter->Is_DataRate_Auto = Is_Rate_Auto(priv);
+        if (Adapter->Is_DataRate_Auto)
+            Adapter->DataRate = 0;
+        else {
+            rateindex = GetRateIndex(priv);
+            Adapter->DataRate = index_to_data_rate(rateindex);
+        }
+        PRINTM(INFO, "RateBitmap=%x,IsRateAuto=%d,DataRate=%d\n",
+               Adapter->RateBitmap, Adapter->Is_DataRate_Auto,
+               Adapter->DataRate);
+        ret =
+            PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RATE_ADAPT_RATESET,
+                                  HostCmd_ACT_GEN_SET,
+                                  HostCmd_OPTION_WAITFORRSP, 0, NULL);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set inactivity timeout
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_inactivity_timeout(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    int data = 0;
+    u16 timeout = 0;
+
+    ENTER();
+    if (wrq->u.data.length > 1)
+        return -ENOTSUPP;
+
+    if (wrq->u.data.length == 0) {
+        /* Get */
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_INACTIVITY_TIMEOUT,
+                                    HostCmd_ACT_GET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, &timeout);
+        data = timeout;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+    } else {
+        /* Set */
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        timeout = data;
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_INACTIVITY_TIMEOUT,
+                                    HostCmd_ACT_SET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, &timeout);
+    }
+
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get LOG
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_getlog_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    char *buf = NULL;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, " GET STATS\n");
+
+    if (!(buf = kmalloc(GETLOG_BUFSIZE, GFP_KERNEL))) {
+        PRINTM(INFO, "kmalloc failed!\n");
+        return -ENOMEM;
+    }
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_GET_LOG,
+                                0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    if (!ret && wrq->u.data.pointer) {
+        sprintf(buf, "\n"
+                "mcasttxframe     %u\n"
+                "failed           %u\n"
+                "retry            %u\n"
+                "multiretry       %u\n"
+                "framedup         %u\n"
+                "rtssuccess       %u\n"
+                "rtsfailure       %u\n"
+                "ackfailure       %u\n"
+                "rxfrag           %u\n"
+                "mcastrxframe     %u\n"
+                "fcserror         %u\n"
+                "txframe          %u\n"
+                "wepundecryptable %u\n",
+                Adapter->LogMsg.mcasttxframe,
+                Adapter->LogMsg.failed,
+                Adapter->LogMsg.retry,
+                Adapter->LogMsg.multiretry,
+                Adapter->LogMsg.framedup,
+                Adapter->LogMsg.rtssuccess,
+                Adapter->LogMsg.rtsfailure,
+                Adapter->LogMsg.ackfailure,
+                Adapter->LogMsg.rxfrag,
+                Adapter->LogMsg.mcastrxframe,
+                Adapter->LogMsg.fcserror,
+                Adapter->LogMsg.txframe, Adapter->LogMsg.wepundecryptable);
+        wrq->u.data.length = strlen(buf) + 1;
+        if (copy_to_user(wrq->u.data.pointer, buf, wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+    }
+
+    kfree(buf);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief config sleep parameters
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_sleep_params_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_sleep_params_config sp;
+
+    ENTER();
+
+    memset(&sp, 0, sizeof(sp));
+
+    if (!wrq->u.data.pointer)
+        return -EFAULT;
+    if (copy_from_user(&sp, wrq->u.data.pointer,
+                       MIN(sizeof(sp), wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    memcpy(&Adapter->sp, &sp.Error, sizeof(SleepParams));
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SLEEP_PARAMS,
+                                sp.Action, HostCmd_OPTION_WAITFORRSP,
+                                0, NULL);
+
+    if (!ret && !sp.Action) {
+        memcpy(&sp.Error, &Adapter->sp, sizeof(SleepParams));
+        if (copy_to_user(wrq->u.data.pointer, &sp, sizeof(sp))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = sizeof(sp);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Read the CIS Table
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_getcis_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, Adapter->CisInfoBuf,
+                         Adapter->CisInfoLen)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = Adapter->CisInfoLen;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set BCA timeshare
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_bca_timeshare_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_bca_timeshare_config bca_ts;
+
+    ENTER();
+
+    memset(&bca_ts, 0, sizeof(HostCmd_DS_802_11_BCA_TIMESHARE));
+
+    if (!wrq->u.data.pointer)
+        return -EFAULT;
+    if (copy_from_user(&bca_ts, wrq->u.data.pointer,
+                       MIN(sizeof(bca_ts), wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    PRINTM(INFO, "TrafficType=%x TimeShareInterva=%x BTTime=%x\n",
+           bca_ts.TrafficType, bca_ts.TimeShareInterval, bca_ts.BTTime);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE,
+                                bca_ts.Action, HostCmd_OPTION_WAITFORRSP,
+                                0, &bca_ts);
+
+    if (!ret && !bca_ts.Action) {
+        if (copy_to_user(wrq->u.data.pointer, &Adapter->bca_ts,
+                         sizeof(bca_ts))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = sizeof(HostCmd_DS_802_11_BCA_TIMESHARE);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set scan type
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_scan_type_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    u8 buf[12];
+    u8 *option[] = { "active", "passive", "get", };
+    int i, max_options = (sizeof(option) / sizeof(option[0]));
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wlan_get_state_11d(priv) == ENABLE_11D) {
+        PRINTM(INFO, "11D: Cannot set scantype when 11D enabled\n");
+        return -EFAULT;
+    }
+
+    memset(buf, 0, sizeof(buf));
+
+    if (copy_from_user(buf, wrq->u.data.pointer, MIN(sizeof(buf),
+                                                     wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    PRINTM(INFO, "Scan Type Option = %s\n", buf);
+
+    buf[sizeof(buf) - 1] = '\0';
+
+    for (i = 0; i < max_options; i++) {
+        if (!strcmp(buf, option[i]))
+            break;
+    }
+
+    switch (i) {
+    case 0:
+        Adapter->ScanType = HostCmd_SCAN_TYPE_ACTIVE;
+        break;
+    case 1:
+        Adapter->ScanType = HostCmd_SCAN_TYPE_PASSIVE;
+        break;
+    case 2:
+        wrq->u.data.length = strlen(option[Adapter->ScanType]) + 1;
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         option[Adapter->ScanType], wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+
+        break;
+    default:
+        PRINTM(INFO, "Invalid Scan Type Ioctl Option\n");
+        ret = -EINVAL;
+        break;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set scan mode
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_scan_mode_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u8 buf[12];
+    u8 *option[] = { "bss", "ibss", "any", "get" };
+    int i, max_options = (sizeof(option) / sizeof(option[0]));
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    memset(buf, 0, sizeof(buf));
+
+    if (copy_from_user(buf, wrq->u.data.pointer, MIN(sizeof(buf),
+                                                     wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    PRINTM(INFO, "Scan Mode Option = %s\n", buf);
+
+    buf[sizeof(buf) - 1] = '\0';
+
+    for (i = 0; i < max_options; i++) {
+        if (!strcmp(buf, option[i]))
+            break;
+    }
+
+    switch (i) {
+
+    case 0:
+        Adapter->ScanMode = HostCmd_BSS_TYPE_BSS;
+        break;
+    case 1:
+        Adapter->ScanMode = HostCmd_BSS_TYPE_IBSS;
+        break;
+    case 2:
+        Adapter->ScanMode = HostCmd_BSS_TYPE_ANY;
+        break;
+    case 3:
+
+        wrq->u.data.length = strlen(option[Adapter->ScanMode - 1]) + 1;
+
+        PRINTM(INFO, "Get Scan Mode Option = %s\n",
+               option[Adapter->ScanMode - 1]);
+
+        PRINTM(INFO, "Scan Mode Length %d\n", wrq->u.data.length);
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         option[Adapter->ScanMode - 1], wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+        PRINTM(INFO, "GET Scan Type Option after copy = %s\n",
+               (char *) wrq->u.data.pointer);
+
+        break;
+
+    default:
+        PRINTM(INFO, "Invalid Scan Mode Ioctl Option\n");
+        ret = -EINVAL;
+        break;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set Adhoc G Rate
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_do_set_grate_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data, data1;
+    int *val;
+
+    ENTER();
+
+    data1 = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    switch (data1) {
+    case 0:
+        Adapter->adhoc_grate_enabled = FALSE;
+        break;
+    case 1:
+        Adapter->adhoc_grate_enabled = TRUE;
+        break;
+    case 2:
+        break;
+    default:
+        return -EINVAL;
+    }
+    data = Adapter->adhoc_grate_enabled;
+    val = (int *) wrq->u.name;
+    *val = data;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Firmware wakeup method
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_cmd_fw_wakeup_method(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u16 action;
+    u16 method;
+    int ret;
+    int data;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0 || !wrq->u.data.pointer) {
+        action = HostCmd_ACT_GET;
+    } else {
+        action = HostCmd_ACT_SET;
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        switch (data) {
+        case 0:
+            Adapter->fwWakeupMethod = WAKEUP_FW_UNCHANGED;
+            break;
+        case 1:
+            Adapter->fwWakeupMethod = WAKEUP_FW_THRU_INTERFACE;
+            break;
+        case 2:
+            Adapter->fwWakeupMethod = WAKEUP_FW_THRU_GPIO;
+            break;
+        default:
+            return -EINVAL;
+        }
+    }
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_FW_WAKEUP_METHOD, action,
+                                HostCmd_OPTION_WAITFORRSP, 0,
+                                &Adapter->fwWakeupMethod);
+
+    if (action == HostCmd_ACT_GET) {
+        method = Adapter->fwWakeupMethod;
+        if (copy_to_user(wrq->u.data.pointer, &method, sizeof(method))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+/** 
+ *  @brief ioctl function - entry point
+ *  
+ *  @param dev		A pointer to net_device structure
+ *  @param req	   	A pointer to ifreq structure
+ *  @param cmd 		command
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+int
+wlan_do_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+    int subcmd = 0;
+    int idata = 0;
+    int *pdata;
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    if (Adapter->IsDeepSleep) {
+        int count = sizeof(Commands_Allowed_In_DeepSleep)
+            / sizeof(Commands_Allowed_In_DeepSleep[0]);
+
+        if (!Is_Command_Allowed_In_Sleep
+            (req, cmd, Commands_Allowed_In_DeepSleep, count)) {
+            PRINTM(MSG,
+                   "():%s IOCTLS called when station is" " in DeepSleep\n",
+                   __FUNCTION__);
+            return -EBUSY;
+        }
+    }
+
+    PRINTM(INFO, "wlan_do_ioctl: ioctl cmd = 0x%x\n", cmd);
+    switch (cmd) {
+    case WLANEXTSCAN:
+        ret = wlan_extscan_ioctl(priv, req);
+        break;
+    case WLANHOSTCMD:
+        ret = wlan_hostcmd_ioctl(dev, req, cmd);
+        break;
+    case WLANARPFILTER:
+        ret = wlan_arpfilter_ioctl(dev, req, cmd);
+        break;
+
+    case WLANCISDUMP:          /* Read CIS Table  */
+        ret = wlan_do_getcis_ioctl(priv, req);
+        break;
+
+    case WLANSCAN_TYPE:
+        PRINTM(INFO, "Scan Type Ioctl\n");
+        ret = wlan_scan_type_ioctl(priv, wrq);
+        break;
+
+#ifdef MFG_CMD_SUPPORT
+    case WLANMANFCMD:
+        PRINTM(INFO, "Entering the Manufacturing ioctl SIOCCFMFG\n");
+        ret = wlan_mfg_command(priv, (void *) req->ifr_data);
+
+        PRINTM(INFO, "Manufacturing Ioctl %s\n",
+               (ret) ? "failed" : "success");
+        break;
+#endif
+
+    case WLANREGRDWR:          /* Register read write command */
+        ret = wlan_regrdwr_ioctl(priv, req);
+        break;
+
+    case WLANCMD52RDWR:        /* CMD52 read/write command */
+        ret = wlan_cmd52rdwr_ioctl(priv, req);
+        break;
+
+    case WLANCMD53RDWR:        /* CMD53 read/write command */
+        ret = wlan_cmd53rdwr_ioctl(priv, req);
+        break;
+
+    case SIOCSIWENCODE:        /* set encoding token & mode for WPA */
+        ret = wlan_set_encode(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
+        break;
+    case WLAN_SETNONE_GETNONE: /* set WPA mode on/off ioctl #20 */
+        switch (wrq->u.data.flags) {
+        case WLANDEAUTH:
+            PRINTM(INFO, "Deauth\n");
+            wlan_send_deauth(priv);
+            break;
+
+        case WLANADHOCSTOP:
+            PRINTM(INFO, "Adhoc stop\n");
+            ret = wlan_do_adhocstop_ioctl(priv);
+            break;
+
+        case WLANRADIOON:
+            wlan_radio_ioctl(priv, RADIO_ON);
+            break;
+
+        case WLANRADIOOFF:
+            wlan_radio_ioctl(priv, RADIO_OFF);
+            break;
+        case WLANREMOVEADHOCAES:
+            ret = wlan_remove_aes(priv);
+            break;
+#ifdef REASSOCIATION
+        case WLANREASSOCIATIONAUTO:
+            reassociation_on(priv);
+            break;
+        case WLANREASSOCIATIONUSER:
+            reassociation_off(priv);
+            break;
+#endif /* REASSOCIATION */
+        case WLANWLANIDLEON:
+            wlanidle_on(priv);
+            break;
+        case WLANWLANIDLEOFF:
+            wlanidle_off(priv);
+            break;
+        }                       /* End of switch */
+        break;
+
+    case WLAN_SETWORDCHAR_GETNONE:
+        switch (wrq->u.data.flags) {
+        case WLANSETADHOCAES:
+            ret = wlan_setadhocaes_ioctl(priv, req);
+            break;
+        }
+        break;
+
+    case WLAN_SETNONE_GETWORDCHAR:
+        switch (wrq->u.data.flags) {
+        case WLANGETADHOCAES:
+            ret = wlan_getadhocaes_ioctl(priv, req);
+            break;
+        case WLANVERSION:      /* Get driver version */
+            ret = wlan_version_ioctl(priv, req);
+            break;
+        }
+        break;
+
+    case WLANSETWPAIE:
+        ret = wlan_setwpaie_ioctl(priv, req);
+        break;
+    case WLAN_SETINT_GETINT:
+        /* The first 4 bytes of req->ifr_data is sub-ioctl number
+         * after 4 bytes sits the payload.
+         */
+        subcmd = (int) req->ifr_data;   //from iwpriv subcmd
+        switch (subcmd) {
+        case WLANNF:
+            ret = wlan_get_nf(priv, wrq);
+            break;
+        case WLANRSSI:
+            ret = wlan_get_rssi(priv, wrq);
+            break;
+        case WLANBGSCAN:
+            {
+                int data, data1;
+                int *val;
+                data1 = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+                switch (data1) {
+                case CMD_DISABLED:
+                    PRINTM(INFO, "Background scan is set to disable\n");
+                    ret = wlan_bg_scan_enable(priv, FALSE);
+                    val = (int *) wrq->u.name;
+                    *val = data1;
+                    break;
+                case CMD_ENABLED:
+                    PRINTM(INFO, "Background scan is set to enable\n");
+                    ret = wlan_bg_scan_enable(priv, TRUE);
+                    val = (int *) wrq->u.name;
+                    *val = data1;
+                    break;
+                case CMD_GET:
+                    data = (Adapter->bgScanConfig->Enable == TRUE) ?
+                        CMD_ENABLED : CMD_DISABLED;
+                    val = (int *) wrq->u.name;
+                    *val = data;
+                    break;
+                default:
+                    ret = -EINVAL;
+                    PRINTM(INFO, "Background scan: wrong parameter\n");
+                    break;
+                }
+            }
+            break;
+        case WLANENABLE11D:
+            ret = wlan_cmd_enable_11d(priv, wrq);
+            break;
+        case WLANADHOCGRATE:
+            ret = wlan_do_set_grate_ioctl(priv, wrq);
+            break;
+        case WLANSDIOCLOCK:
+            {
+                int data;
+                int *val;
+                data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+                switch (data) {
+                case CMD_DISABLED:
+                    PRINTM(INFO, "SDIO clock is turned off\n");
+                    ret = sbi_set_bus_clock(priv, FALSE);
+                    break;
+                case CMD_ENABLED:
+                    PRINTM(INFO, "SDIO clock is turned on\n");
+                    ret = sbi_set_bus_clock(priv, TRUE);
+                    break;
+                case CMD_GET:  /* need an API in sdio.c to get STRPCL */
+                default:
+                    ret = -EINVAL;
+                    PRINTM(INFO, "sdioclock: wrong parameter\n");
+                    break;
+                }
+                val = (int *) wrq->u.name;
+                *val = data;
+            }
+            break;
+        case WLANWMM_ENABLE:
+            ret = wlan_wmm_enable_ioctl(priv, wrq);
+            break;
+        case WLANNULLGEN:
+            ret = wlan_null_pkg_gen(priv, wrq);
+            /* enable/disable null pkg generation */
+            break;
+        case WLAN_SUBCMD_SET_PRESCAN:
+            ret = wlan_subcmd_setprescan_ioctl(priv, wrq);
+            break;
+        case WLANADHOCCSET:
+            ret = wlan_set_coalescing_ioctl(priv, wrq);
+            break;
+        }
+        break;
+
+    case WLAN_SETONEINT_GETONEINT:
+        switch (wrq->u.data.flags) {
+
+        case WLAN_WMM_QOSINFO:
+            {
+                int data;
+                if (wrq->u.data.length == 1) {
+                    if (copy_from_user
+                        (&data, wrq->u.data.pointer, sizeof(int))) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        return -EFAULT;
+                    }
+                    Adapter->wmm.qosinfo = (u8) data;
+                } else {
+                    data = (int) Adapter->wmm.qosinfo;
+                    if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+                        PRINTM(INFO, "Copy to user failed\n");
+                        return -EFAULT;
+                    }
+                    wrq->u.data.length = 1;
+                }
+            }
+            break;
+        case WLAN_LISTENINTRVL:
+            if (!wrq->u.data.length) {
+                int data;
+                PRINTM(INFO, "Get LocalListenInterval Value\n");
+#define GET_ONE_INT	1
+                data = Adapter->LocalListenInterval;
+                if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+                    PRINTM(INFO, "Copy to user failed\n");
+                    return -EFAULT;
+                }
+
+                wrq->u.data.length = GET_ONE_INT;
+            } else {
+                int data;
+                if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+                    PRINTM(INFO, "Copy from user failed\n");
+                    return -EFAULT;
+                }
+
+                PRINTM(INFO, "Set LocalListenInterval = %d\n", data);
+#define MAX_U16_VAL	65535
+                if (data > MAX_U16_VAL) {
+                    PRINTM(INFO, "Exceeds U16 value\n");
+                    return -EINVAL;
+                }
+                Adapter->LocalListenInterval = data;
+            }
+            break;
+        case WLAN_FW_WAKEUP_METHOD:
+            ret = wlan_cmd_fw_wakeup_method(priv, wrq);
+            break;
+        case WLAN_TXCONTROL:
+            ret = wlan_txcontrol(priv, wrq);    //adds for txcontrol ioctl
+            break;
+
+        case WLAN_NULLPKTINTERVAL:
+            ret = wlan_null_pkt_interval(priv, wrq);
+            break;
+        case WLAN_ADHOC_AWAKE_PERIOD:
+            ret = wlan_adhoc_awake_period(priv, wrq);
+            break;
+        case WLAN_LDO:
+            ret = wlan_ldo_config(priv, wrq);
+            break;
+        default:
+            ret = -EOPNOTSUPP;
+            break;
+        }
+        break;
+
+    case WLAN_SETONEINT_GETNONE:
+        /* The first 4 bytes of req->ifr_data is sub-ioctl number
+         * after 4 bytes sits the payload.
+         */
+        subcmd = wrq->u.data.flags;     //from wpa_supplicant subcmd
+
+        if (!subcmd)
+            subcmd = (int) req->ifr_data;       //from iwpriv subcmd
+
+        switch (subcmd) {
+        case WLAN_SUBCMD_SETRXANTENNA: /* SETRXANTENNA */
+            idata = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+            ret = SetRxAntenna(priv, idata);
+            break;
+        case WLAN_SUBCMD_SETTXANTENNA: /* SETTXANTENNA */
+            idata = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+            ret = SetTxAntenna(priv, idata);
+            break;
+
+        case WLANSETBCNAVG:
+            {
+                u16 bcn_avg = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+
+                if (bcn_avg == 0)
+                    Adapter->bcn_avg_factor = DEFAULT_BCN_AVG_FACTOR;
+                else if (bcn_avg > MAX_BCN_AVG_FACTOR
+                         || bcn_avg < MIN_BCN_AVG_FACTOR) {
+                    PRINTM(MSG,
+                           "The value '%u' is out of the range (0-%u).\n",
+                           bcn_avg, MAX_BCN_AVG_FACTOR);
+                    return -EINVAL;
+                } else
+                    Adapter->bcn_avg_factor = bcn_avg;
+                break;
+            }
+        case WLANSETDATAAVG:
+            {
+                u16 data_avg = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+
+                if (data_avg == 0)
+                    Adapter->data_avg_factor = DEFAULT_DATA_AVG_FACTOR;
+                else if (data_avg > MAX_DATA_AVG_FACTOR
+                         || data_avg < MIN_DATA_AVG_FACTOR) {
+                    PRINTM(MSG,
+                           "The value '%u' is out of the range (0-%u).\n",
+                           data_avg, MAX_DATA_AVG_FACTOR);
+                    return -EINVAL;
+                } else
+                    Adapter->data_avg_factor = data_avg;
+                memset(Adapter->rawSNR, 0x00, sizeof(Adapter->rawSNR));
+                memset(Adapter->rawNF, 0x00, sizeof(Adapter->rawNF));
+                Adapter->nextSNRNF = 0;
+                Adapter->numSNRNF = 0;
+                break;
+            }
+        case WLANSETREGION:
+            idata = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+            ret = wlan_set_region(priv, (u16) idata);
+            break;
+
+        case WLAN_SET_LISTEN_INTERVAL:
+            idata = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+            Adapter->ListenInterval = (u16) idata;
+            break;
+
+        case WLAN_SET_MULTIPLE_DTIM:
+            ret = wlan_set_multiple_dtim_ioctl(priv, req);
+            break;
+
+        case WLANSETAUTHALG:
+            ret = wlan_setauthalg_ioctl(priv, req);
+            break;
+
+        case WLANSETENCRYPTIONMODE:
+            ret = wlan_setencryptionmode_ioctl(priv, req);
+            break;
+        default:
+            ret = -EOPNOTSUPP;
+            break;
+        }
+
+        break;
+
+    case WLAN_SETNONE_GETTWELVE_CHAR:  /* Get Antenna settings */
+        /* 
+         * We've not used IW_PRIV_TYPE_FIXED so sub-ioctl number is
+         * in flags of iwreq structure, otherwise it will be in
+         * mode member of iwreq structure.
+         */
+        switch ((int) wrq->u.data.flags) {
+        case WLAN_SUBCMD_GETRXANTENNA: /* Get Rx Antenna */
+            ret = wlan_subcmd_getrxantenna_ioctl(priv, req);
+            break;
+
+        case WLAN_SUBCMD_GETTXANTENNA: /* Get Tx Antenna */
+            ret = wlan_subcmd_gettxantenna_ioctl(priv, req);
+            break;
+
+        case WLAN_GET_TSF:
+            ret = wlan_get_tsf_ioctl(priv, wrq);
+            break;
+
+        }
+        break;
+
+    case WLANDEEPSLEEP:
+        ret = wlan_deepsleep_ioctl(priv, req);
+        break;
+
+    case WLANHOSTSLEEPCFG:
+        ret = wlan_do_hostsleepcfg_ioctl(priv, wrq);
+        break;
+
+    case WLAN_SET64CHAR_GET64CHAR:
+        switch ((int) wrq->u.data.flags) {
+
+        case WLANSLEEPPARAMS:
+            ret = wlan_sleep_params_ioctl(priv, wrq);
+            break;
+
+        case WLAN_BCA_TIMESHARE:
+            ret = wlan_bca_timeshare_ioctl(priv, wrq);
+            break;
+        case WLANSCAN_MODE:
+            PRINTM(INFO, "Scan Mode Ioctl\n");
+            ret = wlan_scan_mode_ioctl(priv, wrq);
+            break;
+
+        case WLAN_GET_ADHOC_STATUS:
+            ret = wlan_get_adhoc_status_ioctl(priv, wrq);
+            break;
+        case WLAN_SET_GEN_IE:
+            ret = wlan_set_gen_ie_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_GEN_IE:
+            ret = wlan_get_gen_ie_ioctl(priv, wrq);
+            break;
+        case WLAN_REASSOCIATE:
+            ret = wlan_reassociate_ioctl(dev, wrq);
+            break;
+        case WLAN_WMM_QUEUE_STATUS:
+            ret = wlan_wmm_queue_status_ioctl(priv, wrq);
+            break;
+        }
+        break;
+
+    case WLAN_SETCONF_GETCONF:
+        PRINTM(INFO, "The WLAN_SETCONF_GETCONF=0x%x is %d\n",
+               WLAN_SETCONF_GETCONF, *(u8 *) req->ifr_data);
+        switch (*(u8 *) req->ifr_data) {
+        case CAL_DATA_EXT_CONFIG:
+            ret = wlan_do_caldata_ext_ioctl(priv, req);
+            break;
+        case BG_SCAN_CONFIG:
+            ret = wlan_do_bg_scan_config_ioctl(priv, req);
+            break;
+
+        case WMM_ACK_POLICY:
+            ret = wlan_wmm_ack_policy_ioctl(priv, req);
+            break;
+        case WMM_PARA_IE:
+            ret = wlan_wmm_para_ie_ioctl(priv, req);
+            break;
+        }
+        break;
+
+    case WLAN_SETNONE_GETONEINT:
+        switch ((int) req->ifr_data) {
+        case WLANGETBCNAVG:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->bcn_avg_factor;
+            break;
+
+        case WLANGETDATAAVG:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->data_avg_factor;
+            break;
+
+        case WLANGETREGION:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->RegionCode;
+            break;
+
+        case WLAN_GET_LISTEN_INTERVAL:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->ListenInterval;
+            break;
+
+        case WLAN_GET_MULTIPLE_DTIM:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->MultipleDtim;
+            break;
+        case WLAN_GET_TX_RATE:
+            ret = wlan_get_txrate_ioctl(priv, req);
+            break;
+        default:
+            ret = -EOPNOTSUPP;
+
+        }
+
+        break;
+
+    case WLANGETLOG:
+        ret = wlan_do_getlog_ioctl(priv, wrq);
+        break;
+
+    case WLAN_SET_GET_SIXTEEN_INT:
+        switch ((int) wrq->u.data.flags) {
+        case WLAN_TPCCFG:
+            {
+                int data[5];
+                HostCmd_DS_802_11_TPC_CFG cfg;
+                memset(&cfg, 0, sizeof(cfg));
+                if ((wrq->u.data.length > 1) && (wrq->u.data.length != 5))
+                    return WLAN_STATUS_FAILURE;
+
+                if (wrq->u.data.length == 0) {
+                    cfg.Action = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+                } else {
+                    if (copy_from_user
+                        (data, wrq->u.data.pointer, sizeof(int) * 5)) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        return -EFAULT;
+                    }
+
+                    cfg.Action = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+                    cfg.Enable = data[0];
+                    cfg.UseSNR = data[1];
+                    cfg.P0 = data[2];
+                    cfg.P1 = data[3];
+                    cfg.P2 = data[4];
+                }
+
+                ret =
+                    PrepareAndSendCommand(priv, HostCmd_CMD_802_11_TPC_CFG, 0,
+                                          HostCmd_OPTION_WAITFORRSP, 0,
+                                          (void *) &cfg);
+
+                data[0] = cfg.Enable;
+                data[1] = cfg.UseSNR;
+                data[2] = cfg.P0;
+                data[3] = cfg.P1;
+                data[4] = cfg.P2;
+                if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 5)) {
+                    PRINTM(INFO, "Copy to user failed\n");
+                    return -EFAULT;
+                }
+
+                wrq->u.data.length = 5;
+            }
+            break;
+        case WLAN_AUTO_FREQ_SET:
+            {
+                int data[3];
+                HostCmd_DS_802_11_AFC afc;
+                memset(&afc, 0, sizeof(afc));
+                if (wrq->u.data.length != 3)
+                    return WLAN_STATUS_FAILURE;
+                if (copy_from_user
+                    (data, wrq->u.data.pointer, sizeof(int) * 3)) {
+                    PRINTM(INFO, "Copy from user failed\n");
+                    return -EFAULT;
+                }
+                afc.afc_auto = data[0];
+
+                if (afc.afc_auto != 0) {
+                    afc.afc_thre = data[1];
+                    afc.afc_period = data[2];
+                } else {
+                    afc.afc_toff = data[1];
+                    afc.afc_foff = data[2];
+                }
+                ret =
+                    PrepareAndSendCommand(priv, HostCmd_CMD_802_11_SET_AFC, 0,
+                                          HostCmd_OPTION_WAITFORRSP, 0,
+                                          (void *) &afc);
+            }
+            break;
+        case WLAN_AUTO_FREQ_GET:
+            {
+                int data[3];
+                HostCmd_DS_802_11_AFC afc;
+                memset(&afc, 0, sizeof(afc));
+                ret =
+                    PrepareAndSendCommand(priv, HostCmd_CMD_802_11_GET_AFC, 0,
+                                          HostCmd_OPTION_WAITFORRSP, 0,
+                                          (void *) &afc);
+                data[0] = afc.afc_auto;
+                data[1] = afc.afc_toff;
+                data[2] = afc.afc_foff;
+                if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 3)) {
+                    PRINTM(INFO, "Copy to user failed\n");
+                    return -EFAULT;
+                }
+
+                wrq->u.data.length = 3;
+            }
+            break;
+        case WLAN_SCANPROBES:
+            {
+                int data;
+                if (wrq->u.data.length > 0) {
+                    if (copy_from_user
+                        (&data, wrq->u.data.pointer, sizeof(int))) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        return -EFAULT;
+                    }
+
+                    Adapter->ScanProbes = data;
+                } else {
+                    data = Adapter->ScanProbes;
+                    if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+                        PRINTM(INFO, "Copy to user failed\n");
+                        return -EFAULT;
+                    }
+                }
+                wrq->u.data.length = 1;
+            }
+            break;
+        case WLAN_LED_GPIO_CTRL:
+            {
+                int i;
+                int data[16];
+
+                HostCmd_DS_802_11_LED_CTRL ctrl;
+                MrvlIEtypes_LedGpio_t *gpio =
+                    (MrvlIEtypes_LedGpio_t *) ctrl.data;
+
+                memset(&ctrl, 0, sizeof(ctrl));
+                if (wrq->u.data.length > MAX_LEDS * 2)
+                    return -ENOTSUPP;
+                if ((wrq->u.data.length % 2) != 0)
+                    return -ENOTSUPP;
+                if (wrq->u.data.length == 0) {
+                    ctrl.Action = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+                } else {
+                    if (copy_from_user
+                        (data, wrq->u.data.pointer,
+                         sizeof(int) * wrq->u.data.length)) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        return -EFAULT;
+                    }
+
+                    ctrl.Action = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+                    ctrl.NumLed = wlan_cpu_to_le16(0);
+                    gpio->Header.Type = wlan_cpu_to_le16(TLV_TYPE_LED_GPIO);
+                    gpio->Header.Len = wrq->u.data.length;
+                    for (i = 0; i < wrq->u.data.length; i += 2) {
+                        gpio->LedPin[i / 2].Led = data[i];
+                        gpio->LedPin[i / 2].Pin = data[i + 1];
+                    }
+                }
+                ret =
+                    PrepareAndSendCommand(priv,
+                                          HostCmd_CMD_802_11_LED_GPIO_CTRL, 0,
+                                          HostCmd_OPTION_WAITFORRSP, 0,
+                                          (void *) &ctrl);
+                for (i = 0; i < gpio->Header.Len; i += 2) {
+                    data[i] = gpio->LedPin[i / 2].Led;
+                    data[i + 1] = gpio->LedPin[i / 2].Pin;
+                }
+                if (copy_to_user(wrq->u.data.pointer, data,
+                                 sizeof(int) * gpio->Header.Len)) {
+                    PRINTM(INFO, "Copy to user failed\n");
+                    return -EFAULT;
+                }
+
+                wrq->u.data.length = gpio->Header.Len;
+            }
+            break;
+        case WLAN_SLEEP_PERIOD:
+            ret = wlan_sleep_period(priv, wrq);
+            break;
+        case WLAN_ADAPT_RATESET:
+            ret = wlan_adapt_rateset(priv, wrq);
+            break;
+        case WLAN_INACTIVITY_TIMEOUT:
+            ret = wlan_inactivity_timeout(priv, wrq);
+            break;
+        case WLANSNR:
+            ret = wlan_get_snr(priv, wrq);
+            break;
+        case WLAN_GET_RATE:
+            ret = wlan_getrate_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_RXINFO:
+            ret = wlan_get_rxinfo(priv, wrq);
+            break;
+        case WLAN_SET_ATIM_WINDOW:
+            ret = wlan_ATIM_Window(priv, wrq);
+            break;
+        case WLAN_BEACON_INTERVAL:
+            ret = wlan_beacon_interval(priv, wrq);
+            break;
+        case WLAN_SCAN_TIME:
+            ret = wlan_scan_time(priv, wrq);
+            break;
+        case WLANHSCFG:
+            ret = wlan_hscfg_ioctl(priv, wrq);
+            break;
+#ifdef DEBUG_LEVEL1
+        case WLAN_DRV_DBG:
+            ret = wlan_drv_dbg(priv, wrq);
+            break;
+#endif
+        }
+        break;
+
+    case WLAN_SET_GET_2K:
+        switch ((int) wrq->u.data.flags) {
+        case WLAN_SET_USER_SCAN:
+            ret = wlan_set_user_scan_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_SCAN_TABLE:
+            ret = wlan_get_scan_table_ioctl(priv, wrq);
+            break;
+
+        case WLAN_SET_MRVL_TLV:
+            ret = wlan_set_mrvl_tlv_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_ASSOC_RSP:
+            ret = wlan_get_assoc_rsp_ioctl(priv, wrq);
+            break;
+        case WLAN_ADDTS_REQ:
+            ret = wlan_wmm_addts_req_ioctl(priv, wrq);
+            break;
+        case WLAN_DELTS_REQ:
+            ret = wlan_wmm_delts_req_ioctl(priv, wrq);
+            break;
+        case WLAN_QUEUE_CONFIG:
+            ret = wlan_wmm_queue_config_ioctl(priv, wrq);
+            break;
+        case WLAN_QUEUE_STATS:
+            ret = wlan_wmm_queue_stats_ioctl(priv, wrq);
+            break;
+        default:
+            ret = -EOPNOTSUPP;
+        }
+        break;
+
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get wireless statistics
+ *
+ *  NOTE: If PrepareAndSendCommand() with wait option is issued 
+ *    in this function, a kernel dump (scheduling while atomic) 
+ *    issue may happen on some versions of kernels.
+ *
+ *  @param dev		A pointer to net_device structure
+ *  @return 	   	A pointer to iw_statistics buf
+ */
+struct iw_statistics *
+wlan_get_wireless_stats(struct net_device *dev)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return NULL;
+    }
+
+    priv->wstats.status = Adapter->InfrastructureMode;
+    priv->wstats.discard.retries = priv->stats.tx_errors;
+
+    /* send RSSI command to get beacon RSSI/NF, valid only if associated */
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_RSSI, 0, 0, 0, NULL);
+
+    priv->wstats.qual.level =
+        CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_NOAVG],
+                 Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+    priv->wstats.qual.noise = CAL_NF(Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+    if (Adapter->NF[TYPE_BEACON][TYPE_NOAVG] == 0
+        && Adapter->MediaConnectStatus == WlanMediaStateConnected)
+        priv->wstats.qual.noise = MRVDRV_NF_DEFAULT_SCAN_VALUE;
+    else
+        priv->wstats.qual.noise =
+            CAL_NF(Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+    priv->wstats.qual.qual = 0;
+
+    PRINTM(INFO, "Signal Level = %#x\n", priv->wstats.qual.level);
+    PRINTM(INFO, "Noise = %#x\n", priv->wstats.qual.noise);
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_GET_LOG, 0,
+                                0, 0, NULL);
+
+    if (!ret) {
+        priv->wstats.discard.code = Adapter->LogMsg.wepundecryptable;
+        priv->wstats.discard.fragment = Adapter->LogMsg.fcserror;
+        priv->wstats.discard.retries = Adapter->LogMsg.retry;
+        priv->wstats.discard.misc = Adapter->LogMsg.ackfailure;
+    }
+
+    return &priv->wstats;
+}
+
+static int
+wlan_set_coalescing_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int data;
+    int *val;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+
+    switch (data) {
+    case CMD_DISABLED:
+    case CMD_ENABLED:
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_IBSS_COALESCING_STATUS,
+                                    HostCmd_ACT_SET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, &data);
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+        break;
+
+    case CMD_GET:
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_IBSS_COALESCING_STATUS,
+                                    HostCmd_ACT_GET,
+                                    HostCmd_OPTION_WAITFORRSP, 0, &data);
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+        break;
+
+    default:
+        return -EINVAL;
+    }
+
+    val = (int *) wrq->u.name;
+    *val = data;
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set frequency
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @param info			A pointer to iw_request_info structure 
+ *  @param fwrq			A pointer to iw_freq structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int
+wlan_set_freq(struct net_device *dev, struct iw_request_info *info,
+              struct iw_freq *fwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int rc = -EINPROGRESS;      /* Call commit handler */
+    CHANNEL_FREQ_POWER *cfp;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+    if (Adapter->InfrastructureMode != Wlan802_11IBSS)
+        return -EOPNOTSUPP;
+
+    /*
+     * If setting by frequency, convert to a channel 
+     */
+    if (fwrq->e == 1) {
+
+        long f = fwrq->m / 100000;
+        int c = 0;
+
+        cfp = find_cfp_by_band_and_freq(Adapter, 0, f);
+        if (!cfp) {
+            PRINTM(INFO, "Invalid freq=%ld\n", f);
+            return -EINVAL;
+        }
+
+        c = (int) cfp->Channel;
+
+        if (c < 0)
+            return -EINVAL;
+
+        fwrq->e = 0;
+        fwrq->m = c;
+    }
+
+    /*
+     * Setting by channel number 
+     */
+    if (fwrq->m > 1000 || fwrq->e > 0) {
+        rc = -EOPNOTSUPP;
+    } else {
+        int channel = fwrq->m;
+
+        cfp = find_cfp_by_band_and_channel(Adapter, 0, (u16) channel);
+        if (!cfp) {
+            rc = -EINVAL;
+        } else {
+            rc = ChangeAdhocChannel(priv, channel);
+            /*  If station is WEP enabled, send the 
+             *  command to set WEP in firmware
+             */
+            if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled) {
+                PRINTM(INFO, "set_freq: WEP Enabled\n");
+                ret = PrepareAndSendCommand(priv,
+                                            HostCmd_CMD_802_11_SET_WEP,
+                                            0, HostCmd_OPTION_WAITFORRSP,
+                                            OID_802_11_ADD_WEP, NULL);
+
+                if (ret) {
+                    LEAVE();
+                    return ret;
+                }
+                Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_WEP_ENABLE;
+                SetMacPacketFilter(priv);
+            }
+        }
+    }
+
+    LEAVE();
+    return rc;
+}
+
+/** 
+ *  @brief Set Deep Sleep 
+ *   
+ *  @param adapter 	A pointer to wlan_private structure
+ *  @param bDeepSleep	TRUE--enalbe deepsleep, FALSE--disable deepsleep
+ *  @return 	   	WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+
+int
+SetDeepSleep(wlan_private * priv, BOOLEAN bDeepSleep)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (bDeepSleep == TRUE) {
+        if (Adapter->IsDeepSleep != TRUE) {
+            PRINTM(INFO, "Deep Sleep : sleep\n");
+
+            // note: the command could be queued and executed later
+            //       if there is command in prigressing.
+            ret = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_802_11_DEEP_SLEEP, 0,
+                                        HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+            os_stop_queue(priv);
+            os_carrier_off(priv);
+        }
+    } else {
+        if (Adapter->IsDeepSleep == TRUE) {
+            PRINTM(INFO, "Deep Sleep : wakeup\n");
+
+            if (Adapter->IntCounterSaved)
+                Adapter->IntCounter = Adapter->IntCounterSaved;
+
+            if (sbi_exit_deep_sleep(priv))
+                PRINTM(INFO, "Deep Sleep : wakeup failed\n");
+
+            if (Adapter->IsDeepSleep == TRUE) {
+
+                if (interruptible_sleep_on_timeout(&Adapter->ds_awake_q,
+                                                   WAIT_FOR_SCAN_RRESULT_MAX_TIME)
+                    == 0) {
+                    PRINTM(MSG, "ds_awake_q: timer expired\n");
+
+                }
+            }
+
+            if (Adapter->IntCounter)
+                wake_up_interruptible(&priv->MainThread.waitQ);
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief use index to get the data rate
+ *   
+ *  @param index                The index of data rate
+ *  @return 	   		data rate or 0 
+ */
+u32
+index_to_data_rate(u8 index)
+{
+    if (index >= sizeof(WlanDataRates))
+        index = 0;
+
+    return WlanDataRates[index];
+}
+
+/** 
+ *  @brief use rate to get the index
+ *   
+ *  @param rate                 data rate
+ *  @return 	   		index or 0 
+ */
+u8
+data_rate_to_index(u32 rate)
+{
+    u8 *ptr;
+
+    if (rate)
+        if ((ptr = wlan_memchr(WlanDataRates, (u8) rate,
+                               sizeof(WlanDataRates))))
+            return (ptr - WlanDataRates);
+
+    return 0;
+}
+
+/** 
+ *  @brief set data rate
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_rate(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    u32 data_rate;
+    int ret = WLAN_STATUS_SUCCESS;
+    WLAN_802_11_RATES rates;
+    u8 *rate;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    PRINTM(INFO, "Vwrq->value = %d\n", vwrq->value);
+
+    if (vwrq->value == -1) {
+        Adapter->DataRate = 0;
+        Adapter->RateBitmap = 0;
+        memset(rates, 0, sizeof(rates));
+        get_active_data_rates(Adapter, rates);
+        rate = rates;
+        while (*rate) {
+            Adapter->RateBitmap |= 1 << (data_rate_to_index(*rate & 0x7f));
+            rate++;
+        }
+        Adapter->Is_DataRate_Auto = TRUE;
+    } else {
+        if (vwrq->value % 100000) {
+            return -EINVAL;
+        }
+
+        data_rate = vwrq->value / 500000;
+
+        memset(rates, 0, sizeof(rates));
+        get_active_data_rates(Adapter, rates);
+        rate = rates;
+        while (*rate) {
+            PRINTM(INFO, "Rate=0x%X  Wanted=0x%X\n", *rate, data_rate);
+            if ((*rate & 0x7f) == (data_rate & 0x7f))
+                break;
+            rate++;
+        }
+        if (!*rate) {
+            PRINTM(MSG, "The fixed data rate 0x%X is out "
+                   "of range.\n", data_rate);
+            return -EINVAL;
+        }
+
+        Adapter->DataRate = data_rate;
+        Adapter->RateBitmap = 1 << (data_rate_to_index(Adapter->DataRate));
+        Adapter->Is_DataRate_Auto = FALSE;
+    }
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_RATE_ADAPT_RATESET,
+                                HostCmd_ACT_GEN_SET,
+                                HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief get data rate
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_rate(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (Adapter->Is_DataRate_Auto)
+        vwrq->fixed = 0;
+    else
+        vwrq->fixed = 1;
+
+    Adapter->TxRate = 0;
+
+    ret = PrepareAndSendCommand(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,
+                                HostCmd_ACT_GET, HostCmd_OPTION_WAITFORRSP,
+                                0, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+    vwrq->value = index_to_data_rate(Adapter->TxRate) * 500000;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief set wireless mode 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_mode(struct net_device *dev,
+              struct iw_request_info *info, u32 * uwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    WLAN_802_11_NETWORK_INFRASTRUCTURE WantedMode;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    switch (*uwrq) {
+    case IW_MODE_ADHOC:
+        PRINTM(INFO, "Wanted Mode is ad-hoc: current DataRate=%#x\n",
+               Adapter->DataRate);
+        WantedMode = Wlan802_11IBSS;
+        Adapter->AdhocChannel = DEFAULT_AD_HOC_CHANNEL;
+        break;
+
+    case IW_MODE_INFRA:
+        PRINTM(INFO, "Wanted Mode is Infrastructure\n");
+        WantedMode = Wlan802_11Infrastructure;
+        break;
+
+    case IW_MODE_AUTO:
+        PRINTM(INFO, "Wanted Mode is Auto\n");
+        WantedMode = Wlan802_11AutoUnknown;
+        break;
+
+    default:
+        PRINTM(INFO, "Wanted Mode is Unknown: 0x%x\n", *uwrq);
+        return -EINVAL;
+    }
+
+    if (Adapter->InfrastructureMode == WantedMode ||
+        WantedMode == Wlan802_11AutoUnknown) {
+        PRINTM(INFO, "Already set to required mode! No change!\n");
+
+        Adapter->InfrastructureMode = WantedMode;
+
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+        if (Adapter->PSState != PS_STATE_FULL_POWER) {
+            PSWakeup(priv, HostCmd_OPTION_WAITFORRSP);
+        }
+        Adapter->PSMode = Wlan802_11PowerModeCAM;
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+            ret = SendDeauthentication(priv);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+        } else if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+            /* If current mode is Adhoc, clean stale information */
+            ret = StopAdhocNetwork(priv);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+        }
+    }
+
+    if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled) {
+        /* If there is a key with the specified SSID, 
+         * send REMOVE WEP command, to make sure we clean up
+         * the WEP keys in firmware
+         */
+        ret = PrepareAndSendCommand(priv,
+                                    HostCmd_CMD_802_11_SET_WEP,
+                                    0, HostCmd_OPTION_WAITFORRSP,
+                                    OID_802_11_REMOVE_WEP, NULL);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+
+        Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_WEP_ENABLE;
+
+        SetMacPacketFilter(priv);
+    }
+
+    Adapter->SecInfo.WEPStatus = Wlan802_11WEPDisabled;
+    Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+
+    Adapter->InfrastructureMode = WantedMode;
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_SNMP_MIB,
+                                0, HostCmd_OPTION_WAITFORRSP,
+                                OID_802_11_INFRASTRUCTURE_MODE, NULL);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Encryption key
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_encode(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_point *dwrq, char *extra)
+{
+
+    PWLAN_802_11_KEY pKey = NULL;
+
+    ENTER();
+
+    if (dwrq->length > MAX_KEY_SIZE) {
+        pKey = (PWLAN_802_11_KEY) extra;
+
+        if (pKey->KeyLength <= MAX_KEY_SIZE) {
+            //dynamic WEP
+            dwrq->length = pKey->KeyLength;
+            dwrq->flags = pKey->KeyIndex + 1;
+            return wlan_set_encode_nonwpa(dev, info, dwrq, pKey->KeyMaterial);
+        } else {
+            //WPA
+            return wlan_set_encode_wpa(dev, info, dwrq, extra);
+        }
+    } else {
+        //static WEP
+        PRINTM(INFO, "Setting WEP\n");
+        return wlan_set_encode_nonwpa(dev, info, dwrq, extra);
+    }
+
+    return -EINVAL;
+}
+
+/** 
+ *  @brief set tx power 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_txpow(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    u16 dbm;
+
+    ENTER();
+
+    if (!Is_Command_Allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (vwrq->disabled) {
+        wlan_radio_ioctl(priv, RADIO_OFF);
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    Adapter->Preamble = HostCmd_TYPE_AUTO_PREAMBLE;
+
+    wlan_radio_ioctl(priv, RADIO_ON);
+
+#if WIRELESS_EXT > 14
+    if ((vwrq->flags & IW_TXPOW_TYPE) == IW_TXPOW_MWATT) {
+        dbm = (u16) mw_to_dbm(vwrq->value);
+    } else
+#endif
+        dbm = (u16) vwrq->value;
+
+    if ((dbm < Adapter->MinTxPowerLevel) || (dbm > Adapter->MaxTxPowerLevel)) {
+        PRINTM(MSG,
+               "The set txpower value %d dBm is out of range (%d dBm-%d dBm)!\n",
+               dbm, Adapter->MinTxPowerLevel, Adapter->MaxTxPowerLevel);
+        LEAVE();
+        return -EINVAL;
+    }
+
+    /* auto tx power control */
+
+    if (vwrq->fixed == 0)
+        dbm = 0xffff;
+
+    PRINTM(INFO, "<1>TXPOWER SET %d dbm.\n", dbm);
+
+    ret = PrepareAndSendCommand(priv,
+                                HostCmd_CMD_802_11_RF_TX_POWER,
+                                HostCmd_ACT_GEN_SET,
+                                HostCmd_OPTION_WAITFORRSP, 0, (void *) &dbm);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get current essid 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_essid(struct net_device *dev, struct iw_request_info *info,
+               struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+    /*
+     * Note : if dwrq->flags != 0, we should get the relevant SSID from
+     * the SSID list... 
+     */
+
+    /*
+     * Get the current SSID 
+     */
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        memcpy(extra, Adapter->CurBssParams.ssid.Ssid,
+               Adapter->CurBssParams.ssid.SsidLength);
+        extra[Adapter->CurBssParams.ssid.SsidLength] = '\0';
+    } else {
+        memset(extra, 0, 32);
+        extra[Adapter->CurBssParams.ssid.SsidLength] = '\0';
+    }
+    /*
+     * If none, we may want to get the one that was set 
+     */
+
+    /* To make the driver backward compatible with WPA supplicant v0.2.4 */
+    if (dwrq->length == 32)     /* check with WPA supplicant buffer size */
+        dwrq->length = MIN(Adapter->CurBssParams.ssid.SsidLength,
+                           IW_ESSID_MAX_SIZE);
+    else
+        dwrq->length = Adapter->CurBssParams.ssid.SsidLength + 1;
+
+    dwrq->flags = 1;            /* active */
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get version 
+ *   
+ *  @param adapter              A pointer to wlan_adapter structure
+ *  @param version		A pointer to version buffer
+ *  @param maxlen		max length of version buffer
+ *  @return 	   		NA
+ */
+void
+get_version(wlan_adapter * adapter, char *version, int maxlen)
+{
+    union
+    {
+        u32 l;
+        u8 c[4];
+    } ver;
+    char fwver[32];
+
+    ver.l = adapter->FWReleaseNumber;
+    if (ver.c[3] == 0)
+        sprintf(fwver, "%u.%u.%u", ver.c[2], ver.c[1], ver.c[0]);
+    else
+        sprintf(fwver, "%u.%u.%u.p%u",
+                ver.c[2], ver.c[1], ver.c[0], ver.c[3]);
+
+    snprintf(version, maxlen, driver_version, fwver);
+}
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_wext.h b/drivers/net/wireless/8686_wlan/wlan/wlan_wext.h
new file mode 100644
index 0000000..74d503e
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_wext.h
@@ -0,0 +1,307 @@
+/** @file wlan_wext.h
+ * @brief This file contains definition for IOCTL call.
+ *  
+ * (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change log:
+	10/11/05: Add Doxygen format comments
+	12/19/05: Correct a typo in structure _wlan_ioctl_wmm_tspec
+	01/11/06: Conditionalize new scan/join ioctls
+	04/10/06: Add hostcmd generic API
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	06/08/06: Add definitions of custom events
+********************************************************/
+
+#ifndef	_WLAN_WEXT_H_
+#define	_WLAN_WEXT_H_
+
+#define SUBCMD_OFFSET			4
+/** PRIVATE CMD ID */
+#define	WLANIOCTL			0x8BE0
+
+#define WLANSETWPAIE			(WLANIOCTL + 0)
+#define WLANCISDUMP 			(WLANIOCTL + 1)
+#ifdef MFG_CMD_SUPPORT
+#define	WLANMANFCMD			(WLANIOCTL + 2)
+#endif
+#define	WLANREGRDWR			(WLANIOCTL + 3)
+#define MAX_EEPROM_DATA     			256
+#define	WLANHOSTCMD			(WLANIOCTL + 4)
+
+#define WLANHOSTSLEEPCFG		(WLANIOCTL + 5)
+#define WLANARPFILTER			(WLANIOCTL + 6)
+
+#define WLAN_SETINT_GETINT		(WLANIOCTL + 7)
+#define WLANNF					1
+#define WLANRSSI				2
+#define WLANBGSCAN				4
+#define WLANENABLE11D				5
+#define WLANADHOCGRATE				6
+#define WLANSDIOCLOCK				7
+#define WLANWMM_ENABLE				8
+#define WLANNULLGEN				10
+#define WLAN_SUBCMD_SET_PRESCAN			11
+#define WLANADHOCCSET				12
+
+#define WLAN_SETNONE_GETNONE	        (WLANIOCTL + 8)
+#define WLANDEAUTH                  		1
+#define WLANRADIOON                 		2
+#define WLANRADIOOFF                		3
+#define WLANREMOVEADHOCAES          		4
+#define WLANADHOCSTOP               		5
+#ifdef REASSOCIATION
+#define WLANREASSOCIATIONAUTO			8
+#define WLANREASSOCIATIONUSER			9
+#endif /* REASSOCIATION */
+#define WLANWLANIDLEON				10
+#define WLANWLANIDLEOFF				11
+
+#define WLANGETLOG                  	(WLANIOCTL + 9)
+#define WLAN_SETCONF_GETCONF		(WLANIOCTL + 10)
+
+#define BG_SCAN_CONFIG				1
+#define WMM_ACK_POLICY              2
+#define WMM_PARA_IE                 3
+#define WMM_ACK_POLICY_PRIO         4
+#define CAL_DATA_EXT_CONFIG         5
+
+#define WLANSCAN_TYPE			(WLANIOCTL + 11)
+
+#define WLAN_SET_GET_2K         (WLANIOCTL + 13)
+#define WLAN_SET_USER_SCAN              1
+#define WLAN_GET_SCAN_TABLE             2
+#define WLAN_SET_MRVL_TLV               3
+#define WLAN_GET_ASSOC_RSP              4
+#define WLAN_ADDTS_REQ                  5
+#define WLAN_DELTS_REQ                  6
+#define WLAN_QUEUE_CONFIG               7
+#define WLAN_QUEUE_STATS                8
+
+#define WLAN_SETNONE_GETONEINT		(WLANIOCTL + 15)
+#define WLANGETREGION				1
+#define WLAN_GET_LISTEN_INTERVAL		2
+#define WLAN_GET_MULTIPLE_DTIM			3
+#define WLAN_GET_TX_RATE			4
+#define	WLANGETBCNAVG				5
+#define WLANGETDATAAVG				6
+
+#define WLAN_SETNONE_GETTWELVE_CHAR (WLANIOCTL + 19)
+#define WLAN_SUBCMD_GETRXANTENNA    1
+#define WLAN_SUBCMD_GETTXANTENNA    2
+#define WLAN_GET_TSF                3
+
+#define WLAN_SETWORDCHAR_GETNONE	(WLANIOCTL + 20)
+#define WLANSETADHOCAES				1
+
+#define WLAN_SETNONE_GETWORDCHAR	(WLANIOCTL + 21)
+#define WLANGETADHOCAES				1
+#define WLANVERSION				2
+
+#define WLAN_SETONEINT_GETONEINT	(WLANIOCTL + 23)
+#define WLAN_WMM_QOSINFO			2
+#define	WLAN_LISTENINTRVL			3
+#define WLAN_FW_WAKEUP_METHOD			4
+#define WAKEUP_FW_UNCHANGED			0
+#define WAKEUP_FW_THRU_INTERFACE		1
+#define WAKEUP_FW_THRU_GPIO			2
+
+#define WLAN_TXCONTROL				5
+#define WLAN_NULLPKTINTERVAL			6
+#define WLAN_ADHOC_AWAKE_PERIOD			8
+#define WLAN_LDO				9
+
+#define WLAN_SETONEINT_GETNONE		(WLANIOCTL + 24)
+#define WLAN_SUBCMD_SETRXANTENNA		1
+#define WLAN_SUBCMD_SETTXANTENNA		2
+#define WLANSETAUTHALG				5
+#define WLANSETENCRYPTIONMODE			6
+#define WLANSETREGION				7
+#define WLAN_SET_LISTEN_INTERVAL		8
+
+#define WLAN_SET_MULTIPLE_DTIM			9
+
+#define WLANSETBCNAVG				10
+#define WLANSETDATAAVG				11
+
+#define WLAN_SET64CHAR_GET64CHAR	(WLANIOCTL + 25)
+#define WLANSLEEPPARAMS 			2
+#define	WLAN_BCA_TIMESHARE			3
+#define WLANSCAN_MODE				6
+
+#define WLAN_GET_ADHOC_STATUS			9
+
+#define WLAN_SET_GEN_IE                 	10
+#define WLAN_GET_GEN_IE                 	11
+#define WLAN_REASSOCIATE                	12
+#define WLAN_WMM_QUEUE_STATUS               	14
+
+#define WLANEXTSCAN			(WLANIOCTL + 26)
+#define WLANDEEPSLEEP			(WLANIOCTL + 27)
+#define DEEP_SLEEP_ENABLE			1
+#define DEEP_SLEEP_DISABLE  			0
+
+#define WLAN_SET_GET_SIXTEEN_INT       (WLANIOCTL + 29)
+#define WLAN_TPCCFG                             1
+#define WLAN_AUTO_FREQ_SET			3
+#define WLAN_AUTO_FREQ_GET			4
+#define WLAN_LED_GPIO_CTRL			5
+#define WLAN_SCANPROBES 			6
+#define WLAN_SLEEP_PERIOD			7
+#define	WLAN_ADAPT_RATESET			8
+#define	WLAN_INACTIVITY_TIMEOUT			9
+#define WLANSNR					10
+#define WLAN_GET_RATE				11
+#define	WLAN_GET_RXINFO				12
+#define	WLAN_SET_ATIM_WINDOW			13
+#define WLAN_BEACON_INTERVAL			14
+#define WLAN_SCAN_TIME				16
+#define WLANHSCFG				20
+#ifdef DEBUG_LEVEL1
+#define WLAN_DRV_DBG				23
+#endif
+
+#define WLANCMD52RDWR			(WLANIOCTL + 30)
+#define WLANCMD53RDWR			(WLANIOCTL + 31)
+#define CMD53BUFLEN				32
+
+#define	REG_MAC					0x19
+#define	REG_BBP					0x1a
+#define	REG_RF					0x1b
+#define	REG_EEPROM				0x59
+
+#define	CMD_DISABLED				0
+#define	CMD_ENABLED				1
+#define	CMD_GET					2
+#define SKIP_CMDNUM				4
+#define SKIP_TYPE				1
+#define SKIP_SIZE				2
+#define SKIP_ACTION				2
+#define SKIP_TYPE_SIZE			(SKIP_TYPE + SKIP_SIZE)
+#define SKIP_TYPE_ACTION		(SKIP_TYPE + SKIP_ACTION)
+
+/* define custom events */
+#define CUS_EVT_HWM_CFG_DONE		"HWM_CFG_DONE.indication "
+#define CUS_EVT_BEACON_RSSI_LOW		"EVENT=BEACON_RSSI_LOW"
+#define CUS_EVT_BEACON_SNR_LOW		"EVENT=BEACON_SNR_LOW"
+#define CUS_EVT_BEACON_RSSI_HIGH	"EVENT=BEACON_RSSI_HIGH"
+#define CUS_EVT_BEACON_SNR_HIGH		"EVENT=BEACON_SNR_HIGH"
+#define CUS_EVT_MAX_FAIL		"EVENT=MAX_FAIL"
+#define CUS_EVT_MLME_MIC_ERR_UNI	"MLME-MICHAELMICFAILURE.indication unicast "
+#define CUS_EVT_MLME_MIC_ERR_MUL	"MLME-MICHAELMICFAILURE.indication multicast "
+
+#define CUS_EVT_DEEP_SLEEP_AWAKE	"EVENT=DS_AWAKE"
+
+#define CUS_EVT_ADHOC_LINK_SENSED	"EVENT=ADHOC_LINK_SENSED"
+#define CUS_EVT_ADHOC_BCN_LOST		"EVENT=ADHOC_BCN_LOST"
+
+/** wlan_ioctl */
+typedef struct _wlan_ioctl
+{
+        /** Command ID */
+    u16 command;
+        /** data length */
+    u16 len;
+        /** data pointer */
+    u8 *data;
+} wlan_ioctl;
+
+/** wlan_ioctl_rfantenna */
+typedef struct _wlan_ioctl_rfantenna
+{
+    u16 Action;
+    u16 AntennaMode;
+} wlan_ioctl_rfantenna;
+
+/** wlan_ioctl_regrdwr */
+typedef struct _wlan_ioctl_regrdwr
+{
+        /** Which register to access */
+    u16 WhichReg;
+        /** Read or Write */
+    u16 Action;
+    u32 Offset;
+    u16 NOB;
+    u32 Value;
+} wlan_ioctl_regrdwr;
+
+/** wlan_ioctl_cfregrdwr */
+typedef struct _wlan_ioctl_cfregrdwr
+{
+        /** Read or Write */
+    u8 Action;
+        /** register address */
+    u16 Offset;
+        /** register value */
+    u16 Value;
+} wlan_ioctl_cfregrdwr;
+
+/** wlan_ioctl_rdeeprom */
+typedef struct _wlan_ioctl_rdeeprom
+{
+    u16 WhichReg;
+    u16 Action;
+    u16 Offset;
+    u16 NOB;
+    u8 Value;
+} wlan_ioctl_rdeeprom;
+
+/** wlan_ioctl_adhoc_key_info */
+typedef struct _wlan_ioctl_adhoc_key_info
+{
+    u16 action;
+    u8 key[16];
+    u8 tkiptxmickey[16];
+    u8 tkiprxmickey[16];
+} wlan_ioctl_adhoc_key_info;
+
+/** sleep_params */
+typedef struct _wlan_ioctl_sleep_params_config
+{
+    u16 Action;
+    u16 Error;
+    u16 Offset;
+    u16 StableTime;
+    u8 CalControl;
+    u8 ExtSleepClk;
+    u16 Reserved;
+} __ATTRIB_PACK__ wlan_ioctl_sleep_params_config,
+    *pwlan_ioctl_sleep_params_config;
+
+/** BCA TIME SHARE */
+typedef struct _wlan_ioctl_bca_timeshare_config
+{
+        /** ACT_GET/ACT_SET */
+    u16 Action;
+        /** Type: WLAN, BT */
+    u16 TrafficType;
+        /** Interval: 20msec - 60000msec */
+    u32 TimeShareInterval;
+        /** PTA arbiter time in msec */
+    u32 BTTime;
+} __ATTRIB_PACK__ wlan_ioctl_bca_timeshare_config,
+    *pwlan_ioctl_bca_timeshare_config;
+
+typedef struct _wlan_ioctl_reassociation_info
+{
+    u8 CurrentBSSID[6];
+    u8 DesiredBSSID[6];
+    char DesiredSSID[IW_ESSID_MAX_SIZE + 1];
+} __ATTRIB_PACK__ wlan_ioctl_reassociation_info;
+
+#endif /* _WLAN_WEXT_H_ */
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_wmm.c b/drivers/net/wireless/8686_wlan/wlan/wlan_wmm.c
new file mode 100644
index 0000000..b5661a9
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_wmm.c
@@ -0,0 +1,1624 @@
+/** @file wlan_wmm.c
+ * @brief This file contains functions for WMM.
+ * 
+ * (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change log:
+    10/04/05: Add Doxygen format comments
+    11/11/05: Add support for WMM Status change event
+    01/05/06: Add kernel 2.6.x support  
+    01/11/06: Conditionalize new scan/join code modifications.
+    04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+********************************************************/
+#include    "include.h"
+
+/********************************************************
+        Local Variables
+********************************************************/
+
+#define IPTOS_OFFSET 5
+
+static u8 wmm_tos2ac[8] = {
+    AC_PRIO_BE,
+    AC_PRIO_BK,
+    AC_PRIO_BK,
+    AC_PRIO_BE,
+    AC_PRIO_VI,
+    AC_PRIO_VI,
+    AC_PRIO_VO,
+    AC_PRIO_VO
+};
+
+static u8 wmm_ac_downgrade[MAX_AC_QUEUES] = {
+    AC_PRIO_BK,
+    AC_PRIO_BE,
+    AC_PRIO_VI,
+    AC_PRIO_VO
+};
+
+/* This mapping table will be useful if bit-flip is needed */
+static u8 wmm_tos2priority[8] = {
+/*  Priority   DSCP   DSCP   DSCP   WMM
+    P2     P1     P0    AC    */
+    0x00,                       /*  0      0      0 AC_BE */
+    0x01,                       /*  0      0      1 AC_BK */
+    0x02,                       /*  0      1      0 AC_BK */
+    0x03,                       /*  0      1      1 AC_BE */
+    0x04,                       /*  1      0      0 AC_VI */
+    0x05,                       /*  1      0      1 AC_VI */
+    0x06,                       /*  1      1      0 AC_VO */
+    0x07                        /*  1      1      1 AC_VO */
+};
+
+static u8 wmm_ie[WMM_IE_LENGTH] = { WMM_IE, 0x07, 0x00,
+    0x50, 0xf2, 0x02, 0x00, 0x01, 0x00
+};
+
+/********************************************************
+        Global Variables
+********************************************************/
+
+/********************************************************
+        Local Functions
+********************************************************/
+#ifdef DEBUG_LEVEL2
+/** 
+ *  @brief Debug print function to display the priority parameters for a WMM AC
+ *
+ *  @param acStr    String pointer giving the AC enumeration (BK, BE, VI, VO)
+ *  @param pACParam Pointer to the AC paramters to display
+ *
+ *  @return         void
+ */
+static void
+wmm_debugPrintAC(const char *acStr, const WMM_AC_PARAS * pACParam)
+{
+    PRINTM(INFO, "WMM AC_%s: ACI=%d, ACM=%d, AIFSN=%d, "
+           "ECWmin=%d, ECWmax=%d, Txop_Limit=%d\n",
+           acStr, pACParam->ACI_AIFSN.ACI, pACParam->ACI_AIFSN.ACM,
+           pACParam->ACI_AIFSN.AIFSN, pACParam->ECW.ECW_Min,
+           pACParam->ECW.ECW_Max, wlan_le16_to_cpu(pACParam->Txop_Limit));
+}
+
+#define PRINTM_AC(acStr, pACParam) wmm_debugPrintAC(acStr, pACParam)
+#else
+#define PRINTM_AC(acStr, pACParam)
+#endif
+
+/** 
+ *  @brief Initialize WMM priority queues
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+static void
+wmm_setup_queue_priorities(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    WMM_PARAMETER_IE *pIe;
+    u16 cwmax, cwmin, avg_back_off, tmp[4];
+    int i, j, n;
+
+    n = 0;
+
+    pIe = &Adapter->CurBssParams.BSSDescriptor.wmmIE;
+
+    HEXDUMP("WMM: setup_queue_priorities: param IE",
+            (u8 *) pIe, sizeof(WMM_PARAMETER_IE));
+
+    PRINTM(INFO, "WMM Parameter IE: version=%d, "
+           "QoSInfo Parameter Set Count=%d, Reserved=%#x\n",
+           pIe->Version, pIe->QoSInfo.ParaSetCount, pIe->Reserved);
+
+    /*
+     * AC_BE
+     */
+    cwmax = (1 << pIe->AC_Paras_BE.ECW.ECW_Max) - 1;
+    cwmin = (1 << pIe->AC_Paras_BE.ECW.ECW_Min) - 1;
+    avg_back_off = (cwmin >> 1) + pIe->AC_Paras_BE.ACI_AIFSN.AIFSN;
+    Adapter->CurBssParams.wmm_queue_prio[n] = AC_PRIO_BE;
+    tmp[n++] = avg_back_off;
+
+    PRINTM_AC("BE", &pIe->AC_Paras_BE);
+    PRINTM(INFO, "WMM AC_BE: CWmax=%d CWmin=%d Avg Back-off=%d\n",
+           cwmax, cwmin, avg_back_off);
+
+    /*
+     * AC_BK
+     */
+    cwmax = (1 << pIe->AC_Paras_BK.ECW.ECW_Max) - 1;
+    cwmin = (1 << pIe->AC_Paras_BK.ECW.ECW_Min) - 1;
+    avg_back_off = (cwmin >> 1) + pIe->AC_Paras_BK.ACI_AIFSN.AIFSN;
+    Adapter->CurBssParams.wmm_queue_prio[n] = AC_PRIO_BK;
+    tmp[n++] = avg_back_off;
+
+    PRINTM_AC("BK", &pIe->AC_Paras_BK);
+    PRINTM(INFO, "WMM AC_BK: CWmax=%d CWmin=%d Avg Back-off=%d\n",
+           cwmax, cwmin, avg_back_off);
+
+    /*
+     * AC_VI
+     */
+    cwmax = (1 << pIe->AC_Paras_VI.ECW.ECW_Max) - 1;
+    cwmin = (1 << pIe->AC_Paras_VI.ECW.ECW_Min) - 1;
+    avg_back_off = (cwmin >> 1) + pIe->AC_Paras_VI.ACI_AIFSN.AIFSN;
+    Adapter->CurBssParams.wmm_queue_prio[n] = AC_PRIO_VI;
+    tmp[n++] = avg_back_off;
+
+    PRINTM_AC("VI", &pIe->AC_Paras_VI);
+    PRINTM(INFO, "WMM AC_VI: CWmax=%d CWmin=%d Avg Back-off=%d\n",
+           cwmax, cwmin, avg_back_off);
+
+    /*
+     * AC_VO
+     */
+    cwmax = (1 << pIe->AC_Paras_VO.ECW.ECW_Max) - 1;
+    cwmin = (1 << pIe->AC_Paras_VO.ECW.ECW_Min) - 1;
+    avg_back_off = (cwmin >> 1) + pIe->AC_Paras_VO.ACI_AIFSN.AIFSN;
+    Adapter->CurBssParams.wmm_queue_prio[n] = AC_PRIO_VO;
+    tmp[n++] = avg_back_off;
+
+    PRINTM_AC("VO", &pIe->AC_Paras_VO);
+    PRINTM(INFO, "WMM AC_VO: CWmax=%d CWmin=%d Avg Back-off=%d\n",
+           cwmax, cwmin, avg_back_off);
+
+    HEXDUMP("WMM avg_back_off  ", (u8 *) tmp, sizeof(tmp));
+    HEXDUMP("WMM wmm_queue_prio", Adapter->CurBssParams.wmm_queue_prio,
+            sizeof(Adapter->CurBssParams.wmm_queue_prio));
+
+    /* bubble sort */
+    for (i = 0; i < n; i++) {
+        for (j = 1; j < n - i; j++) {
+            if (tmp[j - 1] > tmp[j]) {
+                SWAP_U16(tmp[j - 1], tmp[j]);
+                SWAP_U8(Adapter->CurBssParams.wmm_queue_prio[j - 1],
+                        Adapter->CurBssParams.wmm_queue_prio[j]);
+            } else if (tmp[j - 1] == tmp[j]) {
+                if (Adapter->CurBssParams.wmm_queue_prio[j - 1] <
+                    Adapter->CurBssParams.wmm_queue_prio[j]) {
+                    SWAP_U8(Adapter->CurBssParams.wmm_queue_prio[j - 1],
+                            Adapter->CurBssParams.wmm_queue_prio[j]);
+                }
+            }
+        }
+    }
+
+    HEXDUMP("WMM avg_back_off ", (u8 *) tmp, sizeof(tmp));
+    HEXDUMP("WMM wmm_queue_prio", Adapter->CurBssParams.wmm_queue_prio,
+            sizeof(Adapter->CurBssParams.wmm_queue_prio));
+
+}
+
+/** 
+ *  @brief pop up the highest skb from wmm queue
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+static void
+wmm_pop_highest_prio_skb(wlan_private * priv)
+{
+    int i;
+    wlan_adapter *Adapter = priv->adapter;
+    u8 ac;
+
+    for (i = 0; i < MAX_AC_QUEUES; i++) {
+        ac = Adapter->CurBssParams.wmm_queue_prio[i];
+        if (!list_empty((struct list_head *) &Adapter->wmm.TxSkbQ[ac])) {
+            PRINTM(DATA, "WMM: Highest prio pkt in AC Queue %d\n", i);
+            Adapter->CurrentTxSkb = Adapter->wmm.TxSkbQ[ac].next;
+            list_del((struct list_head *) Adapter->wmm.TxSkbQ[ac].next);
+            break;
+        }
+    }
+}
+
+/** 
+ *  @brief Evaluate whether or not an AC is to be downgraded
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param evalAC   AC to evaluate for downgrading
+ *
+ *  @return WMM AC the evalAC traffic is to be sent on.  
+ */
+static wlan_wmm_ac_e
+wmm_eval_downgrade_ac(wlan_private * priv, wlan_wmm_ac_e evalAC)
+{
+    wlan_wmm_ac_e downAC;
+    wlan_wmm_ac_e retAC;
+    WMM_AC_STATUS *pACStatus;
+
+    pACStatus = &priv->adapter->wmm.acStatus[evalAC];
+
+    if (pACStatus->Disabled == FALSE) {
+        /* Okay to use this AC, its enabled */
+        return evalAC;
+    }
+
+    /* Setup a default return value of the lowest priority */
+    retAC = AC_PRIO_BK;
+
+    /*
+     *  Find the highest AC that is enabled and does not require admission
+     *    control.  The spec disallows downgarding to an AC which is enabled
+     *    due to a completed admission control.  Unadmitted traffic is not 
+     *    to be sent on an AC with admitted traffic.
+     */
+    for (downAC = AC_PRIO_BK; downAC < evalAC; downAC++) {
+        pACStatus = &priv->adapter->wmm.acStatus[downAC];
+
+        if ((pACStatus->Disabled == FALSE)
+            && (pACStatus->FlowRequired == FALSE)) {
+            /* AC is enabled and does not require admission control */
+            retAC = downAC;
+        }
+    }
+
+    return retAC;
+}
+
+/** 
+ *  @brief Downgrade WMM priority queue
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+static void
+wmm_setup_ac_downgrade(wlan_private * priv)
+{
+    wlan_wmm_ac_e acVal;
+
+    PRINTM(INFO, "WMM: AC Priorities: BK(0), BE(1), VI(2), VO(3)\n");
+
+    for (acVal = AC_PRIO_BK; acVal <= AC_PRIO_VO; acVal++) {
+        wmm_ac_downgrade[acVal] = wmm_eval_downgrade_ac(priv, acVal);
+        PRINTM(INFO, "WMM: AC PRIO %d maps to %d\n",
+               acVal, wmm_ac_downgrade[acVal]);
+    }
+}
+
+/** 
+ *  @brief Send cmd to FW to announce package available
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+static void
+wmm_send_prio_pkt_avail(wlan_private * priv)
+{
+#if 0                           /* WMM_PRIO_PKT_AVAIL command not supported for now */
+    int i;
+
+    for (i = 0; i < MAX_AC_QUEUES; i++) {
+        ac = Adapter->CurBssParams.wmm_queue_prio[i];
+        if (!list_empty((struct list_head *)
+                        &priv->adapter->wmm.TxSkbQ[ac]))
+            break;
+
+        if (i >= MAX_AC_QUEUES) /* No High prio packets available */
+            return;
+
+        priv->adapter->priopktavail.PacketAC = ac;
+
+        PrepareAndSendCommand(priv, HostCmd_CMD_WMM_PRIO_PKT_AVAIL,
+                              0, 0, 0, NULL);
+    }
+#endif
+}
+
+/** 
+ *  @brief implement WMM enable command
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param wrq      Pointer to user data
+ *
+ *  @return         WLAN_STATUS_SUCCESS if success; otherwise <0
+ */
+int
+wlan_wmm_enable_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    ulong flags;
+    int data, data1;
+    int *val;
+
+    ENTER();
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    switch (data) {
+    case CMD_DISABLED:         /* disable */
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            return -EPERM;
+        }
+
+        spin_lock_irqsave(&Adapter->CurrentTxLock, flags);
+        Adapter->wmm.required = 0;
+        if (!Adapter->wmm.enabled) {
+            spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+            data1 = Adapter->wmm.required;
+            val = (int *) wrq->u.name;
+            *val = data;
+            return WLAN_STATUS_SUCCESS;
+        } else {
+            Adapter->wmm.enabled = 0;
+        }
+
+        if (Adapter->CurrentTxSkb) {
+            kfree_skb(Adapter->CurrentTxSkb);
+            OS_INT_DISABLE;
+            Adapter->CurrentTxSkb = NULL;
+            OS_INT_RESTORE;
+            priv->stats.tx_dropped++;
+        }
+
+        /* Release all skb's in all the queues */
+        wmm_cleanup_queues(priv);
+
+        spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+        Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_WMM_ENABLE;
+        SetMacPacketFilter(priv);
+        break;
+
+    case CMD_ENABLED:          /* enable */
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            return -EPERM;
+        }
+        spin_lock_irqsave(&Adapter->CurrentTxLock, flags);
+        Adapter->wmm.required = 1;
+        spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+        break;
+
+    case CMD_GET:
+        break;
+    default:
+        PRINTM(INFO, "Invalid option\n");
+        return -EINVAL;
+    }
+    data = Adapter->wmm.required;
+    val = (int *) wrq->u.name;
+    *val = data;
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set WMM IE
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param req      Pointer to user data containing WMM IE
+ *
+ *  @return         WLAN_STATUS_SUCCESS if success; otherwise <0
+ */
+int
+wlan_wmm_para_ie_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    u16 Action;
+    u8 *para_ie = priv->adapter->wmm.Para_IE;
+
+    Action =
+        (u16) * ((u8 *) req->ifr_data +
+                 1) | ((u16) * ((u8 *) req->ifr_data + 2) << 8);
+
+    switch (Action) {
+    case HostCmd_ACT_GEN_GET:
+        if (copy_to_user(req->ifr_data + SKIP_TYPE_SIZE, para_ie,
+                         WMM_PARA_IE_LENGTH)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+
+        HEXDUMP("Para IE Conf GET", (u8 *) para_ie, WMM_PARA_IE_LENGTH);
+
+        break;
+    case HostCmd_ACT_GEN_SET:
+        if (priv->adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            return -EPERM;
+        }
+
+        HEXDUMP("Para IE Conf SET", (u8 *) para_ie, WMM_PARA_IE_LENGTH);
+
+        if (copy_from_user(para_ie, req->ifr_data + SKIP_TYPE_SIZE,
+                           WMM_PARA_IE_LENGTH)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+        break;
+    default:
+        PRINTM(INFO, "Invalid Option\n");
+        return -EINVAL;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Read/Set WMM ACK policy
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param req      Pointer to user data
+ *
+ *  @return         WLAN_STATUS_SUCCESS if success; otherwise <0
+ */
+int
+wlan_wmm_ack_policy_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int ret = WLAN_STATUS_SUCCESS, i, index;
+    HostCmd_DS_WMM_ACK_POLICY ackPolicy;
+
+    memset(&ackPolicy, 0x00, sizeof(ackPolicy));
+
+    if (copy_from_user(&ackPolicy,
+                       req->ifr_data + SKIP_TYPE,
+                       sizeof(HostCmd_DS_WMM_ACK_POLICY))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    HEXDUMP("Ack Policy Conf", (u8 *) & ackPolicy,
+            sizeof(HostCmd_DS_WMM_ACK_POLICY));
+
+    switch (ackPolicy.Action) {
+    case HostCmd_ACT_GET:
+        for (i = 0; i < WMM_ACK_POLICY_PRIO; ++i) {
+            ackPolicy.AC = i;
+
+            if ((ret = PrepareAndSendCommand(priv,
+                                             HostCmd_CMD_WMM_ACK_POLICY,
+                                             0, HostCmd_OPTION_WAITFORRSP,
+                                             0, &ackPolicy))) {
+                LEAVE();
+                PRINTM(MSG, "PrepareAndSend Failed\n");
+                return ret;
+            }
+
+            index = SKIP_TYPE_ACTION + (i * 2);
+            if (copy_to_user(req->ifr_data + index, (u8 *) & ackPolicy.AC, 2)) {
+                PRINTM(MSG, "Copy from user failed\n");
+                return -EFAULT;
+            }
+
+            HEXDUMP("Ack Policy Conf", (u8 *) & ackPolicy + SKIP_ACTION,
+                    sizeof(HostCmd_DS_WMM_ACK_POLICY));
+        }
+        break;
+
+    case HostCmd_ACT_SET:
+        ackPolicy.AC = *((u8 *) req->ifr_data + SKIP_TYPE_ACTION);
+        ackPolicy.AckPolicy = *((u8 *) req->ifr_data + SKIP_TYPE_ACTION + 1);
+
+        if ((ret = PrepareAndSendCommand(priv,
+                                         HostCmd_CMD_WMM_ACK_POLICY, 0,
+                                         HostCmd_OPTION_WAITFORRSP,
+                                         0, &ackPolicy))) {
+
+            LEAVE();
+            return ret;
+        }
+
+        if (copy_to_user(req->ifr_data + SKIP_TYPE,
+                         &ackPolicy, sizeof(HostCmd_DS_WMM_ACK_POLICY))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        HEXDUMP("Ack Policy Conf", (u8 *) & ackPolicy,
+                sizeof(HostCmd_DS_WMM_ACK_POLICY));
+
+        break;
+    default:
+        PRINTM(MSG, "Invalid Action\n");
+        return -EINVAL;
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Implement cmd HostCmd_DS_WMM_ACK_POLICY
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      Pointer to CMD buffer 
+ *  @param InfoBuf  Pointer to cmd data
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmd_wmm_ack_policy(wlan_private * priv,
+                        HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    HostCmd_DS_WMM_ACK_POLICY *pAckPolicy;
+
+    pAckPolicy = (HostCmd_DS_WMM_ACK_POLICY *) InfoBuf;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_ACK_POLICY);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_WMM_ACK_POLICY) + S_DS_GEN);
+
+    memcpy(&cmd->params.ackpolicy, pAckPolicy, sizeof(cmd->params.ackpolicy));
+    cmd->params.ackpolicy.Action =
+        wlan_cpu_to_le16(cmd->params.ackpolicy.Action);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Implement cmd HostCmd_DS_WMM_ACK_POLICY
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response from firmware
+ *
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmdresp_wmm_ack_policy(wlan_private * priv,
+                            const HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_WMM_ACK_POLICY *pAckPolicy;
+
+    pAckPolicy = (HostCmd_DS_WMM_ACK_POLICY *) (Adapter->CurCmd->pdata_buf);
+    memcpy(pAckPolicy,
+           &resp->params.ackpolicy, sizeof(HostCmd_DS_WMM_ACK_POLICY));
+    pAckPolicy->Action = wlan_le16_to_cpu(pAckPolicy->Action);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Implement cmd HostCmd_CMD_WMM_GET_STATUS
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      Pointer to CMD buffer 
+ *  @param InfoBuf  Pointer to cmd data
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmd_wmm_get_status(wlan_private * priv,
+                        HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    PRINTM(INFO, "WMM: WMM_GET_STATUS cmd sent\n");
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_WMM_GET_STATUS) + S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Implement cmd HostCmd_CMD_WMM_PRIO_PKT_AVAIL
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      Pointer to CMD buffer 
+ *  @param InfoBuf  Pointer to cmd data
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmd_wmm_prio_pkt_avail(wlan_private * priv,
+                            HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+#if 0
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_PRIO_PKT_AVAIL);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_WMM_PRIO_PKT_AVAIL) + S_DS_GEN);
+
+    cmd->params.priopktavail.PacketAC = priv->adapter->priopktavail.PacketAC;
+#endif
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Send a command to firmware to retrieve the current WMM status
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+ */
+int
+sendWMMStatusChangeCmd(wlan_private * priv)
+{
+    return PrepareAndSendCommand(priv, HostCmd_CMD_WMM_GET_STATUS,
+                                 0, 0, 0, NULL);
+}
+
+/** 
+ *  @brief Check if wmm TX queue is empty
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         FALSE if not empty; TRUE if empty
+ */
+int
+wmm_lists_empty(wlan_private * priv)
+{
+    int i;
+
+    for (i = 0; i < MAX_AC_QUEUES; i++) {
+        if (!list_empty((struct list_head *) &priv->adapter->wmm.TxSkbQ[i])) {
+            return FALSE;
+        }
+    }
+    return TRUE;
+}
+
+/** 
+ *  @brief Cleanup wmm TX queue
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+void
+wmm_cleanup_queues(wlan_private * priv)
+{
+    int i;
+    struct sk_buff *delNode, *Q;
+
+    for (i = 0; i < MAX_AC_QUEUES; i++) {
+        Q = &priv->adapter->wmm.TxSkbQ[i];
+
+        while (!list_empty((struct list_head *) Q)) {
+            delNode = Q->next;
+            list_del((struct list_head *) delNode);
+            kfree_skb(delNode);
+        }
+    }
+}
+
+/** 
+ *  @brief Add skb to WMM queue
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param skb      Pointer to sk_buff
+ *
+ *  @return         void
+ */
+void
+wmm_map_and_add_skb(wlan_private * priv, struct sk_buff *skb)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u8 tos, ac0, ac;
+    struct ethhdr *eth = (struct ethhdr *) skb->data;
+    struct timeval tstamp;
+
+    switch (eth->h_proto) {
+    case __constant_htons(ETH_P_IP):
+        //PRINTM(DATA, "packet type ETH_P_IP: %04x, tos=%#x prio=%#x\n",
+         //      eth->h_proto, skb->nh.iph->tos, skb->priority);
+	tos = IPTOS_PREC(ipip_hdr(skb)->tos) >> IPTOS_OFFSET;
+        //tos = IPTOS_PREC(skb->nh.iph->tos) >> IPTOS_OFFSET;
+        break;
+    case __constant_htons(ETH_P_ARP):
+        PRINTM(DATA, "ARP packet %04x\n", eth->h_proto);
+    default:
+        tos = 0;
+        break;
+    }
+
+    ac0 = wmm_tos2ac[tos];
+    ac = wmm_ac_downgrade[ac0];
+
+    skb->priority = wmm_tos2priority[tos];
+    PRINTM(DATA, "wmm_map: tos=%#x, ac0=%#x ac=%#x, prio=%#x\n",
+           tos, ac0, ac, skb->priority);
+
+    /* Access control of the current packet not the Lowest */
+    if (ac > AC_PRIO_BE)
+        Adapter->wmm.fw_notify = 1;
+
+    list_add_tail((struct list_head *) skb,
+                  (struct list_head *) &Adapter->wmm.TxSkbQ[ac]);
+
+    /* Record the current time the packet was queued; used to determine
+     *   the amount of time the packet was queued in the driver before it 
+     *   was sent to the firmware.  The delay is then sent along with the 
+     *   packet to the firmware for aggregate delay calculation for stats
+     *   and MSDU lifetime expiry.
+     */
+//mask by feng 
+/*
+    do_gettimeofday(&tstamp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
+    skb_set_timestamp(skb, &tstamp);
+#else
+    memcpy(&skb->stamp, &tstamp, sizeof(skb->stamp));
+#endif
+*/
+	// this is the new API for 2.6.22
+	__net_timestamp(skb);
+
+}
+
+/**
+ *  @brief Process the GET_WMM_STATUS command response from firmware
+ *
+ *  The GET_WMM_STATUS command returns multiple TLVs for:
+ *      - Each AC Queue status
+ *      - Current WMM Paramter IE
+ *
+ *  This function parses the TLVs and then calls further functions
+ *   to process any changes in the queue prioritization or state.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer including TLVs
+ *                 TLVs for each queue and the WMM Parameter IE.
+ * 
+ *  @return WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmdresp_wmm_get_status(wlan_private * priv,
+                            const HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u8 *pCurrent = (u8 *) & resp->params.getWmmStatus;
+    u32 respLen = wlan_le16_to_cpu(resp->Size);
+    int valid = TRUE;
+
+    MrvlIEtypes_Data_t *pTlvHdr;
+    MrvlIEtypes_WmmQueueStatus_t *pTlvWmmQStatus;
+    WMM_PARAMETER_IE *pWmmParamIe;
+    WMM_AC_STATUS *pACStatus;
+
+    PRINTM(INFO, "WMM: WMM_GET_STATUS cmdresp received: %d\n", respLen);
+    HEXDUMP("CMD_RESP: WMM_GET_STATUS", pCurrent, respLen);
+
+    while ((respLen >= sizeof(pTlvHdr->Header)) && valid) {
+        pTlvHdr = (MrvlIEtypes_Data_t *) pCurrent;
+        pTlvHdr->Header.Len = wlan_le16_to_cpu(pTlvHdr->Header.Len);
+
+        switch (wlan_le16_to_cpu(pTlvHdr->Header.Type)) {
+        case TLV_TYPE_WMMQSTATUS:
+            pTlvWmmQStatus = (MrvlIEtypes_WmmQueueStatus_t *) pTlvHdr;
+            PRINTM(INFO,
+                   "CMD_RESP: WMM_GET_STATUS: QSTATUS TLV: %d, %d, %d\n",
+                   pTlvWmmQStatus->QueueIndex, pTlvWmmQStatus->FlowRequired,
+                   pTlvWmmQStatus->Disabled);
+
+            pACStatus = &Adapter->wmm.acStatus[pTlvWmmQStatus->QueueIndex];
+            pACStatus->Disabled = pTlvWmmQStatus->Disabled;
+            pACStatus->FlowRequired = pTlvWmmQStatus->FlowRequired;
+            pACStatus->FlowCreated = pTlvWmmQStatus->FlowCreated;
+            break;
+
+        case WMM_IE:
+            /*
+             * Point the regular IEEE IE 2 bytes into the Marvell IE
+             *   and setup the IEEE IE type and length byte fields
+             */
+
+            HEXDUMP("WMM: WMM TLV:", (u8 *) pTlvHdr, pTlvHdr->Header.Len + 4);
+
+            pWmmParamIe = (WMM_PARAMETER_IE *) (pCurrent + 2);
+            pWmmParamIe->Length = pTlvHdr->Header.Len;
+            pWmmParamIe->ElementId = WMM_IE;
+
+            PRINTM(INFO, "CMD_RESP: WMM_GET_STATUS: WMM Parameter Set: %d\n",
+                   pWmmParamIe->QoSInfo.ParaSetCount);
+
+            memcpy((u8 *) & Adapter->CurBssParams.BSSDescriptor.wmmIE,
+                   pWmmParamIe, pWmmParamIe->Length + 2);
+
+            break;
+
+        default:
+            valid = FALSE;
+            break;
+        }
+
+        pCurrent += (pTlvHdr->Header.Len + sizeof(pTlvHdr->Header));
+        respLen -= (pTlvHdr->Header.Len + sizeof(pTlvHdr->Header));
+    }
+
+    wmm_setup_queue_priorities(priv);
+    wmm_setup_ac_downgrade(priv);
+
+    send_iwevcustom_event(priv, WMM_CONFIG_CHANGE_INDICATION);
+
+    os_carrier_on(priv);
+    os_start_queue(priv);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Call back from the command module to allow insertion of a WMM TLV
+ *   
+ *  If the BSS we are associating to supports WMM, add the required WMM
+ *    Information IE to the association request command buffer in the form
+ *    of a Marvell extended IEEE IE.
+ *     
+ *  @param priv        Pointer to the wlan_private driver data struct
+ *  @param ppAssocBuf  Output parameter: Pointer to the TLV output buffer,
+ *                     modified on return to point after the appended WMM TLV
+ *  @param pWmmIE      Pointer to the WMM IE for the BSS we are joining
+ * 
+ *  @return Length of data appended to the association tlv buffer
+ */
+u32
+wlan_wmm_process_association_req(wlan_private * priv,
+                                 u8 ** ppAssocBuf, WMM_PARAMETER_IE * pWmmIE)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    MrvlIEtypes_WmmParamSet_t *wmm;
+    u32 retLen = 0;
+
+    /* Null checks */
+    if (ppAssocBuf == 0)
+        return 0;
+    if (*ppAssocBuf == 0)
+        return 0;
+    if (pWmmIE == 0)
+        return 0;
+
+    PRINTM(INFO, "WMM: process assoc req: bss->wmmIe=%x\n",
+           pWmmIE->ElementId);
+
+    if (Adapter->wmm.required && pWmmIE->ElementId == WMM_IE) {
+        Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_WMM_ENABLE;
+        SetMacPacketFilter(priv);
+
+        wmm = (MrvlIEtypes_WmmParamSet_t *) * ppAssocBuf;
+        wmm->Header.Type = (u16) wmm_ie[0];
+        wmm->Header.Type = wlan_cpu_to_le16(wmm->Header.Type);
+        wmm->Header.Len = (u16) wmm_ie[1];
+        wmm->Header.Len = wlan_cpu_to_le16(wmm->Header.Len);
+
+        memcpy(wmm->WmmIE, &wmm_ie[2], wmm->Header.Len);
+#define QOS_INFO_PARA_MASK 0x0f
+        if (pWmmIE->QoSInfo.QosUAPSD
+            && ((Adapter->wmm.qosinfo & QOS_INFO_PARA_MASK) != 0)) {
+            memcpy((u8 *) (wmm->WmmIE + wmm->Header.Len
+                           - sizeof(Adapter->wmm.qosinfo)),
+                   &Adapter->wmm.qosinfo, sizeof(Adapter->wmm.qosinfo));
+        }
+        retLen = sizeof(wmm->Header) + wmm->Header.Len;
+
+        HEXDUMP("ASSOC_CMD: WMM IE", (u8 *) wmm, retLen);
+        *ppAssocBuf += retLen;
+
+    } else {
+        Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_WMM_ENABLE;
+        SetMacPacketFilter(priv);
+    }
+
+    return retLen;
+}
+
+/** 
+ *  @brief handle TX data
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *
+ *  @return        void
+ */
+void
+wmm_process_tx(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    ulong flags;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    if ((Adapter->PSState == PS_STATE_SLEEP)
+        || (Adapter->PSState == PS_STATE_PRE_SLEEP)
+        ) {
+        PRINTM(INFO, "In PS State %d"
+               " - Not sending the packet\n", Adapter->PSState);
+        goto done;
+    }
+
+    spin_lock_irqsave(&Adapter->CurrentTxLock, flags);
+
+    if (priv->wlan_dev.dnld_sent) {
+
+        if (priv->adapter->wmm.fw_notify) {
+            wmm_send_prio_pkt_avail(priv);
+            priv->adapter->wmm.fw_notify = 0;
+        }
+
+        spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+
+        goto done;
+    }
+
+    wmm_pop_highest_prio_skb(priv);
+    spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+
+    if (Adapter->CurrentTxSkb) {
+        wlan_process_tx(priv);
+    }
+
+  done:
+    LEAVE();
+}
+
+/**
+ *  @brief Private IOCTL entry to get the status of the WMM queues
+ *
+ *  Return the following information for each WMM AC:
+ *        - WMM IE ACM Required
+ *        - Firmware Flow Required 
+ *        - Firmware Flow Established
+ *        - Firmware Queue Enabled
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_queue_status_t struct for request
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_queue_status_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_wmm_queue_status_t qstatus;
+    wlan_wmm_ac_e acVal;
+    WMM_AC_STATUS *pACStatus;
+    WMM_AC_PARAS *pWmmIeAC;
+
+    for (acVal = AC_PRIO_BK; acVal <= AC_PRIO_VO; acVal++) {
+        pACStatus = &Adapter->wmm.acStatus[acVal];
+
+        /* Get a pointer to the WMM IE parameters for this AC */
+        switch (acVal) {
+        default:
+        case AC_PRIO_BK:
+            pWmmIeAC = &Adapter->CurBssParams.BSSDescriptor.wmmIE.AC_Paras_BK;
+            break;
+        case AC_PRIO_BE:
+            pWmmIeAC = &Adapter->CurBssParams.BSSDescriptor.wmmIE.AC_Paras_BE;
+            break;
+        case AC_PRIO_VI:
+            pWmmIeAC = &Adapter->CurBssParams.BSSDescriptor.wmmIE.AC_Paras_VI;
+            break;
+        case AC_PRIO_VO:
+            pWmmIeAC = &Adapter->CurBssParams.BSSDescriptor.wmmIE.AC_Paras_VO;
+            break;
+        }
+
+        /* ACM bit */
+        qstatus.acStatus[acVal].wmmACM = pWmmIeAC->ACI_AIFSN.ACM;
+
+        /* Firmware status */
+        qstatus.acStatus[acVal].flowRequired = pACStatus->FlowRequired;
+        qstatus.acStatus[acVal].flowCreated = pACStatus->FlowCreated;
+        qstatus.acStatus[acVal].disabled = pACStatus->Disabled;
+    }
+
+    if (copy_to_user(wrq->u.data.pointer, &qstatus, sizeof(qstatus))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Private IOCTL entry to send an ADDTS TSPEC
+ *
+ *  Receive a ADDTS command from the application.  The command structure
+ *    contains a TSPEC and timeout in milliseconds.  The timeout is performed
+ *    in the firmware after the ADDTS command frame is sent.  
+ *
+ *  The TSPEC is received in the API as an opaque block whose length is 
+ *    calculated from the IOCTL data length.  The firmware will send the 
+ *    entire data block, including the bytes after the TSPEC.  This is done
+ *    to allow extra IEs to be packaged with the TSPEC in the ADDTS action
+ *    frame.
+ *
+ *  The IOCTL structure contains two return fields: 
+ *    - The firmware command result which indicates failure and timeouts
+ *    - The IEEE Status code which contains the corresponding value from
+ *      any ADDTS response frame received.
+ *
+ *  In addition, the opaque TSPEC data block passed in is replaced with the 
+ *    TSPEC recieved in the ADDTS response frame.  In case of failure, the
+ *    AP may modify the TSPEC on return and in the case of success, the 
+ *    medium time is returned as calculated by the AP.  Along with the TSPEC,
+ *    any IEs that are sent in the ADDTS response are also returned and can be
+ *    parsed using the IOCTL length as an indicator of extra elements.
+ *
+ *  The return value to the application layer indicates a driver execution
+ *    success or failure.  A successful return could still indicate a firmware
+ *    failure or AP negotiation failure via the commandResult field copied
+ *    back to the application.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_addts_req_t struct for this ADDTS request
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_addts_req_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    static int dialogTok = 0;
+    wlan_ioctl_wmm_addts_req_t addtsIoctl;
+    wlan_cmd_wmm_addts_req_t addtsCmd;
+    int retcode;
+
+    if (copy_from_user(&addtsIoctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length, sizeof(addtsIoctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "TSPEC: ADDTS copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        memset(&addtsCmd, 0x00, sizeof(addtsCmd));
+        addtsCmd.dialogToken = ++dialogTok;
+        addtsCmd.timeout_ms = addtsIoctl.timeout_ms;
+        addtsCmd.tspecDataLen = (wrq->u.data.length
+                                 - sizeof(addtsCmd.timeout_ms)
+                                 - sizeof(addtsCmd.commandResult)
+                                 - sizeof(addtsCmd.ieeeStatusCode));
+        memcpy(addtsCmd.tspecData,
+               addtsIoctl.tspecData, addtsCmd.tspecDataLen);
+
+        retcode = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_WMM_ADDTS_REQ, 0,
+                                        HostCmd_OPTION_WAITFORRSP, 0,
+                                        &addtsCmd);
+
+        wrq->u.data.length = (sizeof(addtsIoctl.timeout_ms)
+                              + sizeof(addtsIoctl.commandResult)
+                              + sizeof(addtsIoctl.ieeeStatusCode)
+                              + addtsCmd.tspecDataLen);
+
+        addtsIoctl.commandResult = addtsCmd.commandResult;
+        addtsIoctl.ieeeStatusCode = addtsCmd.ieeeStatusCode;
+        memcpy(addtsIoctl.tspecData,
+               addtsCmd.tspecData, addtsCmd.tspecDataLen);
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         &addtsIoctl, sizeof(addtsIoctl))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+
+        if (retcode) {
+            return -EFAULT;
+        }
+    }
+
+    return retcode;
+}
+
+/**
+ *  @brief Private IOCTL entry to send a DELTS TSPEC
+ *
+ *  Receive a DELTS command from the application.  The command structure
+ *    contains a TSPEC and reason code along with space for a command result
+ *    to be returned.  The information is packaged is sent to the wlan_cmd.c
+ *    firmware command prep and send routines for execution in the firmware.
+ *
+ *  The reason code is not used for WMM implementations but is indicated in
+ *    the 802.11e specification.
+ *
+ *  The return value to the application layer indicates a driver execution
+ *    success or failure.  A successful return could still indicate a firmware
+ *    failure via the commandResult field copied back to the application.
+ *  
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_delts_req_t struct for this DELTS request
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_delts_req_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_wmm_delts_req_t deltsIoctl;
+    wlan_cmd_wmm_delts_req_t deltsCmd;
+    int retcode;
+
+    if (copy_from_user(&deltsIoctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length, sizeof(deltsIoctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "TSPEC: DELTS copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        memset(&deltsCmd, 0x00, sizeof(deltsCmd));
+
+        /* Dialog token unused for WMM implementations */
+        deltsCmd.dialogToken = 0;
+
+        deltsCmd.ieeeReasonCode = deltsIoctl.ieeeReasonCode;
+
+        /* Calculate the length of the TSPEC and any other IEs */
+        deltsCmd.tspecDataLen = (wrq->u.data.length
+                                 - sizeof(deltsCmd.commandResult)
+                                 - sizeof(deltsCmd.ieeeReasonCode));
+        memcpy(deltsCmd.tspecData,
+               deltsIoctl.tspecData, deltsCmd.tspecDataLen);
+
+        /* Send the DELTS request to firmware, wait for a response */
+        retcode = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_WMM_DELTS_REQ, 0,
+                                        HostCmd_OPTION_WAITFORRSP, 0,
+                                        &deltsCmd);
+
+        /* Return the firmware command result back to the application layer */
+        deltsIoctl.commandResult = deltsCmd.commandResult;
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         &deltsCmd,
+                         MIN(wrq->u.data.length, sizeof(deltsIoctl)))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+
+        if (retcode) {
+            retcode = -EFAULT;
+        }
+    }
+
+    return retcode;
+}
+
+/**
+ *  @brief Process the ADDTS_REQ command response from firmware
+ *
+ *  Return the ADDTS firmware response to the calling thread that sent 
+ *    the command.  The result is then relayed back the app layer.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer including the 
+ *                 command result and any returned ADDTS response TSPEC
+ *                 elements 
+ * 
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_addts_req_ioctl
+ */
+int
+wlan_cmdresp_wmm_addts_req(wlan_private * priv,
+                           const HostCmd_DS_COMMAND * resp)
+{
+    wlan_cmd_wmm_addts_req_t *pAddTsCmd;
+    const HostCmd_DS_WMM_ADDTS_REQ *pCmdResp;
+
+    /* Cast the NULL pointer of the buffer the IOCTL sent in the command req */
+    pAddTsCmd = (wlan_cmd_wmm_addts_req_t *) priv->adapter->CurCmd->pdata_buf;
+
+    /* Convenience variable for the ADDTS response from the firmware */
+    pCmdResp = &resp->params.addTsReq;
+
+    /* Assign return data */
+    pAddTsCmd->dialogToken = pCmdResp->dialogToken;
+    pAddTsCmd->commandResult = pCmdResp->commandResult;
+    pAddTsCmd->ieeeStatusCode = pCmdResp->ieeeStatusCode;
+
+    /* The tspecData field is potentially variable in size due to extra IEs
+     *   that may have been in the ADDTS response action frame.  Calculate
+     *   the data length from the firmware command response.
+     */
+    pAddTsCmd->tspecDataLen = (resp->Size - sizeof(pCmdResp->commandResult)
+                               - sizeof(pCmdResp->timeout_ms)
+                               - sizeof(pCmdResp->dialogToken)
+                               - sizeof(pCmdResp->ieeeStatusCode)
+                               - S_DS_GEN);
+
+    /* Copy back the TSPEC data including any extra IEs after the TSPEC */
+    memcpy(pAddTsCmd->tspecData,
+           pCmdResp->tspecData, pAddTsCmd->tspecDataLen);
+
+    PRINTM(INFO, "TSPEC: ADDTS ret = %d,%d sz=%d\n",
+           pAddTsCmd->commandResult, pAddTsCmd->ieeeStatusCode,
+           pAddTsCmd->tspecDataLen);
+
+    HEXDUMP("TSPEC: ADDTS data",
+            pAddTsCmd->tspecData, pAddTsCmd->tspecDataLen);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process the DELTS_REQ command response from firmware
+ *
+ *  Return the DELTS firmware response to the calling thread that sent 
+ *    the command.  The result is then relayed back the app layer.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer with the command
+ *                 result.  No other response information is passed back 
+ *                 to the driver.
+ * 
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_delts_req_ioctl
+ */
+int
+wlan_cmdresp_wmm_delts_req(wlan_private * priv,
+                           const HostCmd_DS_COMMAND * resp)
+{
+    wlan_cmd_wmm_delts_req_t *pDelTsCmd;
+
+    /* Cast the NULL pointer of the buffer the IOCTL sent in the command req */
+    pDelTsCmd = (wlan_cmd_wmm_delts_req_t *) priv->adapter->CurCmd->pdata_buf;
+
+    pDelTsCmd->commandResult =
+        wlan_le16_to_cpu(resp->params.delTsReq.commandResult);
+
+    PRINTM(INFO, "TSPEC: DELTS result = %d\n", pDelTsCmd->commandResult);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Implement cmd HostCmd_DS_WMM_ADDTS_REQ
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param cmd     Pointer to CMD buffer 
+ *  @param InfoBuf Pointer to cmd data
+ *
+ *  @return        WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_addts_req_ioctl
+ */
+int
+wlan_cmd_wmm_addts_req(wlan_private * priv,
+                       HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    wlan_cmd_wmm_addts_req_t *pAddTsCmd;
+    int tspecCopySize;
+
+    pAddTsCmd = (wlan_cmd_wmm_addts_req_t *) InfoBuf;
+
+    cmd->params.addTsReq.timeout_ms = pAddTsCmd->timeout_ms;
+    cmd->params.addTsReq.dialogToken = pAddTsCmd->dialogToken;
+
+    tspecCopySize = MIN(pAddTsCmd->tspecDataLen,
+                        sizeof(cmd->params.addTsReq.tspecData));
+    memcpy(&cmd->params.addTsReq.tspecData,
+           pAddTsCmd->tspecData, tspecCopySize);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_ADDTS_REQ);
+    cmd->Size = wlan_cpu_to_le16(sizeof(cmd->params.addTsReq.dialogToken)
+                                 + sizeof(cmd->params.addTsReq.timeout_ms)
+                                 + sizeof(cmd->params.addTsReq.commandResult)
+                                 + sizeof(cmd->params.addTsReq.ieeeStatusCode)
+                                 + tspecCopySize + S_DS_GEN);
+
+    cmd->params.addTsReq.timeout_ms =
+        wlan_cpu_to_le32(cmd->params.addTsReq.timeout_ms);
+
+    PRINTM(INFO, "WMM: ADDTS Cmd: Data Len = %d\n", pAddTsCmd->tspecDataLen);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Implement cmd HostCmd_DS_WMM_DELTS_REQ
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      Pointer to CMD buffer 
+ *  @param InfoBuf  Void pointer cast of a wlan_cmd_wmm_delts_req_t struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_delts_req_ioctl
+ */
+int
+wlan_cmd_wmm_delts_req(wlan_private * priv,
+                       HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    wlan_cmd_wmm_delts_req_t *pDelTsCmd;
+    int tspecCopySize;
+
+    pDelTsCmd = (wlan_cmd_wmm_delts_req_t *) InfoBuf;
+
+    cmd->params.delTsReq.dialogToken = pDelTsCmd->dialogToken;
+    cmd->params.delTsReq.ieeeReasonCode = pDelTsCmd->ieeeReasonCode;
+
+    tspecCopySize = MIN(pDelTsCmd->tspecDataLen,
+                        sizeof(cmd->params.delTsReq.tspecData));
+    memcpy(&cmd->params.delTsReq.tspecData,
+           pDelTsCmd->tspecData, tspecCopySize);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_DELTS_REQ);
+    cmd->Size = wlan_cpu_to_le16(sizeof(cmd->params.delTsReq.dialogToken)
+                                 + sizeof(cmd->params.delTsReq.commandResult)
+                                 + sizeof(cmd->params.delTsReq.ieeeReasonCode)
+                                 + tspecCopySize + S_DS_GEN);
+
+    PRINTM(INFO, "WMM: DELTS Cmd prepared\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Prepare the firmware command buffer for the WMM_QUEUE_CONFIG command
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      Pointer to CMD buffer 
+ *  @param InfoBuf  Void pointer cast of a wlan_cmd_wmm_queue_config_t struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmd_wmm_queue_config(wlan_private * priv,
+                          HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    wlan_cmd_wmm_queue_config_t *pQConfigCmd;
+    int tlvCopySize;
+
+    pQConfigCmd = (wlan_cmd_wmm_queue_config_t *) InfoBuf;
+
+    cmd->params.queueConfig.action = pQConfigCmd->action;
+    cmd->params.queueConfig.accessCategory = pQConfigCmd->accessCategory;
+    cmd->params.queueConfig.msduLifetimeExpiry
+        = wlan_cpu_to_le16(pQConfigCmd->msduLifetimeExpiry);
+
+    tlvCopySize = MIN(pQConfigCmd->tlvBufLen,
+                      sizeof(cmd->params.queueConfig.tlvBuffer));
+    memcpy(&cmd->params.queueConfig.tlvBuffer,
+           pQConfigCmd->tlvBuffer, tlvCopySize);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_QUEUE_CONFIG);
+    cmd->Size = wlan_cpu_to_le16(sizeof(cmd->params.queueConfig.action)
+                                 +
+                                 sizeof(cmd->params.queueConfig.
+                                        accessCategory)
+                                 +
+                                 sizeof(cmd->params.queueConfig.
+                                        msduLifetimeExpiry)
+                                 + tlvCopySize + S_DS_GEN);
+
+    PRINTM(INFO, "WMM: QUEUE CONFIG Cmd prepared\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process the WMM_QUEUE_CONFIG command response from firmware
+ *
+ *  Return the firmware command response to the blocked IOCTL caller function.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer with:
+ *                      - action code
+ *                      - access category
+ *                      - collected statistics if requested 
+ *
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_queue_config_ioctl
+ */
+int
+wlan_cmdresp_wmm_queue_config(wlan_private * priv,
+                              const HostCmd_DS_COMMAND * resp)
+{
+    wlan_cmd_wmm_queue_config_t *pQConfigCmd;
+    const HostCmd_DS_WMM_QUEUE_CONFIG *pCmdResp;
+
+    pQConfigCmd =
+        (wlan_cmd_wmm_queue_config_t *) (priv->adapter->CurCmd->pdata_buf);
+    pCmdResp = &resp->params.queueConfig;
+
+    pQConfigCmd->action = pCmdResp->action;
+    pQConfigCmd->accessCategory = pCmdResp->accessCategory;
+    pQConfigCmd->msduLifetimeExpiry =
+        wlan_le16_to_cpu(pCmdResp->msduLifetimeExpiry);
+
+    pQConfigCmd->tlvBufLen = (resp->Size - sizeof(pCmdResp->action)
+                              - sizeof(pCmdResp->accessCategory)
+                              - sizeof(pCmdResp->msduLifetimeExpiry)
+                              - S_DS_GEN);
+
+    memcpy(pQConfigCmd->tlvBuffer,
+           pCmdResp->tlvBuffer, pQConfigCmd->tlvBufLen);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Private IOCTL entry to get/set a specified AC Queue's parameters
+ *
+ *  Receive a AC Queue configuration command which is used to get, set, or 
+ *    default the parameters associated with a specific WMM AC Queue.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_queue_config_t struct
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_queue_config_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_wmm_queue_config_t queueConfigIoctl;
+    wlan_cmd_wmm_queue_config_t queueConfigCmd;
+    int retcode;
+
+    PRINTM(INFO, "WMM: Queue Config IOCTL Enter\n");
+
+    if (copy_from_user(&queueConfigIoctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length,
+                           sizeof(queueConfigIoctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "WMM: Queue Config: copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        memset(&queueConfigCmd, 0x00, sizeof(queueConfigCmd));
+
+        queueConfigCmd.action = queueConfigIoctl.action;
+        queueConfigCmd.accessCategory = queueConfigIoctl.accessCategory;
+        queueConfigCmd.msduLifetimeExpiry
+            = queueConfigIoctl.msduLifetimeExpiry;
+
+        /* Create a rates TLV from the supportedRates[] ioctl field */
+        queueConfigCmd.tlvBufLen = 0;
+
+        retcode = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_WMM_QUEUE_CONFIG, 0,
+                                        HostCmd_OPTION_WAITFORRSP, 0,
+                                        &queueConfigCmd);
+
+        memset(&queueConfigIoctl, 0x00, sizeof(queueConfigIoctl));
+
+        queueConfigIoctl.action = queueConfigCmd.action;
+        queueConfigIoctl.accessCategory = queueConfigCmd.accessCategory;
+        queueConfigIoctl.msduLifetimeExpiry
+            = queueConfigCmd.msduLifetimeExpiry;
+
+        wrq->u.data.length = sizeof(queueConfigIoctl);
+
+        /* Convert the rates TLV in the response (if any) to a rates[] ioctl */
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         &queueConfigIoctl, sizeof(queueConfigIoctl))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+
+        if (retcode) {
+            return -EFAULT;
+        }
+    }
+
+    return retcode;
+}
+
+/** 
+ *  @brief Prepare the firmware command buffer for the WMM_QUEUE_STATS command
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      pointer to CMD buffer 
+ *  @param InfoBuf  void pointer cast of a HostCmd_CMD_WMM_QUEUE_STATS struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmd_wmm_queue_stats(wlan_private * priv,
+                         HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    memcpy(&cmd->params.queueStats, InfoBuf, sizeof(cmd->params.queueStats));
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_QUEUE_STATS);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_WMM_QUEUE_STATS)
+                                 + S_DS_GEN);
+
+    PRINTM(INFO, "WMM: QUEUE STATS Cmd prepared\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process the WMM_QUEUE_STATS command response from firmware
+ *
+ *  Return the firmware command response to the blocked IOCTL caller function.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer with:
+ *                      - action code
+ *                      - access category
+ *                      - collected statistics if requested 
+ *
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_queue_stats_ioctl
+ */
+int
+wlan_cmdresp_wmm_queue_stats(wlan_private * priv,
+                             const HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_WMM_QUEUE_STATS *pQueueStats =
+        (HostCmd_DS_WMM_QUEUE_STATS *) priv->adapter->CurCmd->pdata_buf;
+
+    memcpy(pQueueStats, &resp->params.queueStats, (resp->Size - S_DS_GEN));
+
+    pQueueStats->pktCount = wlan_le16_to_cpu(pQueueStats->pktCount);
+    pQueueStats->pktLoss = wlan_le16_to_cpu(pQueueStats->pktLoss);
+    pQueueStats->avgQueueDelay = wlan_le32_to_cpu(pQueueStats->avgQueueDelay);
+    pQueueStats->avgTxDelay = wlan_le32_to_cpu(pQueueStats->avgTxDelay);
+    pQueueStats->usedTime = wlan_le32_to_cpu(pQueueStats->usedTime);
+
+    PRINTM(INFO, "WMM: Queue Stats response: %d\n", resp->Size - S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Private IOCTL entry to get and start/stop queue stats on a WMM AC
+ *
+ *  Receive a AC Queue statistics command from the application for a specific
+ *    WMM AC.  The command can:
+ *         - Turn stats on
+ *         - Turn stats off
+ *         - Collect and clear the stats 
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_queue_stats_t struct
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_queue_stats_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_wmm_queue_stats_t queueStatsIoctl;
+    HostCmd_DS_WMM_QUEUE_STATS queueStatsCmd;
+    int retcode;
+
+    if (copy_from_user(&queueStatsIoctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length,
+                           sizeof(queueStatsIoctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "WMM: Queue Stats: copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        memcpy(&queueStatsCmd, &queueStatsIoctl, sizeof(queueStatsCmd));
+
+        PRINTM(INFO, "WMM: QUEUE STATS Ioctl: %d, %d\n",
+               queueStatsCmd.action, queueStatsCmd.accessCategory);
+
+        retcode = PrepareAndSendCommand(priv,
+                                        HostCmd_CMD_WMM_QUEUE_STATS, 0,
+                                        HostCmd_OPTION_WAITFORRSP, 0,
+                                        &queueStatsCmd);
+        if (copy_to_user(wrq->u.data.pointer,
+                         &queueStatsCmd,
+                         MIN(wrq->u.data.length, sizeof(queueStatsCmd)))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+
+        if (retcode) {
+            retcode = -EFAULT;
+        }
+    }
+
+    if (retcode != WLAN_STATUS_SUCCESS) {
+        PRINTM(INFO, "WMM: QUEUE STATS Ioctl FAILED: %d, %d\n",
+               queueStatsIoctl.action, queueStatsIoctl.accessCategory);
+    }
+
+    return retcode;
+}
diff --git a/drivers/net/wireless/8686_wlan/wlan/wlan_wmm.h b/drivers/net/wireless/8686_wlan/wlan/wlan_wmm.h
new file mode 100644
index 0000000..11f9e01
--- /dev/null
+++ b/drivers/net/wireless/8686_wlan/wlan/wlan_wmm.h
@@ -0,0 +1,120 @@
+/** @file wlan_wmm.h
+ * @brief This file contains related macros, enum, and struct
+ * of wmm functionalities
+ *
+ * (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/****************************************************
+Change log:
+    09/26/05: add Doxygen format comments 
+    04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+****************************************************/
+
+#ifndef __WLAN_WMM_H
+#define __WLAN_WMM_H
+
+#define WMM_IE_LENGTH                 0x0009
+#define WMM_PARA_IE_LENGTH            0x0018
+#define WMM_QOS_INFO_OFFSET           0x08
+#define WMM_QOS_INFO_UAPSD_BIT        0x80
+#define WMM_OUISUBTYPE_IE             0x00
+#define WMM_OUISUBTYPE_PARA           0x01
+#define WMM_TXOP_LIMIT_UNITS_SHIFT    5
+
+#define WMM_CONFIG_CHANGE_INDICATION  "WMM_CONFIG_CHANGE.indication"
+
+/** Size of a TSPEC.  Used to allocate necessary buffer space in commands */
+#define WMM_TSPEC_SIZE              63
+
+/** Extra IE bytes allocated in messages for appended IEs after a TSPEC */
+#define WMM_ADDTS_EXTRA_IE_BYTES    256
+
+/** Extra TLV bytes allocated in messages for configuring WMM Queues */
+#define WMM_QUEUE_CONFIG_EXTRA_TLV_BYTES 64
+
+#ifdef __KERNEL__
+/** struct of WMM DESC */
+typedef struct
+{
+    u8 required;
+    u8 enabled;
+    u8 fw_notify;
+    struct sk_buff TxSkbQ[MAX_AC_QUEUES];
+    u8 Para_IE[WMM_PARA_IE_LENGTH];
+    u8 qosinfo;
+    WMM_AC_STATUS acStatus[MAX_AC_QUEUES];
+} __ATTRIB_PACK__ WMM_DESC;
+
+extern void wmm_map_and_add_skb(wlan_private * priv, struct sk_buff *);
+#endif
+
+extern int sendWMMStatusChangeCmd(wlan_private * priv);
+extern int wmm_lists_empty(wlan_private * priv);
+extern void wmm_cleanup_queues(wlan_private * priv);
+extern void wmm_process_tx(wlan_private * priv);
+
+extern u32 wlan_wmm_process_association_req(wlan_private * priv,
+                                            u8 ** ppAssocBuf,
+                                            WMM_PARAMETER_IE * pWmmIE);
+
+/* 
+ *  Functions used in the cmd handling routine
+ */
+extern int wlan_cmd_wmm_ack_policy(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_get_status(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_addts_req(wlan_private * priv,
+                                  HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_delts_req(wlan_private * priv,
+                                  HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_queue_config(wlan_private * priv,
+                                     HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_queue_stats(wlan_private * priv,
+                                    HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+
+/* 
+ *  Functions used in the cmdresp handling routine
+ */
+extern int wlan_cmdresp_wmm_ack_policy(wlan_private * priv,
+                                       const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_get_status(wlan_private * priv,
+                                       const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_addts_req(wlan_private * priv,
+                                      const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_delts_req(wlan_private * priv,
+                                      const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_queue_config(wlan_private * priv,
+                                         const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_queue_stats(wlan_private * priv,
+                                        const HostCmd_DS_COMMAND * resp);
+
+/* 
+ * IOCTLs 
+ */
+extern int wlan_wmm_ack_policy_ioctl(wlan_private * priv, struct ifreq *req);
+extern int wlan_wmm_para_ie_ioctl(wlan_private * priv, struct ifreq *req);
+extern int wlan_wmm_enable_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_wmm_queue_status_ioctl(wlan_private * priv,
+                                       struct iwreq *wrq);
+
+extern int wlan_wmm_addts_req_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_wmm_delts_req_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_wmm_queue_config_ioctl(wlan_private * priv,
+                                       struct iwreq *wrq);
+extern int wlan_wmm_queue_stats_ioctl(wlan_private * priv, struct iwreq *wrq);
+#endif /* __WLAN_WMM_H */
diff --git a/drivers/net/wireless/8688_bt/Makefile b/drivers/net/wireless/8688_bt/Makefile
new file mode 100755
index 0000000..0319088
--- /dev/null
+++ b/drivers/net/wireless/8688_bt/Makefile
@@ -0,0 +1,39 @@
+#############################################################################
+# Configuration Options
+#############################################################################
+
+# Debug Option
+# DEBUG LEVEL n/1:
+# n: NO DEBUG
+# 1: PRINTM(MSG,...), PRINTM(FATAL,...), PRINTM(WARN,...) and PRINTM(INFO,...)
+CONFIG_DEBUG=1
+
+#############################################################################
+# Compiler Flags
+#############################################################################
+
+EXTRA_CFLAGS += -Ibt
+
+ifeq ($(CONFIG_DEBUG),1)
+	EXTRA_CFLAGS += -DDEBUG_LEVEL1
+endif
+
+#############################################################################
+# Make Targets
+#############################################################################
+
+ifneq ($(KERNELRELEASE),)
+
+BTOBJS = bt/bt_main.o bt/bt_sdio.o bt/bt_proc.o
+
+obj-m := bt8xxx.o
+bt8xxx-objs := $(BTOBJS)
+
+
+# Otherwise we were called directly from the command line; invoke the kernel build system.
+else
+default:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
+endif
+
+# End of file;
diff --git a/drivers/net/wireless/8688_bt/README b/drivers/net/wireless/8688_bt/README
new file mode 100755
index 0000000..66fbfc6
--- /dev/null
+++ b/drivers/net/wireless/8688_bt/README
@@ -0,0 +1,89 @@
+===============================================================================
+			U S E R  M A N U A L
+
+ (c) Copyright © 2003-2007, Marvell International Ltd. 
+
+ This software file (the "File") is distributed by Marvell International 
+ Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ (the "License").  You may use, redistribute and/or modify this File in 
+ accordance with the terms and conditions of the License, a copy of which 
+ is available along with the File in the gpl.txt file or by writing to 
+ the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+ THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ this warranty disclaimer.
+
+===============================================================================
+
+1) FOR DRIVER BUILD
+
+	Goto source code directory src_xxxx.
+		make [clean] build
+	The driver binaries can be found in ../bin_bt directory.
+
+2) FOR DRIVER INSTALL
+
+	a) Copy helper_sd.bin and sd8688.bin | sd8689.bin | ... to /lib/firmware/mrvl/ 
+	   directory, create the directory if it doesn't exist.
+	b) Install sdio bus driver and bluetooth driver,
+		./load sd8688 | sd8689 | ...
+	c) Uninstall bluetooth driver and sdio bus driver,
+		./unload
+3) cat /proc/net/mbt/hcix/config
+   This command is used to get the current driver settings. 
+
+4) cat /proc/net/mbt/hcix/status
+   This command is used to get driver status
+
+5) proc commands to config bluetooth parameters. 
+
+drvdbg=[n]
+   This command is used to set the bit masks of driver debug message control.
+
+   	bit 0:  MSG  		PRINTM(MSG,...)
+	bit 1:  FATAL		PRINTM(FATAL,...)
+	bit 2:  ERROR		PRINTM(ERROR,...)
+	bit 3:  CMD		PRINTM(CMD,...)
+	bit 27: DATA		DBG_HEXDUMP(DBG_DATA,...)
+	bit 28: ENTRY		PRINTM(ENTRY,...), ENTER(), LEAVE()
+	bit 29: WARN 		PRINTM(WARN,...)
+	bit 30: INFO 		PRINTM(INFO,...)
+
+	Usage:
+		echo "drvdbg=0x7" > /proc/net/mbt/hcix/config		#enable MSG,FATAL,ERROR messages
+
+gpio_gap=[n]
+   This command is used to configure the host sleep parameters.
+	bit 8:0  -- Gap
+	bit 16:8 -- GPIO
+
+	where GPIO is the pin number of GPIO used to wakeup the host. It could be any valid
+		GPIO pin# (e.g. 0-7) or 0xff (Interface, e.g. SDIO will be used instead).
+		
+	where Gap is the gap in milli seconds between wakeup signal and wakeup event 
+		or 0xff for special setting.
+	Usage:
+		echo "gpio_gap=0xff80" > /proc/net/mbt/hcix/config   	# use Interface (e.g. SDIO)
+		echo "hscfgcmd=1" > /proc/net/mbt/hcix/config		# gap = 0x80
+
+		echo "gpio_gap=0x03ff" > /proc/net/mbt/hcix/config   	# use gpio 3
+		echo "hscfgcmd=1" > /proc/net/mbt/hcix/config		# and special host sleep mode
+
+psmode=[n]
+    This command is used to enable/disable auto sleep mode
+	
+	where the option is:
+			1 	-- Enable auto sleep mode
+			0 	-- Disable auto sleep mode
+	Usage:
+		echo "psmode=1" > /proc/net/mbt/hcix/config		#enable power save mode
+		echo "pscmd=1" > /proc/net/mbt/hcix/config
+
+		echo "psmode=0" > /proc/net/mbt/hcix/config		#disable power save mode
+		echo "pscmd=1" > /proc/net/mbt/hcix/config
+		
+						
+==============================================================================
diff --git a/drivers/net/wireless/8688_bt/bt/bt_drv.h b/drivers/net/wireless/8688_bt/bt/bt_drv.h
new file mode 100755
index 0000000..47f6d0c
--- /dev/null
+++ b/drivers/net/wireless/8688_bt/bt/bt_drv.h
@@ -0,0 +1,491 @@
+/** @file bt_drv.h
+ *  @brief This header file contains global constant/enum definitions,
+ *  global variable declaration.
+ *       
+ *  (c) Copyright 2007, Marvell International Ltd.   
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+
+#ifndef _BT_DRV_H_
+#define _BT_DRV_H_
+
+/** Double-Word(32Bit) Bit definition */
+/** Double-Word bit 0 */
+#define DW_BIT_0	0x00000001
+/** Double-Word bit 1 */
+#define DW_BIT_1	0x00000002
+/** Double-Word bit 2 */
+#define DW_BIT_2	0x00000004
+/** Double-Word bit 3 */
+#define DW_BIT_3	0x00000008
+/** Double-Word bit 4 */
+#define DW_BIT_4	0x00000010
+/** Double-Word bit 5 */
+#define DW_BIT_5	0x00000020
+/** Double-Word bit 6 */
+#define DW_BIT_6	0x00000040
+/** Double-Word bit 7 */
+#define DW_BIT_7	0x00000080
+/** Double-Word bit 8 */
+#define DW_BIT_8	0x00000100
+/** Double-Word bit 9 */
+#define DW_BIT_9	0x00000200
+/** Double-Word bit 10 */
+#define DW_BIT_10	0x00000400
+/** Double-Word bit 11 */
+#define DW_BIT_11       0x00000800
+/** Double-Word bit 12 */
+#define DW_BIT_12       0x00001000
+/** Double-Word bit 13 */
+#define DW_BIT_13       0x00002000
+/** Double-Word bit 14 */
+#define DW_BIT_14       0x00004000
+/** Double-Word bit 15 */
+#define DW_BIT_15       0x00008000
+/** Double-Word bit 16 */
+#define DW_BIT_16       0x00010000
+/** Double-Word bit 17 */
+#define DW_BIT_17       0x00020000
+/** Double-Word bit 18 */
+#define DW_BIT_18       0x00040000
+/** Double-Word bit 19 */
+#define DW_BIT_19       0x00080000
+/** Double-Word bit 20 */
+#define DW_BIT_20       0x00100000
+/** Double-Word bit 21 */
+#define DW_BIT_21       0x00200000
+/** Double-Word bit 22 */
+#define DW_BIT_22       0x00400000
+/** Double-Word bit 23 */
+#define DW_BIT_23       0x00800000
+/** Double-Word bit 24 */
+#define DW_BIT_24       0x01000000
+/** Double-Word bit 25 */
+#define DW_BIT_25       0x02000000
+/** Double-Word bit 26 */
+#define DW_BIT_26       0x04000000
+/** Double-Word bit 27 */
+#define DW_BIT_27       0x08000000
+/** Double-Word bit 28 */
+#define DW_BIT_28       0x10000000
+/** Double-Word bit 29 */
+#define DW_BIT_29       0x20000000
+/** Double-Word bit 30 */
+#define DW_BIT_30	0x40000000
+/** Double-Word bit 31 */
+#define DW_BIT_31	0x80000000
+
+/** Word (16bit) Bit Definition*/
+/** Word bit 0 */
+#define W_BIT_0		0x0001
+/** Word bit 1 */
+#define W_BIT_1		0x0002
+/** Word bit 2 */
+#define W_BIT_2		0x0004
+/** Word bit 3 */
+#define W_BIT_3		0x0008
+/** Word bit 4 */
+#define W_BIT_4		0x0010
+/** Word bit 5 */
+#define W_BIT_5		0x0020
+/** Word bit 6 */
+#define W_BIT_6		0x0040
+/** Word bit 7 */
+#define W_BIT_7		0x0080
+/** Word bit 8 */
+#define W_BIT_8		0x0100
+/** Word bit 9 */
+#define W_BIT_9		0x0200
+/** Word bit 10 */
+#define W_BIT_10	0x0400
+/** Word bit 11 */
+#define W_BIT_11	0x0800
+/** Word bit 12 */
+#define W_BIT_12	0x1000
+/** Word bit 13 */
+#define W_BIT_13	0x2000
+/** Word bit 14 */
+#define W_BIT_14	0x4000
+/** Word bit 15 */
+#define W_BIT_15	0x8000
+
+/** Byte (8Bit) Bit definition*/
+/** Byte bit 0 */
+#define B_BIT_0		0x01
+/** Byte bit 1 */
+#define B_BIT_1		0x02
+/** Byte bit 2 */
+#define B_BIT_2		0x04
+/** Byte bit 3 */
+#define B_BIT_3		0x08
+/** Byte bit 4 */
+#define B_BIT_4		0x10
+/** Byte bit 5 */
+#define B_BIT_5		0x20
+/** Byte bit 6 */
+#define B_BIT_6		0x40
+/** Byte bit 7 */
+#define B_BIT_7		0x80
+
+/** Debug level : Message */
+#define	DBG_MSG			DW_BIT_0
+/** Debug level : Fatal */
+#define DBG_FATAL		DW_BIT_1
+/** Debug level : Error */
+#define DBG_ERROR		DW_BIT_2
+/** Debug level : Command */
+#define DBG_CMD			DW_BIT_3
+/** Debug level : Data */
+#define DBG_DATA		DW_BIT_27
+/** Debug level : Entry */
+#define DBG_ENTRY		DW_BIT_28
+/** Debug level : Warning */
+#define DBG_WARN		DW_BIT_29
+/** Debug level : Informative */
+#define DBG_INFO		DW_BIT_30
+
+#ifdef	DEBUG_LEVEL1
+extern u32 drvdbg;
+
+/** Print informative message */
+#define	PRINTM_INFO(msg...)  {if (drvdbg & DBG_INFO)  printk(KERN_DEBUG msg);}
+/** Print warning message */
+#define	PRINTM_WARN(msg...)  {if (drvdbg & DBG_WARN)  printk(KERN_DEBUG msg);}
+/** Print entry message */
+#define	PRINTM_ENTRY(msg...) {if (drvdbg & DBG_ENTRY) printk(KERN_DEBUG msg);}
+/** Print command message */
+#define	PRINTM_CMD(msg...)   {if (drvdbg & DBG_CMD)   printk(KERN_DEBUG msg);}
+/** Print erro message */
+#define	PRINTM_ERROR(msg...) {if (drvdbg & DBG_ERROR) printk(KERN_DEBUG msg);}
+/** Print fatal message */
+#define	PRINTM_FATAL(msg...) {if (drvdbg & DBG_FATAL) printk(KERN_DEBUG msg);}
+/** Print message */
+#define	PRINTM_MSG(msg...)   {if (drvdbg & DBG_MSG)   printk(KERN_ALERT msg);}
+
+/** Print message with required level */
+#define	PRINTM(level,msg...) PRINTM_##level(msg)
+
+/** Debug dump buffer length */
+#define DBG_DUMP_BUF_LEN 	64
+/** Maximum number of dump per line */
+#define MAX_DUMP_PER_LINE	16
+/** Maximum data dump length */
+#define MAX_DATA_DUMP_LEN	48
+
+static inline void
+hexdump(char *prompt, u8 * buf, int len)
+{
+    int i;
+    char dbgdumpbuf[DBG_DUMP_BUF_LEN];
+    char *ptr = dbgdumpbuf;
+
+    printk(KERN_DEBUG "%s: len=%d\n", prompt, len);
+    for (i = 1; i <= len; i++) {
+        ptr += sprintf(ptr, "%02x ", *buf);
+        buf++;
+        if (i % MAX_DUMP_PER_LINE == 0) {
+            *ptr = 0;
+            printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+            ptr = dbgdumpbuf;
+        }
+    }
+    if (len % MAX_DUMP_PER_LINE) {
+        *ptr = 0;
+        printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+    }
+}
+
+/** Debug hexdump of debug data */
+#define DBG_HEXDUMP_DBG_DATA(x,y,z)     {if (drvdbg & DBG_DATA) hexdump(x,y,z);}
+
+/** Debug hexdump */
+#define	DBG_HEXDUMP(level,x,y,z)    DBG_HEXDUMP_##level(x,y,z)
+
+/** Mark entry point */
+#define	ENTER()			PRINTM(ENTRY, "Enter: %s, %s:%i\n", __FUNCTION__, \
+							__FILE__, __LINE__)
+/** Mark exit point */
+#define	LEAVE()			PRINTM(ENTRY, "Leave: %s, %s:%i\n", __FUNCTION__, \
+							__FILE__, __LINE__)
+#else
+/** Do nothing */
+#define	PRINTM(level,msg...) do {} while (0)
+/** Do nothing */
+#define DBG_HEXDUMP(level,x,y,z)    do {} while (0)
+/** Do nothing */
+#define	ENTER()  do {} while (0);
+/** Do nothing */
+#define	LEAVE()  do {} while (0);
+#endif //DEBUG_LEVEL1
+
+/** Length of device name */
+#define DEV_NAME_LEN				32
+/** Bluetooth upload size */
+#define	BT_UPLD_SIZE				2312
+/** Bluetooth status success */
+#define BT_STATUS_SUCCESS			(0)
+/** Bluetooth status failure */
+#define BT_STATUS_FAILURE			(-1)
+
+#ifndef	TRUE
+/** True value */
+#define TRUE			1
+#endif
+#ifndef	FALSE
+/** False value */
+#define	FALSE			0
+#endif
+
+/** Set thread state */
+#define OS_SET_THREAD_STATE(x)		set_current_state(x)
+/** Time to wait until Host Sleep state change */
+#define WAIT_UNTIL_HS_STATE_CHANGED (5 * HZ)
+/** Time to wait cmd resp */
+#define WAIT_UNTIL_CMD_RESP	    (5 * HZ)
+
+/** Set interruptible timeout value */
+#define os_wait_interruptible_timeout(waitq, cond, timeout) \
+	wait_event_interruptible_timeout(waitq, cond, timeout)
+
+typedef struct
+{
+    /** Task */
+    struct task_struct *task;
+    /** Queue */
+    wait_queue_head_t waitQ;
+    /** PID */
+    pid_t pid;
+    /** Private structure */
+    void *priv;
+} bt_thread;
+
+static inline void
+bt_activate_thread(bt_thread * thr)
+{
+        /** Record the thread pid */
+    thr->pid = current->pid;
+
+        /** Initialize the wait queue */
+    init_waitqueue_head(&thr->waitQ);
+}
+
+static inline void
+bt_deactivate_thread(bt_thread * thr)
+{
+    thr->pid = 0;
+    return;
+}
+
+static inline void
+bt_create_thread(int (*btfunc) (void *), bt_thread * thr, char *name)
+{
+    thr->task = kthread_run(btfunc, thr, "%s", name);
+}
+
+static inline int
+bt_terminate_thread(bt_thread * thr)
+{
+    /* Check if the thread is active or not */
+    if (!thr->pid) {
+        return -1;
+    }
+    kthread_stop(thr->task);
+    return 0;
+}
+
+static inline void
+os_sched_timeout(u32 millisec)
+{
+    set_current_state(TASK_INTERRUPTIBLE);
+
+    schedule_timeout((millisec * HZ) / 1000);
+}
+
+#ifndef __ATTRIB_ALIGN__
+#define __ATTRIB_ALIGN__ __attribute__((aligned(4)))
+#endif
+
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__ __attribute__ ((packed))
+#endif
+/** Data structure for the Marvell Bluetooth device */
+typedef struct _bt_dev
+{
+        /** device name */
+    char name[DEV_NAME_LEN];
+        /** card pointer */
+    void *card;
+        /** IO port */
+    u32 ioport;
+    /** HCI device */
+    struct hci_dev *hcidev;
+
+    /** Tx download ready flag */
+    u8 tx_dnld_rdy;
+    /** Function */
+    u8 fn;
+    /** Rx unit */
+    u8 rx_unit;
+    /** Power Save mode */
+    u8 psmode;
+    /** Power Save command */
+    u8 pscmd;
+    /** Host Sleep mode */
+    u8 hsmode;
+    /** Host Sleep command */
+    u8 hscmd;
+    /** Low byte is gap, high byte is GPIO */
+    u16 gpio_gap;
+    /** Host Sleep configuration command */
+    u8 hscfgcmd;
+    /** Host Send Cmd Flag		 */
+    u8 sendcmdflag;
+} bt_dev_t, *pbt_dev_t;
+
+typedef struct _bt_adapter
+{
+    /** Temporry Tx buffer */
+    u8 TmpTxBuf[BT_UPLD_SIZE] __ATTRIB_ALIGN__;
+    /** Chip revision ID */
+    u8 chip_rev;
+    /** Surprise removed flag */
+    u8 SurpriseRemoved;
+    /** IRQ number */
+    int irq;
+    /** Interrupt counter */
+    u32 IntCounter;
+    /** Tx packet queue */
+    struct sk_buff_head tx_queue;
+    /** Power Save mode */
+    u8 psmode;
+    /** Power Save state */
+    u8 ps_state;
+    /** Host Sleep state */
+    u8 hs_state;
+    /** Number of wakeup tries */
+    u8 WakeupTries;
+    /** Host Sleep wait queue */
+    wait_queue_head_t cmd_wait_q __ATTRIB_ALIGN__;
+    /** Host Cmd complet state */
+    u8 cmd_complete;
+} bt_adapter, *pbt_adapter;
+
+/** Private structure for the MV device */
+typedef struct _bt_private
+{
+    /** Bluetooth device */
+    bt_dev_t bt_dev;
+    /** Adapter */
+    bt_adapter *adapter;
+    /** Firmware helper */
+    const struct firmware *fw_helper;
+    /** Firmware */
+    const struct firmware *firmware;
+    /** Hotplug device */
+    struct device *hotplug_device;
+        /** thread to service interrupts */
+    bt_thread MainThread;
+    /** Proc directory entry */
+    struct proc_dir_entry *proc_entry;
+    /** Proc mbt directory entry */
+    struct proc_dir_entry *proc_mbt;
+} bt_private, *pbt_private;
+
+/** Marvell vendor packet */
+#define MRVL_VENDOR_PKT			0xFE
+/** Bluetooth command : Sleep mode */
+#define BT_CMD_AUTO_SLEEP_MODE		0x23
+/** Bluetooth command : Host Sleep configuration */
+#define BT_CMD_HOST_SLEEP_CONFIG	0x59
+/** Bluetooth command : Host Sleep enable */
+#define BT_CMD_HOST_SLEEP_ENABLE	0x5A
+/** Bluetooth command : Module Configuration request */
+#define BT_CMD_MODULE_CFG_REQ		0x5B
+/** Sub Command: Module Bring Up Request */
+#define MODULE_BRINGUP_REQ		0xF1
+/** Sub Command: Module Shut Down Request */
+#define MODULE_SHUTDOWN_REQ		0xF2
+/** Sub Command: Host Interface Control Request */
+#define MODULE_INTERFACE_CTRL_REQ	0xF5
+
+/** Bluetooth event : Power State */
+#define BT_EVENT_POWER_STATE		0x20
+
+/** Bluetooth Power State : Enable */
+#define BT_PS_ENABLE			0x02
+/** Bluetooth Power State : Disable */
+#define BT_PS_DISABLE			0x03
+/** Bluetooth Power State : Sleep */
+#define BT_PS_SLEEP			0x01
+/** Bluetooth Power State : Awake */
+#define BT_PS_AWAKE			0x02
+
+/** OGF */
+#define OGF				0x3F
+
+/** Host Sleep activated */
+#define HS_ACTIVATED			0x01
+/** Host Sleep deactivated */
+#define HS_DEACTIVATED			0x00
+
+/** Power Save sleep */
+#define PS_SLEEP			0x01
+/** Power Save awake */
+#define PS_AWAKE			0x00
+
+typedef struct _BT_CMD
+{
+    /** OCF OGF */
+    u16 ocf_ogf;
+    /** Length */
+    u8 length;
+    /** Data */
+    u8 data[4];
+} __ATTRIB_PACK__ BT_CMD;
+
+typedef struct _BT_EVENT
+{
+    /** Event Counter */
+    u8 EC;
+    /** Length */
+    u8 length;
+    /** Data */
+    u8 data[4];
+} BT_EVENT;
+
+/* Prototype of global function */
+bt_private *bt_add_card(void *card);
+int bt_remove_card(void *card);
+void bt_interrupt(struct hci_dev *hdev);
+
+int bt_proc_init(bt_private * priv);
+void bt_proc_remove(bt_private * priv);
+int bt_process_event(bt_private * priv, struct sk_buff *skb);
+int bt_enable_hs(bt_private * priv);
+int bt_prepare_command(bt_private * priv);
+
+int *sbi_register(void);
+void sbi_unregister(void);
+int sbi_register_dev(bt_private * priv);
+int sbi_unregister_dev(bt_private * priv);
+int sbi_host_to_card(bt_private * priv, u8 type, u8 * payload, u16 nb);
+int sbi_enable_host_int(bt_private * priv);
+int sbi_disable_host_int(bt_private * priv);
+int sbi_dowload_fw(bt_private * priv);
+int sbi_get_int_status(bt_private * priv, u8 * ireg);
+int sbi_wakeup_firmware(bt_private * priv);
+int sbi_download_fw(bt_private *priv);
+#endif /* _BT_DRV_H_ */
diff --git a/drivers/net/wireless/8688_bt/bt/bt_main.c b/drivers/net/wireless/8688_bt/bt/bt_main.c
new file mode 100755
index 0000000..2ee7624
--- /dev/null
+++ b/drivers/net/wireless/8688_bt/bt/bt_main.c
@@ -0,0 +1,820 @@
+/** @file bt_main.c
+  *  
+  * @brief This file contains the major functions in BlueTooth
+  * driver. It includes init, exit, open, close and main
+  * thread etc..
+  * 
+  * (c) Copyright 2007, Marvell International Ltd. 
+  *   
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+
+#include "include.h"
+
+/** Version */
+#define VERSION "1.15"
+
+/** Bluetooth device private structure */
+bt_private *btpriv = NULL;
+/** Firmware flag */
+int fw = 1;
+
+
+#ifdef	DEBUG_LEVEL1
+u32 drvdbg = DBG_MSG | DBG_FATAL | DBG_ERROR;
+//u32 drvdbg = 0xffffffff;
+#endif
+
+/** Driver lock */
+spinlock_t driver_lock;
+/** Driver lock flags */
+ulong driver_flags;
+
+/** Disable interrupt */
+#define OS_INT_DISABLE	spin_lock_irqsave(&driver_lock, driver_flags)
+/** Enable interrupt */
+#define	OS_INT_RESTORE	spin_unlock_irqrestore(&driver_lock, driver_flags); \
+			driver_lock = SPIN_LOCK_UNLOCKED
+
+/** 
+ *  @brief This function verify the received acl loopback pkt
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param skb     A pointer to rx skb 
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_process_event(bt_private * priv, struct sk_buff *skb)
+{
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_EVENT *pEvent;
+    ENTER();
+    pEvent = (BT_EVENT *) skb->data;
+    if (pEvent->EC != 0xff) {
+        PRINTM(CMD, "Not Marvell Event=%x\n", pEvent->EC);
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    switch (pEvent->data[0]) {
+    case BT_CMD_AUTO_SLEEP_MODE:
+        if (pEvent->data[2] == BT_STATUS_SUCCESS) {
+            if (pEvent->data[1] == BT_PS_ENABLE)
+                priv->adapter->psmode = 1;
+            else
+                priv->adapter->psmode = 0;
+            PRINTM(CMD, "PS Mode:%s\n",
+                   (priv->adapter->psmode) ? "Enable" : "Disable");
+        } else
+            PRINTM(CMD, "PS Mode Cmd Fail\n");
+        break;
+    case BT_CMD_HOST_SLEEP_CONFIG:
+        if (pEvent->data[3] == BT_STATUS_SUCCESS) {
+            PRINTM(CMD, "gpio=%x,gap=%x\n", pEvent->data[1], pEvent->data[2]);
+        } else
+            PRINTM(CMD, "HSCFG Cmd Fail\n");
+        break;
+    case BT_CMD_HOST_SLEEP_ENABLE:
+        if (pEvent->data[1] == BT_STATUS_SUCCESS) {
+            priv->adapter->hs_state = HS_ACTIVATED;
+            if (priv->adapter->psmode)
+                priv->adapter->ps_state = PS_SLEEP;
+            wake_up_interruptible(&priv->adapter->cmd_wait_q);
+            PRINTM(CMD, "HS ACTIVATED!\n");
+        } else
+            PRINTM(CMD, "HS Enable Fail\n");
+        break;
+    case BT_CMD_MODULE_CFG_REQ:
+        if ((priv->bt_dev.sendcmdflag == TRUE) &&
+            ((pEvent->data[1] == MODULE_BRINGUP_REQ)
+             || (pEvent->data[1] == MODULE_SHUTDOWN_REQ))) {
+            if (pEvent->data[1] == MODULE_BRINGUP_REQ) {
+                PRINTM(CMD, "EVENT:%s\n",
+                       (pEvent->
+                        data[2]) ? "Bring up Fail" : "Bring up success");
+            }
+            if (pEvent->data[1] == MODULE_SHUTDOWN_REQ) {
+                PRINTM(CMD, "EVENT:%s\n",
+                       (pEvent->
+                        data[2]) ? "Shut down Fail" : "Shut down success");
+            }
+            priv->bt_dev.sendcmdflag = FALSE;
+            priv->adapter->cmd_complete = TRUE;
+            wake_up_interruptible(&priv->adapter->cmd_wait_q);
+        } else {
+            PRINTM(CMD, "BT_CMD_MODULE_CFG_REQ resp for APP\n");
+                ret = BT_STATUS_FAILURE;
+        }
+        break;
+    case BT_EVENT_POWER_STATE:
+        if (pEvent->data[1] == BT_PS_SLEEP)
+            priv->adapter->ps_state = PS_SLEEP;
+        PRINTM(CMD, "EVENT:%s\n",
+               (priv->adapter->ps_state) ? "PS_SLEEP" : "PS_AWAKE");
+        break;
+    default:
+        PRINTM(CMD, "Unknow Event=%d\n", pEvent->data[0]);
+        ret = BT_STATUS_FAILURE;
+        break;
+    }
+  exit:
+    if (ret == BT_STATUS_SUCCESS)
+        kfree_skb(skb);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function send module cfg cmd to firmware
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param subcmd  sub command 
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_send_module_cfg_cmd(bt_private * priv, int subcmd)
+{
+    struct sk_buff *skb = NULL;
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_CMD *pCmd;
+    ENTER();
+    skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+    if (skb == NULL) {
+        PRINTM(WARN, "No free skb\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    pCmd = (BT_CMD *) skb->tail;
+    pCmd->ocf_ogf = (OGF << 10) | BT_CMD_MODULE_CFG_REQ;
+    pCmd->length = 1;
+    pCmd->data[0] = subcmd;
+    bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+    skb_put(skb, sizeof(BT_CMD));
+    skb->dev = (void *) priv->bt_dev.hcidev;
+    skb_queue_head(&priv->adapter->tx_queue, skb);
+    priv->bt_dev.sendcmdflag = TRUE;
+    priv->adapter->cmd_complete = FALSE;
+    PRINTM(CMD, "Queue module cfg Command\n");
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    if (!os_wait_interruptible_timeout
+        (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+         WAIT_UNTIL_CMD_RESP)) {
+        ret = BT_STATUS_FAILURE;
+        PRINTM(MSG, "module_cfg_cmd(%x): timeout: %d\n", subcmd,
+               priv->bt_dev.sendcmdflag);
+    }
+    PRINTM(CMD, "module cfg Command done\n");
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function enable host sleep 
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_enable_hs(bt_private * priv)
+{
+    struct sk_buff *skb = NULL;
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_CMD *pCmd;
+    ENTER();
+    skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+    if (skb == NULL) {
+        PRINTM(WARN, "No free skb\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    pCmd = (BT_CMD *) skb->tail;
+    pCmd->ocf_ogf = (OGF << 10) | BT_CMD_HOST_SLEEP_ENABLE;
+    pCmd->length = 0;
+    bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+    skb_put(skb, sizeof(BT_CMD));
+    skb->dev = (void *) priv->bt_dev.hcidev;
+    skb_queue_head(&priv->adapter->tx_queue, skb);
+    PRINTM(CMD, "Queue hs enable Command\n");
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    if (!os_wait_interruptible_timeout
+        (priv->adapter->cmd_wait_q, priv->adapter->hs_state,
+         WAIT_UNTIL_HS_STATE_CHANGED)) {
+        ret = BT_STATUS_FAILURE;
+        PRINTM(MSG, "bt_enable_hs: timeout: %d, %d,%d\n",
+               priv->adapter->hs_state, priv->adapter->ps_state,
+               priv->adapter->WakeupTries);
+    }
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function used to send command to firmware
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return        BT_STATUS_SUCCESS
+ */
+int
+bt_prepare_command(bt_private * priv)
+{
+    struct sk_buff *skb = NULL;
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_CMD *pCmd;
+    ENTER();
+    if (priv->bt_dev.hscfgcmd) {
+        priv->bt_dev.hscfgcmd = 0;
+        skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+        if (skb == NULL) {
+            PRINTM(WARN, "No free skb\n");
+            ret = BT_STATUS_FAILURE;
+            goto exit;
+        }
+        pCmd = (BT_CMD *) skb->tail;
+        pCmd->ocf_ogf = (OGF << 10) | BT_CMD_HOST_SLEEP_CONFIG;
+        pCmd->length = 2;
+        pCmd->data[0] = (priv->bt_dev.gpio_gap & 0xff00) >> 8;
+        pCmd->data[1] = (u8) (priv->bt_dev.gpio_gap & 0x00ff);
+        bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+        skb_put(skb, sizeof(BT_CMD));
+        skb->dev = (void *) priv->bt_dev.hcidev;
+        skb_queue_head(&priv->adapter->tx_queue, skb);
+        PRINTM(CMD, "Queue HSCFG Command,gpio=%x,gap=%x\n", pCmd->data[0],
+               pCmd->data[1]);
+    }
+    if (priv->bt_dev.pscmd) {
+        priv->bt_dev.pscmd = 0;
+        skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+        if (skb == NULL) {
+            PRINTM(WARN, "No free skb\n");
+            ret = BT_STATUS_FAILURE;
+            goto exit;
+        }
+        pCmd = (BT_CMD *) skb->tail;
+        pCmd->ocf_ogf = (OGF << 10) | BT_CMD_AUTO_SLEEP_MODE;
+        pCmd->length = 1;
+        if (priv->bt_dev.psmode)
+            pCmd->data[0] = BT_PS_ENABLE;
+        else
+            pCmd->data[0] = BT_PS_DISABLE;
+        bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+        skb_put(skb, sizeof(BT_CMD));
+        skb->dev = (void *) priv->bt_dev.hcidev;
+        skb_queue_head(&priv->adapter->tx_queue, skb);
+        PRINTM(CMD, "Queue PSMODE Command:%d\n", pCmd->data[0]);
+    }
+    if (priv->bt_dev.hscmd) {
+        priv->bt_dev.hscmd = 0;
+        if (priv->bt_dev.hsmode)
+            ret = bt_enable_hs(priv);
+        else {
+            ret = sbi_wakeup_firmware(priv);
+            priv->adapter->hs_state = HS_DEACTIVATED;
+        }
+    }
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/**  @brief This function processes a single packet 
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param skb     A pointer to skb which includes TX packet
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+SendSinglePacket(bt_private * priv, struct sk_buff *skb)
+{
+    u8 ret;
+    bt_adapter *Adapter = priv->adapter;
+    ENTER();
+    if (!skb->len || ((skb->len + SDIO_HEADER_LEN) > BT_UPLD_SIZE)) {
+        PRINTM(ERROR, "Tx Error: Bad skb length %d : %d\n", skb->len,
+               BT_UPLD_SIZE);
+        return BT_STATUS_FAILURE;
+    }
+    /*  This is SDIO specific header
+     *  length: byte[3][2][1], 
+     *  type: byte[0] (HCI_COMMAND = 1, ACL_DATA = 2, SCO_DATA = 3, 0xFE = Vendor) 
+     */
+    priv->adapter->TmpTxBuf[0] = (skb->len + SDIO_HEADER_LEN) & 0xff;
+    priv->adapter->TmpTxBuf[1] = ((skb->len + SDIO_HEADER_LEN) >> 8) & 0xff;
+    priv->adapter->TmpTxBuf[2] = ((skb->len + SDIO_HEADER_LEN) >> 16) & 0xff;
+    priv->adapter->TmpTxBuf[3] = bt_cb(skb)->pkt_type;
+    memcpy(&priv->adapter->TmpTxBuf[SDIO_HEADER_LEN], skb->data, skb->len);
+    ret =
+        sbi_host_to_card(priv, MVSD_DAT, Adapter->TmpTxBuf,
+                         skb->len + SDIO_HEADER_LEN);
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function initializes the adapter structure
+ *  and set default value to the member of adapter.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   n/a
+ */
+static void
+bt_init_adapter(bt_private * priv)
+{
+    ENTER();
+    skb_queue_head_init(&priv->adapter->tx_queue);
+    priv->adapter->ps_state = PS_AWAKE;
+    init_waitqueue_head(&priv->adapter->cmd_wait_q);
+    LEAVE();
+}
+
+/** 
+ *  @brief This function initializes firmware
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+bt_init_fw(bt_private * priv)
+{
+    int ret = BT_STATUS_SUCCESS;
+    ENTER();
+    if (fw == 0) {
+        sbi_enable_host_int(priv);
+        goto done;
+    }
+    sbi_disable_host_int(priv);
+
+    if (sbi_download_fw(priv)) {
+        PRINTM(ERROR, "FW failed to be download!\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+
+    mdelay(100);
+    sbi_enable_host_int(priv);
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function frees the structure of adapter
+ *    
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   n/a
+ */
+static void
+bt_free_adapter(bt_private * priv)
+{
+    bt_adapter *Adapter = priv->adapter;
+    ENTER();
+    skb_queue_purge(&priv->adapter->tx_queue);
+    /* Free the adapter object itself */
+    kfree(Adapter);
+    priv->adapter = NULL;
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function handle the ioctl 
+ *  
+ *  @param hev     A pointer to hci_dev structure
+ *  @cmd	   ioctl cmd 
+ *  @arg	    
+ *  @return 	   -ENOIOCTLCMD
+ */
+static int
+bt_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
+{
+    ENTER();
+    LEAVE();
+    return -ENOIOCTLCMD;
+}
+
+/** 
+ *  @brief This function handle destruct 
+ *  
+ *  @param hev     A pointer to hci_dev structure
+ *  
+ *  @return 	   n/a
+ */
+static void
+bt_destruct(struct hci_dev *hdev)
+{
+    ENTER();
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function handle the transmit
+ *  
+ *  @param skb     A pointer to sk_buffer structure
+ *  
+ *  @return 	   BT_STATUS_SUCCESS or other   
+ */
+static int
+bt_send_frame(struct sk_buff *skb)
+{
+    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+    bt_private *priv = (bt_private *) hdev->driver_data;
+
+    ENTER();
+    PRINTM(INFO, "bt_send_frame: Type=%d, len=%d\n", skb->pkt_type, skb->len);
+    DBG_HEXDUMP(DBG_DATA, "bt_send_frame", skb->data, skb->len);
+    if (!hdev) {
+        PRINTM(ERROR, "Frame for unknown HCI device (hdev=NULL)\n");
+        LEAVE();
+        return -ENODEV;
+    }
+    if (!test_bit(HCI_RUNNING, &hdev->flags)) {
+        PRINTM(ERROR, "Fail test HCI_RUNING,flag=%lx\n", hdev->flags);
+        LEAVE();
+        return -EBUSY;
+    }
+    switch (bt_cb(skb)->pkt_type) {
+    case HCI_COMMAND_PKT:
+        hdev->stat.cmd_tx++;
+        break;
+    case HCI_ACLDATA_PKT:
+        hdev->stat.acl_tx++;
+        break;
+    case HCI_SCODATA_PKT:
+        hdev->stat.sco_tx++;
+        break;
+    }
+    skb_queue_tail(&priv->adapter->tx_queue, skb);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function flush the transmit queue
+ *  
+ *  @param hev     A pointer to hci_dev structure
+ *  
+ *  @return 	   BT_STATUS_SUCCESS   
+ */
+static int
+bt_flush(struct hci_dev *hdev)
+{
+    bt_private *priv = (bt_private *) hdev->driver_data;
+    ENTER();
+    skb_queue_purge(&priv->adapter->tx_queue);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function close the bluetooth device
+ *  
+ *  @param hev     A pointer to hci_dev structure
+ *  
+ *  @return 	   BT_STATUS_SUCCESS   
+ */
+static int
+bt_close(struct hci_dev *hdev)
+{
+    bt_private *priv = (bt_private *) hdev->driver_data;
+    ENTER();
+    if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags)) {
+        LEAVE();
+        return BT_STATUS_SUCCESS;
+    }
+    skb_queue_purge(&priv->adapter->tx_queue);
+    module_put(THIS_MODULE);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function open the bluetooth device
+ *  
+ *  @param hev     A pointer to hci_dev structure
+ *  
+ *  @return 	   BT_STATUS_SUCCESS  or other
+ */
+static int
+bt_open(struct hci_dev *hdev)
+{
+    ENTER();
+    if (try_module_get(THIS_MODULE) == 0)
+        return BT_STATUS_FAILURE;
+    set_bit(HCI_RUNNING, &hdev->flags);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function hanldes the major job in bluetooth driver.
+ *  it handles the event generated by firmware, rx data received
+ *  from firmware and tx data sent from kernel.
+ *  
+ *  @param data    A pointer to bt_thread structure
+ *  @return        BT_STATUS_SUCCESS
+ */
+static int
+bt_service_main_thread(void *data)
+{
+    bt_thread *thread = data;
+    bt_private *priv = thread->priv;
+    bt_adapter *Adapter = priv->adapter;
+    wait_queue_t wait;
+    u8 ireg = 0;
+    struct sk_buff *skb;
+    ENTER();
+    bt_activate_thread(thread);
+    init_waitqueue_entry(&wait, current);
+    current->flags |= PF_NOFREEZE;
+
+    for (;;) {
+        add_wait_queue(&thread->waitQ, &wait);
+        OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
+        if (priv->adapter->WakeupTries ||
+            ((!priv->adapter->IntCounter) &&
+             (!priv->bt_dev.tx_dnld_rdy ||
+              skb_queue_empty(&priv->adapter->tx_queue)))) {
+            PRINTM(INFO, "Main: Thread sleeping...\n");
+            schedule();
+        }
+        OS_SET_THREAD_STATE(TASK_RUNNING);
+        remove_wait_queue(&thread->waitQ, &wait);
+        if (kthread_should_stop() || Adapter->SurpriseRemoved) {
+            PRINTM(INFO, "main-thread: break from main thread: "
+                   "SurpriseRemoved=0x%x\n", Adapter->SurpriseRemoved);
+            break;
+        }
+
+        PRINTM(INFO, "Main: Thread waking up...\n");
+        if (priv->adapter->IntCounter) {
+		OS_INT_DISABLE;
+		Adapter->IntCounter = 0;
+		OS_INT_RESTORE;
+		//sbi_get_int_status(priv, &ireg);
+        } else if ((priv->adapter->ps_state == PS_SLEEP) &&
+                   !skb_queue_empty(&priv->adapter->tx_queue)) {
+		priv->adapter->WakeupTries++;
+		sbi_wakeup_firmware(priv);
+		continue;
+        }
+		
+        if (priv->adapter->ps_state == PS_SLEEP)
+  		continue;
+        if (priv->bt_dev.tx_dnld_rdy == TRUE) {
+            if (!skb_queue_empty(&priv->adapter->tx_queue)) {
+                skb = skb_dequeue(&priv->adapter->tx_queue);
+                if (skb) {
+                    if (SendSinglePacket(priv, skb))
+                        priv->bt_dev.hcidev->stat.err_tx++;
+                    else
+                        priv->bt_dev.hcidev->stat.byte_tx += skb->len;
+                    kfree_skb(skb);
+                }
+            }
+        }
+    }
+    bt_deactivate_thread(thread);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the interrupt. it will change PS
+ *  state if applicable. it will wake up main_thread to handle
+ *  the interrupt event as well.
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return        n/a
+ */
+void
+bt_interrupt(struct hci_dev *hdev)
+{
+    bt_private *priv = (bt_private *) hdev->driver_data;
+    ENTER();
+    priv->adapter->ps_state = PS_AWAKE;
+    priv->adapter->hs_state = HS_DEACTIVATED;
+    priv->adapter->WakeupTries = 0;
+    priv->adapter->IntCounter++;
+    /* masked by feng */
+    //wake_up_interruptible(&priv->MainThread.waitQ);
+    LEAVE();
+
+}
+
+/**
+ * @brief This function adds the card. it will probe the
+ * card, allocate the bt_priv and initialize the device. 
+ *  
+ *  @param card    A pointer to card
+ *  @return        A pointer to bt_private structure
+ */
+
+bt_private *
+bt_add_card(void *card)
+{
+    struct hci_dev *hdev = NULL;
+    bt_private *priv = NULL;
+    int ret;
+
+    ENTER();
+
+    priv = kzalloc(sizeof(bt_private), GFP_KERNEL);
+    if (!priv) {
+        PRINTM(FATAL, "Can't allocate priv\n");
+        LEAVE();
+        return NULL;
+    }
+    
+    /* allocate buffer for bt_adapter */
+    if (!(priv->adapter = kzalloc(sizeof(bt_adapter), GFP_KERNEL))) {
+        PRINTM(FATAL, "Allocate buffer for bt_adapter failed!\n");
+        goto err_kmalloc;
+    }
+
+    bt_init_adapter(priv);
+
+    /*Register to HCI Core */
+    hdev = hci_alloc_dev();
+    if (!hdev) {
+        PRINTM(FATAL, "Can't allocate HCI device\n");
+        goto err_kmalloc;
+    }
+
+    PRINTM(INFO, "Starting kthread...\n");
+    priv->MainThread.priv = priv;
+    spin_lock_init(&driver_lock);
+
+    bt_create_thread(bt_service_main_thread, &priv->MainThread,
+                     "bt_main_service");
+
+    /* wait for mainthread to up */
+    while (!priv->MainThread.pid) {
+        os_sched_timeout(1);
+    }
+    priv->bt_dev.hcidev = hdev;
+    priv->bt_dev.card = card;
+    btpriv = priv;
+    ((struct sdio_mmc_card *)card)->priv = priv;
+    /*
+     * Register the device. Fillup the private data structure with
+     * relevant information from the card and request for the required
+     * IRQ. 
+     */
+    if (sbi_register_dev(priv) < 0) {
+        PRINTM(FATAL, "Failed to register bt device!\n");
+        goto err_registerdev;
+    }
+    if (bt_init_fw(priv)) {
+        PRINTM(FATAL, "Firmware Init Failed\n");
+        goto err_init_fw;
+    }
+    priv->bt_dev.tx_dnld_rdy = TRUE;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+    hdev->type = HCI_SDIO;
+#else
+    hdev->type = HCI_PCCARD;
+#endif
+    hdev->driver_data = priv;
+
+    hdev->open = bt_open;
+    hdev->close = bt_close;
+    hdev->flush = bt_flush;
+    hdev->send = bt_send_frame;
+    hdev->destruct = bt_destruct;
+    hdev->ioctl = bt_ioctl;
+
+    hdev->owner = THIS_MODULE;
+    bt_send_module_cfg_cmd(priv, MODULE_BRINGUP_REQ);
+    ret = hci_register_dev(hdev);
+    if (ret < 0) {
+        PRINTM(FATAL, "Can't register HCI device\n");
+        goto err_init_fw;
+    }
+    bt_proc_init(priv);
+    LEAVE();
+    return priv;
+  err_init_fw:
+    sbi_unregister_dev(priv);
+  err_registerdev:
+    /* Stop the thread servicing the interrupts */
+    priv->adapter->SurpriseRemoved = TRUE;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    while (priv->MainThread.pid) {
+        os_sched_timeout(1);
+    }
+  err_kmalloc:
+    if (hdev)
+        hci_free_dev(hdev);
+    bt_free_adapter(priv);
+    kfree(priv);
+    btpriv = NULL;
+    LEAVE();
+    return NULL;
+}
+
+/** 
+ *  @brief This function removes the card.
+ *  
+ *  @param priv    A pointer to card
+ *  @return        BT_STATUS_SUCCESS
+ */
+
+int
+bt_remove_card(void *card)
+{
+    struct hci_dev *hdev;
+    bt_private *priv;
+    ENTER();
+
+    if (!btpriv) {
+        LEAVE();
+        return BT_STATUS_SUCCESS;
+    }
+    hdev = btpriv->bt_dev.hcidev;
+    priv = (bt_private *) hdev->driver_data;
+    /* Disable interrupts on the card */
+    sbi_disable_host_int(priv);
+    wake_up_interruptible(&priv->adapter->cmd_wait_q);
+    priv->adapter->SurpriseRemoved = TRUE;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    while (priv->MainThread.pid) {
+        os_sched_timeout(1);
+    }
+    bt_proc_remove(priv);
+    PRINTM(INFO, "unregester dev\n");
+    sbi_unregister_dev(priv);
+
+    /* UnRegister to HCI Core */
+    if (hci_unregister_dev(hdev) < 0)
+        PRINTM(ERROR, "Can't unregister HCI device %s\n", hdev->name);
+    hci_free_dev(hdev);
+    btpriv->bt_dev.hcidev = NULL;
+    bt_free_adapter(priv);
+    if (btpriv) {
+        kfree(btpriv);
+        btpriv = NULL;
+    }
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function initializes module.
+ *  
+ *  @param     n/a    A pointer to bt_private structure
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+bt_init_module(void)
+{
+    int ret = BT_STATUS_SUCCESS;
+    ENTER();
+    if (sbi_register() == NULL) {
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function cleans module
+ *  
+ *  @param priv    n/a
+ *  @return        n/a
+ */
+static void
+bt_exit_module(void)
+{
+    ENTER();
+    if (btpriv) {
+        bt_send_module_cfg_cmd(btpriv, MODULE_SHUTDOWN_REQ);
+    }
+    sbi_unregister();
+    LEAVE();
+}
+
+module_param(fw, int, 1);
+module_init(bt_init_module);
+module_exit(bt_exit_module);
+
+MODULE_AUTHOR("Marvell International Ltd.");
+MODULE_DESCRIPTION("Marvell Bluetooth Driver Ver " VERSION);
+MODULE_VERSION(VERSION);
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/wireless/8688_bt/bt/bt_proc.c b/drivers/net/wireless/8688_bt/bt/bt_proc.c
new file mode 100755
index 0000000..e8feee6
--- /dev/null
+++ b/drivers/net/wireless/8688_bt/bt/bt_proc.c
@@ -0,0 +1,444 @@
+/** @file bt_proc.c
+  *  
+  * @brief This file handle the functions for proc files
+  * 
+  * (c) Copyright 2007, Marvell International Ltd. 
+  *   
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+
+#include "include.h"
+struct proc_data
+{
+    /** Read length */
+    int rdlen;
+    /** Read buffer */
+    char *rdbuf;
+    /** Write length */
+    int wrlen;
+    /** Maximum write length */
+    int maxwrlen;
+    /** Write buffer */
+    char *wrbuf;
+    void (*on_close) (struct inode *, struct file *);
+};
+
+struct item_data
+{
+    /** Name */
+    char name[32];
+    /** Size */
+    u32 size;
+    /** Address */
+    u32 addr;
+    /** Offset */
+    u32 offset;
+    /** Flag */
+    u32 flag;
+};
+
+struct proc_private_data
+{
+    /** Name */
+    char name[32];
+    /** File flag */
+    u32 fileflag;
+    /** Buffer size */
+    u32 bufsize;
+    /** Number of items */
+    u32 num_items;
+    /** Item data */
+    struct item_data *pdata;
+    /** Private structure */
+    bt_private *pbt;
+    /** File operations */
+    struct file_operations *fops;
+};
+
+/** Default file permission */
+#define DEFAULT_FILE_PERM  0644
+
+/** Bluetooth device offset */
+#define OFFSET_BT_DEV		0x01
+/** Bluetooth adapter offset */
+#define OFFSET_BT_ADAPTER	0x02
+/** Show integer */
+#define SHOW_INT		0x10
+/** Show hex */
+#define SHOW_HEX		0x20
+
+/** Device size */
+#define item_dev_size(n) (sizeof ((bt_dev_t *)0)->n)
+/** Device address */
+#define item_dev_addr(n) ((u32) &((bt_dev_t *)0)->n)
+
+/** Adapter size */
+#define item_adapter_size(n) (sizeof ((bt_adapter *)0)->n)
+/** Adapter address */
+#define item_adapter_addr(n) ((u32) &((bt_adapter *)0)->n)
+static struct item_data config_items[] = {
+    {"drvdbg", sizeof(u32), (u32) & drvdbg, 0, SHOW_HEX}
+    ,
+    {"psmode", item_dev_size(psmode), 0, item_dev_addr(psmode),
+     OFFSET_BT_DEV | SHOW_INT}
+    ,
+    {"pscmd", item_dev_size(pscmd), 0, item_dev_addr(pscmd),
+     OFFSET_BT_DEV | SHOW_INT}
+    ,
+    {"hsmode", item_dev_size(hsmode), 0, item_dev_addr(hsmode),
+     OFFSET_BT_DEV | SHOW_INT}
+    ,
+    {"hscmd", item_dev_size(hscmd), 0, item_dev_addr(hscmd),
+     OFFSET_BT_DEV | SHOW_INT}
+    ,
+    {"gpio_gap", item_dev_size(gpio_gap), 0, item_dev_addr(gpio_gap),
+     OFFSET_BT_DEV | SHOW_HEX}
+    ,
+    {"hscfgcmd", item_dev_size(hscfgcmd), 0, item_dev_addr(hscfgcmd),
+     OFFSET_BT_DEV | SHOW_INT}
+    ,
+};
+
+static struct item_data status_items[] = {
+    {"tx_dnld_rdy", item_dev_size(tx_dnld_rdy), 0, item_dev_addr(tx_dnld_rdy),
+     OFFSET_BT_DEV | SHOW_INT},
+    {"psmode", item_adapter_size(psmode), 0, item_adapter_addr(psmode),
+     OFFSET_BT_ADAPTER | SHOW_INT},
+    {"hs_state", item_adapter_size(hs_state), 0, item_adapter_addr(hs_state),
+     OFFSET_BT_ADAPTER | SHOW_INT},
+    {"ps_state", item_adapter_size(ps_state), 0, item_adapter_addr(ps_state),
+     OFFSET_BT_ADAPTER | SHOW_INT},
+};
+
+/** 
+ *  @brief convert string to number
+ *
+ *  @param s   	   pointer to numbered string
+ *  @return 	   converted number from string s
+ */
+u32
+string_to_number(char *s)
+{
+    u32 r = 0;
+    u32 base = 0;
+
+    if ((strncmp(s, "0x", 2) == 0) || (strncmp(s, "0X", 2) == 0))
+        base = 16;
+    else
+        base = 10;
+    if (base == 16)
+        s += 2;
+    for (s = s; *s != 0; s++) {
+        if ((*s >= 48) && (*s <= 57))
+            r = (r * base) + (*s - 48);
+        else if ((*s >= 65) && (*s <= 70))
+            r = (r * base) + (*s - 55);
+        else if ((*s >= 97) && (*s <= 102))
+            r = (r * base) + (*s - 87);
+        else
+            break;
+    }
+    return r;
+}
+
+/** 
+ *  @brief This function handle generic proc file close
+ *  
+ *  @param inode   A pointer to inode structure
+ *  @param file    A pointer to file structure
+ *  @return 	   BT_STATUS_SUCCESS
+ */
+static int
+proc_close(struct inode *inode, struct file *file)
+{
+    struct proc_data *pdata = file->private_data;
+    ENTER();
+    if (pdata) {
+        if (pdata->on_close != NULL)
+            pdata->on_close(inode, file);
+        if (pdata->rdbuf)
+            kfree(pdata->rdbuf);
+        if (pdata->wrbuf)
+            kfree(pdata->wrbuf);
+        kfree(pdata);
+    }
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handle generic proc file read
+ *  
+ *  @param file    A pointer to file structure
+ *  @param buffer  A pointer to output buffer
+ *  @param len     number of byte to read
+ *  @param offset  A pointer to offset of file
+ *  @return 	   number of output data
+ */
+static ssize_t
+proc_read(struct file *file,
+          char __user * buffer, size_t len, loff_t * offset)
+{
+    loff_t pos = *offset;
+    struct proc_data *pdata = (struct proc_data *) file->private_data;
+    if ((!pdata->rdbuf) || (pos < 0))
+        return -EINVAL;
+    if (pos >= pdata->rdlen)
+        return 0;
+    if (len > pdata->rdlen - pos)
+        len = pdata->rdlen - pos;
+    if (copy_to_user(buffer, pdata->rdbuf + pos, len))
+        return -EFAULT;
+    *offset = pos + len;
+    return len;
+}
+
+/** 
+ *  @brief This function handle generic proc file write
+ *  
+ *  @param file    A pointer to file structure
+ *  @param buffer  A pointer to input buffer
+ *  @param len     number of byte to write
+ *  @param offset  A pointer to offset of file
+ *  @return 	   number of input data
+ */
+static ssize_t
+proc_write(struct file *file,
+           const char __user * buffer, size_t len, loff_t * offset)
+{
+    loff_t pos = *offset;
+    struct proc_data *pdata = (struct proc_data *) file->private_data;
+
+    if (!pdata->wrbuf || (pos < 0))
+        return -EINVAL;
+    if (pos >= pdata->maxwrlen)
+        return 0;
+    if (len > pdata->maxwrlen - pos)
+        len = pdata->maxwrlen - pos;
+    if (copy_from_user(pdata->wrbuf + pos, buffer, len))
+        return -EFAULT;
+    if (pos + len > pdata->wrlen)
+        pdata->wrlen = len + file->f_pos;
+    *offset = pos + len;
+    return len;
+}
+
+/** 
+ *  @brief This function handle the generic file close 
+ *  
+ *  @param inode   A pointer to inode structure
+ *  @param file    A pointer to file structure
+ *  @return 	   BT_STATUS_SUCCESS or other 
+ */
+static void
+proc_on_close(struct inode *inode, struct file *file)
+{
+    struct proc_dir_entry *entry = PDE(inode);
+    struct proc_private_data *priv = entry->data;
+    struct proc_data *pdata = file->private_data;
+    char *line;
+    int i;
+
+    if (!pdata->wrlen)
+        return;
+    line = pdata->wrbuf;
+    while (line[0]) {
+        for (i = 0; i < priv->num_items; i++) {
+            if (!strncmp
+                (line, priv->pdata[i].name, strlen(priv->pdata[i].name))) {
+                line += strlen(priv->pdata[i].name) + 1;
+                if (priv->pdata[i].size == 1)
+                    *((u8 *) priv->pdata[i].addr) =
+                        (u8) string_to_number(line);
+                else if (priv->pdata[i].size == 2)
+                    *((u16 *) priv->pdata[i].addr) =
+                        (u16) string_to_number(line);
+                else if (priv->pdata[i].size == 4)
+                    *((u32 *) priv->pdata[i].addr) =
+                        (u32) string_to_number(line);
+            }
+        }
+        while (line[0] && line[0] != '\n')
+            line++;
+        if (line[0])
+            line++;
+    }
+    if (priv->pbt->bt_dev.hscmd || priv->pbt->bt_dev.pscmd
+        || priv->pbt->bt_dev.hscfgcmd) {
+        bt_prepare_command(priv->pbt);
+        wake_up_interruptible(&priv->pbt->MainThread.waitQ);
+    }
+    return;
+}
+
+/** 
+ *  @brief This function handle the generic file open
+ *  
+ *  @param inode   A pointer to inode structure
+ *  @param file    A pointer to file structure
+ *  @return 	   BT_STATUS_SUCCESS or other 
+ */
+static int
+proc_open(struct inode *inode, struct file *file)
+{
+    struct proc_dir_entry *entry = PDE(inode);
+    struct proc_private_data *priv = entry->data;
+    struct proc_data *pdata;
+    int i;
+    char *p;
+    u32 val = 0;
+    ENTER();
+    if ((file->private_data =
+         kzalloc(sizeof(struct proc_data), GFP_KERNEL)) == NULL) {
+        PRINTM(ERROR, "Can not alloc mem for proc_data\n");
+        LEAVE();
+        return -ENOMEM;
+    }
+    pdata = (struct proc_data *) file->private_data;
+    if ((pdata->rdbuf = kmalloc(priv->bufsize, GFP_KERNEL)) == NULL) {
+        PRINTM(ERROR, "Can not alloc mem for rdbuf\n");
+        kfree(file->private_data);
+        LEAVE();
+        return -ENOMEM;
+    }
+    if (priv->fileflag == DEFAULT_FILE_PERM) {
+        if ((pdata->wrbuf = kzalloc(priv->bufsize, GFP_KERNEL)) == NULL) {
+            PRINTM(ERROR, "Can not alloc mem for wrbuf\n");
+            kfree(pdata->rdbuf);
+            kfree(file->private_data);
+            return -ENOMEM;
+        }
+        pdata->maxwrlen = priv->bufsize;
+        pdata->on_close = proc_on_close;
+    }
+    p = pdata->rdbuf;
+    for (i = 0; i < priv->num_items; i++) {
+        if (priv->pdata[i].size == 1)
+            val = *((u8 *) priv->pdata[i].addr);
+        else if (priv->pdata[i].size == 2)
+            val = *((u16 *) priv->pdata[i].addr);
+        else if (priv->pdata[i].size == 4)
+            val = *((u32 *) priv->pdata[i].addr);
+        if (priv->pdata[i].flag & SHOW_INT)
+            p += sprintf(p, "%s=%d\n", priv->pdata[i].name, val);
+        else if (priv->pdata[i].flag & SHOW_HEX)
+            p += sprintf(p, "%s=0x%x\n", priv->pdata[i].name, val);
+    }
+    pdata->rdlen = strlen(pdata->rdbuf);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+static struct file_operations proc_read_ops = {
+    .read = proc_read,
+    .open = proc_open,
+    .release = proc_close
+};
+
+static struct file_operations proc_rw_ops = {
+    .read = proc_read,
+    .write = proc_write,
+    .open = proc_open,
+    .release = proc_close
+};
+
+static struct proc_private_data proc_files[] = {
+    {"status", S_IRUGO, 1024, sizeof(status_items) / sizeof(status_items[0]),
+     &status_items[0], NULL, &proc_read_ops}
+    ,
+    {"config", DEFAULT_FILE_PERM, 512,
+     sizeof(config_items) / sizeof(config_items[0]), &config_items[0], NULL,
+     &proc_rw_ops}
+    ,
+};
+
+/** 
+ *  @brief This function init proc entry
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS
+ */
+int
+bt_proc_init(bt_private * priv)
+{
+    u8 ret = BT_STATUS_SUCCESS;
+    struct proc_dir_entry *entry;
+    int i, j;
+    ENTER();
+    if (!priv->proc_mbt) {
+        priv->proc_mbt = proc_mkdir("mbt", init_net.proc_net);
+        if (!priv->proc_mbt) {
+            PRINTM(ERROR, "Could not mkdir mbt!\n");
+            ret = BT_STATUS_FAILURE;
+            goto done;
+        }
+        priv->proc_entry =
+            proc_mkdir(priv->bt_dev.hcidev->name, priv->proc_mbt);
+        if (!priv->proc_entry) {
+            PRINTM(ERROR, "Could not mkdir %s!\n", priv->bt_dev.hcidev->name);
+            ret = BT_STATUS_FAILURE;
+            goto done;
+        }
+        for (j = 0; j < sizeof(proc_files) / sizeof(proc_files[0]); j++) {
+            for (i = 0; i < proc_files[j].num_items; i++) {
+                if (proc_files[j].pdata[i].flag & OFFSET_BT_DEV)
+                    proc_files[j].pdata[i].addr =
+                        proc_files[j].pdata[i].offset + (u32) & priv->bt_dev;
+                if (proc_files[j].pdata[i].flag & OFFSET_BT_ADAPTER)
+                    proc_files[j].pdata[i].addr =
+                        proc_files[j].pdata[i].offset + (u32) priv->adapter;
+            }
+            proc_files[j].pbt = priv;
+            entry =
+                create_proc_entry(proc_files[j].name,
+                                  S_IFREG | proc_files[j].fileflag,
+                                  priv->proc_entry);
+            if (entry) {
+                entry->data = &proc_files[j];
+                entry->owner = THIS_MODULE;
+                entry->proc_fops = proc_files[j].fops;
+            }
+        }
+    }
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief remove proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @return 	   N/A
+ */
+void
+bt_proc_remove(bt_private * priv)
+{
+    int j;
+    ENTER();
+    if (priv->proc_mbt) {
+        if (priv->proc_entry) {
+            for (j = 0; j < sizeof(proc_files) / sizeof(proc_files[0]); j++) {
+                remove_proc_entry(proc_files[j].name, priv->proc_entry);
+            }
+        }
+        remove_proc_entry(priv->bt_dev.hcidev->name, priv->proc_mbt);
+        remove_proc_entry("mbt", init_net.proc_net);
+        priv->proc_entry = NULL;
+        priv->proc_mbt = NULL;
+    }
+    LEAVE();
+    return;
+}
diff --git a/drivers/net/wireless/8688_bt/bt/bt_sdio.c b/drivers/net/wireless/8688_bt/bt/bt_sdio.c
new file mode 100755
index 0000000..ead71d5
--- /dev/null
+++ b/drivers/net/wireless/8688_bt/bt/bt_sdio.c
@@ -0,0 +1,1261 @@
+/** @file bt_sdio.c
+ *  @brief This file contains SDIO IF (interface) module
+ *  related functions.
+ * 
+ * (c) Copyright 2007, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+
+#include "include.h"
+
+/** Max retry number of CMD53 write */
+#define MAX_WRITE_IOMEM_RETRY	2
+/** Helper name */
+char *helper_name = NULL;
+/** Firmware name */
+char *fw_name = NULL;
+module_param(helper_name, charp, 0);
+module_param(fw_name, charp, 0);
+/** Default helper name */
+#define DEFAULT_HELPER_NAME "mrvl/helper_sd.bin"
+/** Default firmware name */
+#define DEFAULT_FW_NAME "mrvl/sd8688.bin"
+
+/** Function number 2 */
+#define FN2			2
+/** SD_CLASS_BT_A*/
+#define SD_CLASS_BT_A		0x02
+//#define SD_DEVICE_ID_8688_BT    0xfe03 
+
+
+extern bt_private *btpriv;
+/********************************************************
+		Global Variables
+********************************************************/
+
+/** 
+ *  @brief This function get rx_unit value
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sd_get_rx_unit(bt_private * priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+	u8 reg;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+	ENTER();
+	reg = sdio_readb(card->func, CARD_RX_UNIT_REG, &ret);
+	if (ret == BT_STATUS_SUCCESS)
+		priv->bt_dev.rx_unit = reg;
+	LEAVE();
+	return ret;
+}
+
+/** 
+ *  @brief This function reads fwstatus registers
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param dat	   A pointer to keep returned data
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_read_firmware_status(bt_private * priv, u16 * dat)
+{
+	int ret = BT_STATUS_SUCCESS;
+	u8 fws0;
+	u8 fws1;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+	umd_enter();
+	ENTER();
+	fws0 = sdio_readb(card->func, CARD_FW_STATUS0_REG, &ret);
+	if (ret < 0)
+		return BT_STATUS_FAILURE;
+
+	fws1 = sdio_readb(card->func, CARD_FW_STATUS1_REG, &ret);
+	if (ret < 0)
+		return BT_STATUS_FAILURE;
+
+	*dat = (((u16) fws1) << 8) | fws0;
+
+	LEAVE();
+	umd_exit();
+	return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function reads rx length
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param dat	   A pointer to keep returned data
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_read_rx_len(bt_private * priv, u16 * dat)
+{
+	int ret = BT_STATUS_SUCCESS;
+	u8 reg;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+	ENTER()
+		
+	reg = sdio_readb(card->func, CARD_RX_LEN_REG, &ret);
+	if (ret == BT_STATUS_SUCCESS) {
+		*dat = (u16) reg << priv->bt_dev.rx_unit;
+	}
+	
+	LEAVE();
+	return ret;
+}
+
+/** 
+ *  @brief This function enables the host interrupts mask
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param mask	   the interrupt mask
+ *  @return 	   BT_STATUS_SUCCESS
+ */
+static int
+sd_enable_host_int_mask(bt_private * priv, u8 mask)
+{
+	int ret = BT_STATUS_SUCCESS;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+	ENTER();
+
+	sdio_writeb(card->func, mask, HOST_INT_MASK_REG, &ret);
+	if (ret) {
+		PRINTM(WARN, "Unable to enable the host interrupt!\n");
+		ret = BT_STATUS_FAILURE;
+	}
+	
+	LEAVE();
+	return ret;
+}
+
+/**  @brief This function disables the host interrupts mask.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param mask	   the interrupt mask
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_disable_host_int_mask(bt_private * priv, u8 mask)
+{
+	int ret = BT_STATUS_FAILURE;
+	u8 host_int_mask;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+	ENTER();
+	
+	/* Read back the host_int_mask register */
+	host_int_mask = sdio_readb(card->func, HOST_INT_MASK_REG, &ret);
+	if (ret) {
+		goto done;
+	}
+
+	/* Update with the mask and write back to the register */
+	host_int_mask &= ~mask;
+	sdio_writeb(card->func, host_int_mask, HOST_INT_MASK_REG, &ret);
+	if (ret < 0) {
+		PRINTM(WARN, "Unable to diable the host interrupt!\n");
+		goto done;
+	}
+	ret = BT_STATUS_SUCCESS;
+	
+done:
+	LEAVE();
+	return ret;
+}
+
+/** 
+ *  @brief This function polls the card status register.
+ *  
+ *  @param priv    	A pointer to bt_private structure
+ *  @param fn   	function number
+ *  @param bits    	the bit mask
+ *  @return 	   	BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_poll_card_status(bt_private * priv, u8 bits)
+{
+	int tries;
+	int rval;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+	u8 cs;
+	ENTER();
+	
+	for (tries = 0; tries < MAX_POLL_TRIES * 1000; tries++) {
+		cs = sdio_readb(card->func, CARD_STATUS_REG, &rval);
+		if (rval != 0)
+	    		break;
+		if (rval == 0 && (cs & bits) == bits) {
+	    		LEAVE();
+	    		return BT_STATUS_SUCCESS;
+		}
+		udelay(1);
+	}
+	
+	PRINTM(WARN, "mv_sdio_poll_card_status: FAILED!:%d\n", rval);
+	LEAVE();
+	return BT_STATUS_FAILURE;
+}
+
+/** 
+ *  @brief This function probe the card
+ *  
+ *  @param dev     A pointer to structure _sd_device
+ *  @param id	   A pointer to structure sd_device_id	
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_probe_card(struct sdio_func *func, const struct sdio_device_id *id)
+{
+	int ret = BT_STATUS_SUCCESS;
+	bt_private *priv = NULL;
+	struct sdio_mmc_card *card = NULL;
+	ENTER();
+	
+	PRINTM(INFO, "vendor=%x,device=%x,class=%d,fn=%d\n", id->vendor,
+		id->device, id->class, func->num);
+	umd_dbg("vendor=%x,device=%x,class=%d,fn=%d\n", id->vendor,
+		id->device, id->class, func->num);
+	card = kzalloc(sizeof(struct sdio_mmc_card), GFP_KERNEL);
+	if (!card) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	card->func = func;
+	priv = bt_add_card(card);
+	if (!priv) {
+		ret = BT_STATUS_FAILURE;
+		kfree(card);
+	}
+	card->priv = priv;
+done:
+	LEAVE();
+	return ret;
+}
+
+/** 
+ *  @brief This function checks if the firmware is ready to accept
+ *  command or not.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param pollnum  number of times to polling fw status 
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sd_verify_fw_download(bt_private * priv, int pollnum)
+{
+	int ret = BT_STATUS_FAILURE;
+	u16 firmwarestat;
+	int tries;
+
+	ENTER();
+	/* Wait for firmware initialization event */
+	for (tries = 0; tries < pollnum; tries++) {
+		if (sd_read_firmware_status(priv, &firmwarestat) < 0)
+	    		continue;
+		if (firmwarestat == FIRMWARE_READY) {
+	    		ret = BT_STATUS_SUCCESS;
+	    		break;
+		} else {
+	    		mdelay(10);
+	    		ret = BT_STATUS_FAILURE;
+		}
+	}
+	
+	if (ret < 0) {
+		PRINTM(ERROR, "Timeout waiting for FW to become active\n");
+		umd_dbg("Timeout waiting for FW to become active\n");
+		goto done;
+	}
+	ret = BT_STATUS_SUCCESS;
+	
+done:
+	LEAVE();
+	return ret;
+}
+
+/** 
+ *  @brief This function programs the firmware image.
+ *  
+ *  @param priv    	A pointer to bt_private structure
+ *  @return 	   	BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sd_dowload_helper(bt_private * priv)
+{
+    struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+    const struct firmware *fw_helper = NULL;
+    u8 *helper = NULL;
+    int helperlen;
+    int ret = BT_STATUS_SUCCESS;
+    void *tmphlprbuf = NULL;
+    int tmphlprbufsz;
+    u8 *hlprbuf;
+    int hlprblknow;
+    u32 tx_len;
+#ifdef FW_DOWNLOAD_SPEED
+    u32 tv1, tv2;
+#endif
+    ENTER();
+	
+    if ((ret =
+         request_firmware(&fw_helper, helper_name,
+                          priv->hotplug_device)) < 0) {
+        PRINTM(FATAL,
+               "request_firmware() failed (helper), error code = %#x\n", ret);
+        goto done;
+    }
+
+    if (fw_helper) {
+        helper = fw_helper->data;
+        helperlen = fw_helper->size;
+    } else {
+        PRINTM(MSG, "No helper image found! Terminating download.\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+
+    PRINTM(INFO, "Downloading helper image (%d bytes), block size %d bytes\n",
+           helperlen, SD_BLOCK_SIZE_FW_DL);
+
+#ifdef FW_DOWNLOAD_SPEED
+    tv1 = get_utimeofday();
+#endif
+
+    tmphlprbufsz = BT_UPLD_SIZE;
+    tmphlprbuf = kmalloc(tmphlprbufsz, GFP_KERNEL);
+    if (!tmphlprbuf) {
+        PRINTM(ERROR,
+               "Unable to allocate buffer for helper. Terminating download\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+    memset(tmphlprbuf, 0, tmphlprbufsz);
+
+    hlprbuf = (u8 *) tmphlprbuf;
+
+    /* Perform helper data transfer */
+    tx_len =
+        (FIRMWARE_TRANSFER_NBLOCK * SD_BLOCK_SIZE_FW_DL) - SDIO_HEADER_LEN;
+    hlprblknow = 0;
+    do {
+        /* The host polls for the DN_LD_CARD_RDY and CARD_IO_READY bits */
+        ret = sd_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+        if (ret < 0) {
+            PRINTM(FATAL, "Helper download poll status timeout @ %d\n",
+                   hlprblknow);
+            goto done;
+        }
+
+        /* More data? */
+        if (hlprblknow >= helperlen)
+            break;
+
+        /* Set blocksize to transfer - checking for last block */
+        if (helperlen - hlprblknow < tx_len)
+            tx_len = helperlen - hlprblknow;
+
+        hlprbuf[0] = ((tx_len & 0x000000ff) >> 0);      /* Little-endian */
+        hlprbuf[1] = ((tx_len & 0x0000ff00) >> 8);
+        hlprbuf[2] = ((tx_len & 0x00ff0000) >> 16);
+        hlprbuf[3] = ((tx_len & 0xff000000) >> 24);
+
+        /* Copy payload to buffer */
+        memcpy(&hlprbuf[SDIO_HEADER_LEN], &helper[hlprblknow], tx_len);
+
+        PRINTM(INFO, ".");
+
+        /* Send data */
+        ret = sdio_writesb(card->func, priv->bt_dev.ioport,
+                           hlprbuf,
+                           FIRMWARE_TRANSFER_NBLOCK * SD_BLOCK_SIZE_FW_DL);
+
+        if (ret < 0) {
+            PRINTM(FATAL, "IO error during helper download @ %d\n",
+                   hlprblknow);
+            goto done;
+        }
+
+        hlprblknow += tx_len;
+    } while (TRUE);
+
+#ifdef FW_DOWNLOAD_SPEED
+    tv2 = get_utimeofday();
+    PRINTM(INFO, "helper: %ld.%03ld.%03ld ", tv1 / 1000000,
+           (tv1 % 1000000) / 1000, tv1 % 1000);
+    PRINTM(INFO, " -> %ld.%03ld.%03ld ", tv2 / 1000000,
+           (tv2 % 1000000) / 1000, tv2 % 1000);
+    tv2 -= tv1;
+    PRINTM(INFO, " == %ld.%03ld.%03ld\n", tv2 / 1000000,
+           (tv2 % 1000000) / 1000, tv2 % 1000);
+#endif
+
+    /* Write last EOF data */
+    PRINTM(INFO, "\nTransferring helper image EOF block\n");
+    memset(hlprbuf, 0x0, SD_BLOCK_SIZE_FW_DL);
+
+    ret =
+        sdio_writesb(card->func, priv->bt_dev.ioport, hlprbuf,
+                     SD_BLOCK_SIZE_FW_DL);
+
+    if (ret < 0) {
+        PRINTM(FATAL, "IO error in writing helper image EOF block\n");
+        goto done;
+    }
+
+    ret = BT_STATUS_SUCCESS;
+
+  done:
+    if (tmphlprbuf)
+        kfree(tmphlprbuf);
+    if (fw_helper)
+        release_firmware(fw_helper);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function downloads firmware image to the card.
+ *  
+ *  @param priv    	A pointer to bt_private structure
+ *  @return 	   	BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sd_download_firmware_w_helper(bt_private * priv)
+{
+    struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+    const struct firmware *fw_firmware = NULL;
+    u8 *firmware = NULL;
+    int firmwarelen;
+    u8 base0;
+    u8 base1;
+    int ret = BT_STATUS_SUCCESS;
+    int offset;
+    void *tmpfwbuf = NULL;
+    int tmpfwbufsz;
+    u8 *fwbuf;
+    u16 len;
+    int txlen = 0;
+    int tx_blocks = 0;
+    int i = 0;
+    int tries = 0;
+#ifdef FW_DOWNLOAD_SPEED
+    u32 tv1, tv2;
+#endif
+
+    ENTER();
+    if ((ret =
+         request_firmware(&fw_firmware, fw_name, priv->hotplug_device)) < 0) {
+        PRINTM(FATAL, "request_firmware() failed, error code = %#x\n", ret);
+        goto done;
+    }
+
+    if (fw_firmware) {
+        firmware = fw_firmware->data;
+        firmwarelen = fw_firmware->size;
+    } else {
+        PRINTM(MSG, "No firmware image found! Terminating download.\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+
+    PRINTM(INFO, "Downloading FW image (%d bytes)\n", firmwarelen);
+
+#ifdef FW_DOWNLOAD_SPEED
+    tv1 = get_utimeofday();
+#endif
+
+    tmpfwbufsz = BT_UPLD_SIZE;
+    tmpfwbuf = kmalloc(tmpfwbufsz, GFP_KERNEL);
+    if (!tmpfwbuf) {
+        PRINTM(ERROR,
+               "Unable to allocate buffer for firmware. Terminating download.\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+    memset(tmpfwbuf, 0, tmpfwbufsz);
+
+    fwbuf = (u8 *) tmpfwbuf;
+
+    /* Perform firmware data transfer */
+    offset = 0;
+    do {
+        /* The host polls for the DN_LD_CARD_RDY and CARD_IO_READY bits */
+        ret = sd_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+        if (ret < 0) {
+            PRINTM(FATAL,
+                   "FW download with helper poll status timeout @ %d\n",
+                   offset);
+            goto done;
+        }
+
+        /* More data? */
+        if (offset >= firmwarelen)
+            break;
+
+        for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
+            base0 = sdio_readb(card->func, SQ_READ_BASE_ADDRESS_A0_REG, &ret);
+            if (ret) {
+                PRINTM(WARN, "Dev BASE0 register read failed:"
+                       " base0=0x%04X(%d). Terminating download.\n", base0,
+                       base0);
+                ret = BT_STATUS_FAILURE;
+                goto done;
+            }
+            base1 = sdio_readb(card->func, SQ_READ_BASE_ADDRESS_A1_REG, &ret);
+            if (ret) {
+                PRINTM(WARN, "Dev BASE1 register read failed:"
+                       " base1=0x%04X(%d). Terminating download.\n", base1,
+                       base1);
+                ret = BT_STATUS_FAILURE;
+                goto done;
+            }
+            len = (((u16) base1) << 8) | base0;
+
+            if (len != 0)
+                break;
+            udelay(10);
+        }
+
+        if (len == 0)
+            break;
+        else if (len > BT_UPLD_SIZE) {
+            PRINTM(FATAL, "FW download failure @ %d, invalid length %d\n",
+                   offset, len);
+            ret = BT_STATUS_FAILURE;
+            goto done;
+        }
+
+        txlen = len;
+
+        if (len & B_BIT_0) {
+            i++;
+            if (i > MAX_WRITE_IOMEM_RETRY) {
+                PRINTM(FATAL,
+                       "FW download failure @ %d, over max retry count\n",
+                       offset);
+                ret = BT_STATUS_FAILURE;
+                goto done;
+            }
+            PRINTM(ERROR, "FW CRC error indicated by the helper:"
+                   " len = 0x%04X, txlen = %d\n", len, txlen);
+            len &= ~B_BIT_0;
+            /* Setting this to 0 to resend from same offset */
+            txlen = 0;
+        } else
+            i = 0;
+
+        /* Set blocksize to transfer - checking for last block */
+        if (firmwarelen - offset < txlen) {
+            txlen = firmwarelen - offset;
+        }
+        PRINTM(INFO, ".");
+
+        tx_blocks = (txlen + SD_BLOCK_SIZE_FW_DL - 1) / SD_BLOCK_SIZE_FW_DL;
+
+        /* Copy payload to buffer */
+        memcpy(fwbuf, &firmware[offset], txlen);
+
+        /* Send data */
+        ret =
+            sdio_writesb(card->func, priv->bt_dev.ioport, fwbuf,
+                         tx_blocks * SD_BLOCK_SIZE_FW_DL);
+
+        if (ret < 0) {
+            PRINTM(ERROR, "FW download, write iomem (%d) failed @ %d\n", i,
+                   offset);
+            sdio_writeb(card->func, 0x04, CONFIGURATION_REG, &ret);
+            if (ret) {
+                PRINTM(ERROR, "write ioreg failed (CFG)\n");
+            }
+        }
+
+        offset += txlen;
+    } while (TRUE);
+
+    PRINTM(INFO, "\nFW download over, size %d bytes\n", firmwarelen);
+
+    ret = BT_STATUS_SUCCESS;
+  done:
+#ifdef FW_DOWNLOAD_SPEED
+    tv2 = get_utimeofday();
+    PRINTM(INFO, "FW: %ld.%03ld.%03ld ", tv1 / 1000000,
+           (tv1 % 1000000) / 1000, tv1 % 1000);
+    PRINTM(INFO, " -> %ld.%03ld.%03ld ", tv2 / 1000000,
+           (tv2 % 1000000) / 1000, tv2 % 1000);
+    tv2 -= tv1;
+    PRINTM(INFO, " == %ld.%03ld.%03ld\n", tv2 / 1000000,
+           (tv2 % 1000000) / 1000, tv2 % 1000);
+#endif
+    if (tmpfwbuf)
+        kfree(tmpfwbuf);
+    if (fw_firmware)
+        release_firmware(fw_firmware);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function reads data from the card.
+ *  
+ *  @param priv    	A pointer to bt_private structure
+ *  @return 	   	BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_card_to_host(bt_private * priv)
+{
+    int ret = BT_STATUS_SUCCESS;
+    u16 buf_len = 0;
+    int buf_block_len;
+    int blksz;
+    struct sk_buff *skb = NULL;
+    u32 type;
+    u8 *payload = NULL;
+    struct hci_dev *hdev = priv->bt_dev.hcidev;
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    ENTER();
+    if (!card || !card->func) {
+        PRINTM(ERROR, "card or function is NULL!\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+
+    /* Read the length of data to be transferred */
+    ret = sd_read_rx_len(priv, &buf_len);
+    if (ret < 0) {
+        PRINTM(ERROR, "card_to_host, read scratch reg failed\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+
+    /* Allocate buffer */
+    blksz = SD_BLOCK_SIZE;
+    buf_block_len = (buf_len + blksz - 1) / blksz;
+    if (buf_len <= SDIO_HEADER_LEN ||
+        (buf_block_len * blksz) > ALLOC_BUF_SIZE) {
+        PRINTM(ERROR, "card_to_host, invalid packet length: %d\n", buf_len);
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    skb = bt_skb_alloc(buf_block_len * blksz, GFP_ATOMIC);
+    if (skb == NULL) {
+        PRINTM(WARN, "No free skb\n");
+        goto exit;
+    }
+    payload = skb->tail;
+    ret = sdio_readsb(card->func, payload, priv->bt_dev.ioport,
+                      buf_block_len * blksz);
+    if (ret < 0) {
+        PRINTM(ERROR, "card_to_host, read iomem failed: %d\n", ret);
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    DBG_HEXDUMP(DBG_DATA, "SDIO Blk Rd", payload, blksz * buf_block_len);
+    /*  This is SDIO specific header
+     *  length: byte[2][1][0], 
+     *  type: byte[3] (HCI_COMMAND = 1, ACL_DATA = 2, SCO_DATA = 3, 0xFE = Vendor) 
+     */
+    buf_len = payload[0];
+    buf_len |= (u16) payload[1] << 8;
+    type = payload[3];
+    switch (type) {
+    case HCI_ACLDATA_PKT:
+    case HCI_SCODATA_PKT:
+    case HCI_EVENT_PKT:
+        bt_cb(skb)->pkt_type = type;
+        skb->dev = (void *) hdev;
+        skb_put(skb, buf_len);
+        skb_pull(skb, SDIO_HEADER_LEN);
+        hci_recv_frame(skb);
+        hdev->stat.byte_rx += buf_len;
+        break;
+    case MRVL_VENDOR_PKT:
+        bt_cb(skb)->pkt_type = HCI_VENDOR_PKT;
+        skb->dev = (void *) hdev;
+        skb_put(skb, buf_len);
+        skb_pull(skb, SDIO_HEADER_LEN);
+        if (BT_STATUS_SUCCESS != bt_process_event(priv, skb))
+            hci_recv_frame(skb);
+        hdev->stat.byte_rx += buf_len;
+        break;
+    default:
+        /* Driver specified event and command resp should be handle here */
+        PRINTM(INFO, "Unknow PKT type:%d\n", type);
+        kfree_skb(skb);
+        skb = NULL;
+        break;
+    }
+  exit:
+    if (ret) {
+        hdev->stat.err_rx++;
+        if (skb)
+            kfree_skb(skb);
+    }
+    LEAVE();
+    return ret;
+}
+
+#ifdef CONFIG_PM
+/** 
+ *  @brief This function handle the suspend fuction
+ *  
+ *  @param dev    A pointer to _sd_device structure
+ *  @return	   BT_STATUS_SUCCESS
+ */
+int
+sd_suspend(struct sdio_func *func)
+{
+    struct hci_dev *hcidev;
+    ENTER();
+    if (!btpriv) {
+        LEAVE();
+        return BT_STATUS_SUCCESS;
+    }
+    if (btpriv->adapter->hs_state != HS_ACTIVATED) {
+        if (BT_STATUS_SUCCESS != bt_enable_hs(btpriv)) {
+            LEAVE();
+            return BT_STATUS_FAILURE;
+        }
+    }
+    hcidev = btpriv->bt_dev.hcidev;
+    hci_suspend_dev(hcidev);
+    skb_queue_purge(&btpriv->adapter->tx_queue);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handle the resume fuction
+ *  
+ *  @param dev    A pointer to _sd_device structure
+ *  @return	  BT_STATUS_SUCCESS
+ */
+int
+sd_resume(struct sdio_func *func)
+{
+    struct hci_dev *hcidev;
+    ENTER();
+    if (!btpriv) {
+        LEAVE();
+        return BT_STATUS_SUCCESS;
+    }
+    hcidev = btpriv->bt_dev.hcidev;
+    hci_resume_dev(hcidev);
+    //if (is_bt_the_wakeup_src()){
+    {
+        PRINTM(MSG, "WAKEUP SRC: BT\n");
+        if ((btpriv->bt_dev.gpio_gap & 0x00ff) == 0xff) {
+            sbi_wakeup_firmware(btpriv);
+            btpriv->adapter->hs_state = HS_DEACTIVATED;
+        }
+    }
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+#endif
+
+/** 
+ *  @brief This function removes the card
+ *  
+ *  @param card    A pointer to the card
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static void
+sd_remove_card(struct sdio_func *func)
+{
+	struct sdio_mmc_card *card;
+	ENTER();
+	if (func) {
+		card = sdio_get_drvdata(func);
+		if (card) {
+	    		bt_remove_card(card);
+	    		kfree(card);
+		}
+	}
+	LEAVE();
+}
+
+/** 
+ *  @brief This function handles the interrupt.
+ *  
+ *  @param irq 	   The irq of device.
+ *  @param dev_id  A pointer to net_device structure
+ *  @param fp	   A pointer to pt_regs structure
+ *  @return 	   n/a
+ */
+static void
+sd_interrupt(struct sdio_func *func)
+{
+    bt_private *priv;
+    struct hci_dev *hcidev;
+    struct sdio_mmc_card *card;
+    u8 ireg = 0;
+    ENTER();
+    
+    card = sdio_get_drvdata(func);
+    if (card && card->priv) {
+        priv = card->priv;
+        hcidev = priv->bt_dev.hcidev;
+	bt_interrupt(hcidev);
+	if (sbi_get_int_status(priv, &ireg)) {
+            PRINTM(ERROR, "%s: reading HOST_INT_STATUS_REG failed\n",
+                   __FUNCTION__);
+        } else
+            PRINTM(INFO, "%s: HOST_INT_STATUS_REG %#x\n", __FUNCTION__, ireg);
+        wake_up_interruptible(&priv->MainThread.waitQ);
+    }
+    else {
+	//umd_dbg("card = 0x%08x, priv = 0x%08x", card, card->priv);
+	//umd_dbg("get a interrupt without a card to handle it");
+	}
+
+    LEAVE();
+}
+
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+static const struct sdio_device_id bt_ids[] = {
+//      { SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SD_DEVICE_ID_8688_BT) },
+    {SDIO_DEVICE_CLASS(SD_CLASS_BT_A)},
+    {}
+};
+
+MODULE_DEVICE_TABLE(sdio, bt_ids);
+
+static struct sdio_driver sdio_bt = {
+    .name = "bt_sdio",
+    .id_table = bt_ids,
+    .probe = sd_probe_card,
+    .remove = sd_remove_card,
+//ifdef CONFIG_PM
+//      .suspend        = sd_suspend,
+//      .resume         = sd_resume, 
+//#endif
+};
+
+/** 
+ *  @brief This function registers the bt module in bus driver.
+ *  
+ *  @return	   An int pointer that keeps returned value
+ */
+int *
+sbi_register(void)
+{
+    int *ret;
+    ENTER();
+    if (sdio_register_driver(&sdio_bt) != 0) {
+        PRINTM(FATAL, "SD Driver Registration Failed \n");
+        return NULL;
+    } else
+        ret = (int *) 1;
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function de-registers the bt module in bus driver.
+ *  
+ *  @return 	   n/a
+ */
+void
+sbi_unregister(void)
+{
+    ENTER();
+    sdio_unregister_driver(&sdio_bt);
+    LEAVE();
+}
+
+/** 
+ *  @brief This function registers the device.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_register_dev(bt_private * priv)
+{
+    int ret = BT_STATUS_SUCCESS;
+    u8 reg;
+    u8 chiprev;
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    struct sdio_func *func;
+    ENTER();
+    if (!card || !card->func) {
+        PRINTM(ERROR, "Error: card or function is NULL!\n");
+        goto failed;
+    }
+    func = card->func;
+    priv->hotplug_device = &func->dev;
+    if (helper_name == NULL) {
+        helper_name = DEFAULT_HELPER_NAME;
+    }
+    if (fw_name == NULL) {
+        fw_name = DEFAULT_FW_NAME;
+    }
+    /* Initialize the private structure */
+    strncpy(priv->bt_dev.name, "bt_sdio0", sizeof(priv->bt_dev.name));
+    priv->bt_dev.ioport = 0;
+    priv->bt_dev.fn = func->num;
+
+    sdio_claim_host(func);
+    ret = sdio_enable_func(func);
+    if (ret) {
+        PRINTM(FATAL, "sdio_enable_func() failed: ret=%d\n", ret);
+        goto release_host;
+    }
+
+    ret = sdio_claim_irq(func, sd_interrupt);
+    if (ret) {
+        PRINTM(FATAL, "sdio_claim_irq failed: ret=%d\n", ret);
+        goto disable_func;
+    }
+
+    ret = sdio_set_block_size(card->func, SD_BLOCK_SIZE);
+    if (ret) {
+        PRINTM(FATAL, "%s: cannot set SDIO block size\n", __FUNCTION__);
+        goto release_irq;
+    }
+
+    /* read Revision Register to get the chip revision number */
+    chiprev = sdio_readb(func, CARD_REVISION_REG, &ret);
+    if (ret) {
+        PRINTM(FATAL, "cannot read CARD_REVISION_REG\n");
+        goto release_irq;
+    }
+    priv->adapter->chip_rev = chiprev;
+    PRINTM(INFO, "revision=%#x\n", chiprev);
+    umd_dbg("revision=%#x\n", chiprev);
+
+    /* Read the IO port */
+    reg = sdio_readb(func, IO_PORT_0_REG, &ret);
+    if (ret < 0)
+        goto release_irq;
+    else
+        priv->bt_dev.ioport |= reg;
+
+    reg = sdio_readb(func, IO_PORT_1_REG, &ret);
+    if (ret < 0)
+        goto release_irq;
+    else
+        priv->bt_dev.ioport |= (reg << 8);
+
+    reg = sdio_readb(func, IO_PORT_2_REG, &ret);
+    if (ret < 0)
+        goto release_irq;
+    else
+        priv->bt_dev.ioport |= (reg << 16);
+
+    umd_dbg("SDIO FUNC%d IO port: 0x%x\n", priv->bt_dev.fn,
+           priv->bt_dev.ioport);
+    PRINTM(INFO, "SDIO FUNC%d IO port: 0x%x\n", priv->bt_dev.fn,
+           priv->bt_dev.ioport);
+    sdio_set_drvdata(func, card);
+    sdio_release_host(func);
+    return BT_STATUS_SUCCESS;
+  release_irq:
+    sdio_release_irq(func);
+  disable_func:
+    sdio_disable_func(func);
+  release_host:
+    sdio_release_host(func);
+  failed:
+    return BT_STATUS_FAILURE;
+}
+
+/** 
+ *  @brief This function de-registers the device.
+ *  
+ *  @param priv    A pointer to  bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS
+ */
+int
+sbi_unregister_dev(bt_private * priv)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    ENTER();
+    if (card && card->func) {
+        sdio_claim_host(card->func);
+        sdio_release_irq(card->func);
+        sdio_disable_func(card->func);
+        sdio_release_host(card->func);
+        sdio_set_drvdata(card->func, NULL);
+    }
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function enables the host interrupts.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS
+ */
+int
+sbi_enable_host_int(bt_private * priv)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    int ret;
+    ENTER();
+
+    if (!card || !card->func) {
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+    sdio_claim_host(card->func);
+    ret = sd_enable_host_int_mask(priv, HIM_ENABLE);
+    sd_get_rx_unit(priv);
+    sdio_release_host(card->func);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function disables the host interrupts.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_disable_host_int(bt_private * priv)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    int ret;
+    ENTER();
+    if (!card || !card->func) {
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+    sdio_claim_host(card->func);
+    ret = sd_disable_host_int_mask(priv, HIM_DISABLE);
+    sdio_release_host(card->func);
+    LEAVE();
+    return ret;
+}
+
+/**  
+ *  @brief This function sends data to the card.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param type	   data or command
+ *  @param payload A pointer to the data/cmd buffer
+ *  @param nb	   the length of data/cmd
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_host_to_card(bt_private * priv, u8 type, u8 * payload, u16 nb)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    int ret = BT_STATUS_SUCCESS;
+    int buf_block_len;
+    int blksz;
+    int i = 0;
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "card or function is NULL!\n");
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+
+    /* Allocate buffer and copy payload */
+    blksz = SD_BLOCK_SIZE;
+    buf_block_len = (nb + blksz - 1) / blksz;
+    sdio_claim_host(card->func);
+#define MAX_WRITE_IOMEM_RETRY	2
+    do {
+        /* Transfer data to card */
+        ret =
+            sdio_writesb(card->func, priv->bt_dev.ioport,
+                         priv->adapter->TmpTxBuf, buf_block_len * blksz);
+        if (ret < 0) {
+            i++;
+            PRINTM(ERROR, "host_to_card, write iomem (%d) failed: %d\n", i,
+                   ret);
+            ret = BT_STATUS_FAILURE;
+            if (i > MAX_WRITE_IOMEM_RETRY)
+                goto exit;
+        } else {
+            DBG_HEXDUMP(DBG_DATA, "SDIO Blk Wr", priv->adapter->TmpTxBuf,
+                        blksz * buf_block_len);
+        }
+    } while (ret == BT_STATUS_FAILURE);
+    priv->bt_dev.tx_dnld_rdy = FALSE;
+  exit:
+    sdio_release_host(card->func);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function initializes firmware
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_download_fw(bt_private * priv)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    int ret = BT_STATUS_SUCCESS;
+
+    ENTER();
+
+    umd_dbg("helper = %s, fw = %s", helper_name, fw_name); 
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "card or function is NULL!\n");
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+
+    sdio_claim_host(card->func);
+
+    if (BT_STATUS_SUCCESS == sd_verify_fw_download(priv, 1)) {
+        PRINTM(INFO, "Firmware already downloaded!\n");
+        goto done;
+    }
+
+	umd_dbg("2222");
+
+
+    if (priv->bt_dev.fn == FN2) {
+        ret = BT_STATUS_FAILURE;
+        PRINTM(INFO, "Firmware is not ready (FN2)!\n");
+        umd_dbg("Firmware is not ready (FN2)!\n");
+        //goto done;
+    }
+
+	umd_dbg("Will download helper");
+
+    /* Download the helper */
+    ret = sd_dowload_helper(priv);
+    if (ret) {
+        PRINTM(INFO, "Fail to download helper!\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+
+	umd_dbg("Will download main FW");
+
+    /* Download the main firmware via the helper firmware */
+    if (sd_download_firmware_w_helper(priv)) {
+        PRINTM(INFO, "Bluetooth FW download failed!\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* check if the fimware is downloaded successfully or not */
+    if (sd_verify_fw_download(priv, MAX_FIRMWARE_POLL_TRIES)) {
+        PRINTM(INFO, "FW failed to be active in time!\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+
+  done:
+    sdio_release_host(card->func);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function checks the interrupt status and handle it accordingly.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param ireg    A pointer to variable that keeps returned value
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_get_int_status(bt_private * priv, u8 * ireg)
+{
+    int ret = BT_STATUS_SUCCESS;
+    u8 sdio_ireg = 0;
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    ENTER();
+    *ireg = 0;
+    sdio_ireg = sdio_readb(card->func, HOST_INTSTATUS_REG, &ret);
+    if (ret) {
+        PRINTM(WARN, "sdio_read_ioreg: read int status register failed\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+    if (sdio_ireg) {
+        /*
+         * DN_LD_HOST_INT_STATUS and/or UP_LD_HOST_INT_STATUS
+         * Clear the interrupt status register and re-enable the interrupt
+         */
+        PRINTM(INFO, "sdio_ireg = 0x%x\n", sdio_ireg);
+        sdio_writeb(card->func, ~(sdio_ireg) & (DN_LD_HOST_INT_STATUS |
+                                                UP_LD_HOST_INT_STATUS),
+                    HOST_INTSTATUS_REG, &ret);
+
+        if (ret) {
+            PRINTM(WARN,
+                   "sdio_write_ioreg: clear int status register failed\n");
+            ret = BT_STATUS_FAILURE;
+            goto done;
+        }
+    }
+
+    if (sdio_ireg & DN_LD_HOST_INT_STATUS) {    /* tx_done INT */
+        if (priv->bt_dev.tx_dnld_rdy) { /* tx_done already received */
+            PRINTM(INFO,
+                   "warning: tx_done already received: tx_dnld_rdy=0x%x int status=0x%x\n",
+                   priv->bt_dev.tx_dnld_rdy, sdio_ireg);
+        } else {
+            priv->bt_dev.tx_dnld_rdy = TRUE;
+        }
+    }
+    if (sdio_ireg & UP_LD_HOST_INT_STATUS) {
+	sd_card_to_host(priv);
+    }
+    *ireg = sdio_ireg;
+    ret = BT_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function wakeup firmware
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_wakeup_firmware(bt_private * priv)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    int ret = BT_STATUS_SUCCESS;
+    ENTER();
+    if (!card || !card->func) {
+        PRINTM(ERROR, "card or function is NULL!\n");
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+    sdio_claim_host(card->func);
+    sdio_writeb(card->func, HOST_POWER_UP, CONFIGURATION_REG, &ret);
+    sdio_release_host(card->func);
+    PRINTM(CMD, "wake up firmware\n");
+    LEAVE();
+    return ret;
+}
diff --git a/drivers/net/wireless/8688_bt/bt/bt_sdio.h b/drivers/net/wireless/8688_bt/bt/bt_sdio.h
new file mode 100755
index 0000000..dc1c441
--- /dev/null
+++ b/drivers/net/wireless/8688_bt/bt/bt_sdio.h
@@ -0,0 +1,160 @@
+/** @file bt_sdio.h
+ *  @brief This file contains SDIO (interface) module
+ *  related macros, enum, and structure.
+ *       
+ *  (c) Copyright 2007, Marvell International Ltd.   
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+
+#ifndef _BT_SDIO_H_
+#define _BT_SDIO_H_
+
+/** IRQ return type */
+typedef irqreturn_t IRQ_RET_TYPE;
+/** IRQ return */
+#define IRQ_RET		return IRQ_HANDLED
+/** ISR notifier function */
+typedef IRQ_RET_TYPE(*isr_notifier_fn_t) (s32 irq, void *dev_id,
+                                          struct pt_regs * reg);
+
+/** MVSD type */
+typedef enum _mv_sd_type
+{
+    MVSD_DAT = 0,
+    MVSD_CMD = 1,
+    MVSD_EVENT = 3
+} mv_sd_type;
+
+/** SDIO header length */
+#define SDIO_HEADER_LEN			4
+/** define SD block size for data Tx/Rx */
+#define SD_BLOCK_SIZE			32	
+/** define SD block size for firmware download */
+#define SD_BLOCK_SIZE_FW_DL		32
+/** Number of blocks for firmware transfer */
+#define FIRMWARE_TRANSFER_NBLOCK	2
+
+#ifndef MAX
+/** Return maximum of two */
+#define MAX(a,b)		((a) > (b) ? (a) : (b))
+#endif
+
+/** This is for firmware specific length */
+#define EXTRA_LEN	36
+
+/** Command buffer size for Marvell driver */
+#define MRVDRV_SIZE_OF_CMD_BUFFER       (2 * 1024)
+
+/** Bluetooth Rx packet buffer size for Marvell driver */
+#define MRVDRV_BT_RX_PACKET_BUFFER_SIZE \
+	(HCI_MAX_FRAME_SIZE + EXTRA_LEN)
+
+/** Buffer size to allocate */
+#define ALLOC_BUF_SIZE		(((MAX(MRVDRV_BT_RX_PACKET_BUFFER_SIZE, \
+					MRVDRV_SIZE_OF_CMD_BUFFER) + SDIO_HEADER_LEN \
+					+ SD_BLOCK_SIZE - 1) / SD_BLOCK_SIZE) * SD_BLOCK_SIZE)
+
+/** The number of times to try when polling for status bits */
+#define MAX_POLL_TRIES			100
+
+/** The number of times to try when waiting for downloaded firmware to 
+     become active. (polling the scratch register). */
+
+#define MAX_FIRMWARE_POLL_TRIES		100
+
+/** HIM disable */
+#define	HIM_DISABLE			0xff
+/** HIM enable */
+#define HIM_ENABLE			0x03
+/** Firmware ready */
+#define FIRMWARE_READY			0xfedc
+
+/* Bus Interface Control Reg 0x07 */
+/** SD BUS width 1 */
+#define SD_BUS_WIDTH_1			0x00
+/** SD BUS width 4 */
+#define SD_BUS_WIDTH_4			0x02
+/** SD BUS width mask */
+#define SD_BUS_WIDTH_MASK		0x03
+/** Asynchronous interrupt mode */
+#define ASYNC_INT_MODE			0x20
+
+/* Host Control Registers */
+/** I/O port 0 register */
+#define IO_PORT_0_REG			0x00
+/** I/O port 1 register */
+#define IO_PORT_1_REG			0x01
+/** I/O port 2 register */
+#define IO_PORT_2_REG			0x02
+/** Configuration register */
+#define CONFIGURATION_REG		0x03
+/** Host without Command 53 finish host */
+#define HOST_WO_CMD53_FINISH_HOST	(0x1U << 2)
+/** Host power up */
+#define HOST_POWER_UP			(0x1U << 1)
+/** Host power down */
+#define HOST_POWER_DOWN			(0x1U << 0)
+/** Host interrupt mask register */
+#define HOST_INT_MASK_REG		0x04
+
+/* Card Control Registers */
+/** SQ read base address of A0 register */
+#define SQ_READ_BASE_ADDRESS_A0_REG  	0x10
+/** SQ read base address of A1 register */
+#define SQ_READ_BASE_ADDRESS_A1_REG  	0x11
+
+/** Host interrupt status register */
+#define HOST_INTSTATUS_REG		0x05
+/** Upload host interrupt status */
+#define UP_LD_HOST_INT_STATUS		(0x1U)
+/** Download host interrupt status */
+#define DN_LD_HOST_INT_STATUS		(0x2U)
+
+/** Card status register */
+#define CARD_STATUS_REG              	0x20
+/** Card I/O ready */
+#define CARD_IO_READY              	(0x1U << 3)
+/** CIS card ready */
+#define CIS_CARD_RDY                 	(0x1U << 2)
+/** Upload card ready */
+#define UP_LD_CARD_RDY               	(0x1U << 1)
+/** Download card ready */
+#define DN_LD_CARD_RDY               	(0x1U << 0)
+
+/** Card OCR 0 register */
+#define CARD_OCR_0_REG               	0x34
+/** Card OCR 1 register */
+#define CARD_OCR_1_REG               	0x35
+
+/** Card Control Registers */
+#define CARD_REVISION_REG            	0x3c
+
+/** Firmware status 0 register */
+#define CARD_FW_STATUS0_REG		0x40
+/** Firmware status 1 register */
+#define CARD_FW_STATUS1_REG		0x41
+/** Rx length register */
+#define CARD_RX_LEN_REG			0x42
+/** Rx unit register */
+#define CARD_RX_UNIT_REG		0x43
+
+struct sdio_mmc_card
+{
+    struct sdio_func *func;
+    bt_private *priv;
+};
+
+#endif /* _BT_SDIO_H_ */
diff --git a/drivers/net/wireless/8688_bt/bt/include.h b/drivers/net/wireless/8688_bt/bt/include.h
new file mode 100755
index 0000000..cf7501e
--- /dev/null
+++ b/drivers/net/wireless/8688_bt/bt/include.h
@@ -0,0 +1,43 @@
+/** @file include.h
+ *  @brief This file contains all the necessary include file.
+ *       
+ *  (c) Copyright 2007, Marvell International Ltd.   
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+
+#ifndef _INCLUDE_H_
+#define _INCLUDE_H_
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/proc_fs.h>
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#include  <linux/version.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/card.h>
+#include "bt_drv.h"
+#include "bt_sdio.h"
+#endif /* _INCLUDE_H_ */
diff --git a/drivers/net/wireless/8688_bt/gpl.txt b/drivers/net/wireless/8688_bt/gpl.txt
new file mode 100755
index 0000000..a8e1c52
--- /dev/null
+++ b/drivers/net/wireless/8688_bt/gpl.txt
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+ 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/drivers/net/wireless/8688_wlan/Makefile b/drivers/net/wireless/8688_wlan/Makefile
new file mode 100755
index 0000000..3ba9d4a
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/Makefile
@@ -0,0 +1,187 @@
+# File: Makefile
+#
+# (c) Copyright © 2003-2006, Marvell International Ltd. 
+#
+# This software file (the "File") is distributed by Marvell International 
+# Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+# (the "License").  You may use, redistribute and/or modify this File in 
+# accordance with the terms and conditions of the License, a copy of which 
+# is available along with the File in the gpl.txt file or by writing to 
+# the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+# 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+#
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+# IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+# ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+# this warranty disclaimer.
+
+#CC=		$(CROSS)gcc
+#LD=		$(CROSS)ld
+#BACKUP=		/root/backup
+#YMD=		`date +%Y%m%d%H%M`
+
+#############################################################################
+# Configuration Options
+#############################################################################
+
+# Debug Option
+# DEBUG LEVEL n/1/2:
+# n: NO DEBUG
+# 1: Only PRINTM(MSG,...), PRINTM(FATAL,...), ...
+# 2: All PRINTM()
+CONFIG_DEBUG=0
+
+# Proc in /proc/net/wlan
+CONFIG_PROC_DEBUG=y
+
+# Re-association in driver
+CONFIG_REASSOCIATION=y
+
+# Manufacturing firmware support
+CONFIG_MFG_CMD_SUPPORT=y
+
+# Big-endian platform
+CONFIG_BIG_ENDIAN=n
+
+#############################################################################
+# Select Platform Tools
+#############################################################################
+
+MODEXT = ko
+EXTRA_CFLAGS += -Idrivers/net/wireless/8688_wlan/wlan
+
+LD += -S
+KERNELVERSION_X86 := 	$(shell uname -r)
+
+
+#############################################################################
+# Compiler Flags
+#############################################################################
+
+	#EXTRA_CFLAGS += -I$(KERNELDIR)/include
+
+	EXTRA_CFLAGS += -DFPNUM='"38"'
+
+ifeq ($(CONFIG_DEBUG),1)
+	EXTRA_CFLAGS += -DDEBUG_LEVEL1
+endif
+
+ifeq ($(CONFIG_DEBUG),2)
+	EXTRA_CFLAGS += -DDEBUG_LEVEL1
+	EXTRA_CFLAGS += -DDEBUG_LEVEL2
+	DBG=	-dbg
+endif
+
+ifeq ($(CONFIG_PROC_DEBUG),y)
+	EXTRA_CFLAGS += -DPROC_DEBUG
+	export CONFIG_PROC_DEBUG
+endif
+
+ifeq ($(CONFIG_REASSOCIATION),y)
+	EXTRA_CFLAGS += -DREASSOCIATION
+endif
+
+ifeq ($(CONFIG_MFG_CMD_SUPPORT),y)
+	EXTRA_CFLAGS += -DMFG_CMD_SUPPORT
+endif
+
+ifeq ($(CONFIG_BIG_ENDIAN),y)
+	EXTRA_CFLAGS += -DBIG_ENDIAN
+endif
+
+#############################################################################
+# Make Targets
+#############################################################################
+
+ifneq ($(KERNELRELEASE),)
+
+WLANOBJS =	wlan/wlan_main.o wlan/wlan_init.o wlan/wlan_wext.o \
+		wlan/wlan_rx.o wlan/wlan_tx.o \
+		wlan/wlan_cmd.o wlan/wlan_cmdresp.o \
+		wlan/wlan_scan.o wlan/wlan_join.o
+
+WLANOBJS += wlan/wlan_wmm.o
+WLANOBJS += wlan/wlan_11d.o
+WLANOBJS += wlan/wlan_11h.o
+WLANOBJS += wlan/wlan_meas.o
+
+ifdef CONFIG_PROC_FS
+WLANOBJS += wlan/wlan_proc.o
+ifeq ($(CONFIG_PROC_DEBUG), y)
+WLANOBJS += wlan/wlan_debug.o
+endif
+endif
+
+WLANOBJS += wlan/wlan_sdio.o
+obj-m := 8688_a2.o
+8688_a2-objs := $(WLANOBJS)
+
+# Otherwise we were called directly from the command line; invoke the kernel build system.
+else
+
+default:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
+
+endif
+
+###############################################################
+
+export		CC LD EXTRA_CFLAGS KERNELDIR
+
+.PHONY: app/wlanconfig wlan clean distclean
+
+
+	@echo "Finished Making Marvell Wlan Linux Driver"
+
+wlan app/wlanconfig:
+	$(MAKE) -C $@
+
+echo:
+	@echo "Please make sure the following are done before building:"
+	@echo "	1. Modify wlan/wlan_drv.h to set correct version number"
+	@echo "	2. Update the README"
+
+build:		echo default
+
+	@if [ ! -d $(BINDIR) ]; then \
+		mkdir $(BINDIR); \
+	fi 
+	cp -f 8688_a2.$(MODEXT) $(BINDIR)/sd8688$(DBG).$(MODEXT)
+
+	cp -f README $(BINDIR)
+	$(MAKE) -C app/wlanconfig $@ INSTALLDIR=$(BINDIR)
+	cp -r config $(BINDIR)
+
+clean:
+	-find . -name "*.o" -exec rm {} \;
+	-find . -name "*.ko" -exec rm {} \;
+	-find . -name ".*.cmd" -exec rm {} \;
+	-find . -name "*.mod.c" -exec rm {} \;
+	-find . -name "Module.symvers" -exec rm {} \;
+	-rm -rf .tmp_versions
+	$(MAKE) -C app/wlanconfig $@
+
+install: default
+
+	cp -f io/sdio/$(PLATFORM)/sdio.$(MODEXT) $(INSTALLDIR)
+	$(MAKE) -C app/wlanconfig $@ INSTALLDIR=$(INSTALLDIR)
+	cp -f 8688_a2.$(MODEXT) $(INSTALLDIR)/sd8688$(DBG).$(MODEXT)
+	echo "sd8688 Driver Installed"
+
+distclean:
+	-find . -name "*.o" -exec rm {} \;
+	-find . -name "*.orig" -exec rm {} \;
+	-find . -name "*.swp" -exec rm {} \;
+	-find . -name "*.*~" -exec rm {} \;
+	-find . -name "*~" -exec rm {} \;
+	-find . -name "*.d" -exec rm {} \;
+	-find . -name "*.a" -exec rm {} \;
+	-find . -name "tags" -exec rm {} \;
+	-find . -name ".*" -exec rm -rf 2> /dev/null \;
+	-find . -name "*.ko" -exec rm {} \;
+	-find . -name ".*.cmd" -exec rm {} \;
+	-find . -name "*.mod.c" -exec rm {} \;
+	-rm -rf .tmp_versions
+	$(MAKE) -C app/wlanconfig $@
+
+# End of file
diff --git a/drivers/net/wireless/8688_wlan/gpl.txt b/drivers/net/wireless/8688_wlan/gpl.txt
new file mode 100755
index 0000000..a8e1c52
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/gpl.txt
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+ 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_11d.c b/drivers/net/wireless/8688_wlan/wlan/wlan_11d.c
new file mode 100755
index 0000000..839b98b
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_11d.c
@@ -0,0 +1,963 @@
+/** @file wlan_11d.c
+  * @brief This file contains functions for 802.11D.
+  *
+  * (c) Copyright © 2003-2006, Marvell International Ltd. 
+  *
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	10/04/05: Add Doxygen format comments
+	
+********************************************************/
+#include	"wlan_headers.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+/** Default Tx power */
+#define TX_PWR_DEFAULT	10
+
+static region_code_mapping_t region_code_mapping[] = {
+    {"US ", 0x10},              /* US FCC      */
+    {"CA ", 0x20},              /* IC Canada   */
+    {"SG ", 0x10},              /* Singapore   */
+    {"EU ", 0x30},              /* ETSI        */
+    {"AU ", 0x30},              /* Australia   */
+    {"KR ", 0x30},              /* Republic Of Korea */
+    {"ES ", 0x31},              /* Spain       */
+    {"FR ", 0x32},              /* France      */
+    {"JP ", 0x40},              /* Japan       */
+    {"JP ", 0x41},              /* Japan       */
+};
+
+/* Following 2 structure defines the supported channels */
+/** Channels for 802.11b/g */
+static CHANNEL_FREQ_POWER channel_freq_power_UN_BG[] = {
+    {1, 2412, TX_PWR_DEFAULT},
+    {2, 2417, TX_PWR_DEFAULT},
+    {3, 2422, TX_PWR_DEFAULT},
+    {4, 2427, TX_PWR_DEFAULT},
+    {5, 2432, TX_PWR_DEFAULT},
+    {6, 2437, TX_PWR_DEFAULT},
+    {7, 2442, TX_PWR_DEFAULT},
+    {8, 2447, TX_PWR_DEFAULT},
+    {9, 2452, TX_PWR_DEFAULT},
+    {10, 2457, TX_PWR_DEFAULT},
+    {11, 2462, TX_PWR_DEFAULT},
+    {12, 2467, TX_PWR_DEFAULT},
+    {13, 2472, TX_PWR_DEFAULT},
+    {14, 2484, TX_PWR_DEFAULT}
+};
+
+/** Channels for 802.11a/j */
+static CHANNEL_FREQ_POWER channel_freq_power_UN_AJ[] = {
+    {8, 5040, TX_PWR_DEFAULT},
+    {12, 5060, TX_PWR_DEFAULT},
+    {16, 5080, TX_PWR_DEFAULT},
+    {34, 5170, TX_PWR_DEFAULT},
+    {38, 5190, TX_PWR_DEFAULT},
+    {42, 5210, TX_PWR_DEFAULT},
+    {46, 5230, TX_PWR_DEFAULT},
+    {36, 5180, TX_PWR_DEFAULT},
+    {40, 5200, TX_PWR_DEFAULT},
+    {44, 5220, TX_PWR_DEFAULT},
+    {48, 5240, TX_PWR_DEFAULT},
+    {52, 5260, TX_PWR_DEFAULT},
+    {56, 5280, TX_PWR_DEFAULT},
+    {60, 5300, TX_PWR_DEFAULT},
+    {64, 5320, TX_PWR_DEFAULT},
+    {100, 5500, TX_PWR_DEFAULT},
+    {104, 5520, TX_PWR_DEFAULT},
+    {108, 5540, TX_PWR_DEFAULT},
+    {112, 5560, TX_PWR_DEFAULT},
+    {116, 5580, TX_PWR_DEFAULT},
+    {120, 5600, TX_PWR_DEFAULT},
+    {124, 5620, TX_PWR_DEFAULT},
+    {128, 5640, TX_PWR_DEFAULT},
+    {132, 5660, TX_PWR_DEFAULT},
+    {136, 5680, TX_PWR_DEFAULT},
+    {140, 5700, TX_PWR_DEFAULT},
+    {149, 5745, TX_PWR_DEFAULT},
+    {153, 5765, TX_PWR_DEFAULT},
+    {157, 5785, TX_PWR_DEFAULT},
+    {161, 5805, TX_PWR_DEFAULT},
+    {165, 5825, TX_PWR_DEFAULT},
+/*	{240, 4920, TX_PWR_DEFAULT}, 
+	{244, 4940, TX_PWR_DEFAULT}, 
+	{248, 4960, TX_PWR_DEFAULT}, 
+	{252, 4980, TX_PWR_DEFAULT}, 
+channels for 11J JP 10M channel gap */
+};
+
+/********************************************************
+		Local Functions
+********************************************************/
+/** 
+ *  @brief This function convert Region string to code integer
+ *  @param region     region string
+ *  @return 	      region id
+*/
+static u8
+wlan_region_2_code(s8 * region)
+{
+    u8 i;
+    u8 size = sizeof(region_code_mapping) / sizeof(region_code_mapping_t);
+
+    for (i = 0; i < COUNTRY_CODE_LEN && region[i]; i++)
+        region[i] = toupper(region[i]);
+
+    for (i = 0; i < size; i++) {
+        if (!memcmp(region, region_code_mapping[i].region, COUNTRY_CODE_LEN))
+            return (region_code_mapping[i].code);
+    }
+
+    /* default is US */
+    return (region_code_mapping[0].code);
+}
+
+/** 
+ *  @brief This function converts interger code to region string
+ *  @param code       region code
+ *  @return 	      region string
+*/
+static u8 *
+wlan_code_2_region(u8 code)
+{
+    u8 i;
+    u8 size = sizeof(region_code_mapping) / sizeof(region_code_mapping_t);
+    for (i = 0; i < size; i++) {
+        if (region_code_mapping[i].code == code)
+            return (region_code_mapping[i].region);
+    }
+    /* default is US */
+    return (region_code_mapping[0].region);
+}
+
+/** 
+ *  @brief This function finds the NoOfChan-th chan after the firstChan
+ *  @param band       band
+ *  @param firstChan  first channel number
+ *  @param NoOfChan   number of channels
+ *  @param chan       pointer to the returned NoOfChan-th chan number
+ *  @return 	      TRUE; FALSE
+*/
+static BOOLEAN
+wlan_get_chan_11d(u8 band, u8 firstChan, u8 NoOfChan, u8 * chan)
+/*find the NoOfChan-th chan after the firstChan*/
+{
+    u8 i;
+    CHANNEL_FREQ_POWER *cfp;
+    u8 cfp_no;
+
+    ENTER();
+
+    if (band & (BAND_B | BAND_G)) {
+        cfp = channel_freq_power_UN_BG;
+        cfp_no = sizeof(channel_freq_power_UN_BG) /
+            sizeof(CHANNEL_FREQ_POWER);
+    } else {
+        if (band & BAND_A) {
+            cfp = channel_freq_power_UN_AJ;
+            cfp_no = sizeof(channel_freq_power_UN_AJ) /
+                sizeof(CHANNEL_FREQ_POWER);
+        } else {
+            PRINTM(INFO, "Wrong Band[%d\n", band);
+            return FALSE;
+        }
+    }
+
+    for (i = 0; i < cfp_no; i++) {
+        if ((cfp + i)->Channel == firstChan) {
+            PRINTM(INFO, "firstChan found\n");
+            break;
+        }
+    }
+
+    if (i < cfp_no) {
+        /*if beyond the boundary */
+        if (i + NoOfChan < cfp_no) {
+            *chan = (cfp + i + NoOfChan)->Channel;
+            return TRUE;
+        }
+    }
+
+    LEAVE();
+    return FALSE;
+}
+
+/** 
+ *  @brief This function Checks if chan txpwr is learned from AP/IBSS
+ *  @param chan                 chan number
+ *  @param parsed_region_chan   pointer to parsed_region_chan_11d_t     
+ *  @return 	                TRUE; FALSE
+*/
+BOOLEAN
+wlan_channel_known_11d(u8 chan, parsed_region_chan_11d_t * parsed_region_chan)
+{
+    chan_power_11d_t *chanPwr = parsed_region_chan->chanPwr;
+    u8 NoOfChan = parsed_region_chan->NoOfChan;
+    u8 i = 0;
+
+    ENTER();
+    HEXDUMP("11D:parsed_region_chan:", (char *) chanPwr,
+            sizeof(chan_power_11d_t) * NoOfChan);
+
+    for (i = 0; i < NoOfChan; i++) {
+        if (chan == chanPwr[i].chan) {
+            PRINTM(INFO, "11D: Found Chan:%d\n", chan);
+            LEAVE();
+            return TRUE;
+        }
+    }
+
+    PRINTM(INFO, "11D: Not Find Chan:%d\n", chan);
+    LEAVE();
+    return FALSE;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function Converts chan to frequency
+ *  @param chan                 channel number
+ *  @param band                 band
+ *  @return 	                channel frequency
+*/
+u32
+chan_2_freq(u8 chan, u8 band)
+{
+    CHANNEL_FREQ_POWER *cf;
+    u16 cnt;
+    u16 i;
+    u32 freq = 0;
+
+    ENTER();
+
+    if (band & BAND_A) {
+        cf = channel_freq_power_UN_AJ;
+        cnt = sizeof(channel_freq_power_UN_AJ) / sizeof(CHANNEL_FREQ_POWER);
+    } else {
+        cf = channel_freq_power_UN_BG;
+        cnt = sizeof(channel_freq_power_UN_BG) / sizeof(CHANNEL_FREQ_POWER);
+    }
+
+    for (i = 0; i < cnt; i++) {
+        if (chan == cf[i].Channel)
+            freq = cf[i].Freq;
+    }
+
+    LEAVE();
+    return freq;
+}
+
+/** 
+ *  @brief This function generates domaininfo from parsed_region_chan
+ *  @param parsed_region_chan   pointer to parsed_region_chan_11d_t
+ *  @param domaininfo           pointer to wlan_802_11d_domain_reg_t
+ *  @return 	                WLAN_STATUS_SUCCESS
+*/
+int
+wlan_generate_domain_info_11d(parsed_region_chan_11d_t * parsed_region_chan,
+                              wlan_802_11d_domain_reg_t * domaininfo)
+{
+    u8 NoOfSubband = 0;
+
+    u8 NoOfChan = parsed_region_chan->NoOfChan;
+    u8 NoOfParsedChan = 0;
+
+    u8 firstChan = 0, nextChan = 0, maxPwr = 0;
+
+    u8 i, flag = 0;
+
+    ENTER();
+
+    memcpy(domaininfo->CountryCode, parsed_region_chan->CountryCode,
+           COUNTRY_CODE_LEN);
+
+    PRINTM(INFO, "11D:NoOfChan=%d\n", NoOfChan);
+    HEXDUMP("11D:parsed_region_chan:", (char *) parsed_region_chan,
+            sizeof(parsed_region_chan_11d_t));
+
+    for (i = 0; i < NoOfChan; i++) {
+        if (!flag) {
+            flag = 1;
+            nextChan = firstChan = parsed_region_chan->chanPwr[i].chan;
+            maxPwr = parsed_region_chan->chanPwr[i].pwr;
+            NoOfParsedChan = 1;
+            continue;
+        }
+
+        if (parsed_region_chan->chanPwr[i].chan == nextChan + 1 &&
+            parsed_region_chan->chanPwr[i].pwr == maxPwr) {
+            nextChan++;
+            NoOfParsedChan++;
+        } else {
+            domaininfo->Subband[NoOfSubband].FirstChan = firstChan;
+            domaininfo->Subband[NoOfSubband].NoOfChan = NoOfParsedChan;
+            domaininfo->Subband[NoOfSubband].MaxTxPwr = maxPwr;
+            NoOfSubband++;
+            NoOfParsedChan = 1;
+            nextChan = firstChan = parsed_region_chan->chanPwr[i].chan;
+            maxPwr = parsed_region_chan->chanPwr[i].pwr;
+        }
+    }
+
+    if (flag) {
+        domaininfo->Subband[NoOfSubband].FirstChan = firstChan;
+        domaininfo->Subband[NoOfSubband].NoOfChan = NoOfParsedChan;
+        domaininfo->Subband[NoOfSubband].MaxTxPwr = maxPwr;
+        NoOfSubband++;
+    }
+    domaininfo->NoOfSubband = NoOfSubband;
+
+    PRINTM(INFO, "NoOfSubband=%x\n", domaininfo->NoOfSubband);
+    HEXDUMP("11D:domaininfo:", (char *) domaininfo,
+            COUNTRY_CODE_LEN + 1 +
+            sizeof(IEEEtypes_SubbandSet_t) * NoOfSubband);
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function generates parsed_region_chan from Domain Info learned from AP/IBSS
+ *  @param region_chan          pointer to REGION_CHANNEL
+ *  @param *parsed_region_chan  pointer to parsed_region_chan_11d_t
+ *  @return 	                N/A
+*/
+void
+wlan_generate_parsed_region_chan_11d(REGION_CHANNEL * region_chan,
+                                     parsed_region_chan_11d_t *
+                                     parsed_region_chan)
+{
+    u8 i;
+    CHANNEL_FREQ_POWER *cfp;
+
+    ENTER();
+
+    if (region_chan == NULL) {
+        PRINTM(INFO, "11D: region_chan is NULL\n");
+        return;
+    }
+
+    cfp = region_chan->CFP;
+    if (cfp == NULL) {
+        PRINTM(INFO, "11D: cfp equal NULL \n");
+        return;
+    }
+
+    parsed_region_chan->band = region_chan->Band;
+    parsed_region_chan->region = region_chan->Region;
+    memcpy(parsed_region_chan->CountryCode,
+           wlan_code_2_region(region_chan->Region), COUNTRY_CODE_LEN);
+
+    PRINTM(INFO, "11D: region[0x%x] band[%d]\n", parsed_region_chan->region,
+           parsed_region_chan->band);
+
+    for (i = 0; i < region_chan->NrCFP; i++, cfp++) {
+        parsed_region_chan->chanPwr[i].chan = cfp->Channel;
+        parsed_region_chan->chanPwr[i].pwr = cfp->MaxTxPower;
+        PRINTM(INFO, "11D: Chan[%d] Pwr[%d]\n",
+               parsed_region_chan->chanPwr[i].chan,
+               parsed_region_chan->chanPwr[i].pwr);
+    }
+    parsed_region_chan->NoOfChan = region_chan->NrCFP;
+
+    PRINTM(INFO, "11D: NoOfChan[%d]\n", parsed_region_chan->NoOfChan);
+
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief generate parsed_region_chan from Domain Info learned from AP/IBSS
+ *  @param region               region ID
+ *  @param band                 band
+ *  @param chan                 chan
+ *  @return 	                TRUE;FALSE
+*/
+BOOLEAN
+wlan_region_chan_supported_11d(u8 region, u8 band, u8 chan)
+{
+    CHANNEL_FREQ_POWER *cfp;
+    int cfp_no;
+    u8 idx;
+
+    ENTER();
+
+    if ((cfp = wlan_get_region_cfp_table(region, band, &cfp_no)) == NULL) {
+        return FALSE;
+    }
+
+    for (idx = 0; idx < cfp_no; idx++) {
+        if (chan == (cfp + idx)->Channel) {
+            /* If Mrvl Chip Supported? */
+            if ((cfp + idx)->Unsupported) {
+                return FALSE;
+            } else {
+                return TRUE;
+            }
+        }
+    }
+
+    /*chan is not in the region table */
+    LEAVE();
+    return FALSE;
+}
+
+/** 
+ *  @brief This function checks if chan txpwr is learned from AP/IBSS
+ *  @param CountryInfo          country information
+ *  @param band                 chan band
+ *  @param parsed_region_chan   pointer to parsed_region_chan_11d_t     
+ *  @return 	                WLAN_STATUS_SUCCESS       
+*/
+int
+wlan_parse_domain_info_11d(IEEEtypes_CountryInfoFullSet_t * CountryInfo,
+                           u8 band,
+                           parsed_region_chan_11d_t * parsed_region_chan)
+{
+    u8 NoOfSubband, NoOfChan;
+    u8 lastChan, firstChan, curChan;
+    u8 region;
+
+    u8 idx = 0;                 /*chan index in parsed_region_chan */
+
+    u8 j, i;
+
+    ENTER();
+
+    /*Validation Rules:
+       1. Valid Region Code
+       2. First Chan increment
+       3. Channel range no overlap
+       4. Channel is valid?
+       5. Channel is supported by Region?
+       6. Others
+     */
+
+    HEXDUMP("CountryInfo:", (s8 *) CountryInfo, 30);
+
+    if ((*(CountryInfo->CountryCode)) == 0 ||
+        (CountryInfo->Len <= COUNTRY_CODE_LEN)) {
+        /* No region Info or Wrong region info: treat as No 11D info */
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    /*Step1: check region_code */
+    parsed_region_chan->region = region =
+        wlan_region_2_code((s8 *) CountryInfo->CountryCode);
+
+    PRINTM(INFO, "regioncode=%x\n", (u8) parsed_region_chan->region);
+    HEXDUMP("CountryCode:", (char *) CountryInfo->CountryCode,
+            COUNTRY_CODE_LEN);
+
+    parsed_region_chan->band = band;
+
+    memcpy(parsed_region_chan->CountryCode, CountryInfo->CountryCode,
+           COUNTRY_CODE_LEN);
+
+    NoOfSubband = (CountryInfo->Len - COUNTRY_CODE_LEN) /
+        sizeof(IEEEtypes_SubbandSet_t);
+
+    for (j = 0, lastChan = 0; j < NoOfSubband; j++) {
+
+        if (CountryInfo->Subband[j].FirstChan <= lastChan) {
+            /*Step2&3. Check First Chan Num increment and no overlap */
+            PRINTM(INFO, "11D: Chan[%d>%d] Overlap\n",
+                   CountryInfo->Subband[j].FirstChan, lastChan);
+            continue;
+        }
+
+        firstChan = CountryInfo->Subband[j].FirstChan;
+        NoOfChan = CountryInfo->Subband[j].NoOfChan;
+
+        for (i = 0; idx < MAX_NO_OF_CHAN && i < NoOfChan; i++) {
+            /*step4: channel is supported? */
+
+            if (wlan_get_chan_11d(band, firstChan, i, &curChan)
+                == FALSE) {
+                /* Chan is not found in UN table */
+                PRINTM(INFO, "chan is not supported: %d \n", i);
+                break;
+            }
+
+            lastChan = curChan;
+
+            /*step5: We don't need to Check if curChan is supported by mrvl in region */
+            parsed_region_chan->chanPwr[idx].chan = curChan;
+            parsed_region_chan->chanPwr[idx].pwr =
+                CountryInfo->Subband[j].MaxTxPwr;
+            idx++;
+        }
+
+        /*Step6: Add other checking if any */
+
+    }
+
+    parsed_region_chan->NoOfChan = idx;
+
+    PRINTM(INFO, "NoOfChan=%x\n", parsed_region_chan->NoOfChan);
+    HEXDUMP("11D:parsed_region_chan:", (s8 *) parsed_region_chan,
+            2 + COUNTRY_CODE_LEN + sizeof(parsed_region_chan_11d_t) * idx);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function calculates the scan type for channels
+ *  @param chan                 chan number
+ *  @param parsed_region_chan   pointer to parsed_region_chan_11d_t     
+ *  @return 	                PASSIVE if chan is unknown; ACTIVE if chan is known
+*/
+u8
+wlan_get_scan_type_11d(u8 chan, parsed_region_chan_11d_t * parsed_region_chan)
+{
+    u8 scan_type = HostCmd_SCAN_TYPE_PASSIVE;
+
+    ENTER();
+
+    if (wlan_channel_known_11d(chan, parsed_region_chan)) {
+        PRINTM(INFO, "11D: Found and do Active Scan\n");
+        scan_type = HostCmd_SCAN_TYPE_ACTIVE;
+    } else {
+        PRINTM(INFO, "11D: Not Find and do Passive Scan\n");
+    }
+
+    LEAVE();
+    return scan_type;
+
+}
+
+/** 
+ *  @brief This function gets if 11D is enabled
+ *  @param priv       pointer to wlan_private
+ *  @return 	      ENABLE_11D;DISABLE_11D
+*/
+state_11d_t
+wlan_get_state_11d(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_802_11d_state_t *state = &Adapter->State11D;
+    return (state->Enable11D);
+}
+
+/** 
+ *  @brief initialize internal variable for 11D
+ *  @param priv       pointer to wlan_private
+ *  @return 	      N/A
+*/
+void
+wlan_init_11d(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_802_11d_state_t *state = &Adapter->State11D;
+
+    state->Enable11D = DISABLE_11D;
+
+    memset(&(priv->adapter->parsed_region_chan), 0,
+           sizeof(parsed_region_chan_11d_t));
+
+    return;
+}
+
+/** 
+ *  @brief This function enable/disable 11D
+ *  @param priv       pointer to wlan_private
+ *  @param flag       enable/disable flag
+ *  @return 	      WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+*/
+int
+wlan_enable_11d(wlan_private * priv, state_11d_t flag)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_802_11d_state_t *state = &Adapter->State11D;
+    int ret;
+    state_11d_t enable = flag;
+
+    ENTER();
+
+    state->Enable11D = flag;
+
+    /* send cmd to FW to enable/disable 11D fucntion in FW */
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_SNMP_MIB,
+                           HostCmd_ACT_GEN_SET,
+                           HostCmd_OPTION_WAITFORRSP, Dot11D_i, &enable);
+    if (ret) {
+        PRINTM(INFO, "11D: Fail to enable 11D \n");
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function sets DOMAIN INFO to FW
+ *  @param priv       pointer to wlan_private
+ *  @return 	      WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+*/
+int
+wlan_set_domain_info_11d(wlan_private * priv)
+{
+    int ret;
+
+    if (!wlan_get_state_11d(priv)) {
+        PRINTM(INFO, "11D: dnld domain Info with 11d disabled\n");
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11D_DOMAIN_INFO,
+                           HostCmd_ACT_GEN_SET,
+                           HostCmd_OPTION_WAITFORRSP, 0, NULL);
+    if (ret) {
+        PRINTM(INFO, "11D: Fail to dnld domain Info\n");
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function setups scan channels
+ *  @param priv       pointer to wlan_private
+ *  @param band       band
+ *  @return 	      WLAN_STATUS_SUCCESS
+*/
+int
+wlan_set_universaltable(wlan_private * priv, u8 band)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u16 size = sizeof(CHANNEL_FREQ_POWER);
+    u16 i = 0;
+
+    ENTER();
+
+    memset(Adapter->universal_channel, 0, sizeof(Adapter->universal_channel));
+
+    if (band & (BAND_B | BAND_G)) {
+        Adapter->universal_channel[i].NrCFP =
+            sizeof(channel_freq_power_UN_BG) / size;
+        PRINTM(INFO, "11D: BG-band NrCFP=%d\n",
+               Adapter->universal_channel[i].NrCFP);
+
+        Adapter->universal_channel[i].CFP = channel_freq_power_UN_BG;
+        Adapter->universal_channel[i].Valid = TRUE;
+        Adapter->universal_channel[i].Region = UNIVERSAL_REGION_CODE;
+        Adapter->universal_channel[i].Band =
+            (band & BAND_G) ? BAND_G : BAND_B;
+        i++;
+    }
+
+    if (band & BAND_A) {
+        Adapter->universal_channel[i].NrCFP =
+            sizeof(channel_freq_power_UN_AJ) / size;
+        PRINTM(INFO, "11D: AJ-band NrCFP=%d\n",
+               Adapter->universal_channel[i].NrCFP);
+        Adapter->universal_channel[i].CFP = channel_freq_power_UN_AJ;
+
+        Adapter->universal_channel[i].Valid = TRUE;
+        Adapter->universal_channel[i].Region = UNIVERSAL_REGION_CODE;
+        Adapter->universal_channel[i].Band = BAND_A;
+        i++;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function implements command CMD_802_11D_DOMAIN_INFO
+ *  @param priv       pointer to wlan_private
+ *  @param cmd        pointer to cmd buffer
+ *  @param cmdno      cmd ID
+ *  @param CmdOption  cmd action 
+ *  @return 	      WLAN_STATUS_SUCCESS
+*/
+int
+wlan_cmd_802_11d_domain_info(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, u16 cmdno,
+                             u16 CmdOption)
+{
+    HostCmd_DS_802_11D_DOMAIN_INFO *pDomainInfo = &cmd->params.domaininfo;
+    MrvlIEtypes_DomainParamSet_t *domain = &pDomainInfo->Domain;
+    wlan_adapter *Adapter = priv->adapter;
+    u8 NoOfSubband = Adapter->DomainReg.NoOfSubband;
+
+    ENTER();
+
+    PRINTM(INFO, "NoOfSubband=%x\n", NoOfSubband);
+
+    cmd->Command = wlan_cpu_to_le16(cmdno);
+    pDomainInfo->Action = wlan_cpu_to_le16(CmdOption);
+    if (CmdOption == HostCmd_ACT_GEN_GET) {
+        cmd->Size = wlan_cpu_to_le16(sizeof(pDomainInfo->Action) + S_DS_GEN);
+        HEXDUMP("11D: 802_11D_DOMAIN_INFO:", (u8 *) cmd, (int) (cmd->Size));
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    domain->Header.Type = wlan_cpu_to_le16(TLV_TYPE_DOMAIN);
+    memcpy(domain->CountryCode, Adapter->DomainReg.CountryCode,
+           sizeof(domain->CountryCode));
+
+    domain->Header.Len =
+        wlan_cpu_to_le16(NoOfSubband * sizeof(IEEEtypes_SubbandSet_t) +
+                         sizeof(domain->CountryCode));
+
+    if (NoOfSubband) {
+        memcpy(domain->Subband, Adapter->DomainReg.Subband,
+               NoOfSubband * sizeof(IEEEtypes_SubbandSet_t));
+
+        cmd->Size = wlan_cpu_to_le16(sizeof(pDomainInfo->Action) +
+                                     domain->Header.Len +
+                                     sizeof(MrvlIEtypesHeader_t) + S_DS_GEN);
+    } else {
+        cmd->Size = wlan_cpu_to_le16(sizeof(pDomainInfo->Action) + S_DS_GEN);
+    }
+
+    HEXDUMP("11D:802_11D_DOMAIN_INFO:", (u8 *) cmd, (int) (cmd->Size));
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function implements private cmd: enable/disable 11D
+ *  @param priv    pointer to wlan_private
+ *  @param wrq     pointer to user data 
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_enable_11d(wlan_private * priv, struct iwreq *wrq)
+{
+    int data = 0;
+    int *val;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+
+    PRINTM(INFO, "Enable 11D: %s\n",
+           (data == CMD_ENABLED) ? "Enable" : "Disable");
+    switch (data) {
+    case CMD_ENABLED:
+        wlan_enable_11d(priv, ENABLE_11D);
+        break;
+    case CMD_DISABLED:
+        wlan_enable_11d(priv, DISABLE_11D);
+        break;
+    default:
+        break;
+    }
+
+    data =
+        (Adapter->State11D.Enable11D ==
+         ENABLE_11D) ? CMD_ENABLED : CMD_DISABLED;
+    val = (int *) wrq->u.name;
+    *val = data;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function parses countryinfo from AP and download country info to FW
+ *  @param priv    pointer to wlan_private
+ *  @param resp    pointer to command response buffer
+ *  @return 	   WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11d_domain_info(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11D_DOMAIN_INFO_RSP
+        * domaininfo = &resp->params.domaininforesp;
+    MrvlIEtypes_DomainParamSet_t * domain = &domaininfo->Domain;
+    u16 Action = wlan_le16_to_cpu(domaininfo->Action);
+    s16 ret = WLAN_STATUS_SUCCESS;
+    u8 NoOfSubband = 0;
+
+    ENTER();
+
+    HEXDUMP("11D DOMAIN Info Rsp Data:", (u8 *) resp, resp->Size);
+
+    NoOfSubband =
+        (wlan_le16_to_cpu(domain->Header.Len) -
+         3) / sizeof(IEEEtypes_SubbandSet_t);
+    /* countrycode 3 bytes */
+
+    PRINTM(INFO, "11D Domain Info Resp: NoOfSubband=%d\n", NoOfSubband);
+
+    if (NoOfSubband > MRVDRV_MAX_SUBBAND_802_11D) {
+        PRINTM(INFO, "Invalid Numrer of Subband returned!!\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    switch (Action) {
+    case HostCmd_ACT_GEN_SET:  /*Proc Set Action */
+        break;
+
+    case HostCmd_ACT_GEN_GET:
+        break;
+    default:
+        PRINTM(INFO, "Invalid Action:%d\n", domaininfo->Action);
+        ret = WLAN_STATUS_FAILURE;
+        break;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function parses countryinfo from AP and download country info to FW
+ *  @param priv    pointer to wlan_private
+ *  @return 	   WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+ */
+int
+wlan_parse_dnld_countryinfo_11d(wlan_private * priv)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        /* Skip new 11d download when roaming */
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    if (wlan_get_state_11d(priv) == ENABLE_11D) {
+
+        memset(&Adapter->parsed_region_chan, 0,
+               sizeof(parsed_region_chan_11d_t));
+
+        ret =
+            wlan_parse_domain_info_11d(&Adapter->pAttemptedBSSDesc->
+                                       CountryInfo,
+                                       Adapter->pAttemptedBSSDesc->bss_band,
+                                       &Adapter->parsed_region_chan);
+
+        if (ret == WLAN_STATUS_FAILURE) {
+            PRINTM(INFO, "11D: Err Parse domain_info from AP..\n");
+            LEAVE();
+            return ret;
+        }
+
+        memset(&Adapter->DomainReg, 0, sizeof(wlan_802_11d_domain_reg_t));
+        wlan_generate_domain_info_11d(&Adapter->parsed_region_chan,
+                                      &Adapter->DomainReg);
+
+        ret = wlan_set_domain_info_11d(priv);
+
+        if (ret) {
+            PRINTM(INFO, "11D: Err set domainInfo to FW\n");
+            LEAVE();
+            return ret;
+        }
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function generates 11D info from user specified regioncode and download to FW
+ *  @param priv    pointer to wlan_private
+ *  @return 	   WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+ */
+int
+wlan_create_dnld_countryinfo_11d(wlan_private * priv)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+    REGION_CHANNEL *region_chan;
+    u8 j;
+
+    ENTER();
+    PRINTM(INFO, "11D:CurBssParams.Band[%d]\n", Adapter->CurBssParams.band);
+
+    if (wlan_get_state_11d(priv) == ENABLE_11D) {
+        /* update parsed_region_chan_11; dnld domaininf to FW */
+
+        for (j = 0; j < sizeof(Adapter->region_channel) /
+             sizeof(Adapter->region_channel[0]); j++) {
+            region_chan = &Adapter->region_channel[j];
+
+            PRINTM(INFO, "11D:[%d] region_chan->Band[%d]\n", j,
+                   region_chan->Band);
+
+            if (!region_chan || !region_chan->Valid || !region_chan->CFP)
+                continue;
+            switch (region_chan->Band) {
+            case BAND_A:
+                switch (Adapter->CurBssParams.band) {
+                case BAND_A:
+                    break;
+                default:
+                    continue;
+                }
+                break;
+            case BAND_B:
+            case BAND_G:
+                switch (Adapter->CurBssParams.band) {
+                case BAND_B:
+                case BAND_G:
+                    break;
+                default:
+                    continue;
+                }
+                break;
+            default:
+                continue;
+            }
+            break;
+        }
+
+        if (j >= sizeof(Adapter->region_channel) /
+            sizeof(Adapter->region_channel[0])) {
+            PRINTM(INFO, "11D:region_chan not found. Band[%d]\n",
+                   Adapter->CurBssParams.band);
+            LEAVE();
+            return WLAN_STATUS_FAILURE;
+        }
+
+        memset(&Adapter->parsed_region_chan, 0,
+               sizeof(parsed_region_chan_11d_t));
+        wlan_generate_parsed_region_chan_11d(region_chan,
+                                             &Adapter->parsed_region_chan);
+
+        memset(&Adapter->DomainReg, 0, sizeof(wlan_802_11d_domain_reg_t));
+        wlan_generate_domain_info_11d(&Adapter->parsed_region_chan,
+                                      &Adapter->DomainReg);
+
+        ret = wlan_set_domain_info_11d(priv);
+
+        if (ret) {
+            PRINTM(INFO, "11D: Err set domainInfo to FW\n");
+            LEAVE();
+            return ret;
+        }
+
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_11d.h b/drivers/net/wireless/8688_wlan/wlan/wlan_11d.h
new file mode 100755
index 0000000..9813136
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_11d.h
@@ -0,0 +1,138 @@
+/** @file wlan_11d.h
+ *  @brief This header file contains data structures and 
+ *  function declarations of 802.11d  
+ *
+ * (c) Copyright © 2003-2006, Marvell International Ltd.  
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change log:
+	09/26/05: add Doxygen format comments 
+ ************************************************************/
+
+#ifndef _WLAN_11D_
+#define _WLAN_11D_
+
+/** Maximum number of channels */
+#define MAX_CHAN_NUM				255
+
+/** Universal region code */
+#define UNIVERSAL_REGION_CODE			0xff
+
+/** (Beaconsize(256)-5(IEId,len,contrystr(3))/3(FirstChan,NoOfChan,MaxPwr) 
+ */
+#define MAX_NO_OF_CHAN 				40
+
+/** Preregion channel */
+typedef struct _REGION_CHANNEL *PREGION_CHANNEL;
+
+/** State of 11d */
+typedef enum
+{
+    DISABLE_11D = 0,
+    ENABLE_11D = 1,
+} state_11d_t;
+
+/** domain regulatory information */
+typedef struct _wlan_802_11d_domain_reg
+{
+        /** country Code*/
+    u8 CountryCode[COUNTRY_CODE_LEN];
+        /** No. of subband*/
+    u8 NoOfSubband;
+        /** Subband data */
+    IEEEtypes_SubbandSet_t Subband[MRVDRV_MAX_SUBBAND_802_11D];
+} wlan_802_11d_domain_reg_t;
+
+typedef struct _chan_power_11d
+{
+        /** 11D channel */
+    u8 chan;
+        /** 11D channel power */
+    u8 pwr;
+} __ATTRIB_PACK__ chan_power_11d_t;
+
+typedef struct _parsed_region_chan_11d
+{
+        /** 11d band */
+    u8 band;
+        /** 11d region */
+    u8 region;
+        /** 11d country code */
+    s8 CountryCode[COUNTRY_CODE_LEN];
+        /** 11d channel power per channel */
+    chan_power_11d_t chanPwr[MAX_NO_OF_CHAN];
+        /** 11d number of channels */
+    u8 NoOfChan;
+} __ATTRIB_PACK__ parsed_region_chan_11d_t;
+
+/** Data for state machine */
+typedef struct _wlan_802_11d_state
+{
+        /** True for Enabling  11D*/
+    BOOLEAN Enable11D;
+} wlan_802_11d_state_t;
+
+typedef struct _region_code_mapping
+{
+        /** Region */
+    s8 region[COUNTRY_CODE_LEN];
+        /** Code */
+    u8 code;
+} region_code_mapping_t;
+
+/* function prototypes*/
+int wlan_generate_domain_info_11d(parsed_region_chan_11d_t *
+                                  parsed_region_chan,
+                                  wlan_802_11d_domain_reg_t * domaininfo);
+
+int wlan_parse_domain_info_11d(IEEEtypes_CountryInfoFullSet_t * CountryInfo,
+                               u8 band,
+                               parsed_region_chan_11d_t * parsed_region_chan);
+
+u8 wlan_get_scan_type_11d(u8 chan,
+                          parsed_region_chan_11d_t * parsed_region_chan);
+
+u32 chan_2_freq(u8 chan, u8 band);
+
+int wlan_set_domain_info_11d(wlan_private * priv);
+
+state_11d_t wlan_get_state_11d(wlan_private * priv);
+
+void wlan_init_11d(wlan_private * priv);
+
+int wlan_enable_11d(wlan_private * priv, state_11d_t flag);
+
+int wlan_set_universaltable(wlan_private * priv, u8 band);
+
+void wlan_generate_parsed_region_chan_11d(PREGION_CHANNEL region_chan,
+                                          parsed_region_chan_11d_t *
+                                          parsed_region_chan);
+
+int wlan_cmd_802_11d_domain_info(wlan_private * priv,
+                                 HostCmd_DS_COMMAND * cmd, u16 cmdno,
+                                 u16 CmdOption);
+
+int wlan_cmd_enable_11d(wlan_private * priv, struct iwreq *wrq);
+
+int wlan_ret_802_11d_domain_info(wlan_private * priv,
+                                 HostCmd_DS_COMMAND * resp);
+
+int wlan_parse_dnld_countryinfo_11d(wlan_private * priv);
+
+int wlan_create_dnld_countryinfo_11d(wlan_private * priv);
+
+#endif /* _WLAN_11D_ */
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_11h.c b/drivers/net/wireless/8688_wlan/wlan/wlan_11h.c
new file mode 100755
index 0000000..38e5392
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_11h.c
@@ -0,0 +1,1521 @@
+/**
+ * @file wlan_11h.c
+ *
+ *  @brief Implementation of 802.11h wlan_11h module
+ *
+ *  Driver implementation of the 11h standard.  Contains the following:
+ *    - application/driver ioctl interface functions
+ *    - firmware command preparation and response handling
+ *    - 11h element identification for elements passed in scan responses
+ *
+ *  Requires use of the following preprocessor define:
+ *    - ENABLE_802_11H
+ *
+ *  @sa wlan_11h.h
+ *  
+ *  (c) Copyright © 2003-2006, Marvell International Ltd.  
+ *  
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change Log:
+    9/30/05: Added DFS code, reorganized TPC code to match conventions
+   01/11/06: Add connected channel qualification to radar detection
+             requirement determination.  Update doxygen formatting.
+
+************************************************************/
+
+/*
+ * Include(s)
+ */
+#include "wlan_headers.h"
+
+/*
+ * Constants
+ */
+
+//! Default IBSS DFS recovery interval (in TBTTs); used for adhoc start
+#define WLAN_11H_DEFAULT_DFS_RECOVERY_INTERVAL   100
+
+//! Compiler control flag used to add quiet element to adhoc start command */
+#define WLAN_11H_ADD_QUIET_ELEMENT   1
+
+//! Default 11h power constraint used to offset the maximum transmit power
+#define WLAN_11H_TPC_POWERCONSTRAINT  0
+
+//! 11h TPC Power capability minimum setting, sent in TPC_INFO command to fw
+#define WLAN_11H_TPC_POWERCAPABILITY_MIN     5
+
+//! 11h TPC Power capability maximum setting, sent in TPC_INFO command to fw
+#define WLAN_11H_TPC_POWERCAPABILITY_MAX     20
+
+//! Regulatory requirement for the duration of a channel availability check
+#define WLAN_11H_CHANNEL_AVAIL_CHECK_DURATION    60000  /* in ms */
+
+//! U-NII sub-band config : Start Channel = 36, NumChans = 4
+static const
+    IEEEtypes_SupportChan_Subband_t wlan_11h_unii_lower_band = { 36, 4 };
+
+//! U-NII sub-band config : Start Channel = 52, NumChans = 4
+static const
+    IEEEtypes_SupportChan_Subband_t wlan_11h_unii_middle_band = { 52, 4 };
+
+//! U-NII sub-band config : Start Channel = 100, NumChans = 11
+static const
+    IEEEtypes_SupportChan_Subband_t wlan_11h_unii_mid_upper_band =
+    { 100, 11 };
+
+//! U-NII sub-band config : Start Channel = 149, NumChans = 4
+static const
+    IEEEtypes_SupportChan_Subband_t wlan_11h_unii_upper_band = { 149, 4 };
+
+/*
+ * Local types
+ */
+
+//! Internally passed structure used to send a CMD_802_11_TPC_INFO command
+typedef struct
+{
+    u8 Chan;                    //!< Channel to which the power constraint applies
+    u8 PowerConstraint;         //!< Local power constraint to send to firmware
+} wlan_11h_tpc_info_param_t;
+
+/**
+ *  @brief Utility function to get a random number based on the underlying OS
+ *
+ *  @return random integer
+ */
+static int
+wlan_11h_get_random_num(void)
+{
+    return jiffies;
+}
+
+/**
+ *  @brief Convert an IEEE formatted IE to 16-bit ID/Len Marvell
+ *         proprietary format
+ *
+ *  @param pOutBuf Output parameter: Buffer to output Marvell formatted IE
+ *  @param pInIe   Pointer to IEEE IE to be converted to Marvell format
+ *
+ *  @return        Number of bytes output to pOutBuf parameter return
+ */
+static int
+wlan_11h_convert_ieee_to_mrvl_ie(char *pOutBuf, const char *pInIe)
+{
+    MrvlIEtypesHeader_t mrvlIeHdr;
+    char *pTmpBuf = pOutBuf;
+
+    /* Assign the Element Id and Len to the Marvell struct attributes */
+    mrvlIeHdr.Type = wlan_cpu_to_le16(pInIe[0]);
+    mrvlIeHdr.Len = wlan_cpu_to_le16(pInIe[1]);
+
+    /* If the element ID is zero, return without doing any copying */
+    if (mrvlIeHdr.Type == 0) {
+        return 0;
+    }
+
+    /* Copy the header to the buffer pointer */
+    memcpy(pTmpBuf, &mrvlIeHdr, sizeof(mrvlIeHdr));
+
+    /* Increment the temp buffer pointer by the size appended */
+    pTmpBuf += sizeof(mrvlIeHdr);
+
+    /* Append the data section of the IE; length given by the IEEE IE length */
+    memcpy(pTmpBuf, pInIe + 2, pInIe[1]);
+
+    /* Return the number of bytes appended to pBuf */
+    return (sizeof(mrvlIeHdr) + pInIe[1]);
+}
+
+/**
+ *  @brief Setup the IBSS DFS element passed to the firmware in adhoc start
+ *         and join commands
+ *
+ *  The DFS Owner and recovery fields are set to be our MAC address and
+ *    a predetermined constant recovery value.  If we are joining an adhoc
+ *    network, these values are replaced with the existing IBSS values.
+ *    They are valid only when starting a new IBSS.
+ *
+ *  The IBSS DFS Element is variable in size based on the number of
+ *    channels supported in our current region.
+ *
+ *  @param priv Private driver information structure
+ *  @param pDfs Output parameter: Pointer to the IBSS DFS element setup by
+ *              this function.
+ *
+ *  @return
+ *    - Length of the returned element in pDfs output parameter
+ *    - 0 if returned element is not setup
+ */
+static int
+wlan_11h_set_ibss_dfs_ie(wlan_private * priv, IEEEtypes_IBSS_DFS_t * pDfs)
+{
+    int numChans = 0;
+    MeasRptBasicMap_t initialMap;
+    wlan_adapter *Adapter = priv->adapter;
+
+    PRINTM(INFO, "11h: IBSS DFS Element, 11D parsed region: %c%c (0x%x)\n",
+           Adapter->parsed_region_chan.CountryCode[0],
+           Adapter->parsed_region_chan.CountryCode[1],
+           Adapter->parsed_region_chan.region);
+
+    memset(pDfs, 0x00, sizeof(IEEEtypes_IBSS_DFS_t));
+
+    /*
+     * A basic measurement report is included with each channel in the
+     *   map field.  Initial value for the map for each supported channel
+     *   is with only the unmeasured bit set.
+     */
+    memset(&initialMap, 0x00, sizeof(initialMap));
+    initialMap.unmeasured = 1;
+
+    /* Set the DFS Owner and recovery interval fields */
+    memcpy(pDfs->dfsOwner, Adapter->CurrentAddr, sizeof(pDfs->dfsOwner));
+    pDfs->dfsRecoveryInterval = WLAN_11H_DEFAULT_DFS_RECOVERY_INTERVAL;
+
+    for (; (numChans < Adapter->parsed_region_chan.NoOfChan)
+         && (numChans < WLAN_11H_MAX_IBSS_DFS_CHANNELS); numChans++) {
+        pDfs->channelMap[numChans].channelNumber =
+            Adapter->parsed_region_chan.chanPwr[numChans].chan;
+
+        /*
+         * Set the inital map field with a basic measurement
+         */
+        pDfs->channelMap[numChans].rptMap = initialMap;
+    }
+
+    /*
+     * If we have an established channel map, include it and return
+     *   a valid DFS element
+     */
+    if (numChans) {
+        PRINTM(INFO, "11h: Added %d channels to IBSS DFS Map\n", numChans);
+
+        pDfs->elementId = IBSS_DFS;
+        pDfs->len =
+            (sizeof(pDfs->dfsOwner) + sizeof(pDfs->dfsRecoveryInterval)
+             + numChans * sizeof(IEEEtypes_ChannelMap_t));
+
+        return (pDfs->len + sizeof(pDfs->len) + sizeof(pDfs->elementId));
+    }
+
+    /* Ensure the element is zeroed out for an invalid return */
+    memset(pDfs, 0x00, sizeof(IEEEtypes_IBSS_DFS_t));
+
+    return 0;
+}
+
+/**
+ *  @brief Setup and return a Quiet element used in the start of an adhoc
+ *         network.
+ *
+ *  11h only allows the creator of an adhoc network, or the AP
+ *    in infrastructure mode, to specify quiet intervals.
+ *
+ *  @param pQuiet Output parameter: Pointer to the Quite Element setup
+ *                by this function.
+ *
+ *  @return
+ *     - Length of the returned element in pQuiet output parameter
+ *     - 0 if returned element is not setup
+ */
+static int
+wlan_11h_set_quiet_ie(IEEEtypes_Quiet_t * pQuiet)
+{
+    int retLen = 0;
+
+    /*
+     * Leave the Quiet element blank for now.  No current requirements
+     *   for its use and its use affects available bandwidth.
+     *
+     * Included to reserve space in the driver/FW interface and adhoc start
+     *   routines for its later usage.
+     */
+    memset(pQuiet, 0x00, sizeof(IEEEtypes_Quiet_t));
+
+#if WLAN_11H_ADD_QUIET_ELEMENT
+    /* Setup a quiet element for testing/demonstration purposes only */
+    pQuiet->elementId = QUIET;
+    pQuiet->len = (sizeof(pQuiet->quietCount) + sizeof(pQuiet->quietPeriod)
+                   + sizeof(pQuiet->quietDuration)
+                   + sizeof(pQuiet->quietOffset));
+
+    pQuiet->quietCount = 100;
+    pQuiet->quietPeriod = 200;
+    pQuiet->quietDuration = wlan_cpu_to_le16(50);
+    pQuiet->quietOffset = wlan_cpu_to_le16(50);
+
+    retLen = (pQuiet->len + sizeof(pQuiet->len) + sizeof(pQuiet->elementId));
+#endif
+
+    return retLen;
+}
+
+/**
+ *  @brief Setup the Supported Channel IE sent in association requests
+ *
+ *  The Supported Channels IE is requird to be sent when the spectrum
+ *    management capability (11h) is enabled.  The element contains a
+ *    starting channel and number of channels tuple for each subband
+ *    the STA supports.  This information is based on the operating region.
+ *
+ *  @param priv     Private driver information structure
+ *  @param pSupChan Output parameter: Pointer to the Supported Chan element
+ *                  setup by thsi function.
+ *
+ *  @return
+ *    - Length of the returned element in pSupChan output parameter
+ *    - 0 if returned element is not setup
+ */
+static int
+wlan_11h_set_supp_channels_ie(wlan_private * priv,
+                              IEEEtypes_SupportedChannels_t * pSupChan)
+{
+    int numSubbands = 0;
+    int retLen = 0;
+
+    memset(pSupChan, 0x00, sizeof(IEEEtypes_SupportedChannels_t));
+
+    /*
+     * Set the supported channel elements based on the region code,
+     *   incrementing numSubbands for each subband we append to the
+     *   element.
+     */
+    switch (priv->adapter->RegionCode) {
+    case 0x10:                 /* USA FCC  */
+    case 0x20:                 /* Canada IC    */
+        pSupChan->subband[numSubbands++] = wlan_11h_unii_lower_band;
+        pSupChan->subband[numSubbands++] = wlan_11h_unii_middle_band;
+#ifdef FCC_DFS_APPROVAL
+        pSupChan->subband[numSubbands++] = wlan_11h_unii_mid_upper_band;
+#endif
+        pSupChan->subband[numSubbands++] = wlan_11h_unii_upper_band;
+        break;
+    case 0x30:                 /* Europe ETSI  */
+        pSupChan->subband[numSubbands++] = wlan_11h_unii_lower_band;
+        pSupChan->subband[numSubbands++] = wlan_11h_unii_middle_band;
+        pSupChan->subband[numSubbands++] = wlan_11h_unii_mid_upper_band;
+        break;
+    default:
+        break;
+    }
+
+    /*
+     * If we have setup any supported subbands in the element, return a
+     *    valid IE along with its size, else return 0.
+     */
+    if (numSubbands) {
+        pSupChan->elementId = SUPPORTED_CHANNELS;
+        pSupChan->len = numSubbands * sizeof(IEEEtypes_SupportChan_Subband_t);
+
+        retLen = (pSupChan->len
+                  + sizeof(pSupChan->len) + sizeof(pSupChan->elementId));
+
+        HEXDUMP("11h: SupChan", (u8 *) pSupChan, retLen);
+    }
+
+    return retLen;
+}
+
+/**
+ *  @brief Prepare CMD_802_11_TPC_ADAPT_REQ firmware command
+ *
+ *  @param priv     Private driver information structure
+ *  @param pCmdPtr  Output parameter: Pointer to the command being prepared
+ *                  for the firmware
+ *  @param pInfoBuf HostCmd_DS_802_11_TPC_ADAPT_REQ passed as void data block
+ *
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_11h_cmd_tpc_request(wlan_private * priv,
+                         HostCmd_DS_COMMAND * pCmdPtr, const void *pInfoBuf)
+{
+    ENTER();
+
+    memcpy(&pCmdPtr->params.tpcReq, pInfoBuf,
+           sizeof(HostCmd_DS_802_11_TPC_ADAPT_REQ));
+
+    pCmdPtr->params.tpcReq.req.timeout =
+        wlan_cpu_to_le16(pCmdPtr->params.tpcReq.req.timeout);
+
+    /* Converted to little endian in wlan_11h_cmd_process */
+    pCmdPtr->Size = sizeof(HostCmd_DS_802_11_TPC_ADAPT_REQ) + S_DS_GEN;
+
+    HEXDUMP("11h: 11_TPC_ADAPT_REQ:", (u8 *) pCmdPtr, (int) pCmdPtr->Size);
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Prepare CMD_802_11_TPC_INFO firmware command
+ *
+ *  @param priv     Private driver information structure
+ *  @param pCmdPtr  Output parameter: Pointer to the command being prepared 
+ *                  for the firmware
+ *  @param pInfoBuf wlan_11h_tpc_info_param_t passed as void data block
+ *
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_11h_cmd_tpc_info(wlan_private * priv,
+                      HostCmd_DS_COMMAND * pCmdPtr, const void *pInfoBuf)
+{
+    HostCmd_DS_802_11_TPC_INFO *pTpcInfo = &pCmdPtr->params.tpcInfo;
+    MrvlIEtypes_LocalPowerConstraint_t *pConstraint =
+        &pTpcInfo->localConstraint;
+    MrvlIEtypes_PowerCapability_t *pCap = &pTpcInfo->powerCap;
+
+    wlan_11h_state_t *pState = &priv->adapter->state11h;
+    const wlan_11h_tpc_info_param_t *pTpcInfoParam = pInfoBuf;
+
+    ENTER();
+
+    pCap->MinPower = pState->minTxPowerCapability;
+    pCap->MaxPower = pState->maxTxPowerCapability;
+    pCap->Header.Len = wlan_cpu_to_le16(2);
+    pCap->Header.Type = wlan_cpu_to_le16(TLV_TYPE_POWER_CAPABILITY);
+
+    pConstraint->Chan = pTpcInfoParam->Chan;
+    pConstraint->Constraint = pTpcInfoParam->PowerConstraint;
+    pConstraint->Header.Type = wlan_cpu_to_le16(TLV_TYPE_POWER_CONSTRAINT);
+    pConstraint->Header.Len = wlan_cpu_to_le16(2);
+
+    /* Converted to little endian in wlan_11h_cmd_process */
+    pCmdPtr->Size = sizeof(HostCmd_DS_802_11_TPC_INFO) + S_DS_GEN;
+
+    HEXDUMP("11h: TPC INFO", (u8 *) pCmdPtr, (int) pCmdPtr->Size);
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief  Prepare CMD_802_11_CHAN_SW_ANN firmware command
+ *
+ *  @param priv     Private driver information structure
+ *  @param pCmdPtr  Output parameter: Pointer to the command being 
+ *                  prepared to for firmware
+ *  @param pInfoBuf HostCmd_DS_802_11_CHAN_SW_ANN passed as void data block
+ *
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_11h_cmd_chan_sw_ann(wlan_private * priv,
+                         HostCmd_DS_COMMAND * pCmdPtr, const void *pInfoBuf)
+{
+    const HostCmd_DS_802_11_CHAN_SW_ANN *pChSwAnn = pInfoBuf;
+
+    ENTER();
+
+    /* Converted to little endian in wlan_11h_cmd_process */
+    pCmdPtr->Size = sizeof(HostCmd_DS_802_11_CHAN_SW_ANN) + S_DS_GEN;
+
+    memcpy(&pCmdPtr->params.chan_sw_ann, pChSwAnn,
+           sizeof(HostCmd_DS_802_11_CHAN_SW_ANN));
+
+    PRINTM(INFO, "11h: ChSwAnn: %#x-%u, Seq=%u, Ret=%u\n",
+           pCmdPtr->Command, pCmdPtr->Size, pCmdPtr->SeqNum, pCmdPtr->Result);
+    PRINTM(INFO, "11h: ChSwAnn: Ch=%d, Cnt=%d, Mode=%d\n",
+           pChSwAnn->newChan, pChSwAnn->switchCount, pChSwAnn->switchMode);
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Set the local power constraint in the firmware
+ *
+ *  Construct and send a CMD_802_11_TPC_INFO command with the local power
+ *    constraint.
+ *
+ *  @param priv            Private driver information structure
+ *  @param channel         Channel to which the power constraint applies
+ *  @param powerConstraint Power constraint to be applied on the channel
+ *
+ *  @return                WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_11h_set_local_power_constraint(wlan_private * priv,
+                                    u8 channel, u8 powerConstraint)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    wlan_11h_tpc_info_param_t tpcInfoParam;
+
+    tpcInfoParam.Chan = channel;
+    tpcInfoParam.PowerConstraint = powerConstraint;
+
+    PRINTM(INFO, "11h: Set Local Constraint = %d\n",
+           tpcInfoParam.PowerConstraint);
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_TPC_INFO,
+                           HostCmd_ACT_GEN_SET, 0, 0, &tpcInfoParam);
+
+    if (ret) {
+        PRINTM(INFO, "11h: Err: Send TPC_INFO CMD: %d\n", ret);
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/**
+ *  @brief  Utility function to process a join to an infrastructure BSS
+ *
+ *  @param priv        Private driver information structure
+ *  @param ppBuffer    Output parameter: Pointer to the TLV output buffer,
+ *                     modified on return to point after the appended 11h TLVs
+ *  @param channel     Channel on which we are joining the BSS
+ *  @param p11hBssInfo Pointer to the 11h BSS information for this network
+ *                     that was parsed out of the scan response.
+ *
+ *  @return            Integer number of bytes appended to the TLV output
+ *                     buffer (ppBuffer)
+ */
+static int
+wlan_11h_process_infra_join(wlan_private * priv,
+                            u8 ** ppBuffer,
+                            uint channel, wlan_11h_bss_info_t * p11hBssInfo)
+{
+    MrvlIEtypesHeader_t ieHeader;
+    IEEEtypes_SupportedChannels_t supChanIe;
+    int retLen = 0;
+    int supChanLen = 0;
+
+    /* Null Checks */
+    if (ppBuffer == 0)
+        return 0;
+    if (*ppBuffer == 0)
+        return 0;
+
+    /* Set the local constraint configured in the firmware */
+    wlan_11h_set_local_power_constraint(priv, channel,
+                                        (p11hBssInfo->
+                                         powerConstraint.localConstraint));
+
+    /* Setup the Supported Channels IE */
+    supChanLen = wlan_11h_set_supp_channels_ie(priv, &supChanIe);
+
+    /*
+     * If we returned a valid Supported Channels IE, wrap and append it
+     */
+    if (supChanLen) {
+        /* Wrap the supported channels IE with a passthrough TLV type */
+        ieHeader.Type = cpu_to_le16(TLV_TYPE_PASSTHROUGH);
+        ieHeader.Len = supChanLen;
+        memcpy(*ppBuffer, &ieHeader, sizeof(ieHeader));
+
+        /* Increment the return size and the return buffer pointer param */
+        *ppBuffer += sizeof(ieHeader);
+        retLen += sizeof(ieHeader);
+
+        /* Copy the supported channels IE to the output buf, advance pointer */
+        memcpy(*ppBuffer, &supChanIe, supChanLen);
+        *ppBuffer += supChanLen;
+        retLen += supChanLen;
+    }
+
+    return retLen;
+}
+
+/**
+ *  @brief Utility function to process a start or join to an adhoc network
+ *
+ *  Add the elements to the TLV buffer needed in the start/join adhoc commands:
+ *       - IBSS DFS IE
+ *       - Quiet IE
+ *
+ *  Also send the local constraint to the firmware in a TPC_INFO command.
+ *
+ *  @param priv        Private driver information structure
+ *  @param ppBuffer    Output parameter: Pointer to the TLV output buffer,
+ *                     modified on return to point after the appended 11h TLVs
+ *  @param channel     Channel on which we are starting/joining the IBSS
+ *  @param p11hBssInfo Pointer to the 11h BSS information for this network
+ *                     that was parsed out of the scan response.  NULL
+ *                     indicates we are starting the adhoc network
+ *
+ *  @return            Integer number of bytes appended to the TLV output
+ *                     buffer (ppBuffer)
+ */
+static int
+wlan_11h_process_adhoc(wlan_private * priv,
+                       u8 ** ppBuffer,
+                       uint channel, wlan_11h_bss_info_t * p11hBssInfo)
+{
+    IEEEtypes_IBSS_DFS_t dfsElem;
+    IEEEtypes_Quiet_t quietElem;
+    int sizeAppended;
+    int retLen = 0;
+    s8 localConstraint;
+
+    /* Format our own IBSS DFS Element.  Include our channel map fields */
+    wlan_11h_set_ibss_dfs_ie(priv, &dfsElem);
+
+    if (p11hBssInfo) {
+        /*
+         * Copy the DFS Owner/Recovery Interval from the BSS we are joining
+         */
+        memcpy(dfsElem.dfsOwner,
+               p11hBssInfo->ibssDfs.dfsOwner, sizeof(dfsElem.dfsOwner));
+        dfsElem.dfsRecoveryInterval =
+            p11hBssInfo->ibssDfs.dfsRecoveryInterval;
+    }
+
+    /* Append the dfs element to the TLV buffer */
+    sizeAppended = wlan_11h_convert_ieee_to_mrvl_ie(*ppBuffer,
+                                                    (u8 *) & dfsElem);
+
+    HEXDUMP("11h: IBSS-DFS", (void *) *ppBuffer, sizeAppended);
+    *ppBuffer += sizeAppended;
+    retLen += sizeAppended;
+
+    /*
+     * Check to see if we are joining a network.  Join is indicated by the
+     *   BSS Info pointer being valid (not NULL)
+     */
+    if (p11hBssInfo) {
+        /*
+         * If there was a quiet element, include it in adhoc join command
+         */
+        if (p11hBssInfo->quiet.elementId == QUIET) {
+            sizeAppended
+                = wlan_11h_convert_ieee_to_mrvl_ie(*ppBuffer,
+                                                   (u8 *) & p11hBssInfo->
+                                                   quiet);
+            HEXDUMP("11h: Quiet", (void *) *ppBuffer, sizeAppended);
+            *ppBuffer += sizeAppended;
+            retLen += sizeAppended;
+        }
+
+        /* Copy the local constraint from the network */
+        localConstraint = p11hBssInfo->powerConstraint.localConstraint;
+    } else {
+        /*
+         * If we are the adhoc starter, we can add a quiet element
+         */
+        wlan_11h_set_quiet_ie(&quietElem);
+        sizeAppended = wlan_11h_convert_ieee_to_mrvl_ie(*ppBuffer,
+                                                        (u8 *) & quietElem);
+        HEXDUMP("11h: Quiet", (void *) *ppBuffer, sizeAppended);
+        *ppBuffer += sizeAppended;
+        retLen += sizeAppended;
+
+        /* Use the localConstraint configured in the driver state */
+        localConstraint = priv->adapter->state11h.usrDefPowerConstraint;
+    }
+
+    /* Set the local constraint configured in the firmware */
+    wlan_11h_set_local_power_constraint(priv, channel, localConstraint);
+
+    return retLen;
+}
+
+/**
+ *  @brief Return whether the driver is currently setup to use 11h for
+ *         adhoc start.
+ *
+ *  Association/Join commands are dyanmic in that they enable 11h in the
+ *    driver/firmware when they are detected in the existing BSS.
+ *
+ *  @param priv  Private driver information structure
+ *
+ *  @return
+ *    - TRUE if 11h is enabled
+ *    - FALSE otherwise
+ */
+static int
+wlan_11h_is_enabled(wlan_private * priv)
+{
+    wlan_11h_state_t *pState11h = &priv->adapter->state11h;
+
+    return (pState11h->is11hEnabled ? TRUE : FALSE);
+}
+
+/**
+ *  @brief Query 11h firmware enabled state.
+ *
+ *  Return whether the firmware currently has 11h extensions enabled
+ *
+ *  @param priv  Private driver information structure
+ *
+ *  @return
+ *    - TRUE if 11h has been activated in the firmware
+ *    - FALSE otherwise
+ *
+ *  @sa wlan_11h_activate
+ */
+int
+wlan_11h_is_active(wlan_private * priv)
+{
+    wlan_11h_state_t *pState11h = &priv->adapter->state11h;
+
+    return (pState11h->is11hActive ? TRUE : FALSE);
+}
+
+/**
+ *  @brief Query 11h driver tx enable/disable state at the driver/application
+ *         layer
+ *
+ *  @param priv  Private driver information structure
+ *
+ *  @return
+ *    - TRUE if 11h has disabled the transmit interface
+ *    - FALSE otherwise
+ */
+int
+wlan_11h_is_tx_disabled(wlan_private * priv)
+{
+    wlan_11h_state_t *pState11h = &priv->adapter->state11h;
+
+    return (pState11h->txDisabled);
+}
+
+/**
+ *  @brief Disable the transmit interface and record the state.
+ *
+ *  @param priv  Private driver information structure
+ *
+ *  @return      void
+ */
+void
+wlan_11h_tx_disable(wlan_private * priv)
+{
+    wlan_11h_state_t *pState11h = &priv->adapter->state11h;
+
+    pState11h->txDisabled = TRUE;
+
+    os_carrier_off(priv);
+}
+
+/**
+ *  @brief Enable the transmit interface and record the state.
+ *
+ *  @param priv  Private driver information structure
+ *
+ *  @return      void
+ */
+void
+wlan_11h_tx_enable(wlan_private * priv)
+{
+    wlan_11h_state_t *pState11h = &priv->adapter->state11h;
+
+    os_carrier_on(priv);
+
+    pState11h->txDisabled = FALSE;
+}
+
+/**
+ *  @brief Enable or Disable the 11h extensions in the firmware
+ *
+ *  @param priv  Private driver information structure
+ *  @param flag  Enable 11h if TRUE, disable otherwise
+ *
+ *  @return      WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_11h_activate(wlan_private * priv, int flag)
+{
+    wlan_11h_state_t *pState11h = &priv->adapter->state11h;
+    int enable = flag ? 1 : 0;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    /*
+     * Send cmd to FW to enable/disable 11h function in firmware
+     */
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_SNMP_MIB,
+                           HostCmd_ACT_GEN_SET,
+                           HostCmd_OPTION_WAITFORRSP, Dot11H_i, &enable);
+
+    if (ret) {
+        ret = WLAN_STATUS_FAILURE;
+    } else {
+        /* Set boolean flag in driver 11h state */
+        pState11h->is11hActive = flag;
+    }
+
+    PRINTM(INFO, "11h: %s\n", enable ? "Activate" : "Deactivate");
+
+    LEAVE();
+
+    return ret;
+}
+
+/**
+ *
+ *  @brief Initialize the 11h parameters and enable 11h when starting an IBSS
+ *
+ *  @param priv  Private driver information structure
+ *
+ *  @return      void
+ */
+void
+wlan_11h_init(wlan_private * priv)
+{
+    wlan_11h_state_t *pState11h = &priv->adapter->state11h;
+
+    ENTER();
+
+    pState11h->usrDefPowerConstraint = WLAN_11H_TPC_POWERCONSTRAINT;
+    pState11h->minTxPowerCapability = WLAN_11H_TPC_POWERCAPABILITY_MIN;
+    pState11h->maxTxPowerCapability = WLAN_11H_TPC_POWERCAPABILITY_MAX;
+
+    /*
+     * By default, the driver should have its preference set as 11h being
+     *    activated when starting an ad hoc network.  For infrastructre
+     *    and ad hoc join, 11h will be sensed and activated accordingly.
+     */
+    pState11h->is11hEnabled = TRUE;
+
+    /*
+     * On power up, the firmware should have 11h support inactive.
+     */
+    pState11h->is11hActive = FALSE;
+
+    LEAVE();
+}
+
+/**
+ *  @brief Retrieve a randomly selected starting channel if needed for 11h
+ *
+ *  If 11h is enabled enabled and an A-Band channel start band preference
+ *    configured in the driver, the start channel must be random in order
+ *    to meet with
+ *
+ *  @param priv  Private driver information structure
+ *
+ *  @return      Integer starting channel
+ */
+int
+wlan_11h_get_adhoc_start_channel(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    unsigned int startChn;
+    int region;
+    int randEntry;
+    REGION_CHANNEL *chnTbl;
+
+    ENTER();
+
+    /*
+     * Set startChn to the Default.  Used if 11h is disabled or the band
+     *   does not require 11h support.
+     */
+    startChn = DEFAULT_AD_HOC_CHANNEL;
+
+    /*
+     * Check that we are looking for a channel in the A Band
+     */
+    if (Adapter->adhoc_start_band == BAND_A) {
+        /*
+         * Set default to the A Band default. Used if random selection fails
+         *   or if 11h is not enabled
+         */
+        startChn = DEFAULT_AD_HOC_CHANNEL_A;
+
+        /*
+         * Check that 11h is enabled in the driver
+         */
+        if (wlan_11h_is_enabled(priv)) {
+            /*
+             * Search the region_channel tables for a channel table
+             *   that is marked for the A Band.
+             */
+            for (region = 0; (region < MAX_REGION_CHANNEL_NUM); region++) {
+                chnTbl = Adapter->region_channel + region;
+
+                /* Check if table is valid and marked for A Band */
+                if (chnTbl->Valid
+                    && chnTbl->Region == Adapter->RegionCode
+                    && chnTbl->Band & BAND_A) {
+                    /*
+                     * Set the start channel.  Get a random number and
+                     *   use it to pick an entry in the table between 0
+                     *   and the number of channels in the table (NrCFP).
+                     */
+                    randEntry = wlan_11h_get_random_num() % chnTbl->NrCFP;
+                    startChn = chnTbl->CFP[randEntry].Channel;
+                }
+            }
+        }
+    }
+
+    PRINTM(INFO, "11h: %s: AdHoc Channel set to %u\n",
+           wlan_11h_is_enabled(priv) ? "Enabled" : "Disabled", startChn);
+
+    LEAVE();
+
+    return startChn;
+}
+
+/**
+ *  @brief Check if the current region's regulations require the input channel
+ *         to be scanned for radar.
+ *
+ *  Based on staticly defined requirements for sub-bands per regulatory
+ *    agency requirements.
+ *
+ *  Used in adhoc start to determine if channel availabiilty check is required
+ *
+ *  @param priv    Private driver information structure
+ *  @param channel Channel to determine radar detection requirements
+ *
+ *  @return
+ *    - TRUE if radar detection is required
+ *    - FALSE otherwise
+ *
+ *  @sa wlan_11h_radar_detected
+ */
+int
+wlan_11h_radar_detect_required(wlan_private * priv, u8 channel)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int required;
+
+    /*
+     * Assume that radar detection is required unless exempted below.
+     *   No checks for 11h or measurement code  being enabled is placed here
+     *   since regulatory requirements exist whether we support them or not.
+     */
+    required = TRUE;
+
+    switch (priv->adapter->RegionCode) {
+    case 0x10:                 /* USA FCC  */
+    case 0x20:                 /* Canada IC    */
+#ifndef FCC_DFS_APPROVAL
+        /*
+         * FCC does not yet require radar detection in the
+         *   5.25-5.35 (U-NII middle) band
+         */
+        if (channel >= wlan_11h_unii_middle_band.startChan &&
+            channel < wlan_11h_unii_mid_upper_band.startChan) {
+            required = FALSE;
+        }
+
+        /*
+         * Fall through to check other bands
+         */
+#endif
+    case 0x30:                 /* Europe ETSI  */
+        /*
+         * Radar detection is not required in the
+         *   5.15-5.25 (U-NII lower) and 5.725-5.825 (U-NII upper) bands
+         */
+        if (channel < wlan_11h_unii_middle_band.startChan ||
+            channel >= wlan_11h_unii_upper_band.startChan) {
+            /* Radar detection not required */
+            required = FALSE;
+        }
+        break;
+    default:
+        break;
+    }
+
+    PRINTM(INFO, "11h: Radar detection in region %#02x "
+           "is %srequired for channel %d\n",
+           priv->adapter->RegionCode, (required ? "" : "NOT "), channel);
+
+    if (required == TRUE
+        && Adapter->MediaConnectStatus == WlanMediaStateConnected
+        && Adapter->CurBssParams.BSSDescriptor.Channel == channel) {
+        required = FALSE;
+
+        PRINTM(INFO, "11h: Radar detection not required. "
+               "Already operating on the channel");
+    }
+
+    return required;
+}
+
+/**
+ *  @brief Perform a radar measuremnt and report the result if required on
+ *         given channel
+ *
+ *  Check to see if the provided channel requires a channel availability
+ *    check (60 second radar detection measurement).  If required, perform
+ *    measurement, stalling calling thread until the measurement completes
+ *    and then report result.
+ *
+ *  Used when starting an adhoc network.
+ *
+ *  @param priv    Private driver information structure
+ *  @param channel Channel on which to perform radar measurement
+ *
+ *  @return
+ *    - TRUE if radar has been detected
+ *    - FALSE if radar detection is not required or radar has not been detected
+ *
+ *  @sa wlan_11h_radar_detect_required
+ */
+int
+wlan_11h_radar_detected(wlan_private * priv, u8 channel)
+{
+    int ret;
+
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_MEASUREMENT_REQUEST measReq;
+    HostCmd_DS_MEASUREMENT_REPORT measRpt;
+
+    /*
+     * If the channel requires radar, default the return value to it being
+     *   detected.
+     */
+    ret = wlan_11h_radar_detect_required(priv, channel);
+
+    memset(&measReq, 0x00, sizeof(measReq));
+    memset(&measRpt, 0x00, sizeof(measRpt));
+
+    /*
+     * Send a basic measurement request on the indicated channel for the
+     *   required channel availability check time.
+     */
+    measReq.measType = WLAN_MEAS_BASIC;
+    measReq.req.basic.channel = channel;
+    measReq.req.basic.duration = WLAN_11H_CHANNEL_AVAIL_CHECK_DURATION;
+
+    /*
+     * Set the STA that we are requesting the measurement from to our own
+     *   mac address, causing our firmware to perform the measurement itself
+     */
+    memcpy(measReq.macAddr, Adapter->CurrentAddr, sizeof(measReq.macAddr));
+
+    /*
+     * Send the measurement request and timeout duration to wait for
+     *   the command to pend until the measurement report is received
+     *   from the firmware.  If the command fails, the default ret value set
+     *   above will be returned.
+     */
+    if (wlan_meas_util_send_req(priv, &measReq,
+                                measReq.req.basic.duration, &measRpt) == 0) {
+        /*
+         * If the report indicates no measurement was done, leave the default
+         *   return value alone.
+         */
+        if (measRpt.rpt.basic.map.unmeasured == 0) {
+            /*
+             * Set the return value based on the radar indication bit
+             */
+            ret = measRpt.rpt.basic.map.radar ? TRUE : FALSE;
+        }
+    }
+    return ret;
+}
+
+/**
+ *  @brief Process an TLV buffer for a pending BSS Adhoc start command.
+ *
+ *  Activate 11h functionality in the firmware if driver has is enabled
+ *    for 11h (configured by the application via IOCTL).
+ *
+ *  @param priv        Private driver information structure
+ *  @param ppBuffer    Output parameter: Pointer to the TLV output buffer, 
+ *                     modified on return to point after the appended 11h TLVs
+ *  @param pCapInfo    Pointer to the capability info for the BSS to join
+ *  @param channel     Channel on which we are starting the IBSS
+ *  @param p11hBssInfo Input/Output parameter: Pointer to the 11h BSS 
+ *                     information for this network that we are establishing.
+ *                     11h sensed flag set on output if warranted.
+ *
+ *  @return            Integer number of bytes appended to the TLV output
+ *                     buffer (ppBuffer)
+ *
+ */
+int
+wlan_11h_process_start(wlan_private * priv,
+                       u8 ** ppBuffer,
+                       IEEEtypes_CapInfo_t * pCapInfo,
+                       uint channel, wlan_11h_bss_info_t * p11hBssInfo)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = 0;
+
+    if (wlan_11h_is_enabled(priv) && (Adapter->adhoc_start_band == BAND_A)) {
+        if (wlan_get_state_11d(priv) == DISABLE_11D) {
+            /* No use having 11h enabled without 11d enabled */
+            wlan_enable_11d(priv, ENABLE_11D);
+            wlan_create_dnld_countryinfo_11d(priv);
+        }
+
+        /* Activate 11h functions in firmware, turns on capability bit */
+        wlan_11h_activate(priv, TRUE);
+        pCapInfo->SpectrumMgmt = 1;
+
+        /* Set flag indicating this BSS we are starting is using 11h */
+        p11hBssInfo->sensed11h = TRUE;
+
+        ret = wlan_11h_process_adhoc(priv, ppBuffer, channel, NULL);
+    } else {
+        /* Deactivate 11h functions in the firmware */
+        wlan_11h_activate(priv, FALSE);
+        pCapInfo->SpectrumMgmt = 0;
+    }
+
+    return ret;
+}
+
+/**
+ *  @brief Process an TLV buffer for a pending BSS Join command for
+ *         both adhoc and infra networks
+ *
+ *  The TLV command processing for a BSS join for either adhoc or
+ *    infrastructure network is performed with this function.  The
+ *    capability bits are inspected for the IBSS flag and the appropriate
+ *    local routines are called to setup the necessary TLVs.
+ *
+ *  Activate 11h functionality in the firmware if the spectrum management
+ *    capability bit is found in the network infromation for the BSS we are
+ *    joining.
+ *
+ *  @param priv        Private driver information structure
+ *  @param ppBuffer    Output parameter: Pointer to the TLV output buffer, 
+ *                     modified on return to point after the appended 11h TLVs
+ *  @param pCapInfo    Pointer to the capability info for the BSS to join
+ *  @param channel     Channel on which we are joining the BSS
+ *  @param p11hBssInfo Pointer to the 11h BSS information for this
+ *                     network that was parsed out of the scan response.
+ *
+ *  @return            Integer number of bytes appended to the TLV output
+ *                     buffer (ppBuffer), WLAN_STATUS_FAILURE (-1), 
+ *                     or WLAN_STATUS_SUCCESS (0)
+ */
+int
+wlan_11h_process_join(wlan_private * priv,
+                      u8 ** ppBuffer,
+                      IEEEtypes_CapInfo_t * pCapInfo,
+                      uint channel, wlan_11h_bss_info_t * p11hBssInfo)
+{
+    int ret = 0;
+
+    ENTER();
+
+    if (priv->adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        if (wlan_11h_is_active(priv) == p11hBssInfo->sensed11h) {
+            /* Assume DFS parameters are the same for roaming as long as
+             *   the current & next APs have the same spectrum mgmt capability
+             *   bit setting
+             */
+            ret = WLAN_STATUS_SUCCESS;
+
+        } else {
+            /* No support for roaming between DFS/non-DFS yet */
+            ret = WLAN_STATUS_FAILURE;
+        }
+
+        LEAVE();
+        return ret;
+    }
+
+    if (p11hBssInfo->sensed11h) {
+        /* No use having 11h enabled without 11d enabled */
+        wlan_enable_11d(priv, ENABLE_11D);
+        wlan_parse_dnld_countryinfo_11d(priv);
+
+        /* Activate 11h functions in firmware, turns on capability bit */
+        wlan_11h_activate(priv, TRUE);
+        pCapInfo->SpectrumMgmt = 1;
+
+        if (pCapInfo->Ibss) {
+            PRINTM(INFO, "11h: Adhoc join: Sensed\n");
+            ret = wlan_11h_process_adhoc(priv, ppBuffer, channel,
+                                         p11hBssInfo);
+        } else {
+            PRINTM(INFO, "11h: Infra join: Sensed\n");
+            ret = wlan_11h_process_infra_join(priv, ppBuffer,
+                                              channel, p11hBssInfo);
+        }
+    } else {
+        /* Deactivate 11h functions in the firmware */
+        wlan_11h_activate(priv, FALSE);
+        pCapInfo->SpectrumMgmt = 0;
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/**
+ *
+ *  @brief  Prepare the HostCmd_DS_Command structure for an 11h command.
+ *
+ *  Use the Command field to determine if the command being set up is for
+ *     11h and call one of the local command handlers accordingly for:
+ *
+ *        - HostCmd_CMD_802_11_TPC_ADAPT_REQ
+ *        - HostCmd_CMD_802_11_TPC_INFO
+ *        - HostCmd_CMD_802_11_CHAN_SW_ANN
+ *
+ *  @param priv     Private driver information structure
+ *  @param pCmdPtr  Output parameter: Pointer to the command being prepared 
+ *                  for the firmware
+ *  @param pInfoBuf Void buffer passthrough with data necessary for a
+ *                  specific command type
+ *
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ *
+ *  @sa wlan_11h_cmd_tpc_request
+ *  @sa wlan_11h_cmd_tpc_info
+ *  @sa wlan_11h_cmd_chan_sw_ann
+ */
+int
+wlan_11h_cmd_process(wlan_private * priv,
+                     HostCmd_DS_COMMAND * pCmdPtr, const void *pInfoBuf)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    switch (pCmdPtr->Command) {
+    case HostCmd_CMD_802_11_TPC_ADAPT_REQ:
+        ret = wlan_11h_cmd_tpc_request(priv, pCmdPtr, pInfoBuf);
+        break;
+    case HostCmd_CMD_802_11_TPC_INFO:
+        ret = wlan_11h_cmd_tpc_info(priv, pCmdPtr, pInfoBuf);
+        break;
+    case HostCmd_CMD_802_11_CHAN_SW_ANN:
+        ret = wlan_11h_cmd_chan_sw_ann(priv, pCmdPtr, pInfoBuf);
+        break;
+    default:
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    pCmdPtr->Command = wlan_cpu_to_le16(pCmdPtr->Command);
+    pCmdPtr->Size = wlan_cpu_to_le16(pCmdPtr->Size);
+
+    return ret;
+}
+
+/**
+ *  @brief Handle the command response from the firmware if from an 11h command
+ *
+ *  Use the Command field to determine if the command response being
+ *    is for 11h.  Call the local command response handler accordingly for:
+ *
+ *        - HostCmd_CMD_802_11_TPC_ADAPT_REQ
+ *        - HostCmd_CMD_802_11_TPC_INFO
+ *        - HostCmd_CMD_802_11_CHAN_SW_ANN
+ *
+ *  @param priv  Private driver information structure
+ *  @param resp  HostCmd_DS_COMMAND struct returned from the firmware
+ *               command
+ *
+ *  @return      WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_11h_cmdresp_process(wlan_private * priv, const HostCmd_DS_COMMAND * resp)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    switch (resp->Command) {
+    case HostCmd_CMD_802_11_TPC_ADAPT_REQ:
+        HEXDUMP("11h: TPC REQUEST Rsp:", (u8 *) resp, (int) resp->Size);
+        memcpy(priv->adapter->CurCmd->pdata_buf,
+               &resp->params.tpcReq, sizeof(HostCmd_DS_802_11_TPC_ADAPT_REQ));
+        break;
+
+    case HostCmd_CMD_802_11_TPC_INFO:
+        HEXDUMP("11h: TPC INFO Rsp Data:", (u8 *) resp, (int) resp->Size);
+        break;
+
+    case HostCmd_CMD_802_11_CHAN_SW_ANN:
+        PRINTM(INFO, "11h: Ret ChSwAnn: Sz=%u, Seq=%u, Ret=%u\n",
+               resp->Size, resp->SeqNum, resp->Result);
+        break;
+
+    default:
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    return ret;
+}
+
+/**
+ *  @brief Process an element from a scan response, copy relevant info for 11h
+ *
+ *  @param p11hBssInfo  Output parameter: Pointer to the 11h BSS information
+ *                      for the network that is being processed
+ *  @param pElement     Pointer to the current IE we are inspecting for 11h
+ *                      relevance
+ *
+ *  @return             WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_11h_process_bss_elem(wlan_11h_bss_info_t * p11hBssInfo,
+                          const u8 * pElement)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    switch (*pElement) {
+    case POWER_CONSTRAINT:
+        PRINTM(INFO, "11h: Power Constraint IE Found\n");
+        p11hBssInfo->sensed11h = 1;
+        memcpy(&p11hBssInfo->powerConstraint, pElement,
+               sizeof(IEEEtypes_PowerConstraint_t));
+        break;
+
+    case POWER_CAPABILITY:
+        PRINTM(INFO, "11h: Power Capability IE Found\n");
+        p11hBssInfo->sensed11h = 1;
+        memcpy(&p11hBssInfo->powerCapability, pElement,
+               sizeof(IEEEtypes_PowerCapability_t));
+        break;
+
+    case TPC_REPORT:
+        PRINTM(INFO, "11h: Tpc Report IE Found\n");
+        p11hBssInfo->sensed11h = 1;
+        memcpy(&p11hBssInfo->tpcReport, pElement,
+               sizeof(IEEEtypes_TPCReport_t));
+        break;
+
+    case CHANNEL_SWITCH_ANN:
+        p11hBssInfo->sensed11h = 1;
+        PRINTM(INFO, "11h: Channel Switch Ann IE Found\n");
+        break;
+
+    case QUIET:
+        PRINTM(INFO, "11h: Quiet IE Found\n");
+        p11hBssInfo->sensed11h = 1;
+        memcpy(&p11hBssInfo->quiet, pElement, sizeof(IEEEtypes_Quiet_t));
+        break;
+
+    case IBSS_DFS:
+        PRINTM(INFO, "11h: Ibss Dfs IE Found\n");
+        p11hBssInfo->sensed11h = 1;
+        memcpy(&p11hBssInfo->ibssDfs, pElement, sizeof(IEEEtypes_IBSS_DFS_t));
+        break;
+
+    case SUPPORTED_CHANNELS:
+    case TPC_REQUEST:
+        /*
+         * These elements are not in beacons/probe responses.  Included here
+         *   to cover set of enumerated 11h elements.
+         */
+        break;
+
+    default:
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    return ret;
+}
+
+/**
+ *  @brief IOCTL handler to send a channel switch announcment via
+ *         firmware command
+ *
+ *  @param priv  Private driver information structure
+ *  @param wrq   OS IOCTL passed structure encoded with a 
+ *               HostCmd_DS_802_11_CHAN_SW_ANN structure
+ *
+ *  @return
+ *    - 0 for success
+ *    - -EPROTO if 11h is not active in the firmware
+ *    - -EFAULT if memory copy from user space
+ *    - Error return from wlan_prepare_cmd routine otherwise
+ *             
+ */
+int
+wlan_11h_ioctl_chan_sw_ann(wlan_private * priv, struct iwreq *wrq)
+{
+    HostCmd_DS_802_11_CHAN_SW_ANN chSwParams;
+    int ret;
+
+    ENTER();
+
+    if (!wlan_11h_is_active(priv)) {
+        ret = -EPROTO;
+    } else if (copy_from_user(&chSwParams, wrq->u.data.pointer,
+                              sizeof(chSwParams)) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "11h: ioctl_chan_sw_ann: copy from user failed\n");
+        ret = -EFAULT;
+    } else {
+        /*
+         * Send the channel switch announcment to firmware
+         */
+
+        ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_CHAN_SW_ANN,
+                               HostCmd_ACT_GEN_SET,
+                               0, 0, (void *) &chSwParams);
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/**
+ *  @brief IOCTL handler to return the user defined local power constraint
+ *
+ *  @param priv Private driver information structure
+ *  @param wrq  Input/Output parameter: OS IOCTL passed structure.  Used to set
+ *              the local power constraint if supplied on input.  Currently
+ *              defined local power constraint provided on output.
+ *
+ *  @return
+ *    - 0 for success in all cases
+ */
+int
+wlan_11h_ioctl_get_local_power(wlan_private * priv, struct iwreq *wrq)
+{
+    int data;
+    s8 *localpowerPtr = &priv->adapter->state11h.usrDefPowerConstraint;
+    int localpower;
+
+    ENTER();
+
+    if (wrq->u.data.length != 0) {
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+        *localpowerPtr = (s8) data;
+    }
+
+    localpower = *localpowerPtr;
+    if (copy_to_user(wrq->u.data.pointer, &localpower, sizeof(int))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    wrq->u.data.length = 1;
+
+    LEAVE();
+
+    return 0;
+}
+
+/**
+ *  @brief IOCTL handler to send a TPC request to a given STA address.
+ *
+ *  @param priv Private driver information structure
+ *  @param wrq  Input/Output parmeter: OS IOCTL passed structure containing:
+ *                 - wlan_ioctl_11h_tpc_req on input
+ *                 - wlan_ioctl_11h_tpc_resp on output if successful
+ *
+ *  @return
+ *    - 0 for success
+ *    - -EPROTO if 11h is not active in the firmware
+ *    - -EFAULT if memory copy from user space 
+ *    - Error return from wlan_prepare_cmd routine otherwise
+ */
+int
+wlan_11h_ioctl_request_tpc(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_11h_tpc_req tpcIoctlReq;
+    wlan_ioctl_11h_tpc_resp tpcIoctlResp;
+    HostCmd_DS_802_11_TPC_ADAPT_REQ tpcReq;
+
+    int ret = 0;
+
+    ENTER();
+
+    if (!wlan_11h_is_active(priv)) {
+        ret = -EPROTO;
+    } else if (copy_from_user(&tpcIoctlReq, wrq->u.data.pointer,
+                              sizeof(tpcIoctlReq)) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "11h: ioctl_request_tpc: copy from user failed\n");
+        ret = -EFAULT;
+    } else {
+        PRINTM(INFO, "11h: ioctl_request_tpc req: "
+               "%02x:%02x:%02x:%02x:%02x:%02x, rateIdx(%d), timeout(%d)\n",
+               tpcIoctlReq.destMac[0], tpcIoctlReq.destMac[1],
+               tpcIoctlReq.destMac[2], tpcIoctlReq.destMac[3],
+               tpcIoctlReq.destMac[4], tpcIoctlReq.destMac[5],
+               tpcIoctlReq.rateIndex, tpcIoctlReq.timeout);
+
+        memset(&tpcReq, 0, sizeof(tpcReq));
+        memset(&tpcIoctlResp, 0, sizeof(tpcIoctlResp));
+
+        memcpy(tpcReq.req.destMac, tpcIoctlReq.destMac,
+               sizeof(tpcReq.req.destMac));
+        tpcReq.req.rateIndex = tpcIoctlReq.rateIndex;
+        tpcReq.req.timeout = tpcIoctlReq.timeout;
+
+        ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_TPC_ADAPT_REQ,
+                               HostCmd_ACT_GEN_SET,
+                               HostCmd_OPTION_WAITFORRSP, 0, &tpcReq);
+
+        if (ret == 0) {
+            tpcIoctlResp.statusCode = tpcReq.resp.tpcRetCode;
+            tpcIoctlResp.txPower = tpcReq.resp.txPower;
+            tpcIoctlResp.linkMargin = tpcReq.resp.linkMargin;
+            tpcIoctlResp.rssi = tpcReq.resp.rssi;
+
+            wrq->u.data.length = sizeof(tpcIoctlResp);
+            if (copy_to_user(wrq->u.data.pointer, &tpcIoctlResp,
+                             wrq->u.data.length)) {
+                PRINTM(INFO, "Copy to user failed\n");
+                return -EFAULT;
+            }
+
+            PRINTM(INFO, "11h: ioctl_request_tpc resp: "
+                   "Ret(%d), TxPwr(%d), LinkMrgn(%d), RSSI(%d)\n",
+                   tpcIoctlResp.statusCode,
+                   tpcIoctlResp.txPower,
+                   tpcIoctlResp.linkMargin, tpcIoctlResp.rssi);
+        }
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/**
+ * @brief IOCTL handler to set  min/max power in the 11h power capability IE
+ *
+ *  @param priv  Private driver information structure
+ *  @param wrq   OS IOCTL passed structure
+ *
+ *  @return
+ *    - 0 for success
+ *    - -EFAULT if memory copy from user space fails
+ */
+int
+wlan_11h_ioctl_set_power_cap(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_11h_power_cap powerCapIoctl;
+    int ret = 0;
+
+    ENTER();
+
+    if (copy_from_user(&powerCapIoctl, wrq->u.data.pointer,
+                       sizeof(powerCapIoctl)) == 0) {
+        Adapter->state11h.minTxPowerCapability = powerCapIoctl.minTxPower;
+        Adapter->state11h.maxTxPowerCapability = powerCapIoctl.maxTxPower;
+
+        PRINTM(INFO, "11h: ioctl_set_power_cap, Min(%d) MaxPwr(%d)\n",
+               Adapter->state11h.minTxPowerCapability,
+               Adapter->state11h.maxTxPowerCapability);
+    } else {
+        ret = -EFAULT;
+    }
+
+    LEAVE();
+
+    return ret;
+}
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_11h.h b/drivers/net/wireless/8688_wlan/wlan/wlan_11h.h
new file mode 100755
index 0000000..bfcef70
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_11h.h
@@ -0,0 +1,341 @@
+/** @file wlan_11h.h
+ *
+ *  @brief Interface for the 802.11h wlan_11h module implemented in wlan_11h.c
+ *
+ *  Driver interface functions and type declarations for the 11h module
+ *    implemented in wlan_11h.c.
+ *
+ *  (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change Log:
+    9/30/05: Added DFS code, reorganized TPC code to match conventions
+
+ ************************************************************/
+
+#ifndef _WLAN_11H
+#define _WLAN_11H
+
+#include "wlan_meas.h"
+
+/*
+ *  #defines used in this header file
+ */
+
+//! Maximum number of subbands in the IEEEtypes_SupportedChannels_t structure
+#define WLAN_11H_MAX_SUBBANDS  5
+
+//! Maximum number of DFS channels configured in IEEEtypes_IBSS_DFS_t 
+#define WLAN_11H_MAX_IBSS_DFS_CHANNELS 25
+
+/*
+ *
+ *  IEEE type definitions
+ *
+ */
+
+//!  IEEE Power Constraint element (7.3.2.15)
+typedef struct
+{
+    u8 elementId;               //!< IEEE Element ID = 32
+    u8 len;                     //!< Element length after id and len
+    u8 localConstraint;         //!< Local power constraint applied to 11d chan info
+} __ATTRIB_PACK__ IEEEtypes_PowerConstraint_t;
+
+//!  IEEE Power Capability element (7.3.2.16)
+typedef struct
+{
+    u8 elementId;               //!< IEEE Element ID = 33                  
+    u8 len;                     //!< Element length after id and len
+    s8 minTxPowerCapability;    //!< Minimum Transmit power (dBm)
+    s8 maxTxPowerCapability;    //!< Maximum Transmit power (dBm)
+} __ATTRIB_PACK__ IEEEtypes_PowerCapability_t;
+
+//!  IEEE TPC Report element (7.3.2.18)
+typedef struct
+{
+    u8 elementId;               //!< IEEE Element ID = 35
+    u8 len;                     //!< Element length after id and len
+    s8 txPower;                 //!< Max power used to transmit the TPC Report frame (dBm)
+    s8 linkmargin;              //!< Link margin when TPC Request received (dB)
+} __ATTRIB_PACK__ IEEEtypes_TPCReport_t;
+
+//!  IEEE Supported Channel sub-band description (7.3.2.19)
+/**  
+ *  Sub-band description used in the supported channels element. 
+ */
+typedef struct
+{
+    u8 startChan;               //!< Starting channel in the subband
+    u8 numChans;                //!< Number of channels in the subband
+
+} __ATTRIB_PACK__ IEEEtypes_SupportChan_Subband_t;
+
+//!  IEEE Supported Channel element (7.3.2.19)
+/**
+ *  Sent in association requests. Details the sub-bands and number
+ *    of channels supported in each subband
+ */
+typedef struct
+{
+    u8 elementId;               //!< IEEE Element ID = 36
+    u8 len;                     //!< Element length after id and len
+
+    //! Configured sub-bands information in the element
+    IEEEtypes_SupportChan_Subband_t subband[WLAN_11H_MAX_SUBBANDS];
+
+} __ATTRIB_PACK__ IEEEtypes_SupportedChannels_t;
+
+//!  Channel Switch Announcment element (7.3.2.20)
+/**
+ *  Sent in action frames and in beacon and probe responses.  Indicates 
+ *    new channel, time until channel switch, and whether or not
+ *    transmissions are allowed while the switch is pending.
+ */
+typedef struct
+{
+    u8 elementId;               //!< IEEE Element ID = 37
+    u8 len;                     //!< Element length after id and len
+    u8 channelSwitchMode;       //!< Mode: 1 indicates STA quiet during switch time
+    u8 newChannelNumber;        //!< New channel 
+    u8 channelSwitchCount;      //!< Nubmer of TBTTS until switch
+
+} __ATTRIB_PACK__ IEEEtypes_ChannelSwitchAnn_t;
+
+//!  IEEE Quiet Period Element (7.3.2.23)
+/**
+ *  Provided in beacons and probe responses.  Indicates times during 
+ *    which the STA should not be transmitting data.  Only starting STAs in
+ *    an IBSS and APs are allowed to originate a quiet element. 
+ */
+typedef struct
+{
+    u8 elementId;               //!< IEEE Element ID = 40
+    u8 len;                     //!< Element length after id and len
+    u8 quietCount;              //!< Number of TBTTs until beacon with the quiet period
+    u8 quietPeriod;             //!< Regular quiet period, # of TBTTS between periods
+    u16 quietDuration;          //!< Duration of the quiet period in TUs
+    u16 quietOffset;            //!< Offset in TUs from the TBTT for the quiet period
+
+} __ATTRIB_PACK__ IEEEtypes_Quiet_t;
+
+//!  IEEE DFS Channel Map field (7.3.2.24)
+/**
+ *  Used to list supported channels and provide a octet "map" field which 
+ *    contains a basic measurement report for that channel in the 
+ *    IEEEtypes_IBSS_DFS_t element
+ */
+typedef struct
+{
+    u8 channelNumber;           //!< Channel number
+    MeasRptBasicMap_t rptMap;   //!< Basic measurement report for the channel
+
+} __ATTRIB_PACK__ IEEEtypes_ChannelMap_t;
+
+//!  IEEE IBSS DFS Element (7.3.2.24)
+/**
+ *  IBSS DFS element included in ad hoc beacons and probe responses.  
+ *    Provides information regarding the IBSS DFS Owner as well as the
+ *    originating STAs supported channels and basic measurement results.
+ */
+typedef struct
+{
+    u8 elementId;               //!< IEEE Element ID = 41
+    u8 len;                     //!< Element length after id and len
+    u8 dfsOwner[ETH_ALEN];      //!< DFS Owner STA Address
+    u8 dfsRecoveryInterval;     //!< DFS Recovery time in TBTTs
+
+    //! Variable length map field, one Map entry for each supported channel
+    IEEEtypes_ChannelMap_t channelMap[WLAN_11H_MAX_IBSS_DFS_CHANNELS];
+
+} __ATTRIB_PACK__ IEEEtypes_IBSS_DFS_t;
+
+/*
+ *
+ *  Marvell IE Type definitions
+ *
+ */
+
+/*
+ *  11h IOCTL structures
+ */
+
+//! WLAN_11H_REQUESTTPC IOCTL request data structure 
+/**
+ * Structure passed from the application layer to initiate a TPC request 
+ *    command via the firmware to a given STA address
+ */
+typedef struct
+{
+    u8 destMac[ETH_ALEN];       //!< Destination STA address        
+    u8 rateIndex;               //!< Response timeout in ms         
+    u16 timeout;                //!< IEEE Rate index to send request
+
+} __ATTRIB_PACK__ wlan_ioctl_11h_tpc_req;
+
+//! WLAN_11H_REQUESTTPC IOCTL response data structure 
+/**
+ * Structure passed from the driver to the application providing the 
+ *   results of the application initiated TPC Request
+ */
+typedef struct
+{
+    int statusCode;             //!< Firmware command result status code
+    int txPower;                //!< Reported TX Power from the TPC Report
+    int linkMargin;             //!< Reported Link margin from the TPC Report
+    int rssi;                   //!< RSSI of the received TPC Report frame
+
+} __ATTRIB_PACK__ wlan_ioctl_11h_tpc_resp;
+
+//! WLAN_11H_CHANSWANN IOCTL data structure 
+/**
+ * Structure passed from the application to the driver to initiate
+ *   a channel switch announcement in the firmware (include in beacons, send
+ *   action frame, switch own channel)
+ */
+typedef struct
+{
+    u8 switchMode;              //!< Set to 1 for a quiet switch request, no STA tx
+    u8 newChan;                 //!< Requested new channel
+    u8 switchCount;             //!< Number of TBTTs until the switch is to occur
+
+} __ATTRIB_PACK__ wlan_ioctl_11h_chan_sw_ann;
+
+//! WLAN_11H_POWERCAP IOCTL data structure 
+/**
+ * Structure passed from the application to the driver to set the internal
+ *   min/max TX Power capability settings in the driver.  These settings
+ *   are later passed to the firmware for use in association requests
+ */
+typedef struct
+{
+    s8 minTxPower;              //!< Minimum Tx Power capability
+    s8 maxTxPower;              //!< Maximum Tx Power capability
+
+} __ATTRIB_PACK__ wlan_ioctl_11h_power_cap;
+
+//! 802.11h BSS information kept for each BSSID received in scan results
+/**
+ * IEEE BSS information needed from scan results for later processing in
+ *    join commands 
+ */
+typedef struct
+{
+    u8 sensed11h;               //!< Capability bit set or 11h IE found in this BSS
+
+    IEEEtypes_PowerConstraint_t powerConstraint;        //!< Power Constraint IE
+    IEEEtypes_PowerCapability_t powerCapability;        //!< Power Capability IE
+    IEEEtypes_TPCReport_t tpcReport;    //!< TPC Report IE
+    IEEEtypes_Quiet_t quiet;    //!< Quiet IE
+    IEEEtypes_IBSS_DFS_t ibssDfs;       //!< IBSS DFS Element IE
+
+} wlan_11h_bss_info_t;
+
+//! 802.11h State information kept in the wlan_adapter class for the driver
+typedef struct
+{
+    int is11hEnabled;           //!< Enables/disables 11h in the driver (adhoc start)
+    int is11hActive;            //!< Indicates whether 11h is active in the firmware
+    int txDisabled;             //!< Set when driver receives a STOP TX event from fw
+
+    //! Minimum TX Power capability sent to FW for 11h use and fw power control
+    s8 minTxPowerCapability;
+
+    //! Maximum TX Power capability sent to FW for 11h use and fw power control
+    s8 maxTxPowerCapability;
+
+    //! User provisioned local power constraint sent in association requests
+    s8 usrDefPowerConstraint;
+
+} wlan_11h_state_t;
+
+/*
+**  11H APIs
+*/
+
+/* Initialize the 11h software module */
+extern void wlan_11h_init(wlan_private * priv);
+
+/* Return 1 if 11h is active in the firmware, 0 if it is inactive */
+extern int wlan_11h_is_active(wlan_private * priv);
+
+/* Activate 11h extensions in the firmware */
+extern int wlan_11h_activate(wlan_private * priv, int flag);
+
+/* Enable the tx interface and record the new transmit state */
+extern void wlan_11h_tx_enable(wlan_private * priv);
+
+/* Enable the tx interface and record the new transmit state */
+extern void wlan_11h_tx_disable(wlan_private * priv);
+
+/* Return 1 if 11h has disabled the transmit intervace, 0 otherwise */
+extern int wlan_11h_is_tx_disabled(wlan_private * priv);
+
+/* Check if radar detection is required on the specified channel */
+extern int wlan_11h_radar_detect_required(wlan_private * priv, u8 channel);
+
+/* Perform a standard availibility check on the specified channel */
+extern int wlan_11h_radar_detected(wlan_private * priv, u8 channel);
+
+/* Get an initial random channel to start an adhoc network on */
+extern int wlan_11h_get_adhoc_start_channel(wlan_private * priv);
+
+/* Add any 11h TLVs necessary to complete a join command (adhoc or infra) */
+extern int wlan_11h_process_join(wlan_private * priv,
+                                 u8 ** ppBuffer,
+                                 IEEEtypes_CapInfo_t * pCapInfo,
+                                 uint channel,
+                                 wlan_11h_bss_info_t * p11hBssInfo);
+
+/* Add any 11h TLVs necessary to complete an adhoc start command */
+extern int wlan_11h_process_start(wlan_private * priv,
+                                  u8 ** ppBuffer,
+                                  IEEEtypes_CapInfo_t * pCapInfo,
+                                  uint channel,
+                                  wlan_11h_bss_info_t * p11hBssInfo);
+
+/* Receive IEs from scan processing and record any needed info for 11h */
+int wlan_11h_process_bss_elem(wlan_11h_bss_info_t * p11hBssInfo,
+                              const u8 * pElement);
+
+/* Complete the firmware command preparation for an 11h command function */
+extern int wlan_11h_cmd_process(wlan_private * priv,
+                                HostCmd_DS_COMMAND * pCmdPtr,
+                                const void *pInfoBuf);
+
+/* Process the response of an 11h firmware command */
+extern int wlan_11h_cmdresp_process(wlan_private * priv,
+                                    const HostCmd_DS_COMMAND * resp);
+
+/*
+ *  IOCTL declarations
+ */
+/* Send a channel switch announcment */
+extern int wlan_11h_ioctl_chan_sw_ann(wlan_private * priv, struct iwreq *wrq);
+
+/* Send a TPC request to a specific STA */
+extern int wlan_11h_ioctl_request_tpc(wlan_private * priv, struct iwreq *wrq);
+
+/* Set the power capabilities in the driver to be sent in 11h firmware cmds */
+extern int wlan_11h_ioctl_set_power_cap(wlan_private * priv,
+                                        struct iwreq *wrq);
+
+/* Get the local power constraint setting from the driver */
+extern int wlan_11h_ioctl_get_local_power(wlan_private * priv,
+                                          struct iwreq *wrq);
+
+#endif /*_WLAN_11H */
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_cmd.c b/drivers/net/wireless/8688_wlan/wlan/wlan_cmd.c
new file mode 100755
index 0000000..ee95523
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_cmd.c
@@ -0,0 +1,2635 @@
+/** @file wlan_cmd.c
+  *  
+  * @brief This file contains the handling of command.
+  * it prepares command and sends it to firmware when
+  * it is ready.
+  * 
+  * (c) Copyright © 2003-2007, Marvell International Ltd.  
+  *
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+    10/04/05: Add Doxygen format comments
+    01/05/06: Add kernel 2.6.x support  
+    01/11/06: Conditionalize new scan/join structures
+    01/31/06: Add support to selectively enabe the FW Scan channel filter
+    02/16/06: Clear scan in progress flag when scan command failed and dropped
+    04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+    04/18/06: Remove old Subscrive Event and add new Subscribe Event
+              implementation through generic hostcmd API
+    05/04/06: Add IBSS coalescing related new hostcmd handling	      
+    08/29/06: Add ledgpio private command
+********************************************************/
+
+#include	"wlan_headers.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+static u16 Commands_Allowed_In_PS[] = {
+    HostCmd_CMD_802_11_RSSI,
+    HostCmd_CMD_802_11_HOST_SLEEP_CFG,
+    HostCmd_CMD_802_11_WAKEUP_CONFIRM,
+};
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function checks if the commans is allowed
+ *  in PS mode not.
+ *  
+ *  @param Command the command ID
+ *  @return 	   TRUE or FALSE
+ */
+static BOOLEAN
+wlan_is_cmd_allowed_in_ps(u16 Command)
+{
+    int count = sizeof(Commands_Allowed_In_PS)
+        / sizeof(Commands_Allowed_In_PS[0]);
+    int i;
+
+    for (i = 0; i < count; i++) {
+        if (Command == wlan_cpu_to_le16(Commands_Allowed_In_PS[i]))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+/** 
+ *  @brief This function prepares command of get_hw_spec.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param cmd	   A pointer to HostCmd_DS_COMMAND structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_hw_spec(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    HostCmd_DS_GET_HW_SPEC *hwspec = &cmd->params.hwspec;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_GET_HW_SPEC);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_GET_HW_SPEC) + S_DS_GEN);
+    memcpy(hwspec->PermanentAddr, priv->adapter->CurrentAddr, ETH_ALEN);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of ps_mode.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 	the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_ps_mode(wlan_private * priv,
+                        HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    HostCmd_DS_802_11_PS_MODE *psm = &cmd->params.psmode;
+    u16 Action = cmd_action;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_PS_MODE);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_PS_MODE) + S_DS_GEN);
+    psm->Action = wlan_cpu_to_le16(cmd_action);
+    psm->MultipleDtim = 0;
+    switch (Action) {
+    case HostCmd_SubCmd_Enter_PS:
+        PRINTM(INFO, "PS Command:" "SubCode- Enter PS\n");
+        PRINTM(INFO, "LocalListenInterval = %d\n",
+               Adapter->LocalListenInterval);
+
+        psm->LocalListenInterval =
+            wlan_cpu_to_le16(Adapter->LocalListenInterval);
+        psm->NullPktInterval = wlan_cpu_to_le16(Adapter->NullPktInterval);
+        psm->MultipleDtim = wlan_cpu_to_le16(priv->adapter->MultipleDtim);
+        psm->BCNMissTimeOut = wlan_cpu_to_le16(priv->adapter->BCNMissTimeOut);
+        if (priv->adapter->InfrastructureMode == Wlan802_11IBSS)
+            psm->AdhocAwakePeriod =
+                wlan_cpu_to_le16(priv->adapter->AdhocAwakePeriod);
+        break;
+
+    case HostCmd_SubCmd_Exit_PS:
+        PRINTM(INFO, "PS Command:" "SubCode- Exit PS\n");
+        break;
+
+    case HostCmd_SubCmd_Sleep_Confirmed:
+        PRINTM(INFO, "PS Command: SubCode- sleep confirm\n");
+        break;
+
+    default:
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of fw_wakeup_method.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 	the action: GET or SET
+ *  @param pdata_buf 	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_fw_wakeup_method(wlan_private * priv,
+                                 HostCmd_DS_COMMAND * cmd,
+                                 int cmd_action, void *pdata_buf)
+{
+    HostCmd_DS_802_11_FW_WAKEUP_METHOD *fwwm = &cmd->params.fwwakeupmethod;
+    u16 action = (u16) cmd_action;
+    u16 method = *((u16 *) pdata_buf);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_FW_WAKE_METHOD);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_FW_WAKEUP_METHOD) +
+                         S_DS_GEN);
+    fwwm->Action = wlan_cpu_to_le16(action);
+    switch (action) {
+    case HostCmd_ACT_GEN_SET:
+        fwwm->Method = wlan_cpu_to_le16(method);
+        break;
+    case HostCmd_ACT_GEN_GET:
+    default:
+        fwwm->Method = 0;
+        break;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function sends the HS_Activated event to the application
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_host_sleep_activated_event(wlan_private * priv)
+{
+    ENTER();
+
+    priv->adapter->HS_Activated = TRUE;
+    os_carrier_off(priv);
+    os_stop_queue(priv);
+    wmm_stop_queue(priv);
+
+#if WIRELESS_EXT > 14
+    send_iwevcustom_event(priv, CUS_EVT_HS_ACTIVATED);
+#endif /* WIRELESS_EXT */
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function sends the HS_DeActivated event to the application
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_host_sleep_deactivated_event(wlan_private * priv)
+{
+    ENTER();
+
+    priv->adapter->HS_Activated = FALSE;
+
+#if WIRELESS_EXT > 14
+    send_iwevcustom_event(priv, CUS_EVT_HS_DEACTIVATED);
+#endif /* WIRELESS_EXT */
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function sends the HS_GPIO_INT event to the application
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+int
+wlan_host_sleep_wakeup_event(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->bHostSleepConfigured) {
+#if WIRELESS_EXT > 14
+        send_iwevcustom_event(priv, CUS_EVT_HS_WAKEUP);
+#endif /* WIRELESS_EXT */
+    } else {
+        PRINTM(INFO, "hs_gpio_int: HS not configured !!!\n");
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief This function prepares command of host_sleep_cfg.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf 	A pointer to HostCmd_DS_802_11_HOST_SLEEP_CFG structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_host_sleep_cfg(wlan_private * priv,
+                               HostCmd_DS_COMMAND * cmd,
+                               HostCmd_DS_802_11_HOST_SLEEP_CFG * pdata_buf)
+{
+    HostCmd_DS_802_11_HOST_SLEEP_CFG *phwuc = &cmd->params.hostsleepcfg;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_HOST_SLEEP_CFG);
+    if ((pdata_buf->conditions != HOST_SLEEP_CFG_CANCEL)
+        && ((priv->adapter->ArpFilterSize > 0)
+            && (priv->adapter->ArpFilterSize <= ARP_FILTER_MAX_BUF_SIZE))) {
+        PRINTM(INFO, "Attach %d bytes ArpFilter to HSCfg cmd\n",
+               priv->adapter->ArpFilterSize);
+        memcpy(((u8 *) phwuc) + sizeof(HostCmd_DS_802_11_HOST_SLEEP_CFG),
+               priv->adapter->ArpFilter, priv->adapter->ArpFilterSize);
+        cmd->Size =
+            wlan_cpu_to_le16(priv->adapter->ArpFilterSize +
+                             sizeof(HostCmd_DS_802_11_HOST_SLEEP_CFG) +
+                             S_DS_GEN);
+    } else
+        cmd->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_HOST_SLEEP_CFG) +
+                             S_DS_GEN);
+    phwuc->conditions = wlan_cpu_to_le32(pdata_buf->conditions);
+    phwuc->gpio = pdata_buf->gpio;
+    phwuc->gap = pdata_buf->gap;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of inactivity_timeout.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   Action: GET SET
+ *  @param pdata_buf 	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_inactivity_timeout(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * cmd,
+                                   u16 cmd_action, void *pdata_buf)
+{
+    u16 *timeout = (u16 *) pdata_buf;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_INACTIVITY_TIMEOUT);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_INACTIVITY_TIMEOUT) +
+                         S_DS_GEN);
+
+    cmd->params.inactivity_timeout.Action = wlan_cpu_to_le16(cmd_action);
+
+    if (cmd_action)
+        cmd->params.inactivity_timeout.Timeout = wlan_cpu_to_le16(*timeout);
+    else
+        cmd->params.inactivity_timeout.Timeout = 0;
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of sleep_period.
+ *  
+ *  @param priv    		A pointer to wlan_private structure
+ *  @param cmd	   		A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 		the action: GET or SET
+ *  @param pdata_buf		A pointer to data buffer
+ *  @return 	   		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_sleep_period(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd,
+                             u16 cmd_action, void *pdata_buf)
+{
+    HostCmd_DS_802_11_SLEEP_PERIOD *pSleepPeriod = &cmd->params.ps_sleeppd;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SLEEP_PERIOD);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_SLEEP_PERIOD) +
+                                 S_DS_GEN);
+    memmove(pSleepPeriod, pdata_buf, sizeof(HostCmd_DS_802_11_SLEEP_PERIOD));
+    pSleepPeriod->Action = wlan_cpu_to_le16(pSleepPeriod->Action);
+    pSleepPeriod->Period = wlan_cpu_to_le16(pSleepPeriod->Period);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of wlan_cmd_802_11_crypto
+ *    
+ *  @param priv    		A pointer to wlan_private structure
+ *  @param cmd	   		A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 		the action: GET or SET
+ *  @param pdata_buf		A pointer to data buffer
+ *  @return 	   		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_crypto(wlan_private * priv,
+                       HostCmd_DS_COMMAND * cmd,
+                       u16 cmd_action, void *pdata_buf)
+{
+
+    HostCmd_DS_802_11_CRYPTO *crypto = (HostCmd_DS_802_11_CRYPTO *) pdata_buf;
+    MrvlIEtypes_Data_t *data =
+        (MrvlIEtypes_Data_t *) ((u8 *) pdata_buf +
+                                sizeof(HostCmd_DS_802_11_CRYPTO));
+    int len;
+
+    if (data->Header.Type != TLV_TYPE_CRYPTO_DATA)
+        return WLAN_STATUS_FAILURE;
+    switch (crypto->Algorithm) {
+    case CIPHER_TEST_RC4:
+        if (((crypto->KeyIVLength + crypto->KeyLength) > 256) ||
+            ((crypto->KeyIVLength + crypto->KeyLength) == 0))
+            return WLAN_STATUS_FAILURE;
+        break;
+    case CIPHER_TEST_AES:
+        if ((crypto->KeyLength != 16) && (crypto->KeyLength != 24) &&
+            (crypto->KeyLength != 32))
+            return WLAN_STATUS_FAILURE;
+        break;
+    case CIPHER_TEST_AES_KEY_WRAP:
+        if (crypto->KeyIVLength != 8)
+            return FALSE;
+        if ((crypto->KeyLength != 16) && (crypto->KeyLength != 24) &&
+            (crypto->KeyLength != 32))
+            return WLAN_STATUS_FAILURE;
+        if (data->Header.Len % 8)
+            return WLAN_STATUS_FAILURE;
+        break;
+    default:
+        return WLAN_STATUS_FAILURE;
+
+    }
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_CRYPTO);
+
+    len = data->Header.Len;
+    data->Header.Type = wlan_cpu_to_le16(data->Header.Type);
+    data->Header.Len = wlan_cpu_to_le16(data->Header.Len);
+
+    crypto->EncDec = wlan_cpu_to_le16(crypto->EncDec);
+    crypto->Algorithm = wlan_cpu_to_le16(crypto->Algorithm);
+    crypto->KeyIVLength = wlan_cpu_to_le16(crypto->KeyIVLength);
+    crypto->KeyLength = wlan_cpu_to_le16(crypto->KeyLength);
+
+    memmove(&cmd->params.crypto, pdata_buf, sizeof(HostCmd_DS_802_11_CRYPTO) +
+            len + sizeof(MrvlIEtypesHeader_t));
+
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_CRYPTO) + S_DS_GEN +
+                                 len + sizeof(MrvlIEtypesHeader_t));
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of sleep_params.
+ *  
+ *  @param priv    		A pointer to wlan_private structure
+ *  @param cmd	   		A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 		the action: GET or SET
+ *  @return 	   		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_sleep_params(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_SLEEP_PARAMS *sp = &cmd->params.sleep_params;
+
+    ENTER();
+
+    cmd->Size = wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_SLEEP_PARAMS)) +
+                                 S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SLEEP_PARAMS);
+
+    if (cmd_action == HostCmd_ACT_GEN_GET) {
+        memset(&Adapter->sp, 0, sizeof(SleepParams));
+        memset(sp, 0, sizeof(HostCmd_DS_802_11_SLEEP_PARAMS));
+        sp->Action = wlan_cpu_to_le16(cmd_action);
+    } else if (cmd_action == HostCmd_ACT_GEN_SET) {
+        sp->Action = wlan_cpu_to_le16(cmd_action);
+        sp->Error = wlan_cpu_to_le16(Adapter->sp.sp_error);
+        sp->Offset = wlan_cpu_to_le16(Adapter->sp.sp_offset);
+        sp->StableTime = wlan_cpu_to_le16(Adapter->sp.sp_stabletime);
+        sp->CalControl = (u8) Adapter->sp.sp_calcontrol;
+        sp->ExternalSleepClk = (u8) Adapter->sp.sp_extsleepclk;
+        sp->Reserved = wlan_cpu_to_le16(Adapter->sp.sp_reserved);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** Length of WEP 40 bit key */
+#define WEP_40_BIT_LEN	5
+/** Length of WEP 104 bit key */
+#define WEP_104_BIT_LEN	13
+
+/** 
+ *  @brief This function prepares command of set_wep.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   HostCmd_ACT_ADD or HostCmd_ACT_REMOVE
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_set_wep(wlan_private * priv,
+                        HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    HostCmd_DS_802_11_SET_WEP *wep = &cmd->params.wep;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (cmd_action == HostCmd_ACT_ADD) {
+        cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SET_WEP);
+        cmd->Size =
+            wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_SET_WEP)) + S_DS_GEN);
+        wep->Action = wlan_cpu_to_le16(HostCmd_ACT_ADD);
+
+        /* default tx key index */
+        wep->KeyIndex = wlan_cpu_to_le16(Adapter->CurrentWepKeyIndex &
+                                         HostCmd_WEP_KEY_INDEX_MASK);
+
+        PRINTM(INFO, "Tx Key Index: %u\n", wep->KeyIndex);
+
+        switch (Adapter->WepKey[0].KeyLength) {
+        case WEP_40_BIT_LEN:
+            wep->WEPTypeForKey1 = HostCmd_TYPE_WEP_40_BIT;
+            memmove(wep->WEP1, Adapter->WepKey[0].KeyMaterial,
+                    Adapter->WepKey[0].KeyLength);
+            break;
+        case WEP_104_BIT_LEN:
+            wep->WEPTypeForKey1 = HostCmd_TYPE_WEP_104_BIT;
+            memmove(wep->WEP1, Adapter->WepKey[0].KeyMaterial,
+                    Adapter->WepKey[0].KeyLength);
+            break;
+        case 0:
+            break;
+        default:
+            PRINTM(INFO, "Key1 Length = %d is incorrect\n",
+                   Adapter->WepKey[0].KeyLength);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        switch (Adapter->WepKey[1].KeyLength) {
+        case WEP_40_BIT_LEN:
+            wep->WEPTypeForKey2 = HostCmd_TYPE_WEP_40_BIT;
+            memmove(wep->WEP2, Adapter->WepKey[1].KeyMaterial,
+                    Adapter->WepKey[1].KeyLength);
+            break;
+        case WEP_104_BIT_LEN:
+            wep->WEPTypeForKey2 = HostCmd_TYPE_WEP_104_BIT;
+            memmove(wep->WEP2, Adapter->WepKey[1].KeyMaterial,
+                    Adapter->WepKey[1].KeyLength);
+            break;
+        case 0:
+            break;
+        default:
+            PRINTM(INFO, "Key2 Length = %d is incorrect\n",
+                   Adapter->WepKey[1].KeyLength);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        switch (Adapter->WepKey[2].KeyLength) {
+        case WEP_40_BIT_LEN:
+            wep->WEPTypeForKey3 = HostCmd_TYPE_WEP_40_BIT;
+            memmove(wep->WEP3, Adapter->WepKey[2].KeyMaterial,
+                    Adapter->WepKey[2].KeyLength);
+            break;
+        case WEP_104_BIT_LEN:
+            wep->WEPTypeForKey3 = HostCmd_TYPE_WEP_104_BIT;
+            memmove(wep->WEP3, Adapter->WepKey[2].KeyMaterial,
+                    Adapter->WepKey[2].KeyLength);
+            break;
+        case 0:
+            break;
+        default:
+            PRINTM(INFO, "Key3 Length = %d is incorrect\n",
+                   Adapter->WepKey[2].KeyLength);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        switch (Adapter->WepKey[3].KeyLength) {
+        case WEP_40_BIT_LEN:
+            wep->WEPTypeForKey4 = HostCmd_TYPE_WEP_40_BIT;
+            memmove(wep->WEP4, Adapter->WepKey[3].KeyMaterial,
+                    Adapter->WepKey[3].KeyLength);
+            break;
+        case WEP_104_BIT_LEN:
+            wep->WEPTypeForKey4 = HostCmd_TYPE_WEP_104_BIT;
+            memmove(wep->WEP4, Adapter->WepKey[3].KeyMaterial,
+                    Adapter->WepKey[3].KeyLength);
+            break;
+        case 0:
+            break;
+        default:
+            PRINTM(INFO, "Key4 Length = %d is incorrect\n",
+                   Adapter->WepKey[3].KeyLength);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+    } else if (cmd_action == HostCmd_ACT_REMOVE) {
+        cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SET_WEP);
+        cmd->Size =
+            wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_SET_WEP)) + S_DS_GEN);
+        wep->Action = wlan_cpu_to_le16(HostCmd_ACT_REMOVE);
+
+        /* default tx key index */
+        wep->KeyIndex = wlan_cpu_to_le16((u16) (Adapter->CurrentWepKeyIndex &
+                                                (u32)
+                                                HostCmd_WEP_KEY_INDEX_MASK));
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function prepares command of key_material.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action 	the action: GET or SET
+ *  @param cmd_oid	OID: ENABLE or DISABLE
+ *  @param pdata_buf    A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_key_material(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd,
+                             u16 cmd_action,
+                             WLAN_OID cmd_oid, void *pdata_buf)
+{
+    HostCmd_DS_802_11_KEY_MATERIAL *pKeyMaterial = &cmd->params.keymaterial;
+    WLAN_802_11_KEY *pKey = (WLAN_802_11_KEY *) pdata_buf;
+    u16 KeyParamSet_len;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_KEY_MATERIAL);
+    pKeyMaterial->Action = wlan_cpu_to_le16(cmd_action);
+
+    if (cmd_action == HostCmd_ACT_GEN_GET) {
+        cmd->Size = wlan_cpu_to_le16(2 + S_DS_GEN);
+        ret = WLAN_STATUS_SUCCESS;
+        goto done;
+    }
+
+    memset(&pKeyMaterial->KeyParamSet, 0, sizeof(MrvlIEtype_KeyParamSet_t));
+
+    if (pKey->KeyLength == WPA_AES_KEY_LEN) {
+        PRINTM(INFO, "WPA_AES\n");
+        pKeyMaterial->KeyParamSet.KeyTypeId =
+            wlan_cpu_to_le16(KEY_TYPE_ID_AES);
+
+        if (cmd_oid == (WLAN_OID) KEY_INFO_ENABLED)
+            pKeyMaterial->KeyParamSet.KeyInfo =
+                wlan_cpu_to_le16(KEY_INFO_AES_ENABLED);
+        else
+            pKeyMaterial->KeyParamSet.KeyInfo =
+                !(wlan_cpu_to_le16(KEY_INFO_AES_ENABLED));
+
+        if (pKey->KeyIndex & 0x40000000)        //AES pairwise key: unicast
+            pKeyMaterial->KeyParamSet.KeyInfo |=
+                wlan_cpu_to_le16(KEY_INFO_AES_UNICAST);
+        else                    //AES group key: multicast
+            pKeyMaterial->KeyParamSet.KeyInfo |=
+                wlan_cpu_to_le16(KEY_INFO_AES_MCAST);
+    } else if (pKey->KeyLength == WPA_TKIP_KEY_LEN) {
+        PRINTM(INFO, "WPA_TKIP\n");
+        pKeyMaterial->KeyParamSet.KeyTypeId =
+            wlan_cpu_to_le16(KEY_TYPE_ID_TKIP);
+        pKeyMaterial->KeyParamSet.KeyInfo =
+            wlan_cpu_to_le16(KEY_INFO_TKIP_ENABLED);
+
+        if (pKey->KeyIndex & 0x40000000)        //TKIP pairwise key: unicast
+            pKeyMaterial->KeyParamSet.KeyInfo |=
+                wlan_cpu_to_le16(KEY_INFO_TKIP_UNICAST);
+        else                    //TKIP group key: multicast
+            pKeyMaterial->KeyParamSet.KeyInfo |=
+                wlan_cpu_to_le16(KEY_INFO_TKIP_MCAST);
+    }
+
+    if (pKeyMaterial->KeyParamSet.KeyTypeId) {
+        pKeyMaterial->KeyParamSet.Type =
+            wlan_cpu_to_le16(TLV_TYPE_KEY_MATERIAL);
+        pKeyMaterial->KeyParamSet.KeyLen = wlan_cpu_to_le16(pKey->KeyLength);
+        memcpy(pKeyMaterial->KeyParamSet.Key,
+               pKey->KeyMaterial, pKey->KeyLength);
+        pKeyMaterial->KeyParamSet.Length =
+            wlan_cpu_to_le16(pKey->KeyLength + 6);
+
+#define TYPE_LEN_FIELDS_LEN 4
+        KeyParamSet_len = (pKey->KeyLength + 6) + TYPE_LEN_FIELDS_LEN;
+#define ACTION_FIELD_LEN 2
+        cmd->Size =
+            wlan_cpu_to_le16(KeyParamSet_len + ACTION_FIELD_LEN + S_DS_GEN);
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function prepares command of get_log.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_get_log(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_GET_LOG);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_GET_LOG) + S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of snmp_mib.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param cmd_oid   	the OID of SNMP MIB
+ *  @param pdata_buf	the pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_snmp_mib(wlan_private * priv,
+                         HostCmd_DS_COMMAND * cmd,
+                         int cmd_action, int cmd_oid, void *pdata_buf)
+{
+    HostCmd_DS_802_11_SNMP_MIB *pSNMPMIB = &cmd->params.smib;
+    wlan_adapter *Adapter = priv->adapter;
+    u8 ucTemp;
+
+    ENTER();
+
+    PRINTM(INFO, "SNMP_CMD: cmd_oid = 0x%x\n", cmd_oid);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SNMP_MIB);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_SNMP_MIB) + S_DS_GEN);
+
+    switch (cmd_oid) {
+    case DesiredBssType_i:
+        pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+        pSNMPMIB->OID = wlan_cpu_to_le16((u16) DesiredBssType_i);
+        pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u8));
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure)
+            ucTemp = SNMP_MIB_VALUE_INFRA;
+        else
+            ucTemp = SNMP_MIB_VALUE_ADHOC;
+
+        memmove(pSNMPMIB->Value, &ucTemp, sizeof(u8));
+
+        break;
+
+    case Dot11D_i:
+        {
+            u32 ulTemp;
+
+            pSNMPMIB->OID = wlan_cpu_to_le16((u16) Dot11D_i);
+
+            if (cmd_action == HostCmd_ACT_GEN_SET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+                pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+                ulTemp = *(u32 *) pdata_buf;
+                *((PUSHORT) (pSNMPMIB->Value)) =
+                    wlan_cpu_to_le16((u16) ulTemp);
+            }
+            break;
+        }
+
+    case Dot11H_i:
+        {
+            u32 ulTemp;
+
+            pSNMPMIB->OID = wlan_cpu_to_le16((u16) Dot11H_i);
+
+            if (cmd_action == HostCmd_ACT_GEN_SET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+                pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+                ulTemp = *(u32 *) pdata_buf;
+                *((PUSHORT) (pSNMPMIB->Value)) =
+                    wlan_cpu_to_le16((u16) ulTemp);
+            }
+            break;
+        }
+
+    case FragThresh_i:
+        {
+            WLAN_802_11_FRAGMENTATION_THRESHOLD ulTemp;
+
+            pSNMPMIB->OID = wlan_cpu_to_le16((u16) FragThresh_i);
+
+            if (cmd_action == HostCmd_ACT_GEN_GET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+            } else if (cmd_action == HostCmd_ACT_GEN_SET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+                pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+                ulTemp = *((WLAN_802_11_FRAGMENTATION_THRESHOLD *)
+                           pdata_buf);
+                *((PUSHORT) (pSNMPMIB->Value)) =
+                    wlan_cpu_to_le16((u16) ulTemp);
+
+            }
+
+            break;
+        }
+
+    case RtsThresh_i:
+        {
+
+            WLAN_802_11_RTS_THRESHOLD ulTemp;
+            pSNMPMIB->OID = wlan_cpu_to_le16((u16) RtsThresh_i);
+
+            if (cmd_action == HostCmd_ACT_GEN_GET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+            } else if (cmd_action == HostCmd_ACT_GEN_SET) {
+                pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+                pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+                ulTemp = *((WLAN_802_11_RTS_THRESHOLD *)
+                           pdata_buf);
+                *(PUSHORT) (pSNMPMIB->Value) = wlan_cpu_to_le16((u16) ulTemp);
+
+            }
+            break;
+        }
+    case ShortRetryLim_i:
+        pSNMPMIB->OID = wlan_cpu_to_le16((u16) ShortRetryLim_i);
+
+        if (cmd_action == HostCmd_ACT_GEN_GET) {
+            pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+        } else if (cmd_action == HostCmd_ACT_GEN_SET) {
+            pSNMPMIB->QueryType = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+            pSNMPMIB->BufSize = wlan_cpu_to_le16(sizeof(u16));
+            *((PUSHORT) (pSNMPMIB->Value)) =
+                wlan_cpu_to_le16((u16) Adapter->TxRetryCount);
+        }
+
+        break;
+    default:
+        break;
+    }
+
+    PRINTM(INFO,
+           "SNMP_CMD: Command=0x%x, Size=0x%x, SeqNum=0x%x, Result=0x%x\n",
+           cmd->Command, cmd->Size, cmd->SeqNum, cmd->Result);
+
+    PRINTM(INFO,
+           "SNMP_CMD: Action=0x%x, OID=0x%x, OIDSize=0x%x, Value=0x%x\n",
+           pSNMPMIB->QueryType, pSNMPMIB->OID, pSNMPMIB->BufSize,
+           *(u16 *) pSNMPMIB->Value);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of radio_control.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_radio_control(wlan_private * priv,
+                              HostCmd_DS_COMMAND * cmd, int cmd_action)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_RADIO_CONTROL *pRadioControl = &cmd->params.radio;
+
+    ENTER();
+
+    cmd->Size = wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_RADIO_CONTROL))
+                                 + S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RADIO_CONTROL);
+
+    pRadioControl->Action = wlan_cpu_to_le16(cmd_action);
+    pRadioControl->Control = wlan_cpu_to_le16(Adapter->RadioOn);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of bca_timeshare.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param user_bca_ts	A pointer to HostCmd_DS_802_11_BCA_TIMESHARE structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_bca_timeshare(wlan_private * priv,
+                              HostCmd_DS_COMMAND * cmd,
+                              u16 cmd_action,
+                              HostCmd_DS_802_11_BCA_TIMESHARE * user_bca_ts)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_BCA_TIMESHARE *bca_ts = &cmd->params.bca_timeshare;
+
+    ENTER();
+
+    cmd->Size = wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_BCA_TIMESHARE)) +
+                                 S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE);
+
+    if (cmd_action == HostCmd_ACT_GEN_GET) {
+        memset(&Adapter->bca_ts, 0, sizeof(bca_ts));
+        memset(bca_ts, 0, sizeof(HostCmd_DS_802_11_BCA_TIMESHARE));
+        bca_ts->Action = wlan_cpu_to_le16(cmd_action);
+        bca_ts->TrafficType = wlan_cpu_to_le16(user_bca_ts->TrafficType);
+    } else if (cmd_action == HostCmd_ACT_GEN_SET) {
+        bca_ts->Action = wlan_cpu_to_le16(cmd_action);
+        bca_ts->TrafficType = wlan_cpu_to_le16(user_bca_ts->TrafficType);
+        bca_ts->TimeShareInterval =
+            wlan_cpu_to_le32(user_bca_ts->TimeShareInterval);
+        bca_ts->BTTime = wlan_cpu_to_le32(user_bca_ts->BTTime);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rf_tx_power.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rf_tx_power(wlan_private * priv,
+                            HostCmd_DS_COMMAND * cmd,
+                            u16 cmd_action, void *pdata_buf)
+{
+
+    HostCmd_DS_802_11_RF_TX_POWER *pRTP = &cmd->params.txp;
+
+    ENTER();
+
+    cmd->Size =
+        wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_RF_TX_POWER)) + S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RF_TX_POWER);
+    pRTP->Action = cmd_action;
+
+    PRINTM(INFO, "RF_TX_POWER_CMD: Size:%d Cmd:0x%x Act:%d\n", cmd->Size,
+           cmd->Command, pRTP->Action);
+
+    switch (cmd_action) {
+    case HostCmd_ACT_GEN_GET:
+        pRTP->Action = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+        pRTP->CurrentLevel = 0;
+        break;
+
+    case HostCmd_ACT_GEN_SET:
+        pRTP->Action = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+        pRTP->CurrentLevel = wlan_cpu_to_le16(*((u16 *) pdata_buf));
+        break;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rf_antenna.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rf_antenna(wlan_private * priv,
+                           HostCmd_DS_COMMAND * cmd,
+                           u16 cmd_action, void *pdata_buf)
+{
+    HostCmd_DS_802_11_RF_ANTENNA *rant = &cmd->params.rant;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RF_ANTENNA);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_RF_ANTENNA) + S_DS_GEN);
+
+    rant->Action = wlan_cpu_to_le16(cmd_action);
+    if ((cmd_action == HostCmd_ACT_SET_RX) ||
+        (cmd_action == HostCmd_ACT_SET_TX)) {
+        rant->AntennaMode =
+            wlan_cpu_to_le16((u16) (*(WLAN_802_11_ANTENNA *) pdata_buf));
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rate_adapt_rateset.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rate_adapt_rateset(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    HostCmd_DS_802_11_RATE_ADAPT_RATESET * rateadapt = &cmd->params.rateset;
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_RATE_ADAPT_RATESET) +
+                         S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RATE_ADAPT_RATESET);
+
+    ENTER();
+
+    rateadapt->Action = wlan_cpu_to_le16(cmd_action);
+    rateadapt->HWRateDropMode = wlan_cpu_to_le16(Adapter->HWRateDropMode);
+    rateadapt->Threshold = wlan_cpu_to_le16(Adapter->Threshold);
+    rateadapt->FinalRate = wlan_cpu_to_le16(Adapter->FinalRate);
+    rateadapt->Bitmap = wlan_cpu_to_le16(Adapter->RateBitmap);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of mac_multicast_adr.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_mac_multicast_adr(wlan_private * priv,
+                           HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    HostCmd_DS_MAC_MULTICAST_ADR *pMCastAdr = &cmd->params.madr;
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_MAC_MULTICAST_ADR) + S_DS_GEN);
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_MAC_MULTICAST_ADR);
+
+    pMCastAdr->Action = wlan_cpu_to_le16(cmd_action);
+    pMCastAdr->NumOfAdrs =
+        wlan_cpu_to_le16((u16) Adapter->NumOfMulticastMACAddr);
+    memcpy(pMCastAdr->MACList, Adapter->MulticastList,
+           Adapter->NumOfMulticastMACAddr * ETH_ALEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rf_channel.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param option	the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rf_channel(wlan_private * priv,
+                           HostCmd_DS_COMMAND * cmd,
+                           int option, void *pdata_buf)
+{
+    HostCmd_DS_802_11_RF_CHANNEL *rfchan = &cmd->params.rfchannel;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RF_CHANNEL);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_RF_CHANNEL)
+                                 + S_DS_GEN);
+
+    if (option == HostCmd_OPT_802_11_RF_CHANNEL_SET) {
+        rfchan->CurrentChannel = wlan_cpu_to_le16(*((u16 *) pdata_buf));
+    }
+
+    rfchan->Action = wlan_cpu_to_le16(option);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of rssi.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_rssi(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_RSSI);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_RSSI) + S_DS_GEN);
+    cmd->params.rssi.N = wlan_cpu_to_le16(Adapter->bcn_avg_factor);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of reg_access.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param CmdPtr  	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_reg_access(wlan_private * priv,
+                    HostCmd_DS_COMMAND * CmdPtr,
+                    u8 cmd_action, void *pdata_buf)
+{
+    wlan_offset_value *offval;
+
+    ENTER();
+
+    offval = (wlan_offset_value *) pdata_buf;
+
+    switch (CmdPtr->Command) {
+    case HostCmd_CMD_MAC_REG_ACCESS:
+        {
+            HostCmd_DS_MAC_REG_ACCESS *macreg;
+
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_MAC_REG_ACCESS) +
+                                 S_DS_GEN);
+            macreg = (HostCmd_DS_MAC_REG_ACCESS *) & CmdPtr->params.macreg;
+
+            macreg->Action = wlan_cpu_to_le16(cmd_action);
+            macreg->Offset = wlan_cpu_to_le16((u16) offval->offset);
+            macreg->Value = wlan_cpu_to_le32(offval->value);
+
+            break;
+        }
+
+    case HostCmd_CMD_BBP_REG_ACCESS:
+        {
+            HostCmd_DS_BBP_REG_ACCESS *bbpreg;
+
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_BBP_REG_ACCESS) +
+                                 S_DS_GEN);
+            bbpreg = (HostCmd_DS_BBP_REG_ACCESS *) & CmdPtr->params.bbpreg;
+
+            bbpreg->Action = wlan_cpu_to_le16(cmd_action);
+            bbpreg->Offset = wlan_cpu_to_le16((u16) offval->offset);
+            bbpreg->Value = (u8) offval->value;
+
+            break;
+        }
+
+    case HostCmd_CMD_RF_REG_ACCESS:
+        {
+            HostCmd_DS_RF_REG_ACCESS *rfreg;
+
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_RF_REG_ACCESS) + S_DS_GEN);
+            rfreg = (HostCmd_DS_RF_REG_ACCESS *) & CmdPtr->params.rfreg;
+
+            rfreg->Action = wlan_cpu_to_le16(cmd_action);
+            rfreg->Offset = wlan_cpu_to_le16((u16) offval->offset);
+            rfreg->Value = (u8) offval->value;
+
+            break;
+        }
+
+    default:
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of mac_address.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_mac_address(wlan_private * priv,
+                            HostCmd_DS_COMMAND * cmd, u16 cmd_action)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_MAC_ADDRESS);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_MAC_ADDRESS) +
+                                 S_DS_GEN);
+    cmd->Result = 0;
+
+    cmd->params.macadd.Action = wlan_cpu_to_le16(cmd_action);
+
+    if (cmd_action == HostCmd_ACT_GEN_SET) {
+        memcpy(cmd->params.macadd.MacAdd, Adapter->CurrentAddr, ETH_ALEN);
+        HEXDUMP("SET_CMD: MAC ADDRESS-", Adapter->CurrentAddr, 6);
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of cal_data_ext.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_cal_data_ext(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    HostCmd_DS_802_11_CAL_DATA_EXT *PCalDataext = pdata_buf;
+
+    HostCmd_DS_802_11_CAL_DATA_EXT *pCmdCalData =
+        (HostCmd_DS_802_11_CAL_DATA_EXT *) & cmd->params.caldataext;
+
+    ENTER();
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_CAL_DATA_EXT);
+
+    PRINTM(INFO, "CalDataLen = %d(d)\n", PCalDataext->CalDataLen);
+
+    if (PCalDataext->CalDataLen >
+        MAX_SETGET_CONF_CMD_LEN - CAL_DATA_HEADER_LEN) {
+        PRINTM(MSG, "CAL_DATA_EXT: Cal data lenght too large!\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    memcpy(pCmdCalData, PCalDataext,
+           PCalDataext->CalDataLen + CAL_DATA_HEADER_LEN);
+
+    pCmdCalData->Action = wlan_cpu_to_le16(pCmdCalData->Action);
+    pCmdCalData->Revision = wlan_cpu_to_le16(pCmdCalData->Revision);
+    pCmdCalData->CalDataLen = wlan_cpu_to_le16(pCmdCalData->CalDataLen);
+
+    cmd->Size = wlan_cpu_to_le16(PCalDataext->CalDataLen +
+                                 CAL_DATA_HEADER_LEN + S_DS_GEN);
+
+    PRINTM(INFO, "CAL_DATA_EXT: cmd->Size = %d(d)\n", cmd->Size);
+
+    cmd->Result = 0;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function prepares command of eeprom_access.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd	   	A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_802_11_eeprom_access(wlan_private * priv,
+                              HostCmd_DS_COMMAND * cmd,
+                              int cmd_action, void *pdata_buf)
+{
+    wlan_ioctl_regrdwr *ea = pdata_buf;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_EEPROM_ACCESS);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_EEPROM_ACCESS) + S_DS_GEN);
+    cmd->Result = 0;
+
+    cmd->params.rdeeprom.Action = wlan_cpu_to_le16(ea->Action);
+    cmd->params.rdeeprom.Offset = wlan_cpu_to_le16(ea->Offset);
+    cmd->params.rdeeprom.ByteCount = wlan_cpu_to_le16(ea->NOB);
+    cmd->params.rdeeprom.Value = 0;
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+static int
+wlan_cmd_ibss_coalescing_status(wlan_private * priv,
+                                HostCmd_DS_COMMAND * cmd,
+                                int cmd_action, void *pdata_buf)
+{
+    HostCmd_DS_802_11_IBSS_Status *pIBSSReq = &(cmd->params.ibssCoalescing);
+    u16 *enable = pdata_buf;
+
+    PRINTM(INFO, "HostCmd_CMD_802_11_BSSID_QUERY request");
+
+    cmd->Command =
+        wlan_cpu_to_le16(HostCmd_CMD_802_11_IBSS_COALESCING_STATUS);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_IBSS_Status) + S_DS_GEN);
+    cmd->Result = 0;
+    pIBSSReq->Action = wlan_cpu_to_le16(cmd_action);
+
+    switch (cmd_action) {
+    case HostCmd_ACT_GEN_SET:
+        pIBSSReq->Enable = wlan_cpu_to_le16(*enable);
+        break;
+
+        /* In other case.. Noting to do */
+    case HostCmd_ACT_GEN_GET:
+    default:
+        break;
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function queues the command to cmd list.
+ *  
+ *  @param Adapter	A pointer to wlan_adapter structure
+ *  @param CmdNode   	A pointer to CmdCtrlNode structure
+ *  @param addtail	specify if the cmd needs to be queued in the header or tail
+ *  @return 	   	n/a
+ */
+void
+wlan_insert_cmd_to_pending_q(wlan_adapter * Adapter, CmdCtrlNode * CmdNode,
+                             BOOLEAN addtail)
+{
+    ulong flags;
+    HostCmd_DS_COMMAND *CmdPtr;
+    u16 command;
+
+    ENTER();
+
+    if (!CmdNode) {
+        PRINTM(WARN, "QUEUE_CMD: CmdNode is NULL\n");
+        goto done;
+    }
+
+    CmdPtr = (HostCmd_DS_COMMAND *) CmdNode->BufVirtualAddr;
+    if (!CmdPtr) {
+        PRINTM(WARN, "QUEUE_CMD: CmdPtr is NULL\n");
+        goto done;
+    }
+
+    command = wlan_le16_to_cpu(CmdPtr->Command);
+
+    /* Exit_PS command needs to be queued in the header always. */
+    if (command == HostCmd_CMD_802_11_PS_MODE) {
+        HostCmd_DS_802_11_PS_MODE *psm = &CmdPtr->params.psmode;
+        if (wlan_le16_to_cpu(psm->Action) == HostCmd_SubCmd_Exit_PS) {
+            if (Adapter->PSState != PS_STATE_FULL_POWER)
+                addtail = FALSE;
+        }
+    }
+
+    if ((command == HostCmd_CMD_802_11_WAKEUP_CONFIRM)
+        || (command == HostCmd_CMD_802_11_HOST_SLEEP_ACTIVATE)
+        || (command == HostCmd_CMD_802_11_HOST_SLEEP_CFG)
+        ) {
+        addtail = FALSE;
+    }
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+
+    if (addtail)
+        list_add_tail((struct list_head *) CmdNode, &Adapter->CmdPendingQ);
+    else
+        list_add((struct list_head *) CmdNode, &Adapter->CmdPendingQ);
+
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+    PRINTM(INFO, "QUEUE_CMD: cmd=0x%x is queued\n", command);
+
+  done:
+    LEAVE();
+    return;
+}
+
+#ifdef MFG_CMD_SUPPORT
+/** 
+ *  @brief This function sends general command to firmware.
+ *  
+ *  @param priv     	A pointer to wlan_private structure
+ *  @param cmd      	A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf	A pointer to data buffer
+ *  @return         	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_mfg_cmd(wlan_private * priv,
+                 HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    HostCmd_DS_GEN *pCmdPtr;
+
+    ENTER();
+
+    pCmdPtr = (HostCmd_DS_GEN *) pdata_buf;
+
+    /* copy the MFG command to command buffer */
+    memcpy((void *) cmd, pdata_buf, pCmdPtr->Size);
+
+    PRINTM(INFO, "MFG command size = %d\n", pCmdPtr->Size);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_MFG_COMMAND);
+    cmd->Size = wlan_cpu_to_le16(cmd->Size);
+    cmd->Result = 0;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+#endif
+
+/** 
+ *  @brief This function downloads the command to firmware.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param CmdNode   	A pointer to CmdCtrlNode structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_dnld_cmd_to_fw(wlan_private * priv, CmdCtrlNode * CmdNode)
+{
+    ulong flags;
+    HostCmd_DS_COMMAND *CmdPtr;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 CmdSize;
+    u16 Command;
+    unsigned long driver_flags;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    if (!Adapter || !CmdNode) {
+        PRINTM(ERROR, "DNLD_CMD: Adapter = %#x, CmdNode = %#x\n",
+               (int) Adapter, (int) CmdNode);
+        if (CmdNode)
+            wlan_insert_cmd_to_free_q(priv, CmdNode);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    CmdPtr = (HostCmd_DS_COMMAND *) CmdNode->BufVirtualAddr;
+
+    if (!CmdPtr || !CmdPtr->Size) {
+        PRINTM(ERROR, "DNLD_CMD: CmdPtr is Null or Cmd Size is Zero, "
+               "Not sending\n");
+        wlan_insert_cmd_to_free_q(priv, CmdNode);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Set command sequence number */
+    Adapter->SeqNum++;
+    CmdPtr->SeqNum = wlan_cpu_to_le16(Adapter->SeqNum);
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+    Adapter->CurCmd = CmdNode;
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+    Command = wlan_le16_to_cpu(CmdPtr->Command);
+    CmdSize = wlan_le16_to_cpu(CmdPtr->Size);
+
+    CmdNode->CmdWaitQWoken = FALSE;
+
+    ret = sbi_host_to_card(priv, MV_TYPE_CMD, (u8 *) CmdPtr, CmdSize);
+
+    /* clear TxDone interrupt bit */
+    OS_INT_DISABLE(priv, driver_flags);
+    Adapter->HisRegCpy &= ~HIS_TxDnLdRdy;
+    OS_INT_RESTORE(priv, driver_flags);
+
+    if (ret != 0) {
+        PRINTM(ERROR, "DNLD_CMD: Host to Card Failed\n");
+        /* set error code that will be transferred back to wlan_prepare_cmd() */
+        Adapter->CurCmdRetCode = WLAN_STATUS_FAILURE;
+        wlan_insert_cmd_to_free_q(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+        Adapter->dbg.num_cmd_host_to_card_failure++;
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Save the last command id and action to debug log */
+    Adapter->dbg.LastCmdIndex = (Adapter->dbg.LastCmdIndex + 1) % DBG_CMD_NUM;
+    Adapter->dbg.LastCmdId[Adapter->dbg.LastCmdIndex] = Command;
+    Adapter->dbg.LastCmdAct[Adapter->dbg.LastCmdIndex] =
+        wlan_le16_to_cpu(*(u16 *) ((u8 *) CmdPtr + S_DS_GEN));
+
+    PRINTM(CMND, "DNLD_CMD: 0x%x, act 0x%x, len %d, seqno %d @ %lu\n",
+           Command, wlan_le16_to_cpu(*(u16 *) ((u8 *) CmdPtr + S_DS_GEN)),
+           CmdSize, wlan_le16_to_cpu(CmdPtr->SeqNum), os_time_get());
+    DBG_HEXDUMP(CMD_D, "DNLD_CMD", CmdNode->BufVirtualAddr, CmdSize);
+
+    /* Setup the timer after transmit command */
+    if (Command == HostCmd_CMD_802_11_SCAN
+        || Command == HostCmd_CMD_802_11_DEAUTHENTICATE
+        || Command == HostCmd_CMD_802_11_ASSOCIATE
+        || Command == HostCmd_CMD_WMM_ADDTS_REQ) {
+        wlan_mod_timer(&Adapter->MrvDrvCommandTimer, MRVDRV_TIMER_10S);
+    } else {
+        wlan_mod_timer(&Adapter->MrvDrvCommandTimer, MRVDRV_TIMER_5S);
+    }
+
+    Adapter->CommandTimerIsSet = TRUE;
+
+    if (Command == HostCmd_CMD_802_11_DEEP_SLEEP) {
+        if (Adapter->IntCounter || Adapter->CurrentTxSkb)
+            PRINTM(INFO, "DNLD_CMD: DS- IntCnt=%d CurTxSkb=%s\n",
+                   Adapter->IntCounter, (Adapter->CurrentTxSkb) ? "Y" : "N");
+
+        if (Adapter->IntCounter) {
+            OS_INT_DISABLE(priv, driver_flags);
+            Adapter->IntCounterSaved = Adapter->IntCounter;
+            Adapter->IntCounter = 0;
+            OS_INT_RESTORE(priv, driver_flags);
+        }
+        if (Adapter->CurrentTxSkb) {
+            kfree_skb(Adapter->CurrentTxSkb);
+            OS_INT_DISABLE(priv, driver_flags);
+            Adapter->CurrentTxSkb = NULL;
+            OS_INT_RESTORE(priv, driver_flags);
+            priv->stats.tx_dropped++;
+        }
+        /* 1. change the PS state to DEEP_SLEEP
+         * 2. since there is no response for this command, so 
+         *    delete the command timer and free the Node. */
+
+        Adapter->IsDeepSleep = TRUE;
+
+        wlan_insert_cmd_to_free_q(priv, CmdNode);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+        if (Adapter->CommandTimerIsSet) {
+            wlan_cancel_timer(&Adapter->MrvDrvCommandTimer);
+            Adapter->CommandTimerIsSet = FALSE;
+        }
+
+        if (Adapter->IsAutoDeepSleepEnabled) {
+            Adapter->bWakeupDevRequired = TRUE;
+            /* For auto deep sleep mode, after entering deep sleep state, 
+             * dnld_sent flag should be cleared so that the commands in 
+             * pending queue can be handled by main thread. */
+            priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+        }
+
+        if (Adapter->bHostSleepConfigured) {
+            Adapter->bWakeupDevRequired = TRUE;
+            wlan_host_sleep_activated_event(priv);
+        }
+
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function prepares command of mac_control.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd		A pointer to HostCmd_DS_COMMAND structure
+ *  @param InfoBuf	A pointer to the command string
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_cmd_mac_control(wlan_private * priv,
+                     HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    HostCmd_DS_MAC_CONTROL *mac = &cmd->params.macctrl;
+    u16 Action = *((u16 *) InfoBuf);
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_MAC_CONTROL);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_MAC_CONTROL) + S_DS_GEN);
+    mac->Action = wlan_cpu_to_le16(Action);
+
+    PRINTM(INFO, "wlan_cmd_mac_control(): Action=0x%X Size=%d\n",
+           mac->Action, cmd->Size);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function inserts command node to CmdFreeQ
+ *  after cleans it.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param pTempCmd	A pointer to CmdCtrlNode structure
+ *  @return 		n/a
+ */
+void
+wlan_insert_cmd_to_free_q(wlan_private * priv, CmdCtrlNode * pTempCmd)
+{
+    ulong flags;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!pTempCmd)
+        goto done;
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+    wlan_clean_cmd_node(pTempCmd);
+    list_add_tail((struct list_head *) pTempCmd, &Adapter->CmdFreeQ);
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+  done:
+    LEAVE();
+}
+
+/** 
+ *  @brief This function prepare the command before send to firmware.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param cmd_no	command number
+ *  @param cmd_action	command action: GET or SET
+ *  @param wait_option	wait option: wait response or not
+ *  @param cmd_oid	cmd oid: treated as sub command
+ *  @param pdata_buf	A pointer to informaion buffer
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_prepare_cmd(wlan_private * priv,
+                 u16 cmd_no,
+                 u16 cmd_action,
+                 u16 wait_option, WLAN_OID cmd_oid, void *pdata_buf)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    CmdCtrlNode *CmdNode;
+    HostCmd_DS_COMMAND *CmdPtr;
+
+    ENTER();
+
+    if (!Adapter) {
+        PRINTM(ERROR, "PREP_CMD: Adapter is Null\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (Adapter->SurpriseRemoved) {
+        PRINTM(ERROR, "PREP_CMD: Card is Removed\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    CmdNode = wlan_get_cmd_node(priv);
+
+    if (CmdNode == NULL) {
+        PRINTM(MSG, "PREP_CMD: No free CmdNode\n");
+
+        /* Wake up main thread to execute next command */
+        wake_up_interruptible(&priv->MainThread.waitQ);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    wlan_init_cmd_node(priv, CmdNode, cmd_oid, wait_option, pdata_buf);
+
+    CmdPtr = (HostCmd_DS_COMMAND *) CmdNode->BufVirtualAddr;
+
+    if (!CmdPtr) {
+        PRINTM(MSG, "PREP_CMD: BufVirtualAddr of CmdNode is NULL\n");
+        wlan_insert_cmd_to_free_q(priv, CmdNode);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    CmdPtr->Command = cmd_no;
+    CmdPtr->Result = 0;
+
+    TX_EVENT_FLAGS_SET(&CmdNode->cmdwait_q, 0, TX_AND);
+    switch (cmd_no) {
+    case HostCmd_CMD_GET_HW_SPEC:
+        ret = wlan_cmd_hw_spec(priv, CmdPtr);
+        break;
+    case HostCmd_CMD_802_11_PS_MODE:
+        ret = wlan_cmd_802_11_ps_mode(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_SCAN:
+        ret = wlan_cmd_802_11_scan(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_MAC_CONTROL:
+        ret = wlan_cmd_mac_control(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_ASSOCIATE:
+        ret = wlan_cmd_802_11_associate(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_DEAUTHENTICATE:
+        ret = wlan_cmd_802_11_deauthenticate(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_SET_WEP:
+        ret = wlan_cmd_802_11_set_wep(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_AD_HOC_START:
+        ret = wlan_cmd_802_11_ad_hoc_start(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_RESET:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size = wlan_cpu_to_le16(S_DS_GEN);
+        break;
+
+    case HostCmd_CMD_802_11_GET_LOG:
+        ret = wlan_cmd_802_11_get_log(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_SNMP_MIB:
+        ret = wlan_cmd_802_11_snmp_mib(priv, CmdPtr,
+                                       cmd_action, cmd_oid, pdata_buf);
+        break;
+
+    case HostCmd_CMD_MAC_REG_ACCESS:
+    case HostCmd_CMD_BBP_REG_ACCESS:
+    case HostCmd_CMD_RF_REG_ACCESS:
+        ret = wlan_cmd_reg_access(priv, CmdPtr, cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RF_CHANNEL:
+        ret = wlan_cmd_802_11_rf_channel(priv, CmdPtr, cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RF_TX_POWER:
+        ret = wlan_cmd_802_11_rf_tx_power(priv, CmdPtr,
+                                          cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RADIO_CONTROL:
+        ret = wlan_cmd_802_11_radio_control(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_RF_ANTENNA:
+        ret = wlan_cmd_802_11_rf_antenna(priv, CmdPtr, cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RATE_ADAPT_RATESET:
+        ret = wlan_cmd_802_11_rate_adapt_rateset(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_MAC_MULTICAST_ADR:
+        ret = wlan_cmd_mac_multicast_adr(priv, CmdPtr, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_AD_HOC_JOIN:
+        ret = wlan_cmd_802_11_ad_hoc_join(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_RSSI:
+        ret = wlan_cmd_802_11_rssi(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_AD_HOC_STOP:
+        ret = wlan_cmd_802_11_ad_hoc_stop(priv, CmdPtr);
+        break;
+    case HostCmd_CMD_802_11_KEY_MATERIAL:
+        ret = wlan_cmd_802_11_key_material(priv, CmdPtr,
+                                           cmd_action, cmd_oid, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_MAC_ADDRESS:
+        ret = wlan_cmd_802_11_mac_address(priv, CmdPtr, cmd_action);
+        break;
+    case HostCmd_CMD_802_11_CAL_DATA_EXT:
+        ret = wlan_cmd_802_11_cal_data_ext(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_DEEP_SLEEP:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size = wlan_cpu_to_le16((u16)
+                                        (sizeof
+                                         (HostCmd_DS_802_11_DEEP_SLEEP)));
+        break;
+
+    case HostCmd_CMD_802_11_HOST_SLEEP_CFG:
+        ret = wlan_cmd_802_11_host_sleep_cfg(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_WAKEUP_CONFIRM:
+    case HostCmd_CMD_802_11_HOST_SLEEP_ACTIVATE:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size = wlan_cpu_to_le16(S_DS_GEN);
+        break;
+    case HostCmd_CMD_802_11_EEPROM_ACCESS:
+        ret = wlan_cmd_802_11_eeprom_access(priv, CmdPtr,
+                                            cmd_action, pdata_buf);
+        break;
+
+#ifdef MFG_CMD_SUPPORT
+    case HostCmd_CMD_MFG_COMMAND:
+        ret = wlan_cmd_mfg_cmd(priv, CmdPtr, pdata_buf);
+        break;
+#endif
+
+    case HostCmd_CMD_802_11D_DOMAIN_INFO:
+        ret = wlan_cmd_802_11d_domain_info(priv, CmdPtr, cmd_no, cmd_action);
+        break;
+
+    case HostCmd_CMD_802_11_TPC_ADAPT_REQ:
+    case HostCmd_CMD_802_11_TPC_INFO:
+    case HostCmd_CMD_802_11_CHAN_SW_ANN:
+        ret = wlan_11h_cmd_process(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_MEASUREMENT_REQUEST:
+    case HostCmd_CMD_MEASUREMENT_REPORT:
+        ret = wlan_meas_cmd_process(priv, CmdPtr, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_SLEEP_PARAMS:
+        ret = wlan_cmd_802_11_sleep_params(priv, CmdPtr, cmd_action);
+        break;
+    case HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE:
+        ret = wlan_cmd_802_11_bca_timeshare(priv, CmdPtr,
+                                            cmd_action, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_INACTIVITY_TIMEOUT:
+        ret = wlan_cmd_802_11_inactivity_timeout(priv, CmdPtr,
+                                                 cmd_action, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_BG_SCAN_CONFIG:
+        ret = wlan_cmd_802_11_bg_scan_config(priv, CmdPtr,
+                                             cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_802_11_BG_SCAN_QUERY:
+        ret = wlan_cmd_802_11_bg_scan_query(priv, CmdPtr);
+        break;
+
+    case HostCmd_CMD_802_11_FW_WAKE_METHOD:
+        ret = wlan_cmd_802_11_fw_wakeup_method(priv, CmdPtr,
+                                               cmd_action, pdata_buf);
+        break;
+
+    case HostCmd_CMD_WMM_GET_STATUS:
+        ret = wlan_cmd_wmm_get_status(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_WMM_ADDTS_REQ:
+        ret = wlan_cmd_wmm_addts_req(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_WMM_DELTS_REQ:
+        ret = wlan_cmd_wmm_delts_req(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_WMM_QUEUE_CONFIG:
+        ret = wlan_cmd_wmm_queue_config(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_WMM_QUEUE_STATS:
+        ret = wlan_cmd_wmm_queue_stats(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_WMM_TS_STATUS:
+        ret = wlan_cmd_wmm_ts_status(priv, CmdPtr, pdata_buf);
+        break;
+    case HostCmd_CMD_TX_PKT_STATS:
+        CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_TX_PKT_STATS);
+        CmdPtr->Size = wlan_cpu_to_le16(S_DS_GEN);
+        ret = WLAN_STATUS_SUCCESS;
+        break;
+    case HostCmd_CMD_802_11_TPC_CFG:
+        CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_TPC_CFG);
+        CmdPtr->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_TPC_CFG) + S_DS_GEN);
+
+        memmove(&CmdPtr->params.tpccfg,
+                pdata_buf, sizeof(HostCmd_DS_802_11_TPC_CFG));
+        CmdPtr->params.tpccfg.Action =
+            wlan_cpu_to_le16(CmdPtr->params.tpccfg.Action);
+
+        ret = WLAN_STATUS_SUCCESS;
+        break;
+    case HostCmd_CMD_802_11_LED_CONTROL:
+        {
+            HostCmd_DS_802_11_LED_CTRL *pLedCtrl = &CmdPtr->params.ledgpio;
+            MrvlIEtypes_LedGpio_t *gpio = &pLedCtrl->LedGpio;
+            MrvlIEtypes_LedBehavior_t *pLedBehavior = pLedCtrl->LedBehavior;
+
+            memmove(&CmdPtr->params.ledgpio,
+                    pdata_buf, sizeof(HostCmd_DS_802_11_LED_CTRL));
+
+            CmdPtr->Command =
+                wlan_cpu_to_le16(HostCmd_CMD_802_11_LED_CONTROL);
+
+#define ACTION_NUMLED_TLVTYPE_LEN_FIELDS_LEN 8
+            CmdPtr->Size = wlan_cpu_to_le16(gpio->Header.Len + S_DS_GEN
+                                            +
+                                            ACTION_NUMLED_TLVTYPE_LEN_FIELDS_LEN);
+
+            pLedCtrl->Action = wlan_cpu_to_le16(pLedCtrl->Action);
+            pLedCtrl->LedNums = wlan_cpu_to_le16(pLedCtrl->LedNums);
+
+            gpio->Header.Type = wlan_cpu_to_le16(gpio->Header.Type);
+            gpio->Header.Len = wlan_cpu_to_le16(gpio->Header.Len);
+
+            pLedBehavior->Header.Type =
+                wlan_cpu_to_le16(pLedBehavior->Header.Type);
+            pLedBehavior->Header.Len =
+                wlan_cpu_to_le16(pLedBehavior->Header.Len);
+
+            ret = WLAN_STATUS_SUCCESS;
+            break;
+        }
+    case HostCmd_CMD_802_11_SLEEP_PERIOD:
+        ret = wlan_cmd_802_11_sleep_period(priv, CmdPtr,
+                                           cmd_action, pdata_buf);
+        break;
+    case HostCmd_CMD_802_11_CRYPTO:
+        ret = wlan_cmd_802_11_crypto(priv, CmdPtr, cmd_action, pdata_buf);
+        break;
+    case HostCmd_CMD_GET_TSF:
+        CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_GET_TSF);
+        CmdPtr->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_GET_TSF)
+                                        + S_DS_GEN);
+        ret = WLAN_STATUS_SUCCESS;
+        break;
+    case HostCmd_CMD_802_11_TX_RATE_QUERY:
+        CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);
+        CmdPtr->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_TX_RATE_QUERY) + S_DS_GEN);
+        Adapter->TxRate = 0;
+        ret = WLAN_STATUS_SUCCESS;
+        break;
+    case HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:
+        ret =
+            wlan_cmd_ibss_coalescing_status(priv, CmdPtr, cmd_action,
+                                            pdata_buf);
+        break;
+
+    case HostCmd_CMD_SDIO_PULL_CTRL:
+        {
+            HostCmd_DS_SDIO_PULL_CTRL *pSdiopullctl =
+                &CmdPtr->params.sdiopullctl;
+
+            CmdPtr->Command = wlan_cpu_to_le16(HostCmd_CMD_SDIO_PULL_CTRL);
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_SDIO_PULL_CTRL) +
+                                 S_DS_GEN);
+
+            memcpy(pSdiopullctl, pdata_buf,
+                   sizeof(HostCmd_DS_SDIO_PULL_CTRL));
+            pSdiopullctl->Action = wlan_cpu_to_le16(pSdiopullctl->Action);
+            pSdiopullctl->PullUp = wlan_cpu_to_le16(pSdiopullctl->PullUp);
+            pSdiopullctl->PullDown = wlan_cpu_to_le16(pSdiopullctl->PullDown);
+
+            ret = WLAN_STATUS_SUCCESS;
+            break;
+        }
+
+    case HostCmd_CMD_ECL_SYSTEM_CLOCK_CONFIG:
+        {
+            HostCmd_DS_ECL_SYSTEM_CLOCK_CONFIG *pSysclockcfg =
+                &CmdPtr->params.sysclockcfg;
+
+            CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_ECL_SYSTEM_CLOCK_CONFIG) +
+                                 S_DS_GEN);
+
+            memcpy(pSysclockcfg, pdata_buf,
+                   sizeof(HostCmd_DS_ECL_SYSTEM_CLOCK_CONFIG));
+            pSysclockcfg->Action = wlan_cpu_to_le16(pSysclockcfg->Action);
+            pSysclockcfg->SystemClock =
+                wlan_cpu_to_le16(pSysclockcfg->SystemClock);
+            break;
+        }
+
+    case HostCmd_CMD_MODULE_TYPE_CONFIG:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        CmdPtr->Size =
+            wlan_cpu_to_le16(sizeof(HostCmd_DS_MODULE_TYPE_CONFIG) +
+                             S_DS_GEN);
+        memcpy(&CmdPtr->params.moduletypecfg, pdata_buf,
+               sizeof(HostCmd_DS_MODULE_TYPE_CONFIG));
+        CmdPtr->params.moduletypecfg.Action =
+            wlan_cpu_to_le16(CmdPtr->params.moduletypecfg.Action);
+        CmdPtr->params.moduletypecfg.Module =
+            wlan_cpu_to_le16(CmdPtr->params.moduletypecfg.Module);
+        break;
+
+    case HostCmd_CMD_VERSION_EXT:
+        CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+        memcpy(&CmdPtr->params, pdata_buf, sizeof(HostCmd_DS_VERSION_EXT));
+        CmdPtr->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_VERSION_EXT)
+                                        + S_DS_GEN);
+        break;
+    case HostCmd_CMD_MEF_CFG:
+        {
+            MEF_CFG_DATA *pMefData = (MEF_CFG_DATA *) pdata_buf;
+            CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+            memcpy(&CmdPtr->params, (u8 *) & pMefData->data, pMefData->size);
+            CmdPtr->Size = wlan_cpu_to_le16(pMefData->size + S_DS_GEN);
+            CmdPtr->params.mefcfg.Criteria =
+                wlan_cpu_to_le32(CmdPtr->params.mefcfg.Criteria);
+            CmdPtr->params.mefcfg.NumEntries =
+                wlan_cpu_to_le16(CmdPtr->params.mefcfg.NumEntries);
+        }
+        break;
+    case HostCmd_CMD_DBGS_CFG:
+        {
+            DBGS_CFG_DATA *pDbgCfg = (DBGS_CFG_DATA *) pdata_buf;
+            CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+            memcpy(&CmdPtr->params, (u8 *) & pDbgCfg->data, pDbgCfg->size);
+            CmdPtr->Size = wlan_cpu_to_le16(pDbgCfg->size + S_DS_GEN);
+        }
+        break;
+    case HostCmd_CMD_GET_MEM:
+        {
+            FW_MEM_DATA *pFwData = (FW_MEM_DATA *) pdata_buf;
+            CmdPtr->Command = wlan_cpu_to_le16(cmd_no);
+            memcpy(&CmdPtr->params, (u8 *) & pFwData->data,
+                   sizeof(HostCmd_DS_GET_MEM));
+            CmdPtr->Size =
+                wlan_cpu_to_le16(sizeof(HostCmd_DS_GET_MEM) + S_DS_GEN);
+        }
+        break;
+
+    default:
+        PRINTM(INFO, "PREP_CMD: unknown command- %#x\n", cmd_no);
+        ret = WLAN_STATUS_FAILURE;
+        break;
+    }
+
+    /* return error, since the command preparation failed */
+    if (ret != WLAN_STATUS_SUCCESS) {
+        PRINTM(ERROR, "PREP_CMD: Command 0x%x preparation failed\n", cmd_no);
+        wlan_insert_cmd_to_free_q(priv, CmdNode);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    PRINTM(CMND, "PREP_CMD: 0x%x\n", cmd_no);
+
+    CmdNode->CmdWaitQWoken = FALSE;
+    wlan_insert_cmd_to_pending_q(Adapter, CmdNode, TRUE);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+    if (wait_option & HostCmd_OPTION_WAITFORRSP) {
+        PRINTM(INFO, "PREP_CMD: Wait for CMD response...\n");
+        if (wait_option & HostCmd_OPTION_TIMEOUT) {
+            if (!os_wait_interruptible_timeout
+                (CmdNode->cmdwait_q, CmdNode->CmdWaitQWoken,
+                 MRVDRV_TIMER_10S)) {
+                PRINTM(INFO, "PREP_CMD:Timeout ...\n");
+                ret = WLAN_STATUS_FAILURE;
+                goto done;
+            }
+        } else
+            wait_event_interruptible(CmdNode->cmdwait_q,
+                                     CmdNode->CmdWaitQWoken);
+
+        if (Adapter->CurCmdRetCode) {
+            PRINTM(INFO, "PREP_CMD: Command failed with return code=%d\n",
+                   Adapter->CurCmdRetCode);
+            Adapter->CurCmdRetCode = 0;
+            ret = WLAN_STATUS_FAILURE;
+        }
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function allocates the command buffer and link
+ *  it to command free queue.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_alloc_cmd_buffer(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u32 ulBufSize;
+    u32 i;
+    CmdCtrlNode *TempCmdArray;
+    u8 *pTempVirtualAddr;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /* Allocate and initialize CmdCtrlNode */
+    ulBufSize = sizeof(CmdCtrlNode) * MRVDRV_NUM_OF_CMD_BUFFER;
+
+    if (!(TempCmdArray = kmalloc(ulBufSize, GFP_KERNEL))) {
+        PRINTM(INFO, "ALLOC_CMD_BUF: Failed to allocate TempCmdArray\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    Adapter->CmdArray = TempCmdArray;
+    memset(Adapter->CmdArray, 0, ulBufSize);
+
+    /* Allocate and initialize command buffers */
+    ulBufSize = MRVDRV_SIZE_OF_CMD_BUFFER;
+    for (i = 0; i < MRVDRV_NUM_OF_CMD_BUFFER; i++) {
+        if (!(pTempVirtualAddr = kmalloc(ulBufSize, GFP_KERNEL))) {
+            PRINTM(INFO, "ALLOC_CMD_BUF: pTempVirtualAddr: out of memory\n");
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        memset(pTempVirtualAddr, 0, ulBufSize);
+
+        /* Update command buffer virtual */
+        TempCmdArray[i].BufVirtualAddr = pTempVirtualAddr;
+    }
+
+    for (i = 0; i < MRVDRV_NUM_OF_CMD_BUFFER; i++) {
+        init_waitqueue_head(&TempCmdArray[i].cmdwait_q);
+        wlan_insert_cmd_to_free_q(priv, &TempCmdArray[i]);
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function frees the command buffer.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_free_cmd_buffer(wlan_private * priv)
+{
+    u32 ulBufSize;
+    UINT i;
+    CmdCtrlNode *TempCmdArray;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /* need to check if cmd array is allocated or not */
+    if (Adapter->CmdArray == NULL) {
+        PRINTM(INFO, "FREE_CMD_BUF: CmdArray is Null\n");
+        goto done;
+    }
+
+    TempCmdArray = Adapter->CmdArray;
+
+    /* Release shared memory buffers */
+    ulBufSize = MRVDRV_SIZE_OF_CMD_BUFFER;
+    for (i = 0; i < MRVDRV_NUM_OF_CMD_BUFFER; i++) {
+        if (TempCmdArray[i].BufVirtualAddr) {
+            PRINTM(INFO, "Free all the array\n");
+            kfree(TempCmdArray[i].BufVirtualAddr);
+            TempCmdArray[i].BufVirtualAddr = NULL;
+        }
+    }
+
+    /* Release CmdCtrlNode */
+    if (Adapter->CmdArray) {
+        PRINTM(INFO, "Free CmdArray\n");
+        kfree(Adapter->CmdArray);
+        Adapter->CmdArray = NULL;
+    }
+
+  done:
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function gets a free command node if available in
+ *  command free queue.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @return CmdCtrlNode A pointer to CmdCtrlNode structure or NULL
+ */
+CmdCtrlNode *
+wlan_get_cmd_node(wlan_private * priv)
+{
+    CmdCtrlNode *TempNode;
+    wlan_adapter *Adapter = priv->adapter;
+    ulong flags;
+
+    ENTER();
+
+    if (!Adapter)
+        return NULL;
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+
+    if (!list_empty(&Adapter->CmdFreeQ)) {
+        TempNode = (CmdCtrlNode *) Adapter->CmdFreeQ.next;
+        list_del((struct list_head *) TempNode);
+    } else {
+        PRINTM(WARN, "GET_CMD_NODE: CmdCtrlNode is not available\n");
+        TempNode = NULL;
+    }
+
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+    LEAVE();
+    return TempNode;
+}
+
+/** 
+ *  @brief This function cleans command node.
+ *  
+ *  @param pTempNode	A pointer to CmdCtrlNode structure
+ *  @return 		n/a
+ */
+void
+wlan_clean_cmd_node(CmdCtrlNode * pTempNode)
+{
+    ENTER();
+
+    if (!pTempNode)
+        return;
+    pTempNode->CmdWaitQWoken = TRUE;
+    if (pTempNode->wait_option & HostCmd_OPTION_WAITFORRSP) {
+        wake_up_interruptible(&pTempNode->cmdwait_q);
+    }
+    pTempNode->Status = 0;
+    pTempNode->cmd_oid = (WLAN_OID) 0;
+    pTempNode->wait_option = 0;
+    pTempNode->CmdFlags = 0;
+    pTempNode->pdata_buf = NULL;
+
+    if (pTempNode->BufVirtualAddr != NULL)
+        memset(pTempNode->BufVirtualAddr, 0, MRVDRV_SIZE_OF_CMD_BUFFER);
+
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function initializes the command node.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param pTempNode	A pointer to CmdCtrlNode structure
+ *  @param cmd_oid	cmd oid: treated as sub command
+ *  @param wait_option	wait option: wait response or not
+ *  @param pdata_buf	A pointer to informaion buffer
+ *  @return 		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+void
+wlan_init_cmd_node(wlan_private * priv,
+                   CmdCtrlNode * pTempNode,
+                   WLAN_OID cmd_oid, u16 wait_option, void *pdata_buf)
+{
+    ENTER();
+
+    if (!pTempNode)
+        return;
+
+    pTempNode->cmd_oid = cmd_oid;
+    pTempNode->wait_option = wait_option;
+    pTempNode->pdata_buf = pdata_buf;
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function executes next command in command
+ *  pending queue. It will put fimware back to PS mode
+ *  if applicable.
+ *  
+ *  @param priv     A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_exec_next_cmd(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    CmdCtrlNode *CmdNode = NULL;
+    HostCmd_DS_COMMAND *CmdPtr;
+    ulong flags;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (!Adapter) {
+        PRINTM(MSG, "EXEC_NEXT_CMD: Adapter is NULL\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+
+    if (Adapter->CurCmd) {
+        PRINTM(MSG, "EXEC_NEXT_CMD: there is command in processing!\n");
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (!list_empty(&Adapter->CmdPendingQ)) {
+        CmdNode = (CmdCtrlNode *)
+            Adapter->CmdPendingQ.next;
+    }
+
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+    if (CmdNode) {
+        CmdPtr = (HostCmd_DS_COMMAND *) CmdNode->BufVirtualAddr;
+
+        if (wlan_is_cmd_allowed_in_ps(CmdPtr->Command)) {
+            if ((Adapter->PSState == PS_STATE_SLEEP)
+                || (Adapter->PSState == PS_STATE_PRE_SLEEP)
+                ) {
+                PRINTM(INFO,
+                       "EXEC_NEXT_CMD: Cannot send cmd 0x%x in PSState %d\n",
+                       CmdPtr->Command, Adapter->PSState);
+                ret = WLAN_STATUS_FAILURE;
+                goto done;
+            }
+            PRINTM(INFO, "EXEC_NEXT_CMD: OK to send command "
+                   "0x%x in PSState %d\n", CmdPtr->Command, Adapter->PSState);
+        } else if (Adapter->PSState != PS_STATE_FULL_POWER) {
+            /*
+             * 1. Non-PS command: 
+             * Queue it. set NeedToWakeup to TRUE if current state 
+             * is SLEEP, otherwise call wlan_exit_ps to send Exit_PS.
+             * 2. PS command but not Exit_PS: 
+             * Ignore it.
+             * 3. PS command Exit_PS:
+             * Set NeedToWakeup to TRUE if current state is SLEEP, 
+             * otherwise send this command down to firmware
+             * immediately.
+             */
+            if (CmdPtr->Command !=
+                wlan_cpu_to_le16(HostCmd_CMD_802_11_PS_MODE)) {
+                /*  Prepare to send Exit PS,
+                 *  this non PS command will be sent later */
+                if ((Adapter->PSState == PS_STATE_SLEEP)
+                    || (Adapter->PSState == PS_STATE_PRE_SLEEP)
+                    ) {
+                    /* w/ new scheme, it will not reach here.
+                       since it is blocked in main_thread. */
+                    Adapter->NeedToWakeup = TRUE;
+                } else
+                    wlan_exit_ps(priv, 0);
+
+                ret = WLAN_STATUS_SUCCESS;
+                goto done;
+            } else {
+                /*
+                 * PS command. Ignore it if it is not Exit_PS. 
+                 * otherwise send it down immediately.
+                 */
+                HostCmd_DS_802_11_PS_MODE *psm = &CmdPtr->params.psmode;
+
+                PRINTM(INFO, "EXEC_NEXT_CMD: PS cmd- Action=0x%x\n",
+                       psm->Action);
+                if (psm->Action != wlan_cpu_to_le16(HostCmd_SubCmd_Exit_PS)) {
+                    PRINTM(INFO, "EXEC_NEXT_CMD: Ignore Enter PS cmd\n");
+                    list_del((struct list_head *) CmdNode);
+                    wlan_insert_cmd_to_free_q(priv, CmdNode);
+
+                    ret = WLAN_STATUS_SUCCESS;
+                    goto done;
+                }
+
+                if ((Adapter->PSState == PS_STATE_SLEEP)
+                    || (Adapter->PSState == PS_STATE_PRE_SLEEP)
+                    ) {
+                    PRINTM(INFO,
+                           "EXEC_NEXT_CMD: Ignore ExitPS cmd in sleep\n");
+                    list_del((struct list_head *) CmdNode);
+                    wlan_insert_cmd_to_free_q(priv, CmdNode);
+                    Adapter->NeedToWakeup = TRUE;
+
+                    ret = WLAN_STATUS_SUCCESS;
+                    goto done;
+                }
+
+                PRINTM(INFO, "EXEC_NEXT_CMD: Sending Exit_PS down...\n");
+            }
+        }
+        list_del((struct list_head *) CmdNode);
+        wlan_dnld_cmd_to_fw(priv, CmdNode);
+    } else {
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            /*
+             * check if in power save mode, if yes, put the device back
+             * to PS mode
+             */
+            if ((Adapter->PSMode != Wlan802_11PowerModeCAM) &&
+                (Adapter->PSState == PS_STATE_FULL_POWER)) {
+                if (Adapter->SecInfo.WPAEnabled
+                    || Adapter->SecInfo.WPA2Enabled) {
+                    if (Adapter->IsGTK_SET) {
+                        PRINTM(INFO, "EXEC_NEXT_CMD: WPA enabled and GTK_SET"
+                               " go back to PS_SLEEP");
+                        wlan_enter_ps(priv, 0);
+                    }
+                } else {
+                    if ((Adapter->InfrastructureMode != Wlan802_11IBSS)
+                        || Adapter->CurBssParams.BSSDescriptor.ATIMWindow) {
+                        PRINTM(INFO, "EXEC_NEXT_CMD: Command PendQ is empty,"
+                               " go back to PS_SLEEP");
+                        wlan_enter_ps(priv, 0);
+                    }
+                }
+            }
+        } else {
+            /*
+             * check if in auto deep sleep mode, if yes, put the device back
+             * to DS mode
+             */
+            if (Adapter->IsAutoDeepSleepEnabled && !Adapter->IntCounter) {
+                PRINTM(INFO, "Entering Auto Deep Sleep mode...\n");
+                ret = wlan_prepare_cmd(priv,
+                                       HostCmd_CMD_802_11_DEEP_SLEEP, 0,
+                                       0, 0, NULL);
+            }
+        }
+        /* The hs_activate command is sent when Host Sleep is configured
+           and de-activated in full power mode. */
+        if (Adapter->bHostSleepConfigured && !Adapter->HS_Activated
+            && ((Adapter->MediaConnectStatus == WlanMediaStateConnected)
+                || (!Adapter->IsAutoDeepSleepEnabled))
+            && (((Adapter->PSMode == Wlan802_11PowerModeCAM)
+                 && (Adapter->PSState == PS_STATE_FULL_POWER))
+                || ((Adapter->InfrastructureMode == Wlan802_11IBSS)
+                    && !Adapter->CurBssParams.BSSDescriptor.ATIMWindow)
+            )) {
+            ret = wlan_prepare_cmd(priv,
+                                   HostCmd_CMD_802_11_HOST_SLEEP_ACTIVATE,
+                                   0, 0, 0, NULL);
+        }
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function handles the timeout of command sending.
+ *  It will re-send the same command again.
+ *  
+ *  @param FunctionContext    A pointer to FunctionContext
+ *  @return 	   n/a
+ */
+void
+wlan_cmd_timeout_func(void *FunctionContext)
+{
+    wlan_private *priv = (wlan_private *) FunctionContext;
+    wlan_adapter *Adapter = priv->adapter;
+    CmdCtrlNode *pTempNode;
+    HostCmd_DS_COMMAND *CmdPtr;
+
+    ENTER();
+
+    PRINTM(CMND, "Command timeout.\n");
+
+    Adapter->CommandTimerIsSet = FALSE;
+
+    if (!Adapter->num_cmd_timeout)
+        Adapter->dbg.num_cmd_timeout++;
+
+    pTempNode = Adapter->CurCmd;
+
+    if (pTempNode == NULL) {
+        PRINTM(INFO, "CurCmd Empty\n");
+        goto exit;
+    }
+
+    CmdPtr = (HostCmd_DS_COMMAND *) pTempNode->BufVirtualAddr;
+    if (CmdPtr == NULL) {
+        goto exit;
+    }
+
+    if (CmdPtr->Size) {
+        Adapter->dbg.TimeoutCmdId = wlan_cpu_to_le16(CmdPtr->Command);
+        Adapter->dbg.TimeoutCmdAct =
+            wlan_cpu_to_le16(*(u16 *) ((u8 *) CmdPtr + S_DS_GEN));
+        PRINTM(CMND, "Timeout cmd = 0x%x, act = 0x%x\n",
+               Adapter->dbg.TimeoutCmdId, Adapter->dbg.TimeoutCmdAct);
+    }
+#define MAX_CMD_TIMEOUT_COUNT	5
+    Adapter->num_cmd_timeout++;
+    if (Adapter->num_cmd_timeout > MAX_CMD_TIMEOUT_COUNT) {
+        PRINTM(FATAL, "num_cmd_timeout=%d\n", Adapter->num_cmd_timeout);
+        goto exit;
+    }
+
+    /* Restart the timer to trace command response again */
+    wlan_mod_timer(&Adapter->MrvDrvCommandTimer, MRVDRV_TIMER_1S);
+    Adapter->CommandTimerIsSet = TRUE;
+
+    /* Wake up main thread to read int status register */
+    Adapter->IntCounter++;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+  exit:
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function sends sleep confirm command to firmware.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param CmdPtr  A pointer to the command
+ *  @param size	   the size of command
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_dnld_sleep_confirm_cmd(wlan_private * priv, u8 * CmdPtr, u16 size)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    static u32 i = 0;
+
+    ENTER();
+
+    HEXDUMP("SLEEP_CFM", CmdPtr, size);
+
+    ret = sbi_host_to_card(priv, MV_TYPE_CMD, CmdPtr, size);
+    if (!priv->enhance_flag) {
+        priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+    }
+
+    if (ret) {
+        PRINTM(MSG, "SLEEP_CFM: sbi_host_to_card() failed\n");
+        Adapter->dbg.num_cmd_sleep_cfm_host_to_card_failure++;
+    } else {
+        Adapter->PSState = PS_STATE_SLEEP;
+        if (Adapter->IsEnhancedPSEnabled && !Adapter->sleep_period.period       /* PPS / UAPSD not enabled */
+            )
+            Adapter->bWakeupDevRequired = TRUE;
+        if (Adapter->bHostSleepConfigured &&
+            (Adapter->sleep_period.period == 0)) {
+            Adapter->bWakeupDevRequired = TRUE;
+#define SDIO_CLK_300KHZ 300
+            //sd_set_busclock((psd_device) priv->wlan_dev.card, SDIO_CLK_300KHZ); /* set the clock to the lowest frequency */
+            wlan_host_sleep_activated_event(priv);
+        }
+#define NUM_SC_PER_LINE		16
+        if (++i % NUM_SC_PER_LINE == 0) {
+            PRINTM(EVENT, "+\n");
+        } else {
+            PRINTM(EVENT, "+");
+        }
+
+        /* check if interrupt is received after sleep confirm */
+        if (Adapter->IntCounter) {
+            PRINTM(INFO, "SLEEP_CFM: After sent, IntCnt=%d\n",
+                   Adapter->IntCounter);
+            Adapter->PSState = PS_STATE_AWAKE;
+        }
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function sends Enter_PS command to firmware.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param wait_option	wait response or not
+ *  @return 	   	n/a 
+ */
+void
+wlan_enter_ps(wlan_private * priv, int wait_option)
+{
+
+    ENTER();
+
+    wlan_prepare_cmd(priv, HostCmd_CMD_802_11_PS_MODE,
+                     HostCmd_SubCmd_Enter_PS, wait_option, 0, NULL);
+
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function sends Eixt_PS command to firmware.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param wait_option	wait response or not
+ *  @return 	   	n/a 
+ */
+void
+wlan_exit_ps(wlan_private * priv, int wait_option)
+{
+    WLAN_802_11_POWER_MODE LocalPSMode;
+
+    ENTER();
+
+    LocalPSMode = Wlan802_11PowerModeCAM;
+
+    wlan_prepare_cmd(priv, HostCmd_CMD_802_11_PS_MODE,
+                     HostCmd_SubCmd_Exit_PS, wait_option, 0, &LocalPSMode);
+
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function checks condition and prepares to
+ *  send sleep confirm command to firmware if ok.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param PSMode  	Power Saving mode
+ *  @return 	   	n/a 
+ */
+void
+wlan_ps_cond_check(wlan_private * priv, u16 PSMode)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!priv->wlan_dev.dnld_sent && !Adapter->CurCmd && !Adapter->IntCounter) {
+        wlan_dnld_sleep_confirm_cmd(priv, (u8 *) & Adapter->PSConfirmSleep,
+                                    sizeof(PS_CMD_ConfirmSleep));
+
+        os_start_queue(priv);
+    } else {
+        PRINTM(INFO, "Delay Sleep Confirm (%s%s%s)\n",
+               (priv->wlan_dev.dnld_sent) ? "D" : "",
+               (Adapter->CurCmd) ? "C" : "",
+               (Adapter->IntCounter) ? "I" : "");
+    }
+
+    LEAVE();
+}
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_cmdresp.c b/drivers/net/wireless/8688_wlan/wlan/wlan_cmdresp.c
new file mode 100755
index 0000000..629603c
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_cmdresp.c
@@ -0,0 +1,1730 @@
+/** @file wlan_cmdresp.c
+  * @brief This file contains the handling of command
+  * responses as well as events generated by firmware.
+  *
+  * (c) Copyright © 2003-2007, Marvell International Ltd. 
+  *  
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	10/10/05: Add Doxygen format comments
+	11/11/05: Add support for WMM Status change event
+	12/13/05: Add Proprietary periodic sleep support
+	12/23/05: Fix bug in adhoc start where the current index was
+	          not properly being assigned before it was used.
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join structures.
+	          Update assoc response handling; entire IEEE response returned
+	04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+	04/10/06: Add hostcmd generic API
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	05/04/06: Add IBSS coalescing related new hostcmd response handling
+	05/08/06: Remove PermanentAddr from Adapter
+	06/08/06: Remove function HandleMICFailureEvent()
+	08/29/06: Add ledgpio private command
+********************************************************/
+
+#include	"wlan_headers.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function handles disconnect event. it
+ *  reports disconnect to upper layer, clean tx/rx packets,
+ *  reset link state etc.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+void
+wlan_reset_connect_state(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    union iwreq_data wrqu;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus != WlanMediaStateConnected)
+        return;
+
+    PRINTM(INFO, "Handles disconnect event.\n");
+
+    /* Free Tx and Rx packets, report disconnect to upper layer */
+    wlan_clean_txrx(priv);
+
+    memset(wrqu.ap_addr.sa_data, 0x00, ETH_ALEN);
+    wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+
+    /* reset SNR/NF/RSSI values */
+    memset(Adapter->SNR, 0x00, sizeof(Adapter->SNR));
+    memset(Adapter->NF, 0x00, sizeof(Adapter->NF));
+    memset(Adapter->RSSI, 0x00, sizeof(Adapter->RSSI));
+    memset(Adapter->rawSNR, 0x00, sizeof(Adapter->rawSNR));
+    memset(Adapter->rawNF, 0x00, sizeof(Adapter->rawNF));
+    Adapter->nextSNRNF = 0;
+    Adapter->numSNRNF = 0;
+    Adapter->RxPDRate = 0;
+    PRINTM(INFO, "Current SSID=%s, Ssid Length=%u\n",
+           Adapter->CurBssParams.BSSDescriptor.Ssid.Ssid,
+           Adapter->CurBssParams.BSSDescriptor.Ssid.SsidLength);
+    PRINTM(INFO, "Previous SSID=%s, Ssid Length=%u\n",
+           Adapter->PreviousSSID.Ssid, Adapter->PreviousSSID.SsidLength);
+
+    Adapter->SecInfo.WPAEnabled = FALSE;
+    Adapter->SecInfo.WPA2Enabled = FALSE;
+    Adapter->Wpa_ie_len = 0;
+    Adapter->SecInfo.EncryptionMode = CIPHER_NONE;
+
+    Adapter->MediaConnectStatus = WlanMediaStateDisconnected;
+    Adapter->AdhocState = ADHOC_IDLE;
+    Adapter->AdhocLinkSensed = FALSE;
+
+    /* 
+     * memorize the previous SSID and BSSID
+     * it could be used for re-assoc
+     */
+    memcpy(&Adapter->PreviousSSID,
+           &Adapter->CurBssParams.BSSDescriptor.Ssid,
+           sizeof(WLAN_802_11_SSID));
+    memcpy(Adapter->PreviousBSSID,
+           Adapter->CurBssParams.BSSDescriptor.MacAddress, ETH_ALEN);
+
+    /* need to erase the current SSID and BSSID info */
+    memset(&Adapter->CurBssParams, 0x00, sizeof(Adapter->CurBssParams));
+
+    if (Adapter->PSState != PS_STATE_FULL_POWER) {
+        /* make firmware to exit PS mode */
+        PRINTM(INFO, "Disconnected, so exit PS mode.\n");
+        wlan_exit_ps(priv, 0);
+    }
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function handles link lost, deauth and
+ *  disassoc events.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+static void
+wlan_handle_disconnect_event(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        wlan_reset_connect_state(priv);
+#ifdef REASSOCIATION
+        if (Adapter->Reassoc_on == TRUE) {
+            PRINTM(INFO, "RE-ASSOC: trigger the timer\n");
+            Adapter->ReassocTimerIsSet = TRUE;
+            wlan_mod_timer(&Adapter->MrvDrvTimer, 0);
+        }
+#endif /* REASSOCIATION */
+    }
+}
+
+/** 
+ *  @brief This function handles the command response of reg_access
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param type	   the type of reg access (MAC, BBP or RF)
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_reg_access(wlan_private * priv, u16 type, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_offset_value *pOffsetValue =
+        (wlan_offset_value *) Adapter->CurCmd->pdata_buf;
+
+    ENTER();
+
+    switch (type) {
+    case HostCmd_CMD_MAC_REG_ACCESS:
+        {
+            HostCmd_DS_MAC_REG_ACCESS *reg;
+
+            reg = (HostCmd_DS_MAC_REG_ACCESS *) & resp->params.macreg;
+
+            pOffsetValue->offset = wlan_le16_to_cpu(reg->Offset);
+            pOffsetValue->value = wlan_le32_to_cpu(reg->Value);
+            break;
+        }
+
+    case HostCmd_CMD_BBP_REG_ACCESS:
+        {
+            HostCmd_DS_BBP_REG_ACCESS *reg;
+            reg = (HostCmd_DS_BBP_REG_ACCESS *) & resp->params.bbpreg;
+
+            pOffsetValue->offset = wlan_le16_to_cpu(reg->Offset);
+            pOffsetValue->value = (u8) reg->Value;
+            break;
+        }
+
+    case HostCmd_CMD_RF_REG_ACCESS:
+        {
+            HostCmd_DS_RF_REG_ACCESS *reg;
+            reg = (HostCmd_DS_RF_REG_ACCESS *) & resp->params.rfreg;
+
+            pOffsetValue->offset = wlan_le16_to_cpu(reg->Offset);
+            pOffsetValue->value = (u8) reg->Value;
+            break;
+        }
+
+    default:
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of get_hw_spec
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_get_hw_spec(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    u32 i;
+    HostCmd_DS_GET_HW_SPEC *hwspec = &resp->params.hwspec;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    Adapter->fwCapInfo = wlan_le32_to_cpu(hwspec->fwCapInfo);
+
+    if (IS_SUPPORT_MULTI_BANDS(Adapter)) {
+        Adapter->fw_bands = GET_FW_DEFAULT_BANDS(Adapter);
+        Adapter->is_multiband = 1;
+    } else {
+        Adapter->adhoc_start_band = BAND_B;
+        Adapter->fw_bands = BAND_B;
+        Adapter->is_multiband = 0;
+    }
+
+    Adapter->config_bands = Adapter->fw_bands;
+
+    if (Adapter->fw_bands & BAND_A) {
+        Adapter->adhoc_start_band = BAND_A;
+        Adapter->AdhocChannel = DEFAULT_AD_HOC_CHANNEL_A;
+    } else if (Adapter->fw_bands & BAND_B) {
+        Adapter->adhoc_start_band = BAND_B;
+        Adapter->AdhocChannel = DEFAULT_AD_HOC_CHANNEL;
+    } else if (Adapter->fw_bands & BAND_G) {
+        Adapter->adhoc_start_band = BAND_G;
+        Adapter->AdhocChannel = DEFAULT_AD_HOC_CHANNEL;
+    }
+
+    Adapter->FWReleaseNumber = wlan_le32_to_cpu(hwspec->FWReleaseNumber);
+
+    PRINTM(INFO, "GET_HW_SPEC: FWReleaseVersion- 0x%X\n",
+           Adapter->FWReleaseNumber);
+    PRINTM(INFO, "GET_HW_SPEC: Permanent addr- %2x:%2x:%2x:%2x:%2x:%2x\n",
+           hwspec->PermanentAddr[0], hwspec->PermanentAddr[1],
+           hwspec->PermanentAddr[2], hwspec->PermanentAddr[3],
+           hwspec->PermanentAddr[4], hwspec->PermanentAddr[5]);
+    PRINTM(INFO, "GET_HW_SPEC: HWIfVersion=0x%X  Version=0x%X\n",
+           wlan_le16_to_cpu(hwspec->HWIfVersion),
+           wlan_le16_to_cpu(hwspec->Version));
+
+    Adapter->RegionCode = wlan_le16_to_cpu(hwspec->RegionCode);
+
+    for (i = 0; i < MRVDRV_MAX_REGION_CODE; i++) {
+        /* use the region code to search for the index */
+        if (Adapter->RegionCode == RegionCodeToIndex[i]) {
+            break;
+        }
+    }
+
+    /* if it's unidentified region code, use the default (USA) */
+    if (i >= MRVDRV_MAX_REGION_CODE) {
+        Adapter->RegionCode = 0x10;
+        PRINTM(WARN, "unidentified region code, use the default (USA)\n");
+    }
+
+    if (Adapter->CurrentAddr[0] == 0xff) {
+        memmove(Adapter->CurrentAddr, hwspec->PermanentAddr, ETH_ALEN);
+    }
+    memcpy(priv->wlan_dev.netdev->dev_addr, Adapter->CurrentAddr, ETH_ALEN);
+
+    if (wlan_set_regiontable(priv, Adapter->RegionCode, Adapter->fw_bands)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (wlan_set_universaltable(priv, Adapter->fw_bands)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function handles the command response of host_sleep_cfg
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_host_sleep_cfg(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_HOST_SLEEP_CFG *hscfg = &resp->params.hostsleepcfg;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (hscfg->conditions != HOST_SLEEP_CFG_CANCEL) {
+        Adapter->bHostSleepConfigured = TRUE;
+    } else {
+        Adapter->bHostSleepConfigured = FALSE;
+        if (Adapter->PSState == PS_STATE_FULL_POWER && Adapter->HS_Activated) {
+            wlan_host_sleep_deactivated_event(priv);
+        }
+        os_start_queue(priv);
+        os_carrier_on(priv);
+        wmm_start_queue(priv);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function handles the command response of fw_wakeup_method
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_fw_wakeup_method(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_FW_WAKEUP_METHOD *fwwm = &resp->params.fwwakeupmethod;
+    u16 action;
+
+    ENTER();
+
+    action = wlan_le16_to_cpu(fwwm->Action);
+
+    switch (action) {
+    case HostCmd_ACT_GEN_GET:
+    case HostCmd_ACT_GEN_SET:
+        Adapter->fwWakeupMethod = wlan_le16_to_cpu(fwwm->Method);
+        break;
+    default:
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of sleep_params
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_sleep_params(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_SLEEP_PARAMS *sp = &resp->params.sleep_params;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, "error=%x offset=%x stabletime=%x calcontrol=%x\n"
+           " extsleepclk=%x\n", sp->Error, sp->Offset,
+           sp->StableTime, sp->CalControl, sp->ExternalSleepClk);
+    Adapter->sp.sp_error = wlan_le16_to_cpu(sp->Error);
+    Adapter->sp.sp_offset = wlan_le16_to_cpu(sp->Offset);
+    Adapter->sp.sp_stabletime = wlan_le16_to_cpu(sp->StableTime);
+    Adapter->sp.sp_calcontrol = wlan_le16_to_cpu(sp->CalControl);
+    Adapter->sp.sp_extsleepclk = wlan_le16_to_cpu(sp->ExternalSleepClk);
+    Adapter->sp.sp_reserved = wlan_le16_to_cpu(sp->Reserved);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of sleep_params
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_sleep_period(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_SLEEP_PERIOD *sp_period = &resp->params.ps_sleeppd;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    Adapter->sleep_period.period = wlan_le16_to_cpu(sp_period->Period);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of bca_timeshare
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_bca_timeshare(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_BCA_TIMESHARE *bca_ts = &resp->params.bca_timeshare;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(MSG, "TrafficType=%x TimeShareInterva=%x BTTime=%x\n",
+           bca_ts->TrafficType, bca_ts->TimeShareInterval, bca_ts->BTTime);
+
+    Adapter->bca_ts.TrafficType = wlan_le16_to_cpu(bca_ts->TrafficType);
+    Adapter->bca_ts.TimeShareInterval =
+        wlan_le32_to_cpu(bca_ts->TimeShareInterval);
+    Adapter->bca_ts.BTTime = wlan_le32_to_cpu(bca_ts->BTTime);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of mac_control
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_mac_control(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of set_wep
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_set_wep(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of reset
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_reset(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    ENTER();
+    PRINTM(INFO, "HWAC - Reset command successful\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of snmp_mib
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_snmp_mib(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_SNMP_MIB *smib = &resp->params.smib;
+    u16 OID = wlan_le16_to_cpu(smib->OID);
+    u16 QueryType = wlan_le16_to_cpu(smib->QueryType);
+
+    ENTER();
+
+    PRINTM(INFO, "SNMP_RESP: value of the OID = %x, QueryType=%x\n", OID,
+           QueryType);
+    PRINTM(INFO, "SNMP_RESP: Buf size  = %x\n",
+           wlan_le16_to_cpu(smib->BufSize));
+
+    if (QueryType == HostCmd_ACT_GEN_GET) {
+        switch (OID) {
+        case FragThresh_i:
+            priv->adapter->FragThsd =
+                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
+            PRINTM(INFO, "SNMP_RESP: FragThsd =%u\n",
+                   priv->adapter->FragThsd);
+            break;
+        case RtsThresh_i:
+            priv->adapter->RTSThsd =
+                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
+            PRINTM(INFO, "SNMP_RESP: RTSThsd =%u\n", priv->adapter->RTSThsd);
+            break;
+        case ShortRetryLim_i:
+            priv->adapter->TxRetryCount =
+                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
+            PRINTM(INFO, "SNMP_RESP: TxRetryCount =%u\n",
+                   priv->adapter->RTSThsd);
+            break;
+        default:
+            break;
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of radio_control
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_radio_control(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    ENTER();
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of key_material
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_key_material(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_KEY_MATERIAL *pKey = &resp->params.keymaterial;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wlan_le16_to_cpu(pKey->Action) == HostCmd_ACT_GEN_SET) {
+        if ((wlan_le16_to_cpu(pKey->KeyParamSet.KeyInfo) &
+             KEY_INFO_TKIP_MCAST)
+            || (wlan_le16_to_cpu(pKey->KeyParamSet.KeyInfo) &
+                KEY_INFO_AES_MCAST)) {
+            PRINTM(INFO, "Key: GTK is set\n");
+            Adapter->IsGTK_SET = TRUE;
+        }
+    }
+
+    memcpy(Adapter->aeskey.KeyParamSet.Key, pKey->KeyParamSet.Key,
+           sizeof(pKey->KeyParamSet.Key));
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of mac_address
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_mac_address(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_MAC_ADDRESS *MacAdd = &resp->params.macadd;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    memcpy(Adapter->CurrentAddr, MacAdd->MacAdd, ETH_ALEN);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rf_tx_power
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rf_tx_power(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RF_TX_POWER *rtp = &resp->params.txp;
+    wlan_adapter *Adapter = priv->adapter;
+    u16 Action = wlan_le16_to_cpu(rtp->Action);
+
+    ENTER();
+
+    Adapter->TxPowerLevel = wlan_le16_to_cpu(rtp->CurrentLevel);
+
+    if (Action == HostCmd_ACT_GEN_GET) {
+        Adapter->MaxTxPowerLevel = rtp->MaxPower;
+        Adapter->MinTxPowerLevel = rtp->MinPower;
+    }
+
+    PRINTM(INFO, "Current TxPower Level = %d,Max Power=%d, Min Power=%d\n",
+           Adapter->TxPowerLevel, Adapter->MaxTxPowerLevel,
+           Adapter->MinTxPowerLevel);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rf_antenna
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rf_antenna(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RF_ANTENNA *pAntenna = &resp->params.rant;
+    wlan_adapter *Adapter = priv->adapter;
+    u16 Action = wlan_le16_to_cpu(pAntenna->Action);
+
+    if (Action == HostCmd_ACT_GET_RX)
+        Adapter->RxAntennaMode = wlan_le16_to_cpu(pAntenna->AntennaMode);
+
+    if (Action == HostCmd_ACT_GET_TX)
+        Adapter->TxAntennaMode = wlan_le16_to_cpu(pAntenna->AntennaMode);
+
+    PRINTM(INFO, "RF_ANT_RESP: Action = 0x%x, Mode = 0x%04x\n",
+           Action, wlan_le16_to_cpu(pAntenna->AntennaMode));
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of multicast_address
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_mac_multicast_adr(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rate_adapt_rateset
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rate_adapt_rateset(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RATE_ADAPT_RATESET *rates = &resp->params.rateset;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wlan_le16_to_cpu(rates->Action) == HostCmd_ACT_GEN_GET) {
+        Adapter->HWRateDropMode = wlan_le16_to_cpu(rates->HWRateDropMode);
+        Adapter->Threshold = wlan_le16_to_cpu(rates->Threshold);
+        Adapter->FinalRate = wlan_le16_to_cpu(rates->FinalRate);
+        Adapter->RateBitmap = wlan_le16_to_cpu(rates->Bitmap);
+    }
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rf_channel
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rf_channel(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RF_CHANNEL *rfchannel = &resp->params.rfchannel;
+    wlan_adapter *Adapter = priv->adapter;
+    u16 Action = wlan_le16_to_cpu(rfchannel->Action);
+    u16 newChannel = wlan_le16_to_cpu(rfchannel->CurrentChannel);
+
+    ENTER();
+
+    if (Action == HostCmd_OPT_802_11_RF_CHANNEL_GET
+        && Adapter->CurBssParams.BSSDescriptor.Channel != newChannel) {
+        PRINTM(INFO, "Channel Switch: %d to %d\n",
+               Adapter->CurBssParams.BSSDescriptor.Channel, newChannel);
+
+        /* Update the channel again */
+        Adapter->CurBssParams.BSSDescriptor.Channel = newChannel;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of rssi
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_rssi(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_RSSI_RSP *rssirsp = &resp->params.rssirsp;
+    wlan_adapter *Adapter = priv->adapter;
+
+    /* store the non average value */
+    Adapter->SNR[TYPE_BEACON][TYPE_NOAVG] = wlan_le16_to_cpu(rssirsp->SNR);
+    Adapter->NF[TYPE_BEACON][TYPE_NOAVG] =
+        wlan_le16_to_cpu(rssirsp->NoiseFloor);
+
+    Adapter->SNR[TYPE_BEACON][TYPE_AVG] = wlan_le16_to_cpu(rssirsp->AvgSNR);
+    Adapter->NF[TYPE_BEACON][TYPE_AVG] =
+        wlan_le16_to_cpu(rssirsp->AvgNoiseFloor);
+
+    Adapter->RSSI[TYPE_BEACON][TYPE_NOAVG] =
+        CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_NOAVG],
+                 Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+
+    Adapter->RSSI[TYPE_BEACON][TYPE_AVG] =
+        CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_AVG] / AVG_SCALE,
+                 Adapter->NF[TYPE_BEACON][TYPE_AVG] / AVG_SCALE);
+
+    PRINTM(INFO, "Beacon RSSI value = 0x%x\n",
+           Adapter->RSSI[TYPE_BEACON][TYPE_AVG]);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+#ifdef MFG_CMD_SUPPORT
+/** 
+ *  @brief This function handles the command response of mfg_cmd
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_mfg_cmd(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, "MFG command response size = %d\n", resp->Size);
+
+    resp->Size = MIN(resp->Size, MRVDRV_SIZE_OF_CMD_BUFFER);
+    memcpy(Adapter->CurCmd->pdata_buf, (void *) resp, resp->Size);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+#endif /* MFG_CMD_SUPPORT */
+
+/** 
+ *  @brief This function handles the command response of cal_data_ext.
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param resp		A pointer to HostCmd_DS_COMMAND
+ *  @return    		WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_802_11_cal_data_ext(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_CAL_DATA_EXT *pCalDataExt = &resp->params.caldataext;
+
+    ENTER();
+
+    if (wlan_le16_to_cpu(pCalDataExt->Action) == HostCmd_ACT_GEN_GET) {
+        pCalDataExt->Action = wlan_le16_to_cpu(pCalDataExt->Action);
+        pCalDataExt->Revision = wlan_le16_to_cpu(pCalDataExt->Revision);
+        pCalDataExt->CalDataLen = wlan_le16_to_cpu(pCalDataExt->CalDataLen);
+
+        memmove(Adapter->CurCmd->pdata_buf,
+                pCalDataExt, pCalDataExt->CalDataLen + CAL_DATA_HEADER_LEN);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of eeprom_access
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_eeprom_access(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_regrdwr *pBuf =
+        (wlan_ioctl_regrdwr *) Adapter->CurCmd->pdata_buf;
+
+    PRINTM(INFO, "eeprom read len=%x\n",
+           wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount));
+    if (pBuf->NOB < wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount)) {
+        pBuf->NOB = 0;
+        PRINTM(INFO, "eeprom read return length is too big\n");
+        return WLAN_STATUS_FAILURE;
+    }
+    pBuf->NOB = wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount);
+    if (pBuf->NOB > 0) {
+        memcpy(&pBuf->Value, (u8 *) & resp->params.rdeeprom.Value, pBuf->NOB);
+        HEXDUMP("EEPROM", (char *) &pBuf->Value, pBuf->NOB);
+    }
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of get_log
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_get_log(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_GET_LOG *LogMessage =
+        (HostCmd_DS_802_11_GET_LOG *) & resp->params.glog;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    memcpy(&Adapter->LogMsg, LogMessage, sizeof(HostCmd_DS_802_11_GET_LOG));
+    endian_convert_GET_LOG(Adapter->LogMsg);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the command response of crypto
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp	   A pointer to HostCmd_DS_COMMAND
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_ret_cmd_802_11_crypto(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_CRYPTO *crypto = &resp->params.crypto;
+    MrvlIEtypes_Data_t *data =
+        (MrvlIEtypes_Data_t *) ((u8 *) crypto +
+                                sizeof(HostCmd_DS_802_11_CRYPTO));
+
+    data->Header.Type = wlan_le16_to_cpu(data->Header.Type);
+    data->Header.Len = wlan_le16_to_cpu(data->Header.Len);
+
+    crypto->EncDec = wlan_le16_to_cpu(crypto->EncDec);
+    crypto->Algorithm = wlan_le16_to_cpu(crypto->Algorithm);
+    crypto->KeyIVLength = wlan_le16_to_cpu(crypto->KeyIVLength);
+    crypto->KeyLength = wlan_le16_to_cpu(crypto->KeyLength);
+
+    memmove(Adapter->CurCmd->pdata_buf, crypto,
+            sizeof(HostCmd_DS_802_11_CRYPTO) + data->Header.Len +
+            sizeof(MrvlIEtypesHeader_t));
+
+    return WLAN_STATUS_SUCCESS;
+
+}
+
+static void
+wlan_ret_ibss_coalescing_status(wlan_private * priv,
+                                HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_802_11_IBSS_Status *IBSSStatusRsp;
+    wlan_adapter *Adapter;
+    union iwreq_data wrqu;
+    u8 nullMac[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
+
+    Adapter = priv->adapter;
+    IBSSStatusRsp = &(resp->params.ibssCoalescing);
+
+    if (Adapter->CurCmd->pdata_buf)
+        *(int *) Adapter->CurCmd->pdata_buf = IBSSStatusRsp->Enable;
+
+    if (wlan_le16_to_cpu(IBSSStatusRsp->Action) == HostCmd_ACT_GEN_SET) {
+        return;
+    }
+
+    PRINTM(INFO, "New BSSID %x:%x:%x:%x:%x:%x\n",
+           IBSSStatusRsp->BSSID[0],
+           IBSSStatusRsp->BSSID[1],
+           IBSSStatusRsp->BSSID[2],
+           IBSSStatusRsp->BSSID[3],
+           IBSSStatusRsp->BSSID[4], IBSSStatusRsp->BSSID[5]);
+
+    /* if rsp has NULL BSSID, Just return.. No Action */
+    if (!memcmp(IBSSStatusRsp->BSSID, nullMac, ETH_ALEN)) {
+        PRINTM(MSG, "New BSSID is NULL\n");
+        return;
+    }
+
+    /* if BSSID is diff, Send evnet to Linux */
+    if (memcmp(Adapter->CurBssParams.BSSDescriptor.MacAddress,
+               IBSSStatusRsp->BSSID, ETH_ALEN)) {
+        memcpy((void *) Adapter->CurBssParams.BSSDescriptor.MacAddress,
+               (void *) IBSSStatusRsp->BSSID, ETH_ALEN);
+
+        /* Beacon Interval and ATIM window */
+        Adapter->CurBssParams.BSSDescriptor.BeaconPeriod
+            = IBSSStatusRsp->BeaconInterval;
+        Adapter->CurBssParams.BSSDescriptor.ATIMWindow
+            = IBSSStatusRsp->ATIMWindow;
+        //ERP Information
+        Adapter->CurBssParams.BSSDescriptor.ERPFlags =
+            (u8) IBSSStatusRsp->UseGRateProtection;
+
+        memset(&wrqu, 0, sizeof(wrqu));
+        memcpy(wrqu.ap_addr.sa_data,
+               Adapter->CurBssParams.BSSDescriptor.MacAddress, ETH_ALEN);
+        wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+
+        Adapter->AdhocState = ADHOC_COALESCED;
+        wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+    }
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function stop tx/rx queue and free skb
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+void
+wlan_clean_txrx(wlan_private * priv)
+{
+    ENTER();
+    os_stop_queue(priv);
+    os_carrier_off(priv);
+
+    wmm_stop_queue(priv);
+    wmm_cleanup_queues(priv);
+
+    /* Free Tx and Rx packets */
+    os_free_tx_packet(priv);
+    LEAVE();
+}
+
+/** 
+ *  @brief This function handles the command response
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_process_cmdresp(wlan_private * priv)
+{
+    u16 RespCmdOrig;
+    u16 RespCmd;
+    HostCmd_DS_COMMAND *resp;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    ulong flags;
+    u16 Result;
+
+    ENTER();
+
+    /* Now we got response from FW, cancel the command timer */
+    if (Adapter->CommandTimerIsSet) {
+        wlan_cancel_timer(&Adapter->MrvDrvCommandTimer);
+        Adapter->CommandTimerIsSet = FALSE;
+    }
+
+    if (!Adapter->CurCmd) {
+        resp = (HostCmd_DS_COMMAND *) priv->wlan_dev.upld_buf;
+        resp->Command = wlan_le16_to_cpu(resp->Command);
+        PRINTM(ERROR, "CMD_RESP: NULL CurCmd, 0x%x\n", resp->Command);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    Adapter->num_cmd_timeout = 0;
+
+    DBG_HEXDUMP(CMD_D, "CMD_RESP", Adapter->CurCmd->BufVirtualAddr,
+                priv->wlan_dev.upld_len);
+
+    resp = (HostCmd_DS_COMMAND *) (Adapter->CurCmd->BufVirtualAddr);
+
+    resp->Command = wlan_le16_to_cpu(resp->Command);
+    resp->Size = wlan_le16_to_cpu(resp->Size);
+    resp->SeqNum = wlan_le16_to_cpu(resp->SeqNum);
+    resp->Result = wlan_le16_to_cpu(resp->Result);
+
+    RespCmdOrig = resp->Command;
+    Result = resp->Result;
+
+    /* Save the last command response to debug log */
+    Adapter->dbg.LastCmdRespIndex =
+        (Adapter->dbg.LastCmdRespIndex + 1) % DBG_CMD_NUM;
+    Adapter->dbg.LastCmdRespId[Adapter->dbg.LastCmdRespIndex] = RespCmdOrig;
+
+    PRINTM(CMND, "CMD_RESP: 0x%x, result %d, len %d, seqno %d @ %lu\n",
+           RespCmdOrig, Result, resp->Size, resp->SeqNum, os_time_get());
+
+    if (!(RespCmdOrig & HostCmd_RET_BIT)) {
+        PRINTM(ERROR, "CMD_RESP: Invalid response to command!");
+        Adapter->CurCmdRetCode = WLAN_STATUS_FAILURE;
+        wlan_insert_cmd_to_free_q(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Clear the HostCmd_RET_BIT */
+    resp->Command &= ~HostCmd_RET_BIT;
+    RespCmd = resp->Command;
+
+    /* Store the response code to CurCmdRetCode. */
+    Adapter->CurCmdRetCode = resp->Result;
+
+    if (RespCmd == HostCmd_CMD_802_11_PS_MODE) {
+        HostCmd_DS_802_11_PS_MODE *psmode;
+
+        psmode = &resp->params.psmode;
+        PRINTM(INFO, "CMD_RESP: PS_MODE cmd reply result=%#x action=0x%X\n",
+               resp->Result, psmode->Action);
+        psmode->Action = wlan_cpu_to_le16(psmode->Action);
+
+        if (Result) {
+            PRINTM(ERROR, "CMD_RESP: PS command failed- %#x \n",
+                   resp->Result);
+            if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+                /* 
+                 * We should not re-try enter-ps command in 
+                 * ad-hoc mode. It takes place in 
+                 * wlan_exec_next_cmd().
+                 */
+                if (psmode->Action == HostCmd_SubCmd_Enter_PS)
+                    Adapter->PSMode = Wlan802_11PowerModeCAM;
+            }
+        } else if (psmode->Action == HostCmd_SubCmd_Enter_PS) {
+            Adapter->NeedToWakeup = FALSE;
+            Adapter->PSState = PS_STATE_AWAKE;
+            if (Adapter->MediaConnectStatus != WlanMediaStateConnected) {
+                /*
+                 * When Deauth Event received before Enter_PS command
+                 * response, We need to wake up the firmware.
+                 */
+                PRINTM(INFO,
+                       "CMD_RESP: Disconnected, Going to invoke wlan_exit_ps\n");
+                wlan_exit_ps(priv, 0);
+            }
+        } else if (psmode->Action == HostCmd_SubCmd_Exit_PS) {
+            Adapter->NeedToWakeup = FALSE;
+            Adapter->PSState = PS_STATE_FULL_POWER;
+        } else {
+            PRINTM(INFO, "CMD_RESP: PS- Action=0x%X\n", psmode->Action);
+        }
+
+        wlan_insert_cmd_to_free_q(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+        ret = WLAN_STATUS_SUCCESS;
+        goto done;
+    }
+
+    if (Adapter->CurCmd->CmdFlags & CMD_F_HOSTCMD) {
+        /* Copy the response back to response buffer */
+        memcpy(Adapter->CurCmd->pdata_buf, resp, resp->Size);
+
+        Adapter->CurCmd->CmdFlags &= ~CMD_F_HOSTCMD;
+
+        if ((Result == HostCmd_RESULT_OK)
+            && (RespCmd == HostCmd_CMD_802_11_HOST_SLEEP_CFG)) {
+            ret = wlan_ret_host_sleep_cfg(priv, resp);
+        }
+    } else {
+        /* If the command is not successful, cleanup and return failure */
+        if (Result != HostCmd_RESULT_OK) {
+            PRINTM(ERROR, "CMD_RESP: cmd %#x error, result=%#x\n",
+                   resp->Command, resp->Result);
+            /*
+             * Handling errors here
+             */
+            switch (RespCmd) {
+            case HostCmd_CMD_GET_HW_SPEC:
+                PRINTM(INFO, "CMD_RESP: HW spec command Failed\n");
+                break;
+
+            }
+
+            wlan_insert_cmd_to_free_q(priv, Adapter->CurCmd);
+            spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+            Adapter->CurCmd = NULL;
+            spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+            return WLAN_STATUS_FAILURE;
+        }
+
+        switch (RespCmd) {
+        case HostCmd_CMD_MAC_REG_ACCESS:
+        case HostCmd_CMD_BBP_REG_ACCESS:
+        case HostCmd_CMD_RF_REG_ACCESS:
+            ret = wlan_ret_reg_access(priv, RespCmd, resp);
+            break;
+
+        case HostCmd_CMD_GET_HW_SPEC:
+            ret = wlan_ret_get_hw_spec(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_BG_SCAN_QUERY:
+            {
+                union iwreq_data wrqu;
+
+                ret = wlan_ret_802_11_scan(priv, resp);
+                memset(&wrqu, 0, sizeof(union iwreq_data));
+                wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu,
+                                    NULL);
+                PRINTM(INFO, "CMD_RESP: BG_SCAN result is ready!\n");
+                break;
+            }
+        case HostCmd_CMD_802_11_SCAN:
+            ret = wlan_ret_802_11_scan(priv, resp);
+            break;
+
+        case HostCmd_CMD_MAC_CONTROL:
+            ret = wlan_ret_mac_control(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_GET_LOG:
+            ret = wlan_ret_get_log(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_ASSOCIATE:
+            ret = wlan_ret_802_11_associate(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_DEAUTHENTICATE:
+            ret = wlan_ret_802_11_deauthenticate(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_SET_WEP:
+            ret = wlan_ret_802_11_set_wep(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_AD_HOC_START:
+        case HostCmd_CMD_802_11_AD_HOC_JOIN:
+            ret = wlan_ret_802_11_ad_hoc(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_RESET:
+            ret = wlan_ret_802_11_reset(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_SNMP_MIB:
+            ret = wlan_ret_802_11_snmp_mib(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_RF_TX_POWER:
+            ret = wlan_ret_802_11_rf_tx_power(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_RADIO_CONTROL:
+            ret = wlan_ret_802_11_radio_control(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_HOST_SLEEP_CFG:
+            ret = wlan_ret_host_sleep_cfg(priv, resp);
+            break;
+        case HostCmd_CMD_802_11_WAKEUP_CONFIRM:
+            wlan_host_sleep_deactivated_event(priv);
+            break;
+        case HostCmd_CMD_802_11_HOST_SLEEP_ACTIVATE:
+            if (Adapter->bHostSleepConfigured
+                && Adapter->HSCfg.gap == HOST_SLEEP_CFG_GAP_FF)
+                Adapter->bWakeupDevRequired = TRUE;
+            wlan_host_sleep_activated_event(priv);
+            break;
+
+        case HostCmd_CMD_802_11_RF_ANTENNA:
+            ret = wlan_ret_802_11_rf_antenna(priv, resp);
+            break;
+
+        case HostCmd_CMD_MAC_MULTICAST_ADR:
+            ret = wlan_ret_mac_multicast_adr(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_RATE_ADAPT_RATESET:
+            ret = wlan_ret_802_11_rate_adapt_rateset(priv, resp);
+            break;
+        case HostCmd_CMD_802_11_RF_CHANNEL:
+            ret = wlan_ret_802_11_rf_channel(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_RSSI:
+            ret = wlan_ret_802_11_rssi(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_MAC_ADDRESS:
+            ret = wlan_ret_802_11_mac_address(priv, resp);
+            break;
+
+#ifdef MFG_CMD_SUPPORT
+        case HostCmd_CMD_MFG_COMMAND:
+            ret = wlan_ret_mfg_cmd(priv, resp);
+            break;
+#endif
+        case HostCmd_CMD_802_11_AD_HOC_STOP:
+            ret = wlan_ret_802_11_ad_hoc_stop(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_CAL_DATA_EXT:
+            ret = wlan_ret_802_11_cal_data_ext(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_KEY_MATERIAL:
+            ret = wlan_ret_802_11_key_material(priv, resp);
+            break;
+        case HostCmd_CMD_802_11_EEPROM_ACCESS:
+            ret = wlan_ret_802_11_eeprom_access(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11D_DOMAIN_INFO:
+            ret = wlan_ret_802_11d_domain_info(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_TPC_ADAPT_REQ:
+        case HostCmd_CMD_802_11_TPC_INFO:
+        case HostCmd_CMD_802_11_CHAN_SW_ANN:
+            ret = wlan_11h_cmdresp_process(priv, resp);
+            break;
+        case HostCmd_CMD_MEASUREMENT_REQUEST:
+        case HostCmd_CMD_MEASUREMENT_REPORT:
+            ret = wlan_meas_cmdresp_process(priv, resp);
+            break;
+        case HostCmd_CMD_802_11_SLEEP_PARAMS:
+            ret = wlan_ret_802_11_sleep_params(priv, resp);
+            break;
+        case HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE:
+            ret = wlan_ret_802_11_bca_timeshare(priv, resp);
+            break;
+        case HostCmd_CMD_802_11_INACTIVITY_TIMEOUT:
+            *((u16 *) Adapter->CurCmd->pdata_buf) =
+                wlan_le16_to_cpu(resp->params.inactivity_timeout.Timeout);
+            break;
+        case HostCmd_CMD_802_11_BG_SCAN_CONFIG:
+            break;
+
+        case HostCmd_CMD_802_11_FW_WAKE_METHOD:
+            ret = wlan_ret_fw_wakeup_method(priv, resp);
+            break;
+
+        case HostCmd_CMD_802_11_SLEEP_PERIOD:
+            ret = wlan_ret_802_11_sleep_period(priv, resp);
+            break;
+        case HostCmd_CMD_WMM_GET_STATUS:
+            ret = wlan_cmdresp_wmm_get_status(priv, resp);
+            break;
+        case HostCmd_CMD_WMM_ADDTS_REQ:
+            ret = wlan_cmdresp_wmm_addts_req(priv, resp);
+            break;
+        case HostCmd_CMD_WMM_DELTS_REQ:
+            ret = wlan_cmdresp_wmm_delts_req(priv, resp);
+            break;
+        case HostCmd_CMD_WMM_QUEUE_CONFIG:
+            ret = wlan_cmdresp_wmm_queue_config(priv, resp);
+            break;
+        case HostCmd_CMD_WMM_QUEUE_STATS:
+            ret = wlan_cmdresp_wmm_queue_stats(priv, resp);
+            break;
+        case HostCmd_CMD_WMM_TS_STATUS:
+            ret = wlan_cmdresp_wmm_ts_status(priv, resp);
+            break;
+        case HostCmd_CMD_TX_PKT_STATS:
+            memcpy(Adapter->CurCmd->pdata_buf,
+                   &resp->params.txPktStats, sizeof(HostCmd_DS_TX_PKT_STATS));
+            ret = WLAN_STATUS_SUCCESS;
+            break;
+        case HostCmd_CMD_802_11_TPC_CFG:
+            memmove(Adapter->CurCmd->pdata_buf,
+                    &resp->params.tpccfg, sizeof(HostCmd_DS_802_11_TPC_CFG));
+            break;
+        case HostCmd_CMD_802_11_LED_CONTROL:
+            {
+                HostCmd_DS_802_11_LED_CTRL *pLedCtrl = &resp->params.ledgpio;
+                MrvlIEtypes_LedGpio_t *pGpio = &pLedCtrl->LedGpio;
+                MrvlIEtypes_LedBehavior_t *pBehavior = pLedCtrl->LedBehavior;
+
+                pLedCtrl->Action = wlan_le16_to_cpu(pLedCtrl->Action);
+                pLedCtrl->LedNums = wlan_le16_to_cpu(pLedCtrl->LedNums);
+                pGpio->Header.Type = wlan_le16_to_cpu(pGpio->Header.Type);
+                pGpio->Header.Len = wlan_le16_to_cpu(pGpio->Header.Len);
+                pBehavior->Header.Type =
+                    wlan_le16_to_cpu(pBehavior->Header.Type);
+                pBehavior->Header.Len =
+                    wlan_le16_to_cpu(pBehavior->Header.Len);
+                memmove(Adapter->CurCmd->pdata_buf, &resp->params.ledgpio,
+                        sizeof(HostCmd_DS_802_11_LED_CTRL));
+                break;
+            }
+        case HostCmd_CMD_802_11_CRYPTO:
+            ret = wlan_ret_cmd_802_11_crypto(priv, resp);
+            break;
+
+        case HostCmd_CMD_GET_TSF:
+            resp->params.gettsf.TsfValue =
+                wlan_le64_to_cpu(resp->params.gettsf.TsfValue);
+            memcpy(priv->adapter->CurCmd->pdata_buf,
+                   &resp->params.gettsf.TsfValue, sizeof(u64));
+            break;
+        case HostCmd_CMD_802_11_TX_RATE_QUERY:
+            priv->adapter->TxRate =
+                wlan_le16_to_cpu(resp->params.txrate.TxRate);
+            break;
+        case HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:
+            wlan_ret_ibss_coalescing_status(priv, resp);
+            break;
+
+        case HostCmd_CMD_SDIO_PULL_CTRL:
+            memmove(Adapter->CurCmd->pdata_buf,
+                    &resp->params.sdiopullctl,
+                    sizeof(HostCmd_DS_SDIO_PULL_CTRL));
+            break;
+        case HostCmd_CMD_ECL_SYSTEM_CLOCK_CONFIG:
+            {
+                int i;
+                HostCmd_DS_ECL_SYSTEM_CLOCK_CONFIG *pSysclockcfg =
+                    &resp->params.sysclockcfg;
+
+                pSysclockcfg->Action = wlan_le16_to_cpu(pSysclockcfg->Action);
+                pSysclockcfg->SystemClock =
+                    wlan_le16_to_cpu(pSysclockcfg->SystemClock);
+                pSysclockcfg->SupportedSysClockLen =
+                    wlan_le16_to_cpu(pSysclockcfg->SupportedSysClockLen);
+                for (i = 0;
+                     i <
+                     (sizeof(pSysclockcfg->SupportedSysClock) / sizeof(u16));
+                     i++)
+                    pSysclockcfg->SupportedSysClock[i] =
+                        wlan_le16_to_cpu(pSysclockcfg->SupportedSysClock[i]);
+                memmove(Adapter->CurCmd->pdata_buf, &resp->params.sysclockcfg,
+                        sizeof(HostCmd_DS_ECL_SYSTEM_CLOCK_CONFIG));
+                break;
+            }
+
+        case HostCmd_CMD_MODULE_TYPE_CONFIG:
+            resp->params.moduletypecfg.Action =
+                wlan_le16_to_cpu(resp->params.moduletypecfg.Action);
+            resp->params.moduletypecfg.Module =
+                wlan_le16_to_cpu(resp->params.moduletypecfg.Module);
+            memmove(Adapter->CurCmd->pdata_buf, &resp->params.moduletypecfg,
+                    sizeof(HostCmd_DS_MODULE_TYPE_CONFIG));
+            break;
+
+        case HostCmd_CMD_VERSION_EXT:
+            memcpy(Adapter->CurCmd->pdata_buf,
+                   &resp->params.verext, sizeof(HostCmd_DS_VERSION_EXT));
+            break;
+        case HostCmd_CMD_MEF_CFG:
+            break;
+        case HostCmd_CMD_DBGS_CFG:
+            break;
+        case HostCmd_CMD_GET_MEM:
+            {
+                FW_MEM_DATA *pFwData =
+                    (FW_MEM_DATA *) Adapter->CurCmd->pdata_buf;
+                pFwData->size = resp->Size - S_DS_GEN;
+                memcpy((u8 *) & pFwData->data, &resp->params.getmem,
+                       pFwData->size);
+            }
+            break;
+        default:
+            PRINTM(INFO, "CMD_RESP: Unknown command response %#x\n",
+                   resp->Command);
+            break;
+        }
+    }
+
+    if (Adapter->CurCmd) {
+        /* Clean up and Put current command back to CmdFreeQ */
+        wlan_insert_cmd_to_free_q(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+#if WIRELESS_EXT >= 18
+/** 
+ *  @brief This function sends mic error event to application.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @para event    MIC ERROR EVENT. 
+ *  @return 	   n/a
+ */
+void
+send_mic_error_event(wlan_private * priv, u32 event)
+{
+    union iwreq_data iwrq;
+    struct iw_michaelmicfailure mic;
+
+    ENTER();
+
+    memset(&iwrq, 0, sizeof(iwrq));
+    memset(&mic, 0, sizeof(mic));
+    if (event == EVENT_MIC_ERR_UNICAST) {
+        mic.flags = IW_MICFAILURE_PAIRWISE;
+    } else {
+        mic.flags = IW_MICFAILURE_GROUP;
+    }
+
+    iwrq.data.pointer = &mic;
+    iwrq.data.length = sizeof(mic);
+
+    wireless_send_event(priv->wlan_dev.netdev, IWEVMICHAELMICFAILURE, &iwrq,
+                        (u8 *) & mic);
+
+    LEAVE();
+    return;
+}
+#endif
+
+/** 
+ *  @brief This function handles events generated by firmware
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_process_event(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    u32 eventcause = Adapter->EventCause;
+
+    ENTER();
+
+    /* Save the last event to debug log */
+    Adapter->dbg.LastEventIndex =
+        (Adapter->dbg.LastEventIndex + 1) % DBG_CMD_NUM;
+    Adapter->dbg.LastEvent[Adapter->dbg.LastEventIndex] = eventcause;
+
+    if (eventcause != EVENT_PS_SLEEP && eventcause != EVENT_PS_AWAKE)
+        PRINTM(EVENT, "EVENT: 0x%x @ %lu\n", eventcause, os_time_get());
+
+    switch (eventcause) {
+    case EVENT_DUMMY_HOST_WAKEUP_SIGNAL:
+        PRINTM(INFO, "EVENT: DUMMY_HOST_WAKEUP_SIGNAL\n");
+        if (!priv->adapter->HS_Activated) {
+            PRINTM(WARN, "DUMMY_HOST_WAKEUP_SIGNAL (HS_Deactivated)\n");
+        } else {
+            wlan_host_sleep_wakeup_event(priv);
+        }
+        break;
+    case EVENT_LINK_SENSED:
+        PRINTM(INFO, "EVENT: LINK_SENSED\n");
+        Adapter->AdhocLinkSensed = TRUE;
+        os_carrier_on(priv);
+        os_start_queue(priv);
+        wmm_start_queue(priv);
+        send_iwevcustom_event(priv, CUS_EVT_ADHOC_LINK_SENSED);
+        break;
+
+    case EVENT_DEAUTHENTICATED:
+        PRINTM(INFO, "EVENT: Deauthenticated\n");
+        Adapter->dbg.num_event_deauth++;
+        wlan_handle_disconnect_event(priv);
+        break;
+
+    case EVENT_DISASSOCIATED:
+        PRINTM(INFO, "EVENT: Disassociated\n");
+        Adapter->dbg.num_event_disassoc++;
+        wlan_handle_disconnect_event(priv);
+        break;
+
+    case EVENT_LINK_LOST:
+        PRINTM(INFO, "EVENT: Link lost\n");
+        Adapter->dbg.num_event_link_lost++;
+        wlan_handle_disconnect_event(priv);
+        break;
+
+    case EVENT_PS_SLEEP:
+        PRINTM(INFO, "EVENT: SLEEP\n");
+        PRINTM(EVENT, "_");
+
+        /* handle unexpected PS SLEEP event */
+        if (Adapter->PSState == PS_STATE_FULL_POWER) {
+            PRINTM(INFO, "EVENT: In FULL POWER mode - ignore PS SLEEP\n");
+            break;
+        }
+        Adapter->PSState = PS_STATE_PRE_SLEEP;
+
+        wlan_ps_cond_check(priv, (u16) Adapter->PSMode);
+        break;
+
+    case EVENT_PS_AWAKE:
+        PRINTM(INFO, "EVENT: AWAKE \n");
+        PRINTM(EVENT, "|");
+        Adapter->bWakeupDevRequired = FALSE;
+        Adapter->WakeupTries = 0;
+        sbi_reset_deepsleep_wakeup(priv);
+
+        /* handle unexpected PS AWAKE event */
+        if (Adapter->PSState == PS_STATE_FULL_POWER) {
+            PRINTM(INFO, "EVENT: In FULL POWER mode - ignore PS AWAKE\n");
+            break;
+        }
+
+        Adapter->TxLockFlag = FALSE;
+        if (TRUE == wlan_check_last_packet_indication(priv)) {
+            if (!priv->wlan_dev.dnld_sent && Adapter->gen_null_pkg) {
+                wlan_send_null_packet(priv,
+                                      MRVDRV_TxPD_POWER_MGMT_NULL_PACKET |
+                                      MRVDRV_TxPD_POWER_MGMT_LAST_PACKET);
+                Adapter->TxLockFlag = TRUE;
+            }
+        }
+
+        Adapter->PSState = PS_STATE_AWAKE;
+
+        if (Adapter->NeedToWakeup == TRUE) {
+            /*
+             * wait for the command processing to finish
+             * before resuming sending 
+             * Adapter->NeedToWakeup will be set to FALSE 
+             * in PSWakup()
+             */
+            PRINTM(INFO, "Waking up...\n");
+            wlan_exit_ps(priv, 0);
+        }
+        break;
+
+    case EVENT_DEEP_SLEEP_AWAKE:
+        sbi_reset_deepsleep_wakeup(priv);
+        PRINTM(INFO, "EVENT: DS_AWAKE\n");
+        if (priv->adapter->IsDeepSleep == TRUE) {
+            Adapter->IsDeepSleep = FALSE;
+            Adapter->bWakeupDevRequired = FALSE;
+            Adapter->WakeupTries = 0;
+            /* 
+             * For auto DS + BGS case, some delay is needed to 
+             * avoid going back to DS before getting BGS result
+             */
+            if (Adapter->IsAutoDeepSleepEnabled &&
+                Adapter->bgScanConfig->Enable)
+                os_sched_timeout(10);
+            if (!priv->enhance_flag) {
+                priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+                priv->adapter->HisRegCpy |= HIS_TxDnLdRdy;
+            }
+        }
+        send_iwevcustom_event(priv, CUS_EVT_DEEP_SLEEP_AWAKE);
+        wake_up_interruptible(&Adapter->ds_awake_q);
+        break;
+
+    case EVENT_HOST_SLEEP_AWAKE:
+        PRINTM(INFO, "EVENT: HS_AWAKE\n");
+        Adapter->bWakeupDevRequired = FALSE;
+        Adapter->WakeupTries = 0;
+        sbi_reset_deepsleep_wakeup(priv);
+        /*
+         * in BG SCAN mode w/ deep sleep, WAKE UP event
+         * will be sent first, Deep Sleep Awake will
+         * be sent later. 
+         */
+        if (priv->adapter->IsDeepSleep == TRUE) {
+            priv->adapter->IsDeepSleep = FALSE;
+            if (!priv->enhance_flag) {
+                priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+                priv->adapter->HisRegCpy |= HIS_TxDnLdRdy;
+            }
+        }
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_WAKEUP_CONFIRM,
+                               0, 0, 0, NULL);
+        break;
+
+    case EVENT_MIC_ERR_UNICAST:
+        PRINTM(INFO, "EVENT: UNICAST MIC ERROR\n");
+#if WIRELESS_EXT >= 18
+        send_mic_error_event(priv, EVENT_MIC_ERR_UNICAST);
+#else
+        send_iwevcustom_event(priv, CUS_EVT_MLME_MIC_ERR_UNI);
+#endif
+        break;
+
+    case EVENT_MIC_ERR_MULTICAST:
+        PRINTM(INFO, "EVENT: MULTICAST MIC ERROR\n");
+#if WIRELESS_EXT >= 18
+        send_mic_error_event(priv, EVENT_MIC_ERR_MULTICAST);
+#else
+        send_iwevcustom_event(priv, CUS_EVT_MLME_MIC_ERR_MUL);
+#endif
+        break;
+    case EVENT_MIB_CHANGED:
+    case EVENT_INIT_DONE:
+        break;
+
+    case EVENT_ADHOC_BCN_LOST:
+        PRINTM(INFO, "EVENT: ADHOC_BCN_LOST\n");
+        Adapter->AdhocLinkSensed = FALSE;
+        wlan_clean_txrx(priv);
+        send_iwevcustom_event(priv, CUS_EVT_ADHOC_BCN_LOST);
+        break;
+
+    case EVENT_BG_SCAN_REPORT:
+        PRINTM(INFO, "EVENT: BGS_REPORT\n");
+        Adapter->bgScanConfig->Enable = FALSE;
+        ret = wlan_cmd_bgs_query(priv);
+        break;
+    case EVENT_STOP_TX:
+        PRINTM(INFO, "EVENT: Stop Tx (%#x)\n", eventcause);
+        wlan_11h_tx_disable(priv);
+        break;
+    case EVENT_START_TX:
+        PRINTM(INFO, "EVENT: Start Tx (%#x)\n", eventcause);
+        wlan_11h_tx_enable(priv);
+        break;
+    case EVENT_CHANNEL_SWITCH:
+        PRINTM(INFO, "EVENT: Channel Switch (%#x)\n", eventcause);
+
+        wlan_prepare_cmd(priv, HostCmd_CMD_802_11_RF_CHANNEL,
+                         HostCmd_OPT_802_11_RF_CHANNEL_GET, 0, 0, NULL);
+        break;
+    case EVENT_MEAS_REPORT_RDY:
+        PRINTM(INFO, "EVENT: Measurement Report Ready (%#x)\n", eventcause);
+        wlan_prepare_cmd(priv, HostCmd_CMD_MEASUREMENT_REPORT,
+                         HostCmd_ACT_GEN_SET, 0, 0, NULL);
+        break;
+    case EVENT_WMM_STATUS_CHANGE:
+        PRINTM(INFO, "EVENT: WMM status changed\n");
+        ret = wlan_cmd_wmm_status_change(priv);
+        break;
+
+    case EVENT_RSSI_LOW:
+        PRINTM(INFO, "EVENT: Beacon RSSI_LOW\n");
+        send_iwevcustom_event(priv, CUS_EVT_BEACON_RSSI_LOW);
+        break;
+    case EVENT_SNR_LOW:
+        PRINTM(INFO, "EVENT: Beacon SNR_LOW\n");
+        send_iwevcustom_event(priv, CUS_EVT_BEACON_SNR_LOW);
+        break;
+    case EVENT_MAX_FAIL:
+        PRINTM(INFO, "EVENT: MAX_FAIL\n");
+        send_iwevcustom_event(priv, CUS_EVT_MAX_FAIL);
+        break;
+    case EVENT_RSSI_HIGH:
+        PRINTM(INFO, "EVENT: Beacon RSSI_HIGH\n");
+        send_iwevcustom_event(priv, CUS_EVT_BEACON_RSSI_HIGH);
+        break;
+    case EVENT_SNR_HIGH:
+        PRINTM(INFO, "EVENT: Beacon SNR_HIGH\n");
+        send_iwevcustom_event(priv, CUS_EVT_BEACON_SNR_HIGH);
+        break;
+    case EVENT_DATA_RSSI_LOW:
+        PRINTM(INFO, "EVENT: Data RSSI_LOW\n");
+        send_iwevcustom_event(priv, CUS_EVT_DATA_RSSI_LOW);
+        break;
+    case EVENT_DATA_SNR_LOW:
+        PRINTM(INFO, "EVENT: Data SNR_LOW\n");
+        send_iwevcustom_event(priv, CUS_EVT_DATA_SNR_LOW);
+        break;
+    case EVENT_DATA_RSSI_HIGH:
+        PRINTM(INFO, "EVENT: Data RSSI_HIGH\n");
+        send_iwevcustom_event(priv, CUS_EVT_DATA_RSSI_HIGH);
+        break;
+    case EVENT_DATA_SNR_HIGH:
+        PRINTM(INFO, "EVENT: Data SNR_HIGH\n");
+        send_iwevcustom_event(priv, CUS_EVT_DATA_SNR_HIGH);
+        break;
+    case EVENT_IBSS_COALESCED:
+        PRINTM(INFO, "EVENT: IBSS_COALESCED\n");
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_IBSS_COALESCING_STATUS,
+                               HostCmd_ACT_GEN_GET, 0, 0, NULL);
+
+        break;
+    default:
+        PRINTM(INFO, "EVENT: unknown event id: %#x\n", eventcause);
+        break;
+    }
+
+    Adapter->EventCause = 0;
+    LEAVE();
+    return ret;
+}
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_debug.c b/drivers/net/wireless/8688_wlan/wlan/wlan_debug.c
new file mode 100755
index 0000000..126c943
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_debug.c
@@ -0,0 +1,297 @@
+/** @file wlan_debug.c
+  * @brief This file contains functions for debug proc file.
+  *   
+  * (c) Copyright © 2003-2007, Marvell International Ltd.  
+  *   
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	10/04/05: Add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	
+********************************************************/
+
+#include  "wlan_headers.h"
+
+#ifdef CONFIG_PROC_FS
+/********************************************************
+		Local Variables
+********************************************************/
+
+#define item_size(n) (sizeof ((wlan_adapter *)0)->n)
+#define item_addr(n) ((u32) &((wlan_adapter *)0)->n)
+
+#define item_dbg_size(n) (sizeof (((wlan_adapter *)0)->dbg.n))
+#define item_dbg_addr(n) ((u32) &(((wlan_adapter *)0)->dbg.n))
+
+#define item1_size(n) (sizeof ((wlan_dev_t *)0)->n)
+#define item1_addr(n) ((u32) &((wlan_dev_t *)0)->n)
+
+struct debug_data
+{
+    char name[32];
+    u32 size;
+    u32 addr;
+    u32 offset;
+};
+
+/* To debug any member of wlan_adapter or wlan_dev_t, simply add one line here.
+ */
+#define ITEMS_FROM_WLAN_DEV		1
+
+static struct debug_data items[] = {
+    {"IntCounter", item_size(IntCounter), 0, item_addr(IntCounter)},
+    {"ConnectStatus", item_size(MediaConnectStatus), 0,
+     item_addr(MediaConnectStatus)},
+    {"wmmQStp", item_size(wmm.queueStopped), 0, item_addr(wmm.queueStopped)},
+    {"wmmPkts", item_size(wmm.packetsQueued), 0,
+     item_addr(wmm.packetsQueued)},
+    {"wmmAcVo", item_size(wmm.packetsOut[WMM_AC_VO]), 0,
+     item_addr(wmm.packetsOut[WMM_AC_VO])},
+    {"wmmAcVi", item_size(wmm.packetsOut[WMM_AC_VI]), 0,
+     item_addr(wmm.packetsOut[WMM_AC_VI])},
+    {"wmmAcBE", item_size(wmm.packetsOut[WMM_AC_BE]), 0,
+     item_addr(wmm.packetsOut[WMM_AC_BE])},
+    {"wmmAcBK", item_size(wmm.packetsOut[WMM_AC_BK]), 0,
+     item_addr(wmm.packetsOut[WMM_AC_BK])},
+    {"PSMode", item_size(PSMode), 0, item_addr(PSMode)},
+    {"PSState", item_size(PSState), 0, item_addr(PSState)},
+    {"IsDeepSleep", item_size(IsDeepSleep), 0, item_addr(IsDeepSleep)},
+    {"IsAutoDeepSleepEnabled", item_size(IsAutoDeepSleepEnabled), 0,
+     item_addr(IsAutoDeepSleepEnabled)},
+    {"WakeupDevReq", item_size(bWakeupDevRequired), 0,
+     item_addr(bWakeupDevRequired)},
+    {"WakeupTries", item_size(WakeupTries), 0, item_addr(WakeupTries)},
+    {"HS_Configured", item_size(bHostSleepConfigured), 0,
+     item_addr(bHostSleepConfigured)},
+    {"HS_Activated", item_size(HS_Activated), 0, item_addr(HS_Activated)},
+    {"num_tx_timeout", item_dbg_size(num_tx_timeout), 0,
+     item_dbg_addr(num_tx_timeout)},
+    {"num_cmd_timeout", item_dbg_size(num_cmd_timeout), 0,
+     item_dbg_addr(num_cmd_timeout)},
+    {"TimeoutCmdId", item_dbg_size(TimeoutCmdId), 0,
+     item_dbg_addr(TimeoutCmdId)},
+    {"TimeoutCmdAct", item_dbg_size(TimeoutCmdAct), 0,
+     item_dbg_addr(TimeoutCmdAct)},
+    {"LastCmdId", item_dbg_size(LastCmdId), 0, item_dbg_addr(LastCmdId)},
+    {"LastCmdAct", item_dbg_size(LastCmdAct), 0, item_dbg_addr(LastCmdAct)},
+    {"LastCmdIndex", item_dbg_size(LastCmdIndex), 0,
+     item_dbg_addr(LastCmdIndex)},
+    {"LastCmdRespId", item_dbg_size(LastCmdRespId), 0,
+     item_dbg_addr(LastCmdRespId)},
+    {"LastCmdRespIndex", item_dbg_size(LastCmdRespIndex), 0,
+     item_dbg_addr(LastCmdRespIndex)},
+    {"LastEvent", item_dbg_size(LastEvent), 0, item_dbg_addr(LastEvent)},
+    {"LastEventIndex", item_dbg_size(LastEventIndex), 0,
+     item_dbg_addr(LastEventIndex)},
+    {"num_cmd_h2c_fail", item_dbg_size(num_cmd_host_to_card_failure), 0,
+     item_dbg_addr(num_cmd_host_to_card_failure)},
+    {"num_cmd_sleep_cfm_fail",
+     item_dbg_size(num_cmd_sleep_cfm_host_to_card_failure), 0,
+     item_dbg_addr(num_cmd_sleep_cfm_host_to_card_failure)},
+    {"num_tx_h2c_fail", item_dbg_size(num_tx_host_to_card_failure), 0,
+     item_dbg_addr(num_tx_host_to_card_failure)},
+    {"num_evt_deauth", item_dbg_size(num_event_deauth), 0,
+     item_dbg_addr(num_event_deauth)},
+    {"num_evt_disassoc", item_dbg_size(num_event_disassoc), 0,
+     item_dbg_addr(num_event_disassoc)},
+    {"num_evt_link_lost", item_dbg_size(num_event_link_lost), 0,
+     item_dbg_addr(num_event_link_lost)},
+    {"num_cmd_deauth", item_dbg_size(num_cmd_deauth), 0,
+     item_dbg_addr(num_cmd_deauth)},
+    {"num_cmd_assoc_ok", item_dbg_size(num_cmd_assoc_success), 0,
+     item_dbg_addr(num_cmd_assoc_success)},
+    {"num_cmd_assoc_fail", item_dbg_size(num_cmd_assoc_failure), 0,
+     item_dbg_addr(num_cmd_assoc_failure)},
+
+    {"dnld_sent", item1_size(dnld_sent), 0, item1_addr(dnld_sent)},
+};
+
+static int num_of_items = sizeof(items) / sizeof(items[0]);
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+/** 
+ *  @brief proc read function
+ *
+ *  @param page	   pointer to buffer
+ *  @param s       read data starting position
+ *  @param off     offset
+ *  @param cnt     counter 
+ *  @param eof     end of file flag
+ *  @param data    data to output
+ *  @return 	   number of output data
+ */
+static int
+wlan_debug_read(char *page, char **s, off_t off, int cnt, int *eof,
+                void *data)
+{
+    int val = 0;
+    char *p = page;
+    int i;
+
+    struct debug_data *d = (struct debug_data *) data;
+
+    if (MODULE_GET == 0)
+        return WLAN_STATUS_FAILURE;
+
+    for (i = 0; i < num_of_items; i++) {
+        if (d[i].size == 1)
+            val = *((u8 *) d[i].addr);
+        else if (d[i].size == 2)
+            val = *((u16 *) d[i].addr);
+        else if (d[i].size == 4)
+            val = *((u32 *) d[i].addr);
+        else {
+            int j;
+            p += sprintf(p, "%s=", d[i].name);
+            for (j = 0; j < d[i].size; j += 2) {
+                val = *(u16 *) (d[i].addr + j);
+                p += sprintf(p, "0x%x ", val);
+            }
+            p += sprintf(p, "\n");
+            continue;
+        }
+
+        if (strstr(d[i].name, "Id"))
+            p += sprintf(p, "%s=0x%x\n", d[i].name, val);
+        else
+            p += sprintf(p, "%s=%d\n", d[i].name, val);
+    }
+    MODULE_PUT;
+    return p - page;
+}
+
+/** 
+ *  @brief proc write function
+ *
+ *  @param f	   file pointer
+ *  @param buf     pointer to data buffer
+ *  @param cnt     data number to write
+ *  @param data    data to write
+ *  @return 	   number of data
+ */
+static int
+wlan_debug_write(struct file *f, const char *buf, unsigned long cnt,
+                 void *data)
+{
+    int r, i;
+    char *pdata;
+    char *p;
+    char *p0;
+    char *p1;
+    char *p2;
+    struct debug_data *d = (struct debug_data *) data;
+
+    if (MODULE_GET == 0)
+        return WLAN_STATUS_FAILURE;
+
+    pdata = (char *) kmalloc(cnt, GFP_KERNEL);
+    if (pdata == NULL) {
+        MODULE_PUT;
+        return 0;
+    }
+
+    if (copy_from_user(pdata, buf, cnt)) {
+        PRINTM(INFO, "Copy from user failed\n");
+        kfree(pdata);
+        MODULE_PUT;
+        return 0;
+    }
+
+    p0 = pdata;
+    for (i = 0; i < num_of_items; i++) {
+        do {
+            p = strstr(p0, d[i].name);
+            if (p == NULL)
+                break;
+            p1 = strchr(p, '\n');
+            if (p1 == NULL)
+                break;
+            p0 = p1++;
+            p2 = strchr(p, '=');
+            if (!p2)
+                break;
+            p2++;
+            r = string_to_number(p2);
+            if (d[i].size == 1)
+                *((u8 *) d[i].addr) = (u8) r;
+            else if (d[i].size == 2)
+                *((u16 *) d[i].addr) = (u16) r;
+            else if (d[i].size == 4)
+                *((u32 *) d[i].addr) = (u32) r;
+            break;
+        } while (TRUE);
+    }
+    kfree(pdata);
+    MODULE_PUT;
+    return cnt;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+/** 
+ *  @brief create debug proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @param dev     pointer net_device
+ *  @return 	   N/A
+ */
+void
+wlan_debug_entry(wlan_private * priv, struct net_device *dev)
+{
+    int i;
+    struct proc_dir_entry *r;
+
+    if (priv->proc_entry == NULL)
+        return;
+
+    for (i = 0; i < (num_of_items - ITEMS_FROM_WLAN_DEV); i++) {
+        items[i].addr = items[i].offset + (u32) priv->adapter;
+    }
+    for (i = num_of_items - ITEMS_FROM_WLAN_DEV; i < num_of_items; i++) {
+        items[i].addr = items[i].offset + (u32) & priv->wlan_dev;
+    }
+    r = create_proc_entry("debug", 0644, priv->proc_entry);
+    if (r == NULL)
+        return;
+
+    r->data = &items[0];
+    r->read_proc = wlan_debug_read;
+    r->write_proc = wlan_debug_write;
+    r->owner = THIS_MODULE;
+
+}
+
+/** 
+ *  @brief remove proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @return 	   N/A
+ */
+void
+wlan_debug_remove(wlan_private * priv)
+{
+    remove_proc_entry("debug", priv->proc_entry);
+}
+
+#endif
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_decl.h b/drivers/net/wireless/8688_wlan/wlan/wlan_decl.h
new file mode 100755
index 0000000..722a4de
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_decl.h
@@ -0,0 +1,212 @@
+/** @file wlan_decl.h
+ *  @brief This file contains declaration referring to
+ *  functions defined in other source files
+ *     
+ *  (c) Copyright © 2003-2007, Marvell International Ltd.  
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/******************************************************
+Change log:
+	09/29/05: add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join structures.
+	          Move wlan_wext statics to their source file.
+******************************************************/
+
+#ifndef _WLAN_DECL_H_
+#define _WLAN_DECL_H_
+
+/** Function Prototype Declaration */
+int wlan_init_fw(wlan_private * priv);
+int wlan_init_sw(wlan_private * priv);
+int wlan_tx_packet(wlan_private * priv, struct sk_buff *skb);
+void wlan_free_adapter(wlan_private * priv);
+
+int wlan_send_null_packet(wlan_private * priv, u8 flags);
+BOOLEAN wlan_check_last_packet_indication(wlan_private * priv);
+
+void Wep_encrypt(wlan_private * priv, u8 * Buf, u32 Len);
+int wlan_free_cmd_buffer(wlan_private * priv);
+void wlan_clean_cmd_node(CmdCtrlNode * pTempNode);
+CmdCtrlNode *wlan_get_cmd_node(wlan_private * priv);
+
+void wlan_init_cmd_node(wlan_private * priv,
+                        CmdCtrlNode * pTempNode,
+                        WLAN_OID cmd_oid, u16 wait_option, void *pdata_buf);
+
+BOOLEAN wlan_is_cmd_allowed(wlan_private * priv);
+
+int wlan_prepare_cmd(wlan_private * priv,
+                     u16 cmd_no,
+                     u16 cmd_action,
+                     u16 wait_option, WLAN_OID cmd_oid, void *pdata_buf);
+
+void wlan_insert_cmd_to_pending_q(wlan_adapter * Adapter,
+                                  CmdCtrlNode * CmdNode, BOOLEAN addtail);
+
+int wlan_set_deep_sleep(wlan_private * priv, BOOLEAN bDeepSleep);
+int wlan_alloc_cmd_buffer(wlan_private * priv);
+int wlan_exec_next_cmd(wlan_private * priv);
+int wlan_process_event(wlan_private * priv);
+void wlan_interrupt(wlan_private *);
+u32 index_to_data_rate(u8 index);
+u8 data_rate_to_index(u32 rate);
+void get_version(wlan_adapter * adapter, char *version, int maxlen);
+void wlan_read_write_rfreg(wlan_private * priv);
+
+#ifdef CONFIG_PROC_FS
+/** The proc fs interface */
+void wlan_proc_entry(wlan_private * priv, struct net_device *dev);
+void wlan_proc_remove(wlan_private * priv);
+int string_to_number(char *s);
+#ifdef PROC_DEBUG
+void wlan_debug_entry(wlan_private * priv, struct net_device *dev);
+void wlan_debug_remove(wlan_private * priv);
+#endif /* PROC_DEBUG */
+#endif /* CONFIG_PROC_FS */
+int wlan_process_cmdresp(wlan_private * priv);
+void wlan_process_tx(wlan_private * priv);
+void wlan_insert_cmd_to_free_q(wlan_private * priv, CmdCtrlNode * pTempCmd);
+void wlan_cmd_timeout_func(void *FunctionContext);
+
+#ifdef REASSOCIATION
+void wlan_reassoc_timer_func(void *FunctionContext);
+#endif /* REASSOCIATION */
+
+int wlan_set_essid(struct net_device *dev, struct iw_request_info *info,
+                   struct iw_point *dwrq, char *extra);
+int wlan_set_regiontable(wlan_private * priv, u8 region, u8 band);
+
+void wlan_clean_txrx(wlan_private * priv);
+
+int wlan_host_sleep_activated_event(wlan_private * priv);
+int wlan_host_sleep_deactivated_event(wlan_private * priv);
+int wlan_host_sleep_wakeup_event(wlan_private * priv);
+int wlan_deep_sleep_ioctl(wlan_private * priv, struct ifreq *rq);
+
+int wlan_process_rx_packet(wlan_private * priv, struct sk_buff *);
+
+void wlan_enter_ps(wlan_private * priv, int wait_option);
+void wlan_ps_cond_check(wlan_private * priv, u16 PSMode);
+void wlan_exit_ps(wlan_private * priv, int wait_option);
+
+extern CHANNEL_FREQ_POWER *find_cfp_by_band_and_channel(wlan_adapter *
+                                                        adapter, u8 band,
+                                                        u16 channel);
+extern CHANNEL_FREQ_POWER *get_cfp_by_band_and_channel(u8 band, u16 channel,
+                                                       REGION_CHANNEL *
+                                                       region_channnel);
+
+CHANNEL_FREQ_POWER *wlan_get_region_cfp_table(u8 region, u8 band,
+                                              int *cfp_no);
+
+extern void wlan_reset_connect_state(wlan_private * priv);
+
+#if WIRELESS_EXT > 14
+void send_iwevcustom_event(wlan_private * priv, s8 * str);
+#endif
+
+/* Macros and Functions in interface module */
+/** INT Status Bit Definition : Rx upload ready */
+#define HIS_RxUpLdRdy			BIT(0)
+/** INT Status Bit Definition : Tx download ready */
+#define HIS_TxDnLdRdy			BIT(1)
+/** INT Status Bit Definition : Command download ready */
+#define HIS_CmdDnLdRdy			BIT(2)
+/** INT Status Bit Definition : Card event */
+#define HIS_CardEvent			BIT(3)
+/** INT Status Bit Definition : Command upload ready */
+#define HIS_CmdUpLdRdy			BIT(4)
+
+/** Disable Host interrupt mask */
+#define	HIM_DISABLE			0xff
+/** Enable Host interrupt mask */
+#define HIM_ENABLE			0x03
+
+/** Firmware ready */
+#define FIRMWARE_READY			0xfedc
+/** Length of device name */
+#ifndef DEV_NAME_LEN
+#define DEV_NAME_LEN			32
+#endif
+/** Maximum length of key */
+#define MAXKEYLEN			13
+
+/** The number of times to try when polling for status bits */
+#define MAX_POLL_TRIES			100
+
+/** The number of times to try when waiting for downloaded firmware to 
+     become active. (polling the scratch register). */
+
+#define MAX_FIRMWARE_POLL_TRIES		100
+
+/** Number of firmware blocks to transfer */
+#define FIRMWARE_TRANSFER_NBLOCK	2
+
+/** Packet type: data, command & event */
+typedef enum _mv_type
+{
+    MV_TYPE_DAT = 0,
+    MV_TYPE_CMD = 1,
+    MV_TYPE_EVENT = 3
+} mv_type;
+
+/** Function Prototype Declaration : Function add */
+typedef wlan_private *(*wlan_notifier_fn_add) (void *dev_id);
+/** Function Prototype Declaration : Function remove */
+typedef int (*wlan_notifier_fn_remove) (void *dev_id);
+
+/** Function Prototype Declaration : ISR notifier */
+typedef IRQ_RET_TYPE(*isr_notifier_fn_t) (s32 irq, void *dev_id,
+                                          struct pt_regs * reg);
+/** Function Prototype Declaration : IRQ handler */
+typedef IRQ_RET_TYPE(*handler_fn_t) (s32 irq, void *dev_id, struct pt_regs *);
+
+/* Probe and Check if the card is present*/
+int sbi_probe_card(void *card);
+/** Register SBI functions */
+int *sbi_register(wlan_notifier_fn_add, wlan_notifier_fn_remove, void *);
+/** Unregister SBI function */
+void sbi_unregister(void);
+/** Register SBI device */
+int sbi_register_dev(wlan_private * priv);
+/** Unregister SBI device */
+int sbi_unregister_dev(wlan_private *);
+int sbi_disable_host_int(wlan_private * priv);
+/** Get interrupt status */
+int sbi_get_int_status(wlan_private * priv, u8 *);
+int sbi_prog_firmware(wlan_private *);
+/** Check firmware status */
+int sbi_check_fw_status(wlan_private *, int);
+
+int sbi_prog_helper(wlan_private *);
+int sbi_prog_fw_w_helper(wlan_private *);
+
+/** Send data from host to card */
+int sbi_host_to_card(wlan_private * priv, u8 type, u8 * payload, u16 nb);
+int sbi_enable_host_int(wlan_private *);
+
+int sbi_exit_deep_sleep(wlan_private *);
+int sbi_reset_deepsleep_wakeup(wlan_private *);
+
+int sbi_read_ioreg(wlan_private * priv, u32 reg, u8 * dat);
+int sbi_write_ioreg(wlan_private * priv, u32 reg, u8 dat);
+int sbi_set_bus_clock(wlan_private * priv, u8 option);
+
+/** Get CIS information */
+int sbi_get_cis_info(wlan_private * priv, void *cisinfo, int *cislen);
+
+#endif /* _WLAN_DECL_H_ */
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_drv.h b/drivers/net/wireless/8688_wlan/wlan/wlan_drv.h
new file mode 100755
index 0000000..312ac8a
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_drv.h
@@ -0,0 +1,753 @@
+/** @file wlan_drv.h
+  * @brief This file contains wlan driver specific defines etc.
+  * 
+  * (c) Copyright © 2003-2006, Marvell International Ltd. 
+  *
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	05/30/07: Initial creation
+	
+********************************************************/
+
+#ifndef _WLAN_DRV_H
+#define _WLAN_DRV_H
+
+/** Driver release version */
+#define DRIVER_RELEASE_VERSION		"26530"
+
+/** Maximum number of BSSID per channel */
+#define	MAX_BSSID_PER_CHANNEL		16
+
+/** For the extended Scan */
+#define MAX_EXTENDED_SCAN_BSSID_LIST    (MAX_BSSID_PER_CHANNEL * \
+						MRVDRV_MAX_CHANNEL_SIZE + 1)
+enum
+{
+    ADHOC_IDLE,
+    ADHOC_STARTED,
+    ADHOC_JOINED,
+    ADHOC_COALESCED
+};
+
+typedef struct _PER_CHANNEL_BSSID_LIST_DATA
+{
+    /** BSSID list data start */
+    u8 ucStart;
+    /** BSSID list data count */
+    u8 ucNumEntry;
+} PER_CHANNEL_BSSID_LIST_DATA, *PPER_CHANNEL_BSSID_LIST_DATA;
+
+typedef struct _MRV_BSSID_IE_LIST
+{
+    /** Fixed IEs */
+    WLAN_802_11_FIXED_IEs FixedIE;
+    /** Variable IEs */
+    u8 VariableIE[MRVDRV_SCAN_LIST_VAR_IE_SPACE];
+} MRV_BSSID_IE_LIST, *PMRV_BSSID_IE_LIST;
+
+/** Maximum number of region channel */
+#define	MAX_REGION_CHANNEL_NUM	2
+
+/** Chan-Freq-TxPower mapping table*/
+typedef struct _CHANNEL_FREQ_POWER
+{
+        /** Channel Number		*/
+    u16 Channel;
+        /** Frequency of this Channel	*/
+    u32 Freq;
+        /** Max allowed Tx power level	*/
+    u16 MaxTxPower;
+        /** TRUE:channel unsupported;  FLASE:supported*/
+    BOOLEAN Unsupported;
+} CHANNEL_FREQ_POWER;
+
+/** region-band mapping table*/
+typedef struct _REGION_CHANNEL
+{
+        /** TRUE if this entry is valid		     */
+    BOOLEAN Valid;
+        /** Region code for US, Japan ...	     */
+    u8 Region;
+        /** Band B/G/A, used for BAND_CONFIG cmd	     */
+    u8 Band;
+        /** Actual No. of elements in the array below */
+    u8 NrCFP;
+        /** chan-freq-txpower mapping table*/
+    CHANNEL_FREQ_POWER *CFP;
+} REGION_CHANNEL;
+
+typedef struct _wlan_802_11_security_t
+{
+    /** WPA enabled flag */
+    BOOLEAN WPAEnabled;
+    /** WPA2 enabled flag */
+    BOOLEAN WPA2Enabled;
+    /** WEP status */
+    WLAN_802_11_WEP_STATUS WEPStatus;
+    /** Authentication mode */
+    WLAN_802_11_AUTHENTICATION_MODE AuthenticationMode;
+    /** Encryption mode */
+    WLAN_802_11_ENCRYPTION_MODE EncryptionMode;
+} wlan_802_11_security_t;
+
+/** Current Basic Service Set State Structure */
+typedef struct
+{
+    /** BSS descriptor */
+    BSSDescriptor_t BSSDescriptor;
+
+        /** band */
+    u8 band;
+
+        /** number of rates supported */
+    int NumOfRates;
+
+        /** supported rates*/
+    u8 DataRates[WLAN_SUPPORTED_RATES];
+
+        /** wmm enable? */
+    u8 wmm_enabled;
+
+        /** uapsd enable?*/
+    u8 wmm_uapsd_enabled;
+} CurrentBSSParams_t;
+
+/** sleep_params */
+typedef struct SleepParams
+{
+    /** Sleep parameter error */
+    u16 sp_error;
+    /** Sleep parameter offset */
+    u16 sp_offset;
+    /** Sleep parameter stable time */
+    u16 sp_stabletime;
+    /** Sleep parameter calibration control */
+    u8 sp_calcontrol;
+    /** Sleep parameter external sleep clock */
+    u8 sp_extsleepclk;
+    /** Sleep parameter reserved */
+    u16 sp_reserved;
+} SleepParams;
+
+/** sleep_period */
+typedef struct SleepPeriod
+{
+    /** Sleep period */
+    u16 period;
+    /** Reserved */
+    u16 reserved;
+} SleepPeriod;
+
+/** Debug command number */
+#define DBG_CMD_NUM	5
+
+/** info for debug purpose */
+typedef struct _wlan_dbg
+{
+    /** Number of host to card command failures */
+    u32 num_cmd_host_to_card_failure;
+    /** Number of host to card sleep confirm failures */
+    u32 num_cmd_sleep_cfm_host_to_card_failure;
+    /** Number of host to card Tx failures */
+    u32 num_tx_host_to_card_failure;
+    /** Number of deauthentication events */
+    u32 num_event_deauth;
+    /** Number of disassosiation events */
+    u32 num_event_disassoc;
+    /** Number of link lost events */
+    u32 num_event_link_lost;
+    /** Number of deauthentication commands */
+    u32 num_cmd_deauth;
+    /** Number of association comamnd successes */
+    u32 num_cmd_assoc_success;
+    /** Number of association command failures */
+    u32 num_cmd_assoc_failure;
+    /** Number of Tx timeouts */
+    u32 num_tx_timeout;
+    /** Number of command timeouts */
+    u32 num_cmd_timeout;
+    /** Timeout command ID */
+    u16 TimeoutCmdId;
+    /** Timeout command action */
+    u16 TimeoutCmdAct;
+    /** List of last command IDs */
+    u16 LastCmdId[DBG_CMD_NUM];
+    /** List of last command actions */
+    u16 LastCmdAct[DBG_CMD_NUM];
+    /** Last command index */
+    u16 LastCmdIndex;
+    /** List of last command response IDs */
+    u16 LastCmdRespId[DBG_CMD_NUM];
+    /** Last command response index */
+    u16 LastCmdRespIndex;
+    /** List of last events */
+    u16 LastEvent[DBG_CMD_NUM];
+    /** Last event index */
+    u16 LastEventIndex;
+} wlan_dbg;
+
+/** Data structure for the Marvell WLAN device */
+typedef struct _wlan_dev
+{
+        /** device name */
+    char name[DEV_NAME_LEN];
+        /** card pointer */
+    void *card;
+        /** IO port */
+    u32 ioport;
+        /** Upload received */
+    u32 upld_rcv;
+        /** Upload type */
+    u32 upld_typ;
+        /** Upload length */
+    u32 upld_len;
+        /** netdev pointer */
+    struct net_device *netdev;
+        /** Upload buffer*/
+    u8 upld_buf[WLAN_UPLD_SIZE];
+        /** Download sent: 
+	 	bit0 1/0=data_sent/data_tx_done, 
+		bit1 1/0=cmd_sent/cmd_tx_done, 
+		all other bits reserved 0 */
+    u8 dnld_sent;
+} wlan_dev_t, *pwlan_dev_t;
+
+/** Data structure for WPS information */
+typedef struct
+{
+    /** Session enable flag */
+    BOOLEAN SessionEnable;
+} wps_t;
+
+/** Private structure for the MV device */
+struct _wlan_private
+{
+    /** Device open */
+    int open;
+
+    /** Device adapter structure */
+    wlan_adapter *adapter;
+    /** Device structure */
+    wlan_dev_t wlan_dev;
+
+    /** Net device statistics structure */
+    struct net_device_stats stats;
+
+    /** IW statistics */
+    struct iw_statistics wstats;
+#ifdef CONFIG_PROC_FS
+    struct proc_dir_entry *proc_mwlan;
+    struct proc_dir_entry *proc_entry;
+#endif                          /* CONFIG_PROC_FS */
+    /** Firmware helper */
+    const struct firmware *fw_helper;
+    /** Firmware */
+    const struct firmware *firmware;
+    /** Hotplug device */
+    struct device *hotplug_device;
+
+        /** thread to service interrupts */
+    wlan_thread MainThread;
+
+#ifdef REASSOCIATION
+        /** thread to service mac events */
+    wlan_thread ReassocThread;
+#endif                          /* REASSOCIATION */
+
+        /** Enhancement flag - for V10 and UP */
+    int enhance_flag;
+};
+
+/** Wlan Adapter data structure*/
+struct _wlan_adapter
+{
+        /** STATUS variables */
+    WLAN_HARDWARE_STATUS HardwareStatus;
+    /** Firmware release number */
+    u32 FWReleaseNumber;
+    /** Firmware capability information */
+    u32 fwCapInfo;
+    /** Chip revision number */
+    u8 chip_rev;
+
+        /** Command-related variables */
+    /** Command sequence number */
+    u16 SeqNum;
+    /** Command controller nodes */
+    CmdCtrlNode *CmdArray;
+        /** Current Command */
+    CmdCtrlNode *CurCmd;
+    /** Current command return code */
+    int CurCmdRetCode;
+
+        /** Command Queues */
+        /** Free command buffers */
+    struct list_head CmdFreeQ;
+        /** Pending command buffers */
+    struct list_head CmdPendingQ;
+
+        /** Variables brought in from private structure */
+    int irq;
+
+        /** Async and Sync Event variables */
+    u32 IntCounter;
+    /** save int for DS/PS */
+    u32 IntCounterSaved;
+    /** Event cause */
+    u32 EventCause;
+        /** nickname */
+    u8 nodeName[16];
+
+        /** spin locks */
+    spinlock_t QueueSpinLock __ATTRIB_ALIGN__;
+
+        /** Timers */
+    WLAN_DRV_TIMER MrvDrvCommandTimer __ATTRIB_ALIGN__;
+    /** Command timer set flag */
+    BOOLEAN CommandTimerIsSet;
+
+#ifdef REASSOCIATION
+        /**Reassociation timer*/
+    BOOLEAN ReassocTimerIsSet;
+    WLAN_DRV_TIMER MrvDrvTimer __ATTRIB_ALIGN__;
+#endif                          /* REASSOCIATION */
+
+        /** Event Queues */
+    wait_queue_head_t ds_awake_q __ATTRIB_ALIGN__;
+
+    /** His registry copy */
+    u8 HisRegCpy;
+
+    /** bg scan related variable */
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgScanConfig;
+    /** BG scan configuration size */
+    u32 bgScanConfigSize;
+
+    /** WMM related variable*/
+    WMM_DESC wmm;
+
+        /** current ssid/bssid related parameters*/
+    CurrentBSSParams_t CurBssParams;
+
+    /** Infrastructure mode */
+    WLAN_802_11_NETWORK_INFRASTRUCTURE InfrastructureMode;
+
+    /** Attempted BSS descriptor */
+    BSSDescriptor_t *pAttemptedBSSDesc;
+
+    /** Attempted SSID before scan */
+    WLAN_802_11_SSID AttemptedSSIDBeforeScan;
+    /** Prevous SSID */
+    WLAN_802_11_SSID PreviousSSID;
+    /** Previous BSSID */
+    u8 PreviousBSSID[ETH_ALEN];
+
+    /** Scan table */
+    BSSDescriptor_t *ScanTable;
+    /** Number of records in the scan table */
+    u32 NumInScanTable;
+
+    /** Scan type */
+    u8 ScanType;
+    /** Scan mode */
+    u32 ScanMode;
+    /** Specific scan time */
+    u16 SpecificScanTime;
+    /** Active scan time */
+    u16 ActiveScanTime;
+    /** Passive scan time */
+    u16 PassiveScanTime;
+
+    /** Beacon period */
+    u16 BeaconPeriod;
+    /** AdHoc G rate */
+    u8 AdhocState;
+    /** AdHoc link sensed flag */
+    BOOLEAN AdhocLinkSensed;
+
+#ifdef REASSOCIATION
+        /** Reassociation on and off */
+    BOOLEAN Reassoc_on;
+    SEMAPHORE ReassocSem;
+#endif                          /* REASSOCIATION */
+
+    /** ATIM enabled flag */
+    BOOLEAN ATIMEnabled;
+
+        /** MAC address information */
+    u8 CurrentAddr[ETH_ALEN];
+    /** Multicast address list */
+    u8 MulticastList[MRVDRV_MAX_MULTICAST_LIST_SIZE]
+        [ETH_ALEN];
+    /** Number of multicast addresses in the list */
+    u32 NumOfMulticastMACAddr;
+
+    /** Hardware rate drop mode */
+    u16 HWRateDropMode;
+    /** Rate bitmap */
+    u16 RateBitmap;
+    /** Threshold */
+    u16 Threshold;
+    /** Final rate */
+    u16 FinalRate;
+        /** control G Rates */
+    BOOLEAN adhoc_grate_enabled;
+
+    /** Tx antenna */
+    WLAN_802_11_ANTENNA TxAntenna;
+    /** Rx antenna */
+    WLAN_802_11_ANTENNA RxAntenna;
+
+    /** AdHoc channel */
+    u8 AdhocChannel;
+    /** AdHoc autoselect */
+    u8 AdhocAutoSel;
+    /** Fragmentation threshold */
+    WLAN_802_11_FRAGMENTATION_THRESHOLD FragThsd;
+    /** RTS threshold */
+    WLAN_802_11_RTS_THRESHOLD RTSThsd;
+
+    /** Data rate */
+    u32 DataRate;
+    /** Automatic data rate flag */
+    BOOLEAN Is_DataRate_Auto;
+
+        /** number of association attempts for the current SSID cmd */
+    /** Listen interval */
+    u16 ListenInterval;
+    /** Tx retry count */
+    u8 TxRetryCount;
+
+        /** Tx-related variables (for single packet tx) */
+    /** Current Tx packet */
+    struct sk_buff *CurrentTxSkb;
+    /** Tx lock flag */
+    BOOLEAN TxLockFlag;
+    /** Gen NULL pkg */
+    u16 gen_null_pkg;
+    /** Current Tx lock */
+    spinlock_t CurrentTxLock __ATTRIB_ALIGN__;
+
+        /** NIC Operation characteristics */
+    /** Current packet filter */
+    u16 CurrentPacketFilter;
+    /** Media connection status */
+    u32 MediaConnectStatus;
+    /** Region code */
+    u16 RegionCode;
+    /** Tx power level */
+    u16 TxPowerLevel;
+    /** Maximum Tx power level */
+    u8 MaxTxPowerLevel;
+    /** Minimum Tx power level */
+    u8 MinTxPowerLevel;
+
+        /** POWER MANAGEMENT AND PnP SUPPORT */
+    BOOLEAN SurpriseRemoved;
+    /** ATIM window */
+    u16 AtimWindow;
+
+    /** Power Save mode */
+    u16 PSMode;                 /* Wlan802_11PowerModeCAM=disable
+                                   Wlan802_11PowerModeMAX_PSP=enable */
+    /** Multiple DTIM */
+    u16 MultipleDtim;
+    /** Beacon miss timeout */
+    u16 BCNMissTimeOut;
+    /** Power Save state */
+    u32 PSState;
+    /** Need to wakeup flag */
+    BOOLEAN NeedToWakeup;
+
+    /** Power save confirm sleep command */
+    PS_CMD_ConfirmSleep PSConfirmSleep;
+    /** Local listen interval */
+    u16 LocalListenInterval;
+    /** Null packet interval */
+    u16 NullPktInterval;
+    /** AdHoc awake period */
+    u16 AdhocAwakePeriod;
+    /** Firmware wakeup method */
+    u16 fwWakeupMethod;
+    /** Deep Sleep flag */
+    BOOLEAN IsDeepSleep;
+    /** Auto Deep Sleep enabled flag */
+    BOOLEAN IsAutoDeepSleepEnabled;
+    /** Enhanced Power Save enabled flag */
+    BOOLEAN IsEnhancedPSEnabled;
+    /** Device wakeup required flag */
+    BOOLEAN bWakeupDevRequired;
+    /** Number of wakeup tries */
+    u32 WakeupTries;
+    /** Host Sleep configured flag */
+    BOOLEAN bHostSleepConfigured;
+    /** Host Sleep configuration */
+    HostCmd_DS_802_11_HOST_SLEEP_CFG HSCfg;
+        /** ARP filter related variable */
+    u8 ArpFilter[ARP_FILTER_MAX_BUF_SIZE];
+    /** ARP filter size */
+    u32 ArpFilterSize;
+    /** Host Sleep activated flag */
+    BOOLEAN HS_Activated;
+
+        /** Encryption parameter */
+    wlan_802_11_security_t SecInfo;
+
+    /** WEP keys */
+    MRVL_WEP_KEY WepKey[MRVL_NUM_WEP_KEY];
+    /** Current WEP key index */
+    u16 CurrentWepKeyIndex;
+
+    /** Buffer for TLVs passed from the application to be inserted into the
+     *    association request to firmware 
+     */
+    u8 mrvlAssocTlvBuffer[MRVDRV_ASSOC_TLV_BUF_SIZE];
+
+    /** Length of the data stored in mrvlAssocTlvBuffer*/
+    u8 mrvlAssocTlvBufferLen;
+
+    /** Buffer to store the association response for application retrieval */
+    u8 assocRspBuffer[MRVDRV_ASSOC_RSP_BUF_SIZE];
+
+    /** Length of the data stored in assocRspBuffer */
+    int assocRspSize;
+
+    /** Generice IEEE IEs passed from the application to be inserted into the
+     *    association request to firmware 
+     */
+    u8 genIeBuffer[MRVDRV_GENIE_BUF_SIZE];
+
+    /** Length of the data stored in genIeBuffer */
+    u8 genIeBufferLen;
+
+    /** GTK set flag */
+    BOOLEAN IsGTK_SET;
+
+        /** Encryption Key*/
+    u8 Wpa_ie[256];
+    /** WPA IE length */
+    u8 Wpa_ie_len;
+
+    /** AES key material */
+    HostCmd_DS_802_11_KEY_MATERIAL aeskey;
+
+        /** Advanced Encryption Standard */
+    BOOLEAN AdhocAESEnabled;
+    /** Encryption key command queue */
+    wait_queue_head_t cmd_EncKey __ATTRIB_ALIGN__;
+
+    /** Rx antenna mode */
+    u16 RxAntennaMode;
+    /** TX antenna mode */
+    u16 TxAntennaMode;
+
+        /** Requested Signal Strength*/
+    /** Factor for calculating beacon average */
+    u16 bcn_avg_factor;
+    /** Factor for calculating data average */
+    u16 data_avg_factor;
+    /** Signal to Noise ratio */
+    u16 SNR[MAX_TYPE_B][MAX_TYPE_AVG];
+    /** Noise Floor */
+    u16 NF[MAX_TYPE_B][MAX_TYPE_AVG];
+    /** RSSI */
+    u8 RSSI[MAX_TYPE_B][MAX_TYPE_AVG];
+    /** Raw SNR */
+    u8 rawSNR[DEFAULT_DATA_AVG_FACTOR];
+    /** Raw NF */
+    u8 rawNF[DEFAULT_DATA_AVG_FACTOR];
+    /** Next SNR/NF */
+    u16 nextSNRNF;
+    /** Number of SNR/NF */
+    u16 numSNRNF;
+    /** Rx PD age */
+    u32 RxPDAge;
+    /** Rx PD rate */
+    u16 RxPDRate;
+
+    /** Radio on flag */
+    BOOLEAN RadioOn;
+
+        /** F/W supports multiband? */
+    u16 is_multiband;
+        /** F/W supported bands */
+    u16 fw_bands;
+        /** User selected bands (a/b/bg/abg) */
+    u16 config_bands;
+        /** User selected bands (a/b/g) to start adhoc network */
+    u16 adhoc_start_band;
+
+    /** Pointer to channel list last sent to the firmware for scanning */
+    ChanScanParamSet_t *pScanChannels;
+
+        /** Blue Tooth Co-existence Arbitration */
+    HostCmd_DS_802_11_BCA_TIMESHARE bca_ts;
+
+        /** sleep_params */
+    SleepParams sp;
+
+        /** sleep_period (Enhanced Power Save) */
+    SleepPeriod sleep_period;
+
+/** Maximum number of region channel */
+#define	MAX_REGION_CHANNEL_NUM	2
+        /** Region Channel data */
+    REGION_CHANNEL region_channel[MAX_REGION_CHANNEL_NUM];
+
+    /** Universal Channel data */
+    REGION_CHANNEL universal_channel[MAX_REGION_CHANNEL_NUM];
+
+        /** 11D and Domain Regulatory Data */
+    wlan_802_11d_domain_reg_t DomainReg;
+    /** Parsed region channel */
+    parsed_region_chan_11d_t parsed_region_chan;
+
+        /** FSM variable for 11d support */
+    wlan_802_11d_state_t State11D;
+    /** FSM variable for 11h support */
+    wlan_11h_state_t state11h;
+    /** FSM variable for MEAS support */
+    wlan_meas_state_t stateMeas;
+    /** Beaco buffer */
+    u8 beaconBuffer[MAX_SCAN_BEACON_BUFFER];
+    /** Pointer to valid beacon buffer end */
+    u8 *pBeaconBufEnd;
+
+    /** Log message  */
+    HostCmd_DS_802_11_GET_LOG LogMsg;
+    /** Scan probes */
+    u16 ScanProbes;
+
+    /** Tx packet control */
+    u32 PktTxCtrl;
+
+    /** Tx rate */
+    u16 TxRate;
+
+    /** WPS */
+    wps_t wps;
+
+    /** Debug */
+    wlan_dbg dbg;
+    /** Number of command timeouts */
+    u32 num_cmd_timeout;
+    /** Number of loops that main thread runs w/o sleep */
+    u32 main_thread_loops;
+
+    /** Driver spin lock */
+    spinlock_t driver_lock;
+};
+
+static inline int
+wlan_copy_mcast_addr(wlan_adapter * Adapter, struct net_device *dev)
+{
+    int i = 0;
+    struct dev_mc_list *mcptr = dev->mc_list;
+
+    for (i = 0; i < dev->mc_count; i++) {
+        memcpy(&Adapter->MulticastList[i], mcptr->dmi_addr, ETH_ALEN);
+        mcptr = mcptr->next;
+    }
+
+    return i;
+}
+
+static inline int
+os_upload_rx_packet(wlan_private * priv, struct sk_buff *skb)
+{
+
+    skb->dev = priv->wlan_dev.netdev;
+    skb->protocol = eth_type_trans(skb, priv->wlan_dev.netdev);
+    skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+    netif_rx(skb);
+
+    return 0;
+}
+
+static inline void
+os_free_tx_packet(wlan_private * priv)
+{
+    ulong flags;
+
+    if (priv->adapter->CurrentTxSkb) {
+        kfree_skb(priv->adapter->CurrentTxSkb);
+        spin_lock_irqsave(&priv->adapter->CurrentTxLock, flags);
+        priv->adapter->CurrentTxSkb = NULL;
+        spin_unlock_irqrestore(&priv->adapter->CurrentTxLock, flags);
+    }
+}
+
+/*
+ *  netif carrier_on/off and start(wake)/stop_queue handling
+ *
+ *           carrier_on      carrier_off     start_queue     stop_queue
+ * open           x(connect)      x(disconnect)   x
+ * close                          x                               x
+ * assoc          x                               x
+ * deauth                         x                               x
+ * adhoc-start
+ * adhoc-join
+ * adhoc-link     x                               x
+ * adhoc-bcnlost                  x                               x
+ * scan-begin                     x                               x
+ * scan-end       x                               x
+ * ds-enter                       x                               x
+ * ds-exit        x                               x
+ * xmit                                                           x
+ * xmit-done                                      x
+ * tx-timeout
+ */
+static inline void
+os_carrier_on(wlan_private * priv)
+{
+    if (!netif_carrier_ok(priv->wlan_dev.netdev) &&
+        (priv->adapter->MediaConnectStatus == WlanMediaStateConnected) &&
+        ((priv->adapter->InfrastructureMode != Wlan802_11IBSS) ||
+         (priv->adapter->AdhocLinkSensed))) {
+        netif_carrier_on(priv->wlan_dev.netdev);
+    }
+}
+
+static inline void
+os_carrier_off(wlan_private * priv)
+{
+    if (netif_carrier_ok(priv->wlan_dev.netdev)) {
+        netif_carrier_off(priv->wlan_dev.netdev);
+    }
+}
+
+static inline void
+os_start_queue(wlan_private * priv)
+{
+    if (netif_queue_stopped(priv->wlan_dev.netdev) &&
+        (priv->adapter->MediaConnectStatus == WlanMediaStateConnected) &&
+        ((priv->adapter->InfrastructureMode != Wlan802_11IBSS) ||
+         (priv->adapter->AdhocLinkSensed))) {
+        netif_wake_queue(priv->wlan_dev.netdev);
+    }
+}
+
+static inline void
+os_stop_queue(wlan_private * priv)
+{
+    if (!netif_queue_stopped(priv->wlan_dev.netdev)) {
+        netif_stop_queue(priv->wlan_dev.netdev);
+    }
+}
+
+#endif /* _WLAN_DRV_H */
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_fw.h b/drivers/net/wireless/8688_wlan/wlan/wlan_fw.h
new file mode 100755
index 0000000..b2c7958
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_fw.h
@@ -0,0 +1,3921 @@
+/** @file wlan_fw.h
+ * 
+ * @brief This file contains firmware specific defines. 
+ *  
+ * (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change log:
+	05/30/07: Initial creation
+********************************************************/
+
+#ifndef _WLAN_FW_H
+#define _WLAN_FW_H
+
+/** Macros for Data Alignment : size */
+#define ALIGN_SZ(p, a)	\
+	(((p) + ((a) - 1)) & ~((a) - 1))
+
+/** Macros for Data Alignment : address */
+#define ALIGN_ADDR(p, a)	\
+	((((u32)(p)) + (((u32)(a)) - 1)) & ~(((u32)(a)) - 1))
+
+/** The first valid channel for use */
+#define FIRST_VALID_CHANNEL	0xff
+/** PUBLIC DEFINITIONS */
+/** Default Ad-Hoc channel */
+#define DEFAULT_AD_HOC_CHANNEL       6
+/** Default Ad-Hoc channel A */
+#define DEFAULT_AD_HOC_CHANNEL_A    36
+
+/** Length of SNAP header */
+#define MRVDRV_SNAP_HEADER_LEN          8
+
+/** This is for firmware specific length */
+#define EXTRA_LEN	36
+
+/** Buffer size for ethenet Tx packets */
+#define MRVDRV_ETH_TX_PACKET_BUFFER_SIZE \
+	(ETH_FRAME_LEN + sizeof(TxPD) + EXTRA_LEN)
+
+/** Buffer size for ethernet Rx packets */
+#define MRVDRV_ETH_RX_PACKET_BUFFER_SIZE \
+	(ETH_FRAME_LEN + sizeof(RxPD) \
+	 + MRVDRV_SNAP_HEADER_LEN + EXTRA_LEN)
+
+/** Host Command option for wait for RSP */
+#define HostCmd_OPTION_WAITFORRSP             0x0002
+/** Host Command option for wait for RSP Timeout */
+#define HostCmd_OPTION_TIMEOUT	              0x0004
+
+/** Host Command ID : Get hardware specifications */
+#define HostCmd_CMD_GET_HW_SPEC               0x0003
+/** Host Command ID : 802.11 reset */
+#define HostCmd_CMD_802_11_RESET              0x0005
+/** Host Command ID : 802.11 scan */
+#define HostCmd_CMD_802_11_SCAN               0x0006
+/** Host Command ID : 802.11 get log */
+#define HostCmd_CMD_802_11_GET_LOG            0x000b
+/** Host Command ID : MAC multicast address */
+#define HostCmd_CMD_MAC_MULTICAST_ADR         0x0010
+/** Host Command ID : 802.11 EEPROM access */
+#define HostCmd_CMD_802_11_EEPROM_ACCESS      0x0059
+/** Host Command ID : 802.11 associate */
+#define HostCmd_CMD_802_11_ASSOCIATE          0x0012
+/** Host Command ID : 802.11 set WEP */
+#define HostCmd_CMD_802_11_SET_WEP            0x0013
+/** Host Command ID : 802.11 SNMP MIB */
+#define HostCmd_CMD_802_11_SNMP_MIB           0x0016
+/** Host Command ID : MAC register access */
+#define HostCmd_CMD_MAC_REG_ACCESS            0x0019
+/** Host Command ID : BBP register access */
+#define HostCmd_CMD_BBP_REG_ACCESS            0x001a
+/** Host Command ID : RF register access */
+#define HostCmd_CMD_RF_REG_ACCESS             0x001b
+/** Host Command ID : 802.11 radio control */
+#define HostCmd_CMD_802_11_RADIO_CONTROL      0x001c
+/** Host Command ID : 802.11 RF channel */
+#define HostCmd_CMD_802_11_RF_CHANNEL         0x001d
+/** Host Command ID : 802.11 RF Tx power */
+#define HostCmd_CMD_802_11_RF_TX_POWER        0x001e
+/** Host Command ID : 802.11 RSSI */
+#define HostCmd_CMD_802_11_RSSI               0x001f
+/** Host Command ID : 802.11 RF antenna */
+#define HostCmd_CMD_802_11_RF_ANTENNA         0x0020
+
+/** Host Command ID : 802.11 Power Save mode */
+#define HostCmd_CMD_802_11_PS_MODE	      0x0021
+
+/** Host Command ID : 802.11 deauthenticate */
+#define HostCmd_CMD_802_11_DEAUTHENTICATE     0x0024
+/** Host Command ID : MAC control */
+#define HostCmd_CMD_MAC_CONTROL               0x0028
+/** Host Command ID : 802.11 Ad-Hoc start */
+#define HostCmd_CMD_802_11_AD_HOC_START       0x002b
+/** Host Command ID : 802.11 Ad-Hoc join */
+#define HostCmd_CMD_802_11_AD_HOC_JOIN        0x002c
+
+/** Host Command ID : 802.11 key material */
+#define HostCmd_CMD_802_11_KEY_MATERIAL       0x005e
+
+/** Host Command ID : 802.11 Deep Sleep */
+#define HostCmd_CMD_802_11_DEEP_SLEEP         0x003e
+
+/** Host Command ID : 802.11 Ad-Hoc stop */
+#define HostCmd_CMD_802_11_AD_HOC_STOP        0x0040
+
+/** Host Command ID : 802.11 Host Sleep configuration */
+#define HostCmd_CMD_802_11_HOST_SLEEP_CFG     0x0043
+/** Host Command ID : 802.11 Wakeup confirm */
+#define HostCmd_CMD_802_11_WAKEUP_CONFIRM     0x0044
+/** Host Command ID : 802.11 Host Sleep activated */
+#define HostCmd_CMD_802_11_HOST_SLEEP_ACTIVATE	0x0045
+
+/** Host Command ID : 802.22 MAC address */
+#define HostCmd_CMD_802_11_MAC_ADDRESS        0x004D
+/** Host Command ID : 802.11 EEPROM access */
+#define HostCmd_CMD_802_11_EEPROM_ACCESS      0x0059
+
+/** Host Command ID : 802.11 D domain information */
+#define HostCmd_CMD_802_11D_DOMAIN_INFO       0x005b
+
+/** Host Command ID : WMM Traffic Stream Status */
+#define HostCmd_CMD_WMM_TS_STATUS             0x005d
+
+/** Host Command ID : 802.11 TPC information */
+#define HostCmd_CMD_802_11_TPC_INFO           0x005f
+/** Host Command ID : 802.11 TPC adapt req */
+#define HostCmd_CMD_802_11_TPC_ADAPT_REQ      0x0060
+/** Host Command ID : 802.11 channel SW ann */
+#define HostCmd_CMD_802_11_CHAN_SW_ANN        0x0061
+/** Host Command ID : Measurement request */
+#define HostCmd_CMD_MEASUREMENT_REQUEST       0x0062
+/** Host Command ID : Measurement report */
+#define HostCmd_CMD_MEASUREMENT_REPORT        0x0063
+
+/** Host Command ID : 802.11 sleep parameters */
+#define HostCmd_CMD_802_11_SLEEP_PARAMS          0x0066
+
+/** Host Command ID : 802.11 inactivity timeout */
+#define HostCmd_CMD_802_11_INACTIVITY_TIMEOUT    0x0067
+
+/** Host Command ID : 802.11 sleep period */
+#define HostCmd_CMD_802_11_SLEEP_PERIOD          0x0068
+/** Host Command ID : 802.11 BCA configuration timeshare */
+#define HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE  0x0069
+
+/** Host Command ID : 802.11 BG scan configuration */
+#define HostCmd_CMD_802_11_BG_SCAN_CONFIG        0x006b
+/** Host Command ID : 802.11 BG scan query */
+#define HostCmd_CMD_802_11_BG_SCAN_QUERY         0x006c
+
+/** Host Command ID : 802.11 calibration data ext */
+#define HostCmd_CMD_802_11_CAL_DATA_EXT          0x006d
+
+/** Host Command ID : WMM ADDTS req  */
+#define HostCmd_CMD_WMM_ADDTS_REQ                0x006E
+/** Host Command ID : WMM DELTS req */
+#define HostCmd_CMD_WMM_DELTS_REQ                0x006F
+/** Host Command ID : WMM queue configuration */
+#define HostCmd_CMD_WMM_QUEUE_CONFIG             0x0070
+/** Host Command ID : 802.11 get status */
+#define HostCmd_CMD_WMM_GET_STATUS               0x0071
+
+/** Host Command ID : 802.11 TPC configuration */
+#define HostCmd_CMD_802_11_TPC_CFG               0x0072
+
+/** Host Command ID : 802.11 firmware wakeup method */
+#define HostCmd_CMD_802_11_FW_WAKE_METHOD        0x0074
+
+/** Host Command ID : 802.11 LED control */
+#define HostCmd_CMD_802_11_LED_CONTROL           0x004e
+
+/** Host Command ID : 802.11 subscribe event */
+#define HostCmd_CMD_802_11_SUBSCRIBE_EVENT       0x0075
+
+/** Host Command ID : 802.11 rate adapt rateset */
+#define HostCmd_CMD_802_11_RATE_ADAPT_RATESET    0x0076
+
+/** Host Command ID : 802.11 crypto */
+#define HostCmd_CMD_802_11_CRYPTO                0x0078
+
+/** Host Command ID : 802.11 Tx rate query */
+#define HostCmd_CMD_802_11_TX_RATE_QUERY	0x007f
+
+/** Host Command ID : 802.11 power adapt configuration ext */
+#define HostCmd_CMD_802_11_POWER_ADAPT_CFG_EXT	0x007e
+
+/** Host Command ID : Get TSF */
+#define HostCmd_CMD_GET_TSF                      0x0080
+
+/** Host Command ID : WMM queue stats */
+#define HostCmd_CMD_WMM_QUEUE_STATS              0x0081
+
+/** Host Command ID : 802.11 auto Tx */
+#define HostCmd_CMD_802_11_AUTO_TX		0x0082
+/** Host Command ID : 802.11 IBSS coalescing status */
+#define HostCmd_CMD_802_11_IBSS_COALESCING_STATUS 0x0083
+
+/** Host Command ID : Memory access */
+#define HostCmd_CMD_MEM_ACCESS			0x0086
+
+#ifdef MFG_CMD_SUPPORT
+/** Host Command ID : Mfg command */
+#define HostCmd_CMD_MFG_COMMAND               0x0089
+#endif
+
+/** Host Command ID : DBGS configuration */
+#define HostCmd_CMD_DBGS_CFG		      0x008b
+/** Host Command ID : Get memory */
+#define HostCmd_CMD_GET_MEM		      0x008c
+
+/** Host Command ID : Tx packets stats */
+#define HostCmd_CMD_TX_PKT_STATS              0x008d
+
+/** Host Command ID : Configuration data */
+#define HostCmd_CMD_CFG_DATA                  0x008f
+
+/** Host Command ID : SDIO pull control */
+#define HostCmd_CMD_SDIO_PULL_CTRL		      0x0093
+
+/** Host Command ID : ECL system clock configuration */
+#define HostCmd_CMD_ECL_SYSTEM_CLOCK_CONFIG   0x0094
+
+/** Host Command ID : Extended version */
+#define HostCmd_CMD_VERSION_EXT               0x0097
+
+/** Host Command ID : Module type configuration */
+#define HostCmd_CMD_MODULE_TYPE_CONFIG        0x0099
+
+/** Host Command ID : MEF configuration */
+#define HostCmd_CMD_MEF_CFG		      0x009a
+
+/* For the IEEE Power Save */
+/** Host Subcommand ID : Enter power save */
+#define HostCmd_SubCmd_Enter_PS               0x0030
+/** Host Subcommand ID : Exit power save */
+#define HostCmd_SubCmd_Exit_PS                0x0031
+/** Host Subcommand ID : Sleep confirmed */
+#define HostCmd_SubCmd_Sleep_Confirmed        0x0034
+/** Host Subcommand ID : Full power down */
+#define HostCmd_SubCmd_Full_PowerDown         0x0035
+/** Host Subcommand ID : Full power up */
+#define HostCmd_SubCmd_Full_PowerUp           0x0036
+
+/** Command RET code, MSB is set to 1 */
+#define HostCmd_RET_BIT                       0x8000
+
+/** General Result Code*/
+/** General result code OK */
+#define HostCmd_RESULT_OK                    0x0000
+/** Genenral error */
+#define HostCmd_RESULT_ERROR                 0x0001
+/** Command is not valid */
+#define HostCmd_RESULT_NOT_SUPPORT           0x0002
+/** Command is pending */
+#define HostCmd_RESULT_PENDING               0x0003
+/** System is busy (command ignored) */
+#define HostCmd_RESULT_BUSY                  0x0004
+/** Data buffer is not big enough */
+#define HostCmd_RESULT_PARTIAL_DATA          0x0005
+
+/* Definition of action or option for each command */
+
+/* Define general purpose action */
+/** General purpose action : Read */
+#define HostCmd_ACT_GEN_READ                    0x0000
+/** General purpose action : Write */
+#define HostCmd_ACT_GEN_WRITE                   0x0001
+/** General purpose action : Get */
+#define HostCmd_ACT_GEN_GET                     0x0000
+/** General purpose action : Set */
+#define HostCmd_ACT_GEN_SET                     0x0001
+/** General purpose action : Remove */
+#define HostCmd_ACT_GEN_REMOVE                  0x0002
+/** General purpose action : Off */
+#define HostCmd_ACT_GEN_OFF                     0x0000
+/** General purpose action : On */
+#define HostCmd_ACT_GEN_ON                      0x0001
+
+/* Define action or option for HostCmd_CMD_802_11_SET_WEP */
+/** WEP action : Add */
+#define HostCmd_ACT_ADD                         0x0002
+/** WEP action : Remove */
+#define HostCmd_ACT_REMOVE                      0x0004
+
+/** WEP type : 40 bit */
+#define HostCmd_TYPE_WEP_40_BIT                 0x0001
+/** WEP type : 104 bit */
+#define HostCmd_TYPE_WEP_104_BIT                0x0002
+
+/** WEP Key index mask */
+#define HostCmd_WEP_KEY_INDEX_MASK              0x3fff
+
+/* Define action or option for HostCmd_CMD_802_11_SCAN */
+/** Scan type : BSS */
+#define HostCmd_BSS_TYPE_BSS                    0x0001
+/** Scan type : IBSS */
+#define HostCmd_BSS_TYPE_IBSS                   0x0002
+/** Scan type : Any */
+#define HostCmd_BSS_TYPE_ANY                    0x0003
+
+/* Define action or option for HostCmd_CMD_802_11_SCAN */
+/** Scan type : Active */
+#define HostCmd_SCAN_TYPE_ACTIVE                0x0000
+/** Scan type : Passive */
+#define HostCmd_SCAN_TYPE_PASSIVE               0x0001
+
+/* Radio type definitions for the channel TLV */
+/** Radio type BG */
+#define HostCmd_SCAN_RADIO_TYPE_BG		0
+/** Radio type A */
+#define HostCmd_SCAN_RADIO_TYPE_A		1
+
+/* Define action or option for HostCmd_CMD_MAC_CONTROL */
+/** MAC action : Rx on */
+#define HostCmd_ACT_MAC_RX_ON                   0x0001
+/** MAC action : Tx on */
+#define HostCmd_ACT_MAC_TX_ON                   0x0002
+/** MAC action : Loopback on */
+#define HostCmd_ACT_MAC_LOOPBACK_ON             0x0004
+/** MAC action : WEP enable */
+#define HostCmd_ACT_MAC_WEP_ENABLE              0x0008
+/** MAC action : EthernetII enable */
+#define HostCmd_ACT_MAC_ETHERNETII_ENABLE       0x0010
+/** MAC action : Promiscous mode enable */
+#define HostCmd_ACT_MAC_PROMISCUOUS_ENABLE      0x0080
+/** MAC action : All multicast enable */
+#define HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE    0x0100
+/** MAC action : Strict protection enable */
+#define HostCmd_ACT_MAC_STRICT_PROTECTION_ENABLE  0x0400
+/** MAC action : Ad-Hoc G protection on */
+#define HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON	  0x2000
+
+/* Define action or option or constant for HostCmd_CMD_MAC_MULTICAST_ADR */
+/** MAC address size */
+#define HostCmd_SIZE_MAC_ADR                    6
+/** Maximum number of MAC addresses */
+#define HostCmd_MAX_MCAST_ADRS                  32
+
+/** Radio on */
+#define RADIO_ON                                0x01
+/** Radio off */
+#define RADIO_OFF                               0x00
+
+/* Define action or option for CMD_802_11_RF_CHANNEL */
+/** Get RF channel */
+#define HostCmd_OPT_802_11_RF_CHANNEL_GET       0x00
+/** Set RF channel */
+#define HostCmd_OPT_802_11_RF_CHANNEL_SET       0x01
+
+/** Host command action : Set Rx */
+#define HostCmd_ACT_SET_RX                      0x0001
+/** Host command action : Set Tx */
+#define HostCmd_ACT_SET_TX                      0x0002
+/** Host command action : Set both Rx and Tx */
+#define HostCmd_ACT_SET_BOTH                    0x0003
+/** Host command action : Get Rx */
+#define HostCmd_ACT_GET_RX                      0x0004
+/** Host command action : Get Tx */
+#define HostCmd_ACT_GET_TX                      0x0008
+/** Host command action : Get both Rx and Tx */
+#define HostCmd_ACT_GET_BOTH                    0x000c
+
+/** Card Event definition : Dummy host wakeup signal */
+#define EVENT_DUMMY_HOST_WAKEUP_SIGNAL  0x00000001
+/** Card Event definition : Link lost with scan */
+#define EVENT_LINK_LOST_WITH_SCAN       0x00000002
+/** Card Event definition : Link lost */
+#define EVENT_LINK_LOST                 0x00000003
+/** Card Event definition : Link sensed */
+#define EVENT_LINK_SENSED               0x00000004
+/** Card Event definition : MIB changed */
+#define EVENT_MIB_CHANGED               0x00000006
+/** Card Event definition : Init done */
+#define EVENT_INIT_DONE                 0x00000007
+/** Card Event definition : Deauthenticated */
+#define EVENT_DEAUTHENTICATED           0x00000008
+/** Card Event definition : Disassociated */
+#define EVENT_DISASSOCIATED             0x00000009
+/** Card Event definition : Power save awake */
+#define EVENT_PS_AWAKE                  0x0000000a
+/** Card Event definition : Power save sleep */
+#define EVENT_PS_SLEEP                  0x0000000b
+/** Card Event definition : MIC error multicast */
+#define EVENT_MIC_ERR_MULTICAST         0x0000000d
+/** Card Event definition : MIC error unicast */
+#define EVENT_MIC_ERR_UNICAST           0x0000000e
+/** Card Event definition : WM awake */
+#define EVENT_WM_AWAKE                  0x0000000f
+/** Card Event definition : Deep Sleep awake */
+#define EVENT_DEEP_SLEEP_AWAKE          0x00000010
+/** Card Event definition : Ad-Hoc BCN lost */
+#define EVENT_ADHOC_BCN_LOST            0x00000011
+/** Card Event definition : Host Sleep awake */
+#define EVENT_HOST_SLEEP_AWAKE          0x00000012
+/** Card Event definition : Stop Tx */
+#define EVENT_STOP_TX                   0x00000013
+/** Card Event definition : Start Tx */
+#define EVENT_START_TX                  0x00000014
+/** Card Event definition : Channel switch */
+#define EVENT_CHANNEL_SWITCH            0x00000015
+/** Card Event definition : MEAS report ready */
+#define EVENT_MEAS_REPORT_RDY           0x00000016
+/** Card Event definition : WMM status change */
+#define EVENT_WMM_STATUS_CHANGE         0x00000017
+/** Card Event definition : BG scan report */
+#define EVENT_BG_SCAN_REPORT            0x00000018
+/** Card Event definition : Beacon RSSI low */
+#define EVENT_RSSI_LOW                  0x00000019
+/** Card Event definition : Beacon SNR low */
+#define EVENT_SNR_LOW                   0x0000001a
+/** Card Event definition : Maximum fail */
+#define EVENT_MAX_FAIL                  0x0000001b
+/** Card Event definition : Beacon RSSI high */
+#define EVENT_RSSI_HIGH                 0x0000001c
+/** Card Event definition : Beacon SNR high */
+#define EVENT_SNR_HIGH                  0x0000001d
+/** Card Event definition : IBSS coalsced */
+#define EVENT_IBSS_COALESCED            0x0000001e
+/** Card Event definition : Data RSSI low */
+#define EVENT_DATA_RSSI_LOW             0x00000024
+/** Card Event definition : Data SNR low */
+#define EVENT_DATA_SNR_LOW              0x00000025
+/** Card Event definition : Data RSSI high */
+#define EVENT_DATA_RSSI_HIGH            0x00000026
+/** Card Event definition : Data SNR high */
+#define EVENT_DATA_SNR_HIGH             0x00000027
+
+/** Define bitmap conditions for HOST_SLEEP_CFG : Cancel */
+#define HOST_SLEEP_CFG_CANCEL			0xffffffff
+/** Define bitmap conditions for HOST_SLEEP_CFG : GPIO FF */
+#define HOST_SLEEP_CFG_GPIO_FF			0xff
+/** Define bitmap conditions for HOST_SLEEP_CFG : GAP FF */
+#define HOST_SLEEP_CFG_GAP_FF			0xff
+
+/** Maximum size of multicast list */
+#define MRVDRV_MAX_MULTICAST_LIST_SIZE	32
+/** Maximum size of channel */
+#define MRVDRV_MAX_CHANNEL_SIZE		14
+/** Maximum length of SSID */
+#define MRVDRV_MAX_SSID_LENGTH			32
+/** Maximum number of BSS descriptors */
+#define MRVDRV_MAX_BSS_DESCRIPTS		16
+/** WEP list macros & data structures */
+/** Size of key buffer in bytes */
+#define MRVL_KEY_BUFFER_SIZE_IN_BYTE  16
+/** Maximum length of WPA key */
+#define MRVL_MAX_KEY_WPA_KEY_LENGTH     32
+
+/** 802.11 b */
+#define BS_802_11B	0
+/** 802.11 g */
+#define BS_802_11G	1
+/** 802.11 a */
+#define BS_802_11A	2
+/** Setup the number of rates pased in the driver/firmware API.*/
+#define A_SUPPORTED_RATES		14
+
+/** Firmware multiple bands support */
+#define FW_MULTI_BANDS_SUPPORT	(BIT(8) | BIT(9) | BIT(10))
+/** Band B */
+#define	BAND_B			(0x01)
+/** Band G */
+#define	BAND_G			(0x02)
+/** Band A */
+#define BAND_A			(0x04)
+/** All bands (B, G, A) */
+#define ALL_802_11_BANDS	(BAND_B | BAND_G | BAND_A)
+
+/** Check if multiple bands support is enabled in firmware */
+#define	IS_SUPPORT_MULTI_BANDS(_adapter) \
+				(_adapter->fwCapInfo & FW_MULTI_BANDS_SUPPORT)
+/** Get default bands of the firmware */
+#define GET_FW_DEFAULT_BANDS(_adapter)	\
+				((_adapter->fwCapInfo >> 8) & ALL_802_11_BANDS)
+
+/** Setup the number of rates passed in the driver/firmware API.*/
+#define HOSTCMD_SUPPORTED_RATES A_SUPPORTED_RATES
+
+/** Rates supported in band B */
+#define B_SUPPORTED_RATES		8
+/** Rates supported in band G */
+#define G_SUPPORTED_RATES		14
+
+/** WLAN supported rates */
+#define	WLAN_SUPPORTED_RATES		14
+
+/** Maximum power adapt group size */
+#define	MAX_POWER_ADAPT_GROUP		5
+
+/** 802.11 supported rates */
+typedef u8 WLAN_802_11_RATES[WLAN_SUPPORTED_RATES];
+/** 802.11 MAC address */
+typedef u8 WLAN_802_11_MAC_ADDRESS[ETH_ALEN];
+
+/** WLAN_802_11_NETWORK_TYPE */
+typedef enum _WLAN_802_11_NETWORK_TYPE
+{
+    Wlan802_11FH,
+    Wlan802_11DS,
+    /*defined as upper bound */
+    Wlan802_11NetworkTypeMax
+} WLAN_802_11_NETWORK_TYPE, *PWLAN_802_11_NETWORK_TYPE;
+
+/** WLAN_802_11_NETWORK_INFRASTRUCTURE */
+typedef enum _WLAN_802_11_NETWORK_INFRASTRUCTURE
+{
+    Wlan802_11IBSS,
+    Wlan802_11Infrastructure,
+    Wlan802_11AutoUnknown,
+    /*defined as upper bound */
+    Wlan802_11InfrastructureMax
+} WLAN_802_11_NETWORK_INFRASTRUCTURE, *PWLAN_802_11_NETWORK_INFRASTRUCTURE;
+
+/** Maximum size of IEEE Information Elements */
+#define IEEE_MAX_IE_SIZE  256
+
+/** IEEE Type definitions  */
+typedef enum _IEEEtypes_ElementId_e
+{
+    SSID = 0,
+    SUPPORTED_RATES = 1,
+    FH_PARAM_SET = 2,
+    DS_PARAM_SET = 3,
+    CF_PARAM_SET = 4,
+
+    IBSS_PARAM_SET = 6,
+
+    COUNTRY_INFO = 7,
+
+    POWER_CONSTRAINT = 32,
+    POWER_CAPABILITY = 33,
+    TPC_REQUEST = 34,
+    TPC_REPORT = 35,
+    SUPPORTED_CHANNELS = 36,
+    CHANNEL_SWITCH_ANN = 37,
+    QUIET = 40,
+    IBSS_DFS = 41,
+    ERP_INFO = 42,
+    EXTENDED_SUPPORTED_RATES = 50,
+
+    VENDOR_SPECIFIC_221 = 221,
+    WMM_IE = VENDOR_SPECIFIC_221,
+
+    WPS_IE = VENDOR_SPECIFIC_221,
+
+    WPA_IE = VENDOR_SPECIFIC_221,
+    RSN_IE = 48,
+
+} __ATTRIB_PACK__ IEEEtypes_ElementId_e;
+
+/** Capability information mask */
+#define CAPINFO_MASK    (~( BIT(15) | BIT(14) |               \
+                            BIT(12) | BIT(11) | BIT(9)) )
+
+#ifdef BIG_ENDIAN
+/** Capability Bit Map*/
+typedef struct _IEEEtypes_CapInfo_t
+{
+    u8 Rsrvd1:2;
+    u8 DSSSOFDM:1;
+    u8 Rsvrd2:2;
+    u8 ShortSlotTime:1;
+    u8 Rsrvd3:1;
+    u8 SpectrumMgmt:1;
+    u8 ChanAgility:1;
+    u8 Pbcc:1;
+    u8 ShortPreamble:1;
+    u8 Privacy:1;
+    u8 CfPollRqst:1;
+    u8 CfPollable:1;
+    u8 Ibss:1;
+    u8 Ess:1;
+} __ATTRIB_PACK__ IEEEtypes_CapInfo_t;
+#else
+typedef struct _IEEEtypes_CapInfo_t
+{
+    /** Capability Bit Map : ESS */
+    u8 Ess:1;
+    /** Capability Bit Map : IBSS */
+    u8 Ibss:1;
+    /** Capability Bit Map : CF pollable */
+    u8 CfPollable:1;
+    /** Capability Bit Map : CF poll request */
+    u8 CfPollRqst:1;
+    /** Capability Bit Map : Privacy */
+    u8 Privacy:1;
+    /** Capability Bit Map : Short preamble */
+    u8 ShortPreamble:1;
+    /** Capability Bit Map : PBCC */
+    u8 Pbcc:1;
+    /** Capability Bit Map : Channel agility */
+    u8 ChanAgility:1;
+    /** Capability Bit Map : Spectrum management */
+    u8 SpectrumMgmt:1;
+    /** Capability Bit Map : Reserved */
+    u8 Rsrvd3:1;
+    /** Capability Bit Map : Short slot time */
+    u8 ShortSlotTime:1;
+    /** Capability Bit Map : APSD */
+    u8 Apsd:1;
+    /** Capability Bit Map : Reserved */
+    u8 Rsvrd2:1;
+    /** Capability Bit Map : DSS OFDM */
+    u8 DSSSOFDM:1;
+    /** Capability Bit Map : Reserved */
+    u8 Rsrvd1:2;
+} __ATTRIB_PACK__ IEEEtypes_CapInfo_t;
+
+#endif /* BIG_ENDIAN */
+
+typedef struct
+{
+    /** Element ID */
+    u8 ElementId;
+    /** Length */
+    u8 Len;
+} __ATTRIB_PACK__ IEEEtypes_Header_t;
+
+/** IEEEtypes_CfParamSet_t */
+typedef struct _IEEEtypes_CfParamSet_t
+{
+    /** CF peremeter : Element ID */
+    u8 ElementId;
+    /** CF peremeter : Length */
+    u8 Len;
+    /** CF peremeter : Count */
+    u8 CfpCnt;
+    /** CF peremeter : Period */
+    u8 CfpPeriod;
+    /** CF peremeter : Maximum duration */
+    u16 CfpMaxDuration;
+    /** CF peremeter : Remaining duration */
+    u16 CfpDurationRemaining;
+} __ATTRIB_PACK__ IEEEtypes_CfParamSet_t;
+
+typedef struct IEEEtypes_IbssParamSet_t
+{
+    /** Element ID */
+    u8 ElementId;
+    /** Length */
+    u8 Len;
+    /** ATIM window value */
+    u16 AtimWindow;
+} __ATTRIB_PACK__ IEEEtypes_IbssParamSet_t;
+
+/** IEEEtypes_SsParamSet_t */
+typedef union _IEEEtypes_SsParamSet_t
+{
+    /** SS parameter : CF parameter set */
+    IEEEtypes_CfParamSet_t CfParamSet;
+    /** SS parameter : IBSS parameter set */
+    IEEEtypes_IbssParamSet_t IbssParamSet;
+} __ATTRIB_PACK__ IEEEtypes_SsParamSet_t;
+
+/** IEEEtypes_FhParamSet_t */
+typedef struct _IEEEtypes_FhParamSet_t
+{
+    /** FH parameter : Element ID */
+    u8 ElementId;
+    /** FH parameter : Length */
+    u8 Len;
+    /** FH parameter : Dwell time */
+    u16 DwellTime;
+    /** FH parameter : Hop set */
+    u8 HopSet;
+    /** FH parameter : Hop pattern */
+    u8 HopPattern;
+    /** FH parameter : Hop index */
+    u8 HopIndex;
+} __ATTRIB_PACK__ IEEEtypes_FhParamSet_t;
+
+/** IEEEtypes_DsParamSet_t */
+typedef struct _IEEEtypes_DsParamSet_t
+{
+    /** DS parameter : Element ID */
+    u8 ElementId;
+    /** DS parameter : Length */
+    u8 Len;
+    /** DS parameter : Current channel */
+    u8 CurrentChan;
+} __ATTRIB_PACK__ IEEEtypes_DsParamSet_t;
+
+/** IEEEtypes_PhyParamSet_t */
+typedef union IEEEtypes_PhyParamSet_t
+{
+    /** FH parameter set */
+    IEEEtypes_FhParamSet_t FhParamSet;
+    /** DS parameter set */
+    IEEEtypes_DsParamSet_t DsParamSet;
+} __ATTRIB_PACK__ IEEEtypes_PhyParamSet_t;
+
+typedef struct _IEEEtypes_ERPInfo_t
+{
+    /** Element ID */
+    u8 ElementId;
+    /** Length */
+    u8 Len;
+    /** ERP flags */
+    u8 ERPFlags;
+} __ATTRIB_PACK__ IEEEtypes_ERPInfo_t;
+
+/** 16 bit unsigned integer */
+typedef u16 IEEEtypes_AId_t;
+/** 16 bit unsigned integer */
+typedef u16 IEEEtypes_StatusCode_t;
+
+typedef struct
+{
+    /** Capability information */
+    IEEEtypes_CapInfo_t Capability;
+    /** Association response status code */
+    IEEEtypes_StatusCode_t StatusCode;
+    /** Association ID */
+    IEEEtypes_AId_t AId;
+    /** IE data buffer */
+    u8 IEBuffer[1];
+} __ATTRIB_PACK__ IEEEtypes_AssocRsp_t;
+
+typedef struct
+{
+    /** Element ID */
+    u8 ElementId;
+    /** Length */
+    u8 Len;
+    /** OUI */
+    u8 Oui[3];
+    /** OUI type */
+    u8 OuiType;
+    /** OUI subtype */
+    u8 OuiSubtype;
+    /** Version */
+    u8 Version;
+} __ATTRIB_PACK__ IEEEtypes_VendorHeader_t;
+
+typedef struct
+{
+    /** Vendor specific IE header */
+    IEEEtypes_VendorHeader_t VendHdr;
+
+    /** IE Max - size of previous fields */
+    u8 Data[IEEE_MAX_IE_SIZE - sizeof(IEEEtypes_VendorHeader_t)];
+
+}
+__ATTRIB_PACK__ IEEEtypes_VendorSpecific_t;
+
+typedef struct
+{
+    /** Generic IE header */
+    IEEEtypes_Header_t IeeeHdr;
+
+    /** IE Max - size of previous fields */
+    u8 Data[IEEE_MAX_IE_SIZE - sizeof(IEEEtypes_Header_t)];
+
+}
+__ATTRIB_PACK__ IEEEtypes_Generic_t;
+
+/** TLV  type ID definition */
+#define PROPRIETARY_TLV_BASE_ID		0x0100
+
+/** Terminating TLV Type */
+#define MRVL_TERMINATE_TLV_ID		0xffff
+
+/** TLV type : SSID */
+#define TLV_TYPE_SSID				0x0000
+/** TLV type : Rates */
+#define TLV_TYPE_RATES				0x0001
+/** TLV type : PHY FH */
+#define TLV_TYPE_PHY_FH				0x0002
+/** TLV type : PHY DS */
+#define TLV_TYPE_PHY_DS				0x0003
+/** TLV type : CF */
+#define TLV_TYPE_CF				    0x0004
+/** TLV type : IBSS */
+#define TLV_TYPE_IBSS				0x0006
+
+/** TLV type : Domain */
+#define TLV_TYPE_DOMAIN				0x0007
+
+/** TLV type : Power constraint */
+#define TLV_TYPE_POWER_CONSTRAINT   0x0020
+/** TLV type : Power capability */
+#define TLV_TYPE_POWER_CAPABILITY   0x0021
+
+/** TLV type : Key material */
+#define TLV_TYPE_KEY_MATERIAL       (PROPRIETARY_TLV_BASE_ID + 0)
+/** TLV type : Channel list */
+#define TLV_TYPE_CHANLIST           (PROPRIETARY_TLV_BASE_ID + 1)
+/** TLV type : Number of probes */
+#define TLV_TYPE_NUMPROBES          (PROPRIETARY_TLV_BASE_ID + 2)
+/** TLV type : Beacon RSSI low */
+#define TLV_TYPE_RSSI_LOW           (PROPRIETARY_TLV_BASE_ID + 4)
+/** TLV type : Beacon SNR low */
+#define TLV_TYPE_SNR_LOW            (PROPRIETARY_TLV_BASE_ID + 5)
+/** TLV type : Fail count */
+#define TLV_TYPE_FAILCOUNT          (PROPRIETARY_TLV_BASE_ID + 6)
+/** TLV type : BCN miss */
+#define TLV_TYPE_BCNMISS            (PROPRIETARY_TLV_BASE_ID + 7)
+/** TLV type : LED GPIO */
+#define TLV_TYPE_LED_GPIO           (PROPRIETARY_TLV_BASE_ID + 8)
+/** TLV type : LED behavior */
+#define TLV_TYPE_LEDBEHAVIOR        (PROPRIETARY_TLV_BASE_ID + 9)
+/** TLV type : Passthrough */
+#define TLV_TYPE_PASSTHROUGH        (PROPRIETARY_TLV_BASE_ID + 10)
+/** TLV type : Power TBL 2.4 Ghz */
+#define TLV_TYPE_POWER_TBL_2_4GHZ   (PROPRIETARY_TLV_BASE_ID + 12)
+/** TLV type : Power TBL 5 GHz */
+#define TLV_TYPE_POWER_TBL_5GHZ     (PROPRIETARY_TLV_BASE_ID + 13)
+/** TLV type : WMM queue status */
+#define TLV_TYPE_WMMQSTATUS         (PROPRIETARY_TLV_BASE_ID + 16)
+/** TLV type : Crypto data */
+#define TLV_TYPE_CRYPTO_DATA        (PROPRIETARY_TLV_BASE_ID + 17)
+/** TLV type : Wildcard SSID */
+#define TLV_TYPE_WILDCARDSSID       (PROPRIETARY_TLV_BASE_ID + 18)
+/** TLV type : TSF timestamp */
+#define TLV_TYPE_TSFTIMESTAMP       (PROPRIETARY_TLV_BASE_ID + 19)
+/** TLV type : Power adapter configuration ext */
+#define TLV_TYPE_POWERADAPTCFGEXT   (PROPRIETARY_TLV_BASE_ID + 20)
+/** TLV type : Beacon RSSI high */
+#define TLV_TYPE_RSSI_HIGH          (PROPRIETARY_TLV_BASE_ID + 22)
+/** TLV type : Beacon SNR high */
+#define TLV_TYPE_SNR_HIGH           (PROPRIETARY_TLV_BASE_ID + 23)
+/** TLV type : Auto Tx */
+#define TLV_TYPE_AUTO_TX            (PROPRIETARY_TLV_BASE_ID + 24)
+
+/** TLV type : Start BG scan later */
+#define TLV_TYPE_STARTBGSCANLATER   (PROPRIETARY_TLV_BASE_ID + 30)
+/** TLV type : Authentication type */
+#define TLV_TYPE_AUTH_TYPE          (PROPRIETARY_TLV_BASE_ID + 31)
+/** TLV type : Data RSSI low */
+#define TLV_TYPE_RSSI_LOW_DATA      (PROPRIETARY_TLV_BASE_ID + 38)
+/** TLV type : Data SNR low */
+#define TLV_TYPE_SNR_LOW_DATA       (PROPRIETARY_TLV_BASE_ID + 39)
+/** TLV type : Data RSSI high */
+#define TLV_TYPE_RSSI_HIGH_DATA     (PROPRIETARY_TLV_BASE_ID + 40)
+/** TLV type : Data SNR high */
+#define TLV_TYPE_SNR_HIGH_DATA      (PROPRIETARY_TLV_BASE_ID + 41)
+
+/** TLV related data structures*/
+/** MrvlIEtypesHeader_t */
+typedef struct _MrvlIEtypesHeader
+{
+    /** Header type */
+    u16 Type;
+    /** Header length */
+    u16 Len;
+} __ATTRIB_PACK__ MrvlIEtypesHeader_t;
+
+/** MrvlIEtypes_Data_t */
+typedef struct _MrvlIEtypes_Data_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** Data */
+    u8 Data[1];
+} __ATTRIB_PACK__ MrvlIEtypes_Data_t;
+
+/** MrvlIEtypes_RatesParamSet_t */
+typedef struct _MrvlIEtypes_RatesParamSet_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** Rates */
+    u8 Rates[1];
+} __ATTRIB_PACK__ MrvlIEtypes_RatesParamSet_t;
+
+/** MrvlIEtypes_SsIdParamSet_t */
+typedef struct _MrvlIEtypes_SsIdParamSet_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** SSID */
+    u8 SsId[1];
+} __ATTRIB_PACK__ MrvlIEtypes_SsIdParamSet_t;
+
+/** MrvlIEtypes_WildCardSsIdParamSet_t */
+typedef struct _MrvlIEtypes_WildCardSsIdParamSet_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** Maximum SSID length */
+    u8 MaxSsidLength;
+    /** SSID */
+    u8 SsId[1];
+} __ATTRIB_PACK__ MrvlIEtypes_WildCardSsIdParamSet_t;
+
+/** ChanScanMode_t */
+typedef struct
+{
+#ifdef BIG_ENDIAN
+    u8 Reserved_2_7:6;
+    u8 DisableChanFilt:1;
+    u8 PassiveScan:1;
+#else
+    /** Channel scan mode passive flag */
+    u8 PassiveScan:1;
+    /** Disble channel filtering flag */
+    u8 DisableChanFilt:1;
+    /** Reserved */
+    u8 Reserved_2_7:6;
+#endif
+} __ATTRIB_PACK__ ChanScanMode_t;
+
+/** ChanScanParamSet_t */
+typedef struct _ChanScanParamSet_t
+{
+    /** Channel scan parameter : radio type */
+    u8 RadioType;
+    /** Channel scan parameter : channel number */
+    u8 ChanNumber;
+    /** Channel scan parameter : channel scan mode */
+    ChanScanMode_t ChanScanMode;
+    /** Channel scan parameter : minimum scan time */
+    u16 MinScanTime;
+    /** Channel scan parameter : maximum scan time */
+    u16 MaxScanTime;
+} __ATTRIB_PACK__ ChanScanParamSet_t;
+
+/** MrvlIEtypes_ChanListParamSet_t */
+typedef struct _MrvlIEtypes_ChanListParamSet_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** Channel scan parameters */
+    ChanScanParamSet_t ChanScanParam[1];
+} __ATTRIB_PACK__ MrvlIEtypes_ChanListParamSet_t;
+
+/** CfParamSet_t */
+typedef struct _CfParamSet_t
+{
+    /** CF parameter : count */
+    u8 CfpCnt;
+    /** CF parameter : period */
+    u8 CfpPeriod;
+    /** CF parameter : duration */
+    u16 CfpMaxDuration;
+    /** CF parameter : duration remaining */
+    u16 CfpDurationRemaining;
+} __ATTRIB_PACK__ CfParamSet_t;
+
+/** IbssParamSet_t */
+typedef struct _IbssParamSet_t
+{
+    /** ATIM window value */
+    u16 AtimWindow;
+} __ATTRIB_PACK__ IbssParamSet_t;
+
+/** MrvlIEtypes_SsParamSet_t */
+typedef struct _MrvlIEtypes_SsParamSet_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    union
+    {
+        /** CF parameter set */
+        CfParamSet_t CfParamSet[1];
+        /** IBSS parameter set */
+        IbssParamSet_t IbssParamSet[1];
+    } cf_ibss;
+} __ATTRIB_PACK__ MrvlIEtypes_SsParamSet_t;
+
+/** FhParamSet_t */
+typedef struct _FhParamSet_t
+{
+    /** FH parameter : Dwell time */
+    u16 DwellTime;
+    /** FH parameter : Hop set */
+    u8 HopSet;
+    /** FH parameter : Hop pattern */
+    u8 HopPattern;
+    /** FH parameter : Hop index */
+    u8 HopIndex;
+} __ATTRIB_PACK__ FhParamSet_t;
+
+/** DsParamSet_t */
+typedef struct _DsParamSet_t
+{
+    /** Current channel number */
+    u8 CurrentChan;
+} __ATTRIB_PACK__ DsParamSet_t;
+
+/** MrvlIEtypes_PhyParamSet_t */
+typedef struct _MrvlIEtypes_PhyParamSet_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    union
+    {
+        /** FH parameter set */
+        FhParamSet_t FhParamSet[1];
+        /** DS parameter set */
+        DsParamSet_t DsParamSet[1];
+    } fh_ds;
+} __ATTRIB_PACK__ MrvlIEtypes_PhyParamSet_t;
+
+/** MrvlIEtypes_RsnParamSet_t */
+typedef struct _MrvlIEtypes_RsnParamSet_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** RSN IE */
+    u8 RsnIE[1];
+} __ATTRIB_PACK__ MrvlIEtypes_RsnParamSet_t;
+
+/** MrvlIEtypes_WmmParamSet_t */
+typedef struct _MrvlIEtypes_WmmParamSet_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** WMM IE */
+    u8 WmmIE[1];
+} __ATTRIB_PACK__ MrvlIEtypes_WmmParamSet_t;
+
+typedef struct
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** Queue index */
+    u8 QueueIndex;
+    /** Disabled flag */
+    u8 Disabled;
+    /** Medium time allocation in 32us units*/
+    u16 MediumTime;
+    /** Flow required flag */
+    u8 FlowRequired;
+    /** Flow created flag */
+    u8 FlowCreated;
+    /** Reserved */
+    u32 Reserved;
+} __ATTRIB_PACK__ MrvlIEtypes_WmmQueueStatus_t;
+
+/** Table of TSF values returned in the scan result */
+typedef struct
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** TSF table */
+    u64 tsfTable[1];
+} __ATTRIB_PACK__ MrvlIEtypes_TsfTimestamp_t;
+
+/**  Local Power Capability */
+typedef struct _MrvlIEtypes_PowerCapability_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** Minmum power */
+    s8 MinPower;
+    /** Maximum power */
+    s8 MaxPower;
+} __ATTRIB_PACK__ MrvlIEtypes_PowerCapability_t;
+
+/** MrvlIEtypes_RssiParamSet_t */
+typedef struct _MrvlIEtypes_RssiThreshold_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** RSSI value */
+    u8 RSSIValue;
+    /** RSSI frequency */
+    u8 RSSIFreq;
+} __ATTRIB_PACK__ MrvlIEtypes_RssiThreshold_t;
+
+/** MrvlIEtypes_SnrThreshold_t */
+typedef struct _MrvlIEtypes_SnrThreshold_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** SNR value */
+    u8 SNRValue;
+    /** SNR frequency */
+    u8 SNRFreq;
+} __ATTRIB_PACK__ MrvlIEtypes_SnrThreshold_t;
+
+/** MrvlIEtypes_FailureCount_t */
+typedef struct _MrvlIEtypes_FailureCount_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** Failure value */
+    u8 FailValue;
+    /** Failure frequency */
+    u8 FailFreq;
+} __ATTRIB_PACK__ MrvlIEtypes_FailureCount_t;
+
+/** MrvlIEtypes_BeaconsMissed_t */
+typedef struct _MrvlIEtypes_BeaconsMissed_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** Number of beacons missed */
+    u8 BeaconMissed;
+    /** Reserved */
+    u8 Reserved;
+} __ATTRIB_PACK__ MrvlIEtypes_BeaconsMissed_t;
+
+/** MrvlIEtypes_NumProbes_t */
+typedef struct _MrvlIEtypes_NumProbes_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** Number of probes */
+    u16 NumProbes;
+} __ATTRIB_PACK__ MrvlIEtypes_NumProbes_t;
+
+/** MrvlIEtypes_StartBGScanLater_t */
+typedef struct _MrvlIEtypes_StartBGScanLater_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** Start later flag */
+    u16 StartLater;
+} __ATTRIB_PACK__ MrvlIEtypes_StartBGScanLater_t;
+
+typedef struct _LedGpio_t
+{
+    u8 LedNum;                                  /**< LED # mapped to GPIO pin # below */
+    u8 GpioNum;                                 /**< GPIO pin # used to control LED # above */
+} __ATTRIB_PACK__ LedGpio_t;
+
+/** MrvlIEtypes_LedGpio_t */
+typedef struct _MrvlIEtypes_LedGpio_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** LED GPIO */
+    LedGpio_t LedGpio[1];
+} __ATTRIB_PACK__ MrvlIEtypes_LedGpio_t;
+
+/** MrvlIEtypes_LedBehavior_t */
+typedef struct _MrvlIEtypes_LedBehavior_t
+{
+    MrvlIEtypesHeader_t Header;         /**< Header */
+    u8 FirmwareState;                           /**< Firmware State */
+    u8 LedNum;                                  /**< LED # */
+    u8 LedState;                                /**< LED State corresponding to Firmware State */
+    u8 LedArgs;                                 /**< Arguments for LED State */
+} __ATTRIB_PACK__ MrvlIEtypes_LedBehavior_t;
+
+typedef struct _PA_Group_t
+{
+    u16 PowerAdaptLevel;                            /**< Power adapt level */
+    u16 RateBitmap;                                 /**< Rate bitmap */
+    u32 Reserved;                                   /**< Reserved */
+} __ATTRIB_PACK__ PA_Group_t;
+
+/** MrvlIEtypes_PA_Group_t */
+typedef struct _MrvlIEtypes_PowerAdapt_Group_t
+{
+    MrvlIEtypesHeader_t Header;                               /**< Header */
+    PA_Group_t PA_Group[MAX_POWER_ADAPT_GROUP];                   /**< Power adapt group */
+} __ATTRIB_PACK__ MrvlIEtypes_PowerAdapt_Group_t;
+
+typedef struct _AutoTx_MacFrame_t
+{
+    u16 Interval;                               /**< in seconds */
+    u8 Priority;                                /**< User Priority: 0~7, ignored if non-WMM */
+    u8 Reserved;                                /**< set to 0 */
+    u16 FrameLen;                               /**< Length of MAC frame payload */
+    u8 DestMacAddr[ETH_ALEN];                           /**< Destination MAC address */
+    u8 SrcMacAddr[ETH_ALEN];                            /**< Source MAC address */
+    u8 Payload[];                                       /**< Payload */
+} __ATTRIB_PACK__ AutoTx_MacFrame_t;
+
+/** MrvlIEtypes_AutoTx_t */
+typedef struct _MrvlIEtypes_AutoTx_t
+{
+    MrvlIEtypesHeader_t Header;                     /**< Header */
+    AutoTx_MacFrame_t AutoTx_MacFrame;              /**< Auto Tx MAC frame */
+} __ATTRIB_PACK__ MrvlIEtypes_AutoTx_t;
+
+/** Auth type to be used in the Authentication portion of an Assoc seq */
+typedef struct
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** Authentication type */
+    u16 AuthType;
+} __ATTRIB_PACK__ MrvlIEtypes_AuthType_t;
+
+/** Maximum subbands for 11d */
+#define MRVDRV_MAX_SUBBAND_802_11D		83
+/** Country code length */
+#define COUNTRY_CODE_LEN			3
+
+/** Data structure for Country IE*/
+typedef struct _IEEEtypes_SubbandSet
+{
+    u8 FirstChan;               /**< First channel */
+    u8 NoOfChan;                /**< Number of channels */
+    u8 MaxTxPwr;                    /**< Maximum Tx power */
+} __ATTRIB_PACK__ IEEEtypes_SubbandSet_t;
+
+typedef struct _IEEEtypes_CountryInfoSet
+{
+    u8 ElementId;                               /**< Element ID */
+    u8 Len;                                     /**< Length */
+    u8 CountryCode[COUNTRY_CODE_LEN];           /**< Country code */
+    IEEEtypes_SubbandSet_t Subband[1];      /**< Set of subbands */
+} __ATTRIB_PACK__ IEEEtypes_CountryInfoSet_t;
+
+typedef struct _IEEEtypes_CountryInfoFullSet
+{
+    u8 ElementId;                               /**< Element ID */
+    u8 Len;                                     /**< Length */
+    u8 CountryCode[COUNTRY_CODE_LEN];           /**< Country code */
+    /** Set of subbands */
+    IEEEtypes_SubbandSet_t Subband[MRVDRV_MAX_SUBBAND_802_11D];
+} __ATTRIB_PACK__ IEEEtypes_CountryInfoFullSet_t;
+
+typedef struct _MrvlIEtypes_DomainParamSet
+{
+    MrvlIEtypesHeader_t Header;                         /**< Header */
+    u8 CountryCode[COUNTRY_CODE_LEN];                           /**< Country code */
+    IEEEtypes_SubbandSet_t Subband[1];              /**< Set of subbands */
+} __ATTRIB_PACK__ MrvlIEtypes_DomainParamSet_t;
+
+/** Size of a TSPEC.  Used to allocate necessary buffer space in commands */
+#define WMM_TSPEC_SIZE              63
+
+/** Extra IE bytes allocated in messages for appended IEs after a TSPEC */
+#define WMM_ADDTS_EXTRA_IE_BYTES    256
+
+/** Extra TLV bytes allocated in messages for configuring WMM Queues */
+#define WMM_QUEUE_CONFIG_EXTRA_TLV_BYTES 64
+
+/** Maximum number of AC QOS queues available in the driver/firmware */
+#define MAX_AC_QUEUES 4
+
+/** enum of WMM AC_QUEUES */
+typedef enum
+{
+    WMM_AC_BK,
+    WMM_AC_BE,
+    WMM_AC_VI,
+    WMM_AC_VO,
+} __ATTRIB_PACK__ wlan_wmm_ac_e;
+
+/** data structure of WMM QoS information */
+typedef struct
+{
+#ifdef BIG_ENDIAN
+    /** QoS UAPSD */
+    u8 QosUAPSD:1;
+    /** Reserved */
+    u8 Reserved:3;
+    /** Parameter set count */
+    u8 ParaSetCount:4;
+#else
+    /** Parameter set count */
+    u8 ParaSetCount:4;
+    /** Reserved */
+    u8 Reserved:3;
+    /** QoS UAPSD */
+    u8 QosUAPSD:1;
+#endif
+} __ATTRIB_PACK__ IEEEtypes_WmmQosInfo_t;
+
+typedef struct
+{
+#ifdef BIG_ENDIAN
+    /** Reserved */
+    u8 Reserved:1;
+    /** Aci */
+    u8 Aci:2;
+    /** Acm */
+    u8 Acm:1;
+    /** Aifsn */
+    u8 Aifsn:4;
+#else
+    /** Aifsn */
+    u8 Aifsn:4;
+    /** Acm */
+    u8 Acm:1;
+    /** Aci */
+    u8 Aci:2;
+    /** Reserved */
+    u8 Reserved:1;
+#endif
+} __ATTRIB_PACK__ IEEEtypes_WmmAciAifsn_t;
+
+/**  data structure of WMM ECW */
+typedef struct
+{
+#ifdef BIG_ENDIAN
+    /** Maximum Ecw */
+    u8 EcwMax:4;
+    /** Minimum Ecw */
+    u8 EcwMin:4;
+#else
+    /** Minimum Ecw */
+    u8 EcwMin:4;
+    /** Maximum Ecw */
+    u8 EcwMax:4;
+#endif
+} __ATTRIB_PACK__ IEEEtypes_WmmEcw_t;
+
+/** data structure of WMM AC parameters  */
+typedef struct
+{
+    IEEEtypes_WmmAciAifsn_t AciAifsn;       /**< AciAifSn */
+    IEEEtypes_WmmEcw_t Ecw;                 /**< Ecw */
+    u16 TxopLimit;                          /**< Tx op limit */
+} __ATTRIB_PACK__ IEEEtypes_WmmAcParameters_t;
+
+/** data structure of WMM Info IE  */
+typedef struct
+{
+
+    /**
+     * WMM Info IE - Vendor Specific Header:
+     *   ElementId   [221/0xdd]
+     *   Len         [7] 
+     *   Oui         [00:50:f2]
+     *   OuiType     [2]
+     *   OuiSubType  [0]
+     *   Version     [1]
+     */
+    IEEEtypes_VendorHeader_t VendHdr;
+
+    /** QoS information */
+    IEEEtypes_WmmQosInfo_t QoSInfo;
+
+} __ATTRIB_PACK__ IEEEtypes_WmmInfo_t;
+
+/** data structure of WMM parameter IE  */
+typedef struct
+{
+    /**
+     * WMM Parameter IE - Vendor Specific Header:
+     *   ElementId   [221/0xdd]
+     *   Len         [24] 
+     *   Oui         [00:50:f2]
+     *   OuiType     [2]
+     *   OuiSubType  [1]
+     *   Version     [1]
+     */
+    IEEEtypes_VendorHeader_t VendHdr;
+
+    /** QoS information */
+    IEEEtypes_WmmQosInfo_t QoSInfo;
+    /** Reserved */
+    u8 Reserved;
+
+    /** AC Parameters Record WMM_AC_BE, WMM_AC_BK, WMM_AC_VI, WMM_AC_VO */
+    IEEEtypes_WmmAcParameters_t AcParams[MAX_AC_QUEUES];
+
+} __ATTRIB_PACK__ IEEEtypes_WmmParameter_t;
+
+/**
+ *  @brief Firmware command structure to retrieve the firmware WMM status.
+ *
+ *  Used to retrieve the status of each WMM AC Queue in TLV 
+ *    format (MrvlIEtypes_WmmQueueStatus_t) as well as the current WMM
+ *    parameter IE advertised by the AP.  
+ *  
+ *  Used in response to a EVENT_WMM_STATUS_CHANGE event signalling
+ *    a QOS change on one of the ACs or a change in the WMM Parameter in
+ *    the Beacon.
+ *
+ *  TLV based command, byte arrays used for max sizing purpose. There are no 
+ *    arguments sent in the command, the TLVs are returned by the firmware.
+ */
+typedef struct
+{
+    /** Queue status TLV */
+    u8 queueStatusTlv[sizeof(MrvlIEtypes_WmmQueueStatus_t) * MAX_AC_QUEUES];
+    /** WMM parameter TLV */
+    u8 wmmParamTlv[sizeof(IEEEtypes_WmmParameter_t) + 2];
+
+}
+__ATTRIB_PACK__ HostCmd_DS_WMM_GET_STATUS;
+
+/**
+ *  @brief Enumeration for the command result from an ADDTS or DELTS command 
+ */
+typedef enum
+{
+    TSPEC_RESULT_SUCCESS = 0,
+    TSPEC_RESULT_EXEC_FAILURE = 1,
+    TSPEC_RESULT_TIMEOUT = 2,
+    TSPEC_RESULT_DATA_INVALID = 3,
+
+} __ATTRIB_PACK__ wlan_wmm_tspec_result_e;
+
+/**
+ *  @brief IOCTL structure to send an ADDTS request and retrieve the response.
+ *
+ *  IOCTL structure from the application layer relayed to firmware to 
+ *    instigate an ADDTS management frame with an appropriate TSPEC IE as well
+ *    as any additional IEs appended in the ADDTS Action frame.
+ *
+ *  @sa wlan_wmm_addts_req_ioctl
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;      //!< Firmware execution result
+    u32 timeout_ms;             //!< Timeout value in milliseconds
+
+    u8 ieeeStatusCode;          //!< IEEE status code
+
+    u8 tspecData[WMM_TSPEC_SIZE];       //!< TSPEC to send in the ADDTS
+
+    u8 addtsExtraIEBuf[WMM_ADDTS_EXTRA_IE_BYTES];       //!< ADDTS extra IE buffer
+
+} __ATTRIB_PACK__ wlan_ioctl_wmm_addts_req_t;
+
+/**
+ *  @brief IOCTL structure to send a DELTS request.
+ *
+ *  IOCTL structure from the application layer relayed to firmware to 
+ *    instigate an DELTS management frame with an appropriate TSPEC IE.
+ *
+ *  @sa wlan_wmm_delts_req_ioctl
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;      //!< Firmware execution result
+
+    u8 ieeeReasonCode;          //!< IEEE reason code sent, unused for WMM 
+
+    u8 tspecData[WMM_TSPEC_SIZE];       //!< TSPEC to send in the DELTS
+
+} __ATTRIB_PACK__ wlan_ioctl_wmm_delts_req_t;
+
+/**
+ *  @brief Internal command structure used in executing an ADDTS command.
+ *
+ *  Relay information between the IOCTL layer and the firmware command and 
+ *    command response procedures.
+ *
+ *  @sa wlan_wmm_addts_req_ioctl
+ *  @sa wlan_cmd_wmm_addts_req
+ *  @sa wlan_cmdresp_wmm_addts_req
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;      //!< Firmware execution result
+    u32 timeout_ms;             //!< Timeout value in milliseconds
+
+    u8 dialogToken;             //!< Dialog token
+    u8 ieeeStatusCode;          //!< IEEE status code
+
+    int tspecDataLen;           //!< TSPEC data length
+    u8 tspecData[WMM_TSPEC_SIZE];       //!< TSPEC to send in the ADDTS
+    u8 addtsExtraIEBuf[WMM_ADDTS_EXTRA_IE_BYTES];       //!< ADDTS extra IE buffer
+
+} wlan_cmd_wmm_addts_req_t;
+
+/**
+ *  @brief Internal command structure used in executing an DELTS command.
+ *
+ *  Relay information between the IOCTL layer and the firmware command and 
+ *    command response procedures.
+ *
+ *  @sa wlan_wmm_delts_req_ioctl
+ *  @sa wlan_cmd_wmm_delts_req
+ *  @sa wlan_cmdresp_wmm_delts_req
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;      //!< Firmware execution result
+
+    u8 dialogToken;             //!< Dialog token
+
+    u8 ieeeReasonCode;          //!< IEEE reson code sent
+
+    int tspecDataLen;           //!< TSPEC data length
+    u8 tspecData[WMM_TSPEC_SIZE];       //!< TSPEC data
+
+} wlan_cmd_wmm_delts_req_t;
+
+/**
+ *  @brief Command structure for the HostCmd_CMD_WMM_ADDTS_REQ firmware command
+ *
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;      //!< Command result
+    u32 timeout_ms;             //!< Timeout value in milliseconds
+
+    u8 dialogToken;             //!< Dialog token
+    u8 ieeeStatusCode;          //!< IEEE status code
+    u8 tspecData[WMM_TSPEC_SIZE];       //!< TSPEC data
+    u8 addtsExtraIEBuf[WMM_ADDTS_EXTRA_IE_BYTES];       //!< ADDTS extra IE buffer
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_ADDTS_REQ;
+
+/**
+ *  @brief Command structure for the HostCmd_CMD_WMM_DELTS_REQ firmware command
+ */
+typedef struct
+{
+    wlan_wmm_tspec_result_e commandResult;      //!< Command result
+    u8 dialogToken;             //!< Dialog token
+    u8 ieeeReasonCode;          //!< IEEE reason code
+    u8 tspecData[WMM_TSPEC_SIZE];       //!< TSPEC data
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_DELTS_REQ;
+
+/**
+ *  @brief Enumeration for the action field in the Queue configure command
+ */
+typedef enum
+{
+    WMM_QUEUE_CONFIG_ACTION_GET = 0,
+    WMM_QUEUE_CONFIG_ACTION_SET = 1,
+    WMM_QUEUE_CONFIG_ACTION_DEFAULT = 2,
+
+    WMM_QUEUE_CONFIG_ACTION_MAX
+} __ATTRIB_PACK__ wlan_wmm_queue_config_action_e;
+
+/**
+ *  @brief Command structure for the HostCmd_CMD_WMM_QUEUE_CONFIG firmware cmd
+ *
+ *  Set/Get/Default the Queue parameters for a specific AC in the firmware.
+ *
+ */
+typedef struct
+{
+    wlan_wmm_queue_config_action_e action;      //!< Set, Get, or Default
+    wlan_wmm_ac_e accessCategory;       //!< WMM_AC_BK(0) to WMM_AC_VO(3)
+
+    /** @brief MSDU lifetime expiry per 802.11e
+     *
+     *   - Ignored if 0 on a set command 
+     *   - Set to the 802.11e specified 500 TUs when defaulted
+     */
+    u16 msduLifetimeExpiry;
+
+    u8 tlvBuffer[WMM_QUEUE_CONFIG_EXTRA_TLV_BYTES];     //!< Not supported yet
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_QUEUE_CONFIG;
+
+/**
+ *  @brief Internal command structure used in executing a queue config command.
+ *
+ *  Relay information between the IOCTL layer and the firmware command and 
+ *    command response procedures.
+ *
+ *  @sa wlan_wmm_queue_config_ioctl
+ *  @sa wlan_cmd_wmm_queue_config
+ *  @sa wlan_cmdresp_wmm_queue_config
+ */
+typedef struct
+{
+    wlan_wmm_queue_config_action_e action;      //!< Set, Get, or Default
+    wlan_wmm_ac_e accessCategory;       //!< WMM_AC_BK(0) to WMM_AC_VO(3)
+    u16 msduLifetimeExpiry;     //!< lifetime expiry in TUs
+
+    int tlvBufLen;              //!< Not supported yet
+    u8 tlvBuffer[WMM_QUEUE_CONFIG_EXTRA_TLV_BYTES];     //!< Not supported yet
+
+} wlan_cmd_wmm_queue_config_t;
+
+/**
+ *  @brief IOCTL structure to configure a specific AC Queue's parameters
+ *
+ *  IOCTL structure from the application layer relayed to firmware to 
+ *    get, set, or default the WMM AC queue parameters.
+ *
+ *  - msduLifetimeExpiry is ignored if set to 0 on a set command
+ *
+ *  @sa wlan_wmm_queue_config_ioctl
+ */
+typedef struct
+{
+    wlan_wmm_queue_config_action_e action;      //!< Set, Get, or Default
+    wlan_wmm_ac_e accessCategory;       //!< WMM_AC_BK(0) to WMM_AC_VO(3)
+    u16 msduLifetimeExpiry;     //!< lifetime expiry in TUs
+
+    u8 supportedRates[10];      //!< Not supported yet
+
+} __ATTRIB_PACK__ wlan_ioctl_wmm_queue_config_t;
+
+/**
+ *   @brief Enumeration for the action field in the queue stats command
+ */
+typedef enum
+{
+    WMM_STATS_ACTION_START = 0,
+    WMM_STATS_ACTION_STOP = 1,
+    WMM_STATS_ACTION_GET_CLR = 2,
+    WMM_STATS_ACTION_SET_CFG = 3,       /* Not currently used */
+    WMM_STATS_ACTION_GET_CFG = 4,       /* Not currently used */
+
+    WMM_STATS_ACTION_MAX
+} __ATTRIB_PACK__ wlan_wmm_stats_action_e;
+
+/** Number of bins in the histogram for the HostCmd_DS_WMM_QUEUE_STATS */
+#define WMM_STATS_PKTS_HIST_BINS  7
+
+/**
+ *  @brief Command structure for the HostCmd_CMD_WMM_QUEUE_STATS firmware cmd
+ *
+ *  Turn statistical collection on/off for a given AC or retrieve the 
+ *    accumulated stats for an AC and clear them in the firmware.
+ */
+typedef struct
+{
+    wlan_wmm_stats_action_e action;     //!< Start, Stop, or Get 
+    wlan_wmm_ac_e accessCategory;       //!< WMM_AC_BK(0) to WMM_AC_VO(3)
+
+    u16 pktCount;               //!< Number of successful packets transmitted
+    u16 pktLoss;                //!< Packets lost; not included in pktCount
+    u32 avgQueueDelay;          //!< Average Queue delay in microseconds
+    u32 avgTxDelay;             //!< Average Transmission delay in microseconds
+    u16 usedTime;               //!< Calculated used time - units of 32 microseconds
+    u16 policedTime;            //!< Calculated policed time - units of 32 microseconds
+
+    /** @brief Queue Delay Histogram; number of packets per queue delay range
+     * 
+     *  [0] -  0ms <= delay < 5ms
+     *  [1] -  5ms <= delay < 10ms
+     *  [2] - 10ms <= delay < 20ms
+     *  [3] - 20ms <= delay < 30ms
+     *  [4] - 30ms <= delay < 40ms
+     *  [5] - 40ms <= delay < 50ms
+     *  [6] - 50ms <= delay < msduLifetime (TUs)
+     */
+    u16 delayHistogram[WMM_STATS_PKTS_HIST_BINS];
+
+    /** Reserved */
+    u16 reserved_u16_1;
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_QUEUE_STATS;
+
+/**
+ *  @brief IOCTL structure to start, stop, and get statistics for a WMM AC
+ *
+ *  IOCTL structure from the application layer relayed to firmware to 
+ *    start or stop statistical collection for a given AC.  Also used to 
+ *    retrieve and clear the collected stats on a given AC.
+ *
+ *  @sa wlan_wmm_queue_stats_ioctl
+ */
+typedef struct
+{
+    wlan_wmm_stats_action_e action;     //!< Start, Stop, or Get 
+    wlan_wmm_ac_e accessCategory;       //!< WMM_AC_BK(0) to WMM_AC_VO(3)
+    u16 pktCount;               //!< Number of successful packets transmitted  
+    u16 pktLoss;                //!< Packets lost; not included in pktCount    
+    u32 avgQueueDelay;          //!< Average Queue delay in microseconds
+    u32 avgTxDelay;             //!< Average Transmission delay in microseconds
+    u16 usedTime;               //!< Calculated used time - units of 32 microseconds
+    u16 policedTime;            //!< Calculated policed time - units of 32 microseconds
+
+    /** @brief Queue Delay Histogram; number of packets per queue delay range
+     * 
+     *  [0] -  0ms <= delay < 5ms
+     *  [1] -  5ms <= delay < 10ms
+     *  [2] - 10ms <= delay < 20ms
+     *  [3] - 20ms <= delay < 30ms
+     *  [4] - 30ms <= delay < 40ms
+     *  [5] - 40ms <= delay < 50ms
+     *  [6] - 50ms <= delay < msduLifetime (TUs)
+     */
+    u16 delayHistogram[WMM_STATS_PKTS_HIST_BINS];
+} __ATTRIB_PACK__ wlan_ioctl_wmm_queue_stats_t;
+
+/** 
+ *  @brief IOCTL and command sub structure for a Traffic stream status.
+ */
+typedef struct
+{
+    u8 tid;                     //!< TSID: Range: 0->7
+    u8 valid;                   //!< TSID specified is valid 
+    u8 accessCategory;          //!< AC TSID is active on
+    u8 userPriority;            //!< UP specified for the TSID
+
+    u8 psb;                     //!< Power save mode for TSID: 0 (legacy), 1 (UAPSD)
+    u8 flowDir;                 //!< Upstream (0), Downlink(1), Bidirectional(3)
+    u16 mediumTime;             //!< Medium time granted for the TSID
+
+} __ATTRIB_PACK__ HostCmd_DS_WMM_TS_STATUS,
+    wlan_ioctl_wmm_ts_status_t, wlan_cmd_wmm_ts_status_t;
+
+/** 
+ *  @brief IOCTL sub structure for a specific WMM AC Status
+ */
+typedef struct
+{
+    /** WMM Acm */
+    u8 wmmAcm;
+    /** Flow required flag */
+    u8 flowRequired;
+    /** Flow created flag */
+    u8 flowCreated;
+    /** Disabled flag */
+    u8 disabled;
+} __ATTRIB_PACK__ wlan_ioctl_wmm_queue_status_ac_t;
+
+/**
+ *  @brief IOCTL structure to retrieve the WMM AC Queue status
+ *
+ *  IOCTL structure from the application layer to retrieve:
+ *     - ACM bit setting for the AC
+ *     - Firmware status (flow required, flow created, flow disabled)
+ *
+ *  @sa wlan_wmm_queue_status_ioctl
+ */
+typedef struct
+{
+    /** WMM AC queue status */
+    wlan_ioctl_wmm_queue_status_ac_t acStatus[MAX_AC_QUEUES];
+} __ATTRIB_PACK__ wlan_ioctl_wmm_queue_status_t;
+
+/** Firmware status for a specific AC */
+typedef struct
+{
+    /** Disabled flag */
+    u8 Disabled;
+    /** Flow required flag */
+    u8 FlowRequired;
+    /** Flow created flag */
+    u8 FlowCreated;
+} WmmAcStatus_t;
+
+/* hostcmd.h */
+/*  802.11-related definitions */
+
+/** TxPD descriptor */
+typedef struct _TxPD
+{
+    /** Current Tx packet status */
+    u32 TxStatus;
+    /** Tx Control */
+    u32 TxControl;
+    /** Tx packet location */
+    u32 TxPacketLocation;
+    /** Tx packet length */
+    u16 TxPacketLength;
+    /**Destination MAC address */
+    u8 TxDestAddr[ETH_ALEN];
+    /** Pkt Priority */
+    u8 Priority;
+    /** Trasnit Pkt Flags*/
+    u8 Flags;
+    /** Amount of time the packet has been queued in the driver (units = 2ms)*/
+    u8 PktDelay_2ms;
+    /** Reserved */
+    u8 Reserved1;
+
+} __ATTRIB_PACK__ TxPD, *PTxPD;
+
+/** RxPD Descriptor */
+typedef struct _RxPD
+{
+        /** Current Rx packet status */
+    u16 RxStatus;
+
+        /** SNR */
+    u8 SNR;
+
+        /** Tx Control */
+    u8 RxControl;
+
+        /** Pkt Length */
+    u16 PktLen;
+
+        /** Noise Floor */
+    u8 NF;
+
+        /** Rx Packet Rate */
+    u8 RxRate;
+
+        /** Pkt offset */
+    u32 PktOffset;
+    /** Received packet type */
+    u8 RxPacketType;
+    /** Reserved */
+    u8 Reserved_1[3];
+        /** Pkt Priority */
+    u8 Priority;
+    /** Reserved */
+    u8 Reserved[3];
+
+} __ATTRIB_PACK__ RxPD, *PRxPD;
+
+#if defined(__KERNEL__)
+
+/** CmdCtrlNode */
+typedef struct _CmdCtrlNode
+{
+    /* CMD link list */
+    struct list_head list;
+
+    u32 Status;
+
+    /* CMD ID */
+    WLAN_OID cmd_oid;
+
+    /*CMD wait option: wait for finish or no wait */
+    u16 wait_option;
+
+    /* command parameter */
+    void *pdata_buf;
+
+    /*command data */
+    u8 *BufVirtualAddr;
+
+    u16 CmdFlags;
+
+    /* wait queue */
+    u16 CmdWaitQWoken;
+    wait_queue_head_t cmdwait_q __ATTRIB_ALIGN__;
+} __ATTRIB_PACK__ CmdCtrlNode, *PCmdCtrlNode;
+
+#endif
+
+/** MRVL_WEP_KEY */
+typedef struct _MRVL_WEP_KEY
+{
+    /** Length */
+    u32 Length;
+    /** WEP key index */
+    u32 KeyIndex;
+    /** WEP key length */
+    u32 KeyLength;
+    /** WEP keys */
+    u8 KeyMaterial[MRVL_KEY_BUFFER_SIZE_IN_BYTE];
+} __ATTRIB_PACK__ MRVL_WEP_KEY, *PMRVL_WEP_KEY;
+
+/** Unsigned long long */
+typedef ULONGLONG WLAN_802_11_KEY_RSC;
+
+/** WLAN_802_11_KEY */
+typedef struct _WLAN_802_11_KEY
+{
+    /** Length */
+    u32 Length;
+    /** Key index */
+    u32 KeyIndex;
+    /** Key length */
+    u32 KeyLength;
+    /** BSSID */
+    WLAN_802_11_MAC_ADDRESS BSSID;
+    /** Key RSC */
+    WLAN_802_11_KEY_RSC KeyRSC;
+    /** Key */
+    u8 KeyMaterial[MRVL_MAX_KEY_WPA_KEY_LENGTH];
+} __ATTRIB_PACK__ WLAN_802_11_KEY;
+
+/** MRVL_WPA_KEY */
+typedef struct _MRVL_WPA_KEY
+{
+    /** Key index */
+    u32 KeyIndex;
+    /** Key length */
+    u32 KeyLength;
+    /** Key RSC */
+    u32 KeyRSC;
+    /** Key material */
+    u8 KeyMaterial[MRVL_MAX_KEY_WPA_KEY_LENGTH];
+} MRVL_WPA_KEY, *PMRVL_WPA_KEY;
+
+/** MRVL_WLAN_WPA_KEY */
+typedef struct _MRVL_WLAN_WPA_KEY
+{
+    /** Encryption key */
+    u8 EncryptionKey[16];
+    /** MIC key 1 */
+    u8 MICKey1[8];
+    /** MIC key 2 */
+    u8 MICKey2[8];
+} MRVL_WLAN_WPA_KEY, *PMRVL_WLAN_WPA_KEY;
+
+/** Received Signal Strength Indication  in dBm*/
+typedef LONG WLAN_802_11_RSSI;
+
+/** WLAN_802_11_WEP */
+typedef struct _WLAN_802_11_WEP
+{
+        /** Length of this structure */
+    u32 Length;
+
+        /** 0 is the per-client key, 1-N are the global keys */
+    u32 KeyIndex;
+
+        /** length of key in bytes */
+    u32 KeyLength;
+
+        /** variable length depending on above field */
+    u8 KeyMaterial[1];
+} __ATTRIB_PACK__ WLAN_802_11_WEP;
+
+/** WLAN_802_11_SSID */
+typedef struct _WLAN_802_11_SSID
+{
+        /** SSID Length*/
+    u32 SsidLength;
+
+        /** SSID information field */
+    u8 Ssid[MRVDRV_MAX_SSID_LENGTH];
+} __ATTRIB_PACK__ WLAN_802_11_SSID;
+
+/** Framentation threshold */
+typedef u32 WLAN_802_11_FRAGMENTATION_THRESHOLD;
+/** RTS threshold */
+typedef u32 WLAN_802_11_RTS_THRESHOLD;
+/** 802.11 antenna */
+typedef u32 WLAN_802_11_ANTENNA;
+
+/** wlan_offset_value */
+typedef struct _wlan_offset_value
+{
+    /** Offset */
+    u32 offset;
+    /** Value */
+    u32 value;
+} wlan_offset_value;
+
+/** WLAN_802_11_FIXED_IEs */
+typedef struct _WLAN_802_11_FIXED_IEs
+{
+    /** Timestamp */
+    u8 Timestamp[8];
+    /** Beacon interval */
+    u16 BeaconInterval;
+    /** Capabilities*/
+    u16 Capabilities;
+} WLAN_802_11_FIXED_IEs;
+
+/** WLAN_802_11_VARIABLE_IEs */
+typedef struct _WLAN_802_11_VARIABLE_IEs
+{
+    /** Element ID */
+    u8 ElementID;
+    /** Length */
+    u8 Length;
+    /** IE data */
+    u8 data[1];
+} WLAN_802_11_VARIABLE_IEs;
+
+/** WLAN_802_11_AI_RESFI */
+typedef struct _WLAN_802_11_AI_RESFI
+{
+    /** Capabilities */
+    u16 Capabilities;
+    /** Status code */
+    u16 StatusCode;
+    /** Association ID */
+    u16 AssociationId;
+} WLAN_802_11_AI_RESFI;
+
+/** WLAN_802_11_AI_REQFI */
+typedef struct _WLAN_802_11_AI_REQFI
+{
+    /** Capabilities */
+    u16 Capabilities;
+    /** Listen interval */
+    u16 ListenInterval;
+    /** Current AP address */
+    WLAN_802_11_MAC_ADDRESS CurrentAPAddress;
+} WLAN_802_11_AI_REQFI;
+
+/* Define general data structure */
+/** HostCmd_DS_GEN */
+typedef struct _HostCmd_DS_GEN
+{
+    /** Command */
+    u16 Command;
+    /** Size */
+    u16 Size;
+    /** Sequence number */
+    u16 SeqNum;
+    /** Result */
+    u16 Result;
+} __ATTRIB_PACK__ HostCmd_DS_GEN, HostCmd_DS_802_11_DEEP_SLEEP;
+
+/** Size of HostCmd_DS_GEN */
+#define S_DS_GEN    sizeof(HostCmd_DS_GEN)
+/*
+ * Define data structure for HostCmd_CMD_GET_HW_SPEC
+ * This structure defines the response for the GET_HW_SPEC command
+ */
+/** HostCmd_DS_GET_HW_SPEC */
+typedef struct _HostCmd_DS_GET_HW_SPEC
+{
+        /** HW Interface version number */
+    u16 HWIfVersion;
+
+        /** HW version number */
+    u16 Version;
+
+        /** Max number of TxPD FW can handle*/
+    u16 NumOfTxPD;
+
+        /** Max no of Multicast address  */
+    u16 NumOfMCastAdr;
+
+        /** MAC address */
+    u8 PermanentAddr[ETH_ALEN];
+
+        /** Region Code */
+    u16 RegionCode;
+
+        /** Number of antenna used */
+    u16 NumberOfAntenna;
+
+        /** FW release number, example 0x1234=1.2.3.4 */
+    u32 FWReleaseNumber;
+
+    /** Reserved field */
+    u32 Reserved_1;
+
+    /** Reserved field */
+    u32 Reserved_2;
+
+    /** Reserved field */
+    u32 Reserved_3;
+
+        /** FW/HW Capability */
+    u32 fwCapInfo;
+} __ATTRIB_PACK__ HostCmd_DS_GET_HW_SPEC;
+
+typedef struct _HostCmd_DS_802_11_SUBSCRIBE_EVENT
+{
+    /** Action */
+    u16 Action;
+    /** Events */
+    u16 Events;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SUBSCRIBE_EVENT;
+
+/* 
+ * This scan handle Country Information IE(802.11d compliant) 
+ * Define data structure for HostCmd_CMD_802_11_SCAN 
+ */
+/** HostCmd_DS_802_11_SCAN */
+typedef struct _HostCmd_DS_802_11_SCAN
+{
+    /** BSS type */
+    u8 BSSType;
+    /** BSSID */
+    u8 BSSID[ETH_ALEN];
+    /** TLV buffer */
+    u8 TlvBuffer[1];
+    /* MrvlIEtypes_SsIdParamSet_t   SsIdParamSet; 
+     * MrvlIEtypes_ChanListParamSet_t       ChanListParamSet;
+     * MrvlIEtypes_RatesParamSet_t  OpRateSet; 
+     * */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SCAN;
+
+typedef struct _HostCmd_DS_802_11_SCAN_RSP
+{
+    /** Size of BSS descriptor */
+    u16 BSSDescriptSize;
+    /** Numner of sets */
+    u8 NumberOfSets;
+    /** BSS descriptor and TLV buffer */
+    u8 BssDescAndTlvBuffer[1];
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SCAN_RSP;
+
+/** HostCmd_CMD_802_11_GET_LOG */
+typedef struct _HostCmd_DS_802_11_GET_LOG
+{
+    /** Number of multicast transmitted frames */
+    u32 mcasttxframe;
+    /** Number of failures */
+    u32 failed;
+    /** Number of retries */
+    u32 retry;
+    /** Number of multiretries */
+    u32 multiretry;
+    /** Number of duplicate frames */
+    u32 framedup;
+    /** Number of RTS success */
+    u32 rtssuccess;
+    /** Number of RTS failure */
+    u32 rtsfailure;
+    /** Number of acknowledgement failure */
+    u32 ackfailure;
+    /** Number of fragmented packets received */
+    u32 rxfrag;
+    /** Number of multicast frames received */
+    u32 mcastrxframe;
+    /** FCS error */
+    u32 fcserror;
+    /** Number of transmitted frames */
+    u32 txframe;
+    /** Reserved field */
+    u32 reserved;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_GET_LOG;
+
+/**  HostCmd_CMD_MAC_CONTROL */
+typedef struct _HostCmd_DS_MAC_CONTROL
+{
+    /** Action */
+    u16 Action;
+    /** Reserved field */
+    u16 Reserved;
+} __ATTRIB_PACK__ HostCmd_DS_MAC_CONTROL;
+
+/**  HostCmd_CMD_MAC_MULTICAST_ADR */
+typedef struct _HostCmd_DS_MAC_MULTICAST_ADR
+{
+    /** Action */
+    u16 Action;
+    /** Number of addresses */
+    u16 NumOfAdrs;
+    /** List of MAC */
+    u8 MACList[ETH_ALEN * MRVDRV_MAX_MULTICAST_LIST_SIZE];
+} __ATTRIB_PACK__ HostCmd_DS_MAC_MULTICAST_ADR;
+
+/**  HostCmd_CMD_802_11_DEAUTHENTICATE */
+typedef struct _HostCmd_DS_802_11_DEAUTHENTICATE
+{
+    /** MAC address */
+    u8 MacAddr[ETH_ALEN];
+    /** Deauthentication resaon code */
+    u16 ReasonCode;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_DEAUTHENTICATE;
+
+/** HostCmd_DS_802_11_ASSOCIATE */
+typedef struct _HostCmd_DS_802_11_ASSOCIATE
+{
+    /** Peer STA address */
+    u8 PeerStaAddr[ETH_ALEN];
+    /** Capability information */
+    IEEEtypes_CapInfo_t CapInfo;
+    /** Listen interval */
+    u16 ListenInterval;
+    /** Reserved field */
+    u8 Reserved1[3];
+
+    /*
+     *  MrvlIEtypes_SsIdParamSet_t  SsIdParamSet;
+     *  MrvlIEtypes_PhyParamSet_t   PhyParamSet;
+     *  MrvlIEtypes_SsParamSet_t    SsParamSet;
+     *  MrvlIEtypes_RatesParamSet_t RatesParamSet;
+     */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_ASSOCIATE;
+
+/** HostCmd_CMD_802_11_ASSOCIATE response */
+typedef struct
+{
+    /** Association response structure */
+    IEEEtypes_AssocRsp_t assocRsp;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_ASSOCIATE_RSP;
+
+/**  HostCmd_CMD_802_11_AD_HOC_START response */
+typedef struct _HostCmd_DS_802_11_AD_HOC_RESULT
+{
+    /** Padding */
+    u8 PAD[3];
+    /** AdHoc BSSID */
+    u8 BSSID[ETH_ALEN];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AD_HOC_RESULT;
+
+/**  HostCmd_CMD_802_11_SET_WEP */
+typedef struct _HostCmd_DS_802_11_SET_WEP
+{
+        /** ACT_ADD, ACT_REMOVE or ACT_ENABLE  */
+    u16 Action;
+
+        /** Key Index selected for Tx */
+    u16 KeyIndex;
+
+    /* 40, 128bit or TXWEP */
+    /** Type of WEP for key 1 */
+    u8 WEPTypeForKey1;
+
+    /** Type of WEP for key 2 */
+    u8 WEPTypeForKey2;
+    /** Type of WEP for key 3 */
+    u8 WEPTypeForKey3;
+    /** Type of WEP for key 4 */
+    u8 WEPTypeForKey4;
+    /** WEP key 1 */
+    u8 WEP1[16];
+    /** WEP key 2 */
+    u8 WEP2[16];
+    /** WEP key 3 */
+    u8 WEP3[16];
+    /** WEP key 4 */
+    u8 WEP4[16];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SET_WEP;
+
+/** HostCmd_DS_802_11_AD_HOC_STOP */
+typedef struct _HostCmd_DS_802_11_AD_HOC_STOP
+{
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AD_HOC_STOP;
+
+/**  HostCmd_CMD_802_11_SNMP_MIB */
+typedef struct _HostCmd_DS_802_11_SNMP_MIB
+{
+    /** SNMP query type */
+    u16 QueryType;
+    /** SNMP object ID */
+    u16 OID;
+    /** SNMP buffer size */
+    u16 BufSize;
+    /** Value */
+    u8 Value[128];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SNMP_MIB;
+
+/** HostCmd_CMD_MAC_REG_ACCESS */
+typedef struct _HostCmd_DS_MAC_REG_ACCESS
+{
+    /** Action */
+    u16 Action;
+    /** MAC register offset */
+    u16 Offset;
+    /** MAC register value */
+    u32 Value;
+} __ATTRIB_PACK__ HostCmd_DS_MAC_REG_ACCESS;
+
+/** HostCmd_CMD_BBP_REG_ACCESS */
+typedef struct _HostCmd_DS_BBP_REG_ACCESS
+{
+    /** Acion */
+    u16 Action;
+    /** BBP register offset */
+    u16 Offset;
+    /** BBP register value */
+    u8 Value;
+    /** Reserved field */
+    u8 Reserved[3];
+} __ATTRIB_PACK__ HostCmd_DS_BBP_REG_ACCESS;
+
+/**  HostCmd_CMD_RF_REG_ACCESS */
+typedef struct _HostCmd_DS_RF_REG_ACCESS
+{
+    /** Action */
+    u16 Action;
+    /** RF register offset */
+    u16 Offset;
+    /** RF register value */
+    u8 Value;
+    /** Reserved field */
+    u8 Reserved[3];
+} __ATTRIB_PACK__ HostCmd_DS_RF_REG_ACCESS;
+
+/** HostCmd_CMD_802_11_RADIO_CONTROL */
+typedef struct _HostCmd_DS_802_11_RADIO_CONTROL
+{
+    /** Action */
+    u16 Action;
+    /** Control */
+    u16 Control;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RADIO_CONTROL;
+
+/* HostCmd_DS_802_11_SLEEP_PARAMS */
+typedef struct _HostCmd_DS_802_11_SLEEP_PARAMS
+{
+        /** ACT_GET/ACT_SET */
+    u16 Action;
+
+        /** Sleep clock error in ppm */
+    u16 Error;
+
+        /** Wakeup offset in usec */
+    u16 Offset;
+
+        /** Clock stabilization time in usec */
+    u16 StableTime;
+
+        /** Control periodic calibration */
+    u8 CalControl;
+
+        /** Control the use of external sleep clock */
+    u8 ExternalSleepClk;
+
+        /** Reserved field, should be set to zero */
+    u16 Reserved;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SLEEP_PARAMS;
+
+/* HostCmd_DS_802_11_SLEEP_PERIOD */
+typedef struct _HostCmd_DS_802_11_SLEEP_PERIOD
+{
+        /** ACT_GET/ACT_SET */
+    u16 Action;
+
+        /** Sleep Period in msec */
+    u16 Period;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SLEEP_PERIOD;
+
+/* HostCmd_DS_802_11_BCA_TIMESHARE */
+typedef struct _HostCmd_DS_802_11_BCA_TIMESHARE
+{
+    /** ACT_GET/ACT_SET */
+    u16 Action;
+
+    /** Type: WLAN, BT */
+    u16 TrafficType;
+
+    /** 20msec - 60000msec */
+    u32 TimeShareInterval;
+
+    /** PTA arbiter time in msec */
+    u32 BTTime;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BCA_TIMESHARE;
+
+/* HostCmd_DS_802_11_INACTIVITY_TIMEOUT */
+typedef struct _HostCmd_DS_802_11_INACTIVITY_TIMEOUT
+{
+    /** ACT_GET/ACT_SET */
+    u16 Action;
+
+    /** Inactivity timeout in msec */
+    u16 Timeout;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_INACTIVITY_TIMEOUT;
+
+/** HostCmd_CMD_802_11_RF_CHANNEL */
+typedef struct _HostCmd_DS_802_11_RF_CHANNEL
+{
+    /** Action */
+    u16 Action;
+    /** Current channel */
+    u16 CurrentChannel;
+    /** RF type */
+    u16 RFType;
+    /** Reserved field */
+    u16 Reserved;
+    /** List of channels */
+    u8 ChannelList[32];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RF_CHANNEL;
+
+/**  HostCmd_CMD_802_11_RSSI */
+typedef struct _HostCmd_DS_802_11_RSSI
+{
+        /** weighting factor */
+    u16 N;
+
+    /** Reserved field 0 */
+    u16 Reserved_0;
+    /** Reserved field 1 */
+    u16 Reserved_1;
+    /** Reserved field 2 */
+    u16 Reserved_2;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RSSI;
+
+/** HostCmd_DS_802_11_RSSI_RSP */
+typedef struct _HostCmd_DS_802_11_RSSI_RSP
+{
+    /** Signal to Noise ratio */
+    u16 SNR;
+    /** Noise Floor */
+    u16 NoiseFloor;
+    /** Average Signal to Noise ratio */
+    u16 AvgSNR;
+    /** Average Noise Floor */
+    u16 AvgNoiseFloor;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RSSI_RSP;
+
+/** HostCmd_DS_802_11_MAC_ADDRESS */
+typedef struct _HostCmd_DS_802_11_MAC_ADDRESS
+{
+    /** Action */
+    u16 Action;
+    /** MAC address */
+    u8 MacAdd[ETH_ALEN];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_MAC_ADDRESS;
+
+/** HostCmd_CMD_802_11_RF_TX_POWER */
+typedef struct _HostCmd_DS_802_11_RF_TX_POWER
+{
+    /** Action */
+    u16 Action;
+    /** Current power level */
+    u16 CurrentLevel;
+    /** Maximum power */
+    u8 MaxPower;
+    /** Minimum power */
+    u8 MinPower;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RF_TX_POWER;
+
+/** HostCmd_CMD_802_11_RF_ANTENNA */
+typedef struct _HostCmd_DS_802_11_RF_ANTENNA
+{
+    /** Action */
+    u16 Action;
+
+    /**  Number of antennas or 0xffff(diversity) */
+    u16 AntennaMode;
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RF_ANTENNA;
+
+/** HostCmd_CMD_802_11_PS_MODE */
+typedef struct _HostCmd_DS_802_11_PS_MODE
+{
+    /** Action */
+    u16 Action;
+    /** NULL packet interval */
+    u16 NullPktInterval;
+    /** Multiple DTIM */
+    u16 MultipleDtim;
+    /** Beacon miss timeout */
+    u16 BCNMissTimeOut;
+    /** Local listen interval */
+    u16 LocalListenInterval;
+    /** AdHoc awake period */
+    u16 AdhocAwakePeriod;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_PS_MODE;
+
+/** PS_CMD_ConfirmSleep */
+typedef struct _PS_CMD_ConfirmSleep
+{
+    /** Command */
+    u16 Command;
+    /** Size */
+    u16 Size;
+    /** Sequence number */
+    u16 SeqNum;
+    /** Result */
+    u16 Result;
+
+    /** Action */
+    u16 Action;
+    /** Reserved */
+    u16 Reserved1;
+    /** Multiple DTIM */
+    u16 MultipleDtim;
+    /** Reserved */
+    u16 Reserved;
+    /** Local listen interval */
+    u16 LocalListenInterval;
+} __ATTRIB_PACK__ PS_CMD_ConfirmSleep, *PPS_CMD_ConfirmSleep;
+
+/** HostCmd_CMD_802_11_FW_WAKE_METHOD */
+typedef struct _HostCmd_DS_802_11_FW_WAKEUP_METHOD
+{
+    /** Action */
+    u16 Action;
+    /** Method */
+    u16 Method;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_FW_WAKEUP_METHOD;
+
+/** HostCmd_DS_802_11_RATE_ADAPT_RATESET */
+typedef struct _HostCmd_DS_802_11_RATE_ADAPT_RATESET
+{
+    /** Action */
+    u16 Action;
+    /** Hardware drop rate mode */
+    u16 HWRateDropMode;
+    /** Rate bitmap */
+    u16 Bitmap;
+    /** Rate adapt threshold */
+    u16 Threshold;
+    /** Final rate */
+    u16 FinalRate;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_RATE_ADAPT_RATESET;
+
+/** HostCmd_DS_802_11_AD_HOC_START*/
+typedef struct _HostCmd_DS_802_11_AD_HOC_START
+{
+    /** AdHoc SSID */
+    u8 SSID[MRVDRV_MAX_SSID_LENGTH];
+    /** BSS type */
+    u8 BSSType;
+    /** Beacon period */
+    u16 BeaconPeriod;
+    /** DTIM period */
+    u8 DTIMPeriod;
+    /** SS parameter set */
+    IEEEtypes_SsParamSet_t SsParamSet;
+    /** PHY parameter set */
+    IEEEtypes_PhyParamSet_t PhyParamSet;
+    /** Reserved field */
+    u16 Reserved1;
+    /** Capability information */
+    IEEEtypes_CapInfo_t Cap;
+    /** Supported data rates */
+    u8 DataRate[HOSTCMD_SUPPORTED_RATES];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AD_HOC_START;
+
+/** AdHoc_BssDesc_t */
+typedef struct _AdHoc_BssDesc_t
+{
+    /** BSSID */
+    u8 BSSID[ETH_ALEN];
+    /** SSID */
+    u8 SSID[MRVDRV_MAX_SSID_LENGTH];
+    /** BSS type */
+    u8 BSSType;
+    /** Beacon period */
+    u16 BeaconPeriod;
+    /** DTIM period */
+    u8 DTIMPeriod;
+    /** Tiemstamp */
+    u8 TimeStamp[8];
+    /** Local time */
+    u8 LocalTime[8];
+    /** PHY parameter set */
+    IEEEtypes_PhyParamSet_t PhyParamSet;
+    /** SS parameter set */
+    IEEEtypes_SsParamSet_t SsParamSet;
+    /** Capability information */
+    IEEEtypes_CapInfo_t Cap;
+    /** Supported data rates */
+    u8 DataRates[HOSTCMD_SUPPORTED_RATES];
+
+    /* DO NOT ADD ANY FIELDS TO THIS STRUCTURE.      It is used below in the
+     *      Adhoc join command and will cause a binary layout mismatch with 
+     *      the firmware 
+     */
+} __ATTRIB_PACK__ AdHoc_BssDesc_t;
+
+/** HostCmd_DS_802_11_AD_HOC_JOIN */
+typedef struct _HostCmd_DS_802_11_AD_HOC_JOIN
+{
+    /** AdHoc BSS descriptor */
+    AdHoc_BssDesc_t BssDescriptor;
+    /** Reserved field */
+    u16 Reserved1;
+    /** Reserved field */
+    u16 Reserved2;
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AD_HOC_JOIN;
+
+typedef union _KeyInfo_WEP_t
+{
+    /** Reserved */
+    u8 Reserved;
+
+    /** bits 1-4: Specifies the index of key */
+    u8 WepKeyIndex;
+
+    /** bit 0: Specifies that this key is 
+     * to be used as the default for TX data packets 
+     */
+    u8 isWepDefaultKey;
+} __ATTRIB_PACK__ KeyInfo_WEP_t;
+
+typedef union _KeyInfo_TKIP_t
+{
+    /** Reserved */
+    u8 Reserved;
+
+    /** bit 2: Specifies that this key is 
+     * enabled and valid to use */
+    u8 isKeyEnabled;
+
+    /** bit 1: Specifies that this key is
+     * to be used as the unicast key */
+    u8 isUnicastKey;
+
+    /** bit 0: Specifies that this key is 
+     * to be used as the multicast key */
+    u8 isMulticastKey;
+} __ATTRIB_PACK__ KeyInfo_TKIP_t;
+
+typedef union _KeyInfo_AES_t
+{
+    /** Reserved */
+    u8 Reserved;
+
+    /** bit 2: Specifies that this key is
+     * enabled and valid to use */
+    u8 isKeyEnabled;
+
+    /** bit 1: Specifies that this key is
+     * to be used as the unicast key */
+    u8 isUnicastKey;
+
+    /** bit 0: Specifies that this key is 
+     * to be used as the multicast key */
+    u8 isMulticastKey;
+} __ATTRIB_PACK__ KeyInfo_AES_t;
+
+/** KeyMaterial_TKIP_t */
+typedef struct _KeyMaterial_TKIP_t
+{
+    /** TKIP encryption/decryption key */
+    u8 TkipKey[16];
+
+    /** TKIP TX MIC Key */
+    u8 TkipTxMicKey[16];
+
+    /** TKIP RX MIC Key */
+    u8 TkipRxMicKey[16];
+} __ATTRIB_PACK__ KeyMaterial_TKIP_t, *PKeyMaterial_TKIP_t;
+
+/** KeyMaterial_AES_t */
+typedef struct _KeyMaterial_AES_t
+{
+    /** AES encryption/decryption key */
+    u8 AesKey[16];
+} __ATTRIB_PACK__ KeyMaterial_AES_t, *PKeyMaterial_AES_t;
+
+/** MrvlIEtype_KeyParamSet_t */
+typedef struct _MrvlIEtype_KeyParamSet_t
+{
+    /** Type ID */
+    u16 Type;
+
+    /** Length of Payload */
+    u16 Length;
+
+    /** Type of Key: WEP=0, TKIP=1, AES=2 */
+    u16 KeyTypeId;
+
+    /** Key Control Info specific to a KeyTypeId */
+    u16 KeyInfo;
+
+    /** Length of key */
+    u16 KeyLen;
+
+    /** Key material of size KeyLen */
+    u8 Key[32];
+} __ATTRIB_PACK__ MrvlIEtype_KeyParamSet_t, *PMrvlIEtype_KeyParamSet_t;
+
+/** HostCmd_DS_802_11_KEY_MATERIAL */
+typedef struct _HostCmd_DS_802_11_KEY_MATERIAL
+{
+    /** Action */
+    u16 Action;
+
+    /** Key parameter set */
+    MrvlIEtype_KeyParamSet_t KeyParamSet;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_KEY_MATERIAL;
+
+/** HostCmd_DS_802_11_HOST_SLEEP_CFG */
+typedef struct _HostCmd_DS_HOST_802_11_HOST_SLEEP_CFG
+{
+       /** bit0=1: non-unicast data
+        * bit1=1: unicast data
+        * bit2=1: mac events
+     	* bit3=1: magic packet 
+	*/
+    u32 conditions;
+
+    /** GPIO */
+    u8 gpio;
+
+        /** in milliseconds */
+    u8 gap;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_HOST_SLEEP_CFG;
+
+#define CAL_DATA_HEADER_LEN	6       /**< sizeof(HostCmd_DS_802_11_CAL_DATA_EXT)-sizeof(CalData) */
+
+/** HostCmd_DS_802_11_CAL_DATA_EXT */
+typedef struct _HostCmd_DS_802_11_CAL_DATA_EXT
+{
+    /** Action */
+    u16 Action;
+    /** Revision number */
+    u16 Revision;
+    /** Calibration data length */
+    u16 CalDataLen;
+    /** Calibration data */
+    u8 CalData[1];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_CAL_DATA_EXT;
+
+typedef struct _HostCmd_DS_802_11_CFG_DATA
+{
+    /** Action */
+    u16 u16Action;
+    /** Type */
+    u16 u16Type;
+    /** Data length */
+    u16 u16DataLen;
+    /** Data */
+    u8 u8Data[1];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_CFG_DATA, *pHostCmd_DS_802_11_CFG_DATA;
+
+/** HostCmd_DS_802_11_EEPROM_ACCESS */
+typedef struct _HostCmd_DS_802_11_EEPROM_ACCESS
+{
+    /** Action */
+    u16 Action;
+
+   /** multiple 4 */
+    u16 Offset;
+    /** Number of bytes */
+    u16 ByteCount;
+    /** Value */
+    u8 Value;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_EEPROM_ACCESS;
+
+/** HostCmd_DS_802_11_BG_SCAN_CONFIG */
+typedef struct _HostCmd_DS_802_11_BG_SCAN_CONFIG
+{
+    /** Action */
+    u8 Action;
+
+    /** Configuration type */
+    u8 ConfigType;
+
+    /** 
+     *  Enable/Disable
+     *  0 - Disable
+     *  1 - Enable 
+     */
+    u8 Enable;
+
+    /**
+     *  bssType
+     *  1 - Infrastructure
+     *  2 - IBSS
+     *  3 - any 
+     */
+    u8 BssType;
+
+    /** 
+     * ChannelsPerScan 
+     *   Number of channels to scan during a single scanning opportunity
+     */
+    u8 ChannelsPerScan;
+
+    /** Reserved */
+    u8 Reserved1[3];
+
+    /** ScanInterval */
+    u32 ScanInterval;
+
+    /** Reserved */
+    u8 Reserved2[4];
+
+    /** 
+     * ReportConditions
+     * - SSID Match
+     * - Exceed SNR Threshold
+     * - Exceed RSSI Threshold
+     * - Complete all channels
+     */
+    u32 ReportConditions;
+
+    /** Reserved */
+    u8 Reserved3[2];
+
+    /*  Attach TLV based parameters as needed:
+     *
+     *  MrvlIEtypes_SsIdParamSet_t          Set specific SSID filter
+     *  MrvlIEtypes_ChanListParamSet_t      Set the channels & channel params
+     *  MrvlIEtypes_NumProbes_t             Number of probes per SSID/broadcast
+     *  MrvlIEtypes_WildCardSsIdParamSet_t  Wildcard SSID matching patterns
+     *  MrvlIEtypes_SnrThreshold_t          SNR Threshold for match/report  
+     */
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BG_SCAN_CONFIG;
+
+/** HostCmd_DS_802_11_BG_SCAN_QUERY */
+typedef struct _HostCmd_DS_802_11_BG_SCAN_QUERY
+{
+    /** Flush */
+    u8 Flush;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BG_SCAN_QUERY;
+
+/** HostCmd_DS_802_11_BG_SCAN_QUERY_RSP */
+typedef struct _HostCmd_DS_802_11_BG_SCAN_QUERY_RSP
+{
+    /** Report condition */
+    u32 ReportCondition;
+    /** Scan response */
+    HostCmd_DS_802_11_SCAN_RSP scanresp;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_BG_SCAN_QUERY_RSP;
+
+/** HostCmd_DS_802_11_TPC_CFG */
+typedef struct _HostCmd_DS_802_11_TPC_CFG
+{
+    /** Action */
+    u16 Action;
+    /** Enable flag */
+    u8 Enable;
+    /** P0 value */
+    s8 P0;
+    /** P1 value */
+    s8 P1;
+    /** P2 value */
+    s8 P2;
+    /** SNR */
+    u8 UseSNR;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_TPC_CFG;
+
+/** HostCmd_DS_802_11_LED_CTRL */
+typedef struct _HostCmd_DS_802_11_LED_CTRL
+{
+    u16 Action;                                 /**< 0 = ACT_GET; 1 = ACT_SET; */
+    u16 LedNums;                                 /**< Numbers of LEDs supported */
+    MrvlIEtypes_LedGpio_t LedGpio;                      /**< LED GPIO */
+    MrvlIEtypes_LedBehavior_t LedBehavior[1];           /**< LED behavior */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_LED_CTRL;
+
+/** HostCmd_DS_802_11_POWER_ADAPT_CFG_EXT */
+typedef struct _HostCmd_DS_802_11_POWER_ADAPT_CFG_EXT
+{
+        /** Action */
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    /** Enable power adapt */
+    u16 EnablePA;               /* 0 = disable; 1 = enable; */
+    /** Power adapt group */
+    MrvlIEtypes_PowerAdapt_Group_t PowerAdaptGroup;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_POWER_ADAPT_CFG_EXT;
+
+typedef struct _HostCmd_DS_SDIO_PULL_CTRL
+{
+    u16 Action;                 /**< 0: get; 1: set*/
+    u16 PullUp;                 /**< the delay of pulling up in us */
+    u16 PullDown;               /**< the delay of pulling down in us */
+} __ATTRIB_PACK__ HostCmd_DS_SDIO_PULL_CTRL;
+typedef struct _HostCmd_DS_802_11_IBSS_Status
+{
+    /** Action */
+    u16 Action;
+    /** Enable */
+    u16 Enable;
+    /** BSSID */
+    u8 BSSID[ETH_ALEN];
+    /** Beacon interval */
+    u16 BeaconInterval;
+    /** ATIM window interval */
+    u16 ATIMWindow;
+    /** User G rate protection */
+    u16 UseGRateProtection;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_IBSS_Status;
+
+/** RC4 cipher test */
+#define CIPHER_TEST_RC4 (1)
+/** AES cipher test */
+#define CIPHER_TEST_AES (2)
+/** AES key wrap cipher test */
+#define CIPHER_TEST_AES_KEY_WRAP (3)
+
+/** HostCmd_DS_802_11_CRYPTO */
+typedef struct _HostCmd_DS_802_11_CRYPTO
+{
+    u16 EncDec;                 //!< Decrypt=0, Encrypt=1
+    u16 Algorithm;              //!<  RC4=1 AES=2 , AES_KEY_WRAP=3
+    u16 KeyIVLength;            //!< Length of Key IV (bytes)           
+    u8 KeyIV[32];               //!< Key IV
+    u16 KeyLength;              //!< Length of Key (bytes)
+    u8 Key[32];                 //!< Key
+    /* MrvlIEtypes_Data_t   data  Plain text if EncDec=Encrypt, Ciphertext data if EncDec=Decrypt */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_CRYPTO;
+
+typedef struct _HostCmd_TX_RATE_QUERY
+{
+    /** Tx rate */
+    u16 TxRate;
+} __ATTRIB_PACK__ HostCmd_TX_RATE_QUERY;
+
+/** HostCmd_DS_802_11_AUTO_TX */
+typedef struct _HostCmd_DS_802_11_AUTO_TX
+{
+        /** Action */
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    MrvlIEtypes_AutoTx_t AutoTx;            /**< Auto Tx */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AUTO_TX;
+
+/** HostCmd_MEM_ACCESS */
+typedef struct _HostCmd_DS_MEM_ACCESS
+{
+        /** Action */
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    /** Reserved field */
+    u16 Reserved;
+    /** Address */
+    u32 Addr;
+    /** Value */
+    u32 Value;
+} __ATTRIB_PACK__ HostCmd_DS_MEM_ACCESS;
+
+typedef struct
+{
+    /** TSF value structure */
+    u64 TsfValue;
+} __ATTRIB_PACK__ HostCmd_DS_GET_TSF;
+
+typedef struct _HostCmd_DS_ECL_SYSTEM_CLOCK_CONFIG
+{
+    /** Action */
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    /** System clock */
+    u16 SystemClock;
+    /** Supported system clock length */
+    u16 SupportedSysClockLen;
+    /** Supported system clock */
+    u16 SupportedSysClock[16];
+} __ATTRIB_PACK__ HostCmd_DS_ECL_SYSTEM_CLOCK_CONFIG;
+
+typedef struct _HostCmd_DS_MODULE_TYPE_CONFIG
+{
+    /** Action */
+    u16 Action;                 /* 0 = ACT_GET; 1 = ACT_SET; */
+    /** Module */
+    u16 Module;
+} __ATTRIB_PACK__ HostCmd_DS_MODULE_TYPE_CONFIG;
+
+typedef struct _HostCmd_DS_VERSION_EXT
+{
+    /** Selected version string */
+    u8 versionStrSel;
+    /** Version string */
+    char versionStr[128];
+} __ATTRIB_PACK__ HostCmd_DS_VERSION_EXT;
+
+/** Define data structure for HostCmd_CMD_802_11D_DOMAIN_INFO */
+typedef struct _HostCmd_DS_802_11D_DOMAIN_INFO
+{
+    /** Action */
+    u16 Action;
+    /** Domain parameter set */
+    MrvlIEtypes_DomainParamSet_t Domain;
+} __ATTRIB_PACK__ HostCmd_DS_802_11D_DOMAIN_INFO;
+
+/** Define data structure for HostCmd_CMD_802_11D_DOMAIN_INFO response */
+typedef struct _HostCmd_DS_802_11D_DOMAIN_INFO_RSP
+{
+    /** Action */
+    u16 Action;
+    /** Domain parameter set */
+    MrvlIEtypes_DomainParamSet_t Domain;
+} __ATTRIB_PACK__ HostCmd_DS_802_11D_DOMAIN_INFO_RSP;
+
+typedef struct _HostCmd_DS_MEF_CFG
+{
+    /** Criteria */
+    u32 Criteria;
+    /** Number of entries */
+    u16 NumEntries;
+} __ATTRIB_PACK__ HostCmd_DS_MEF_CFG;
+
+typedef struct _MEF_CFG_DATA
+{
+    /** Size */
+    u16 size;
+    /** Data */
+    HostCmd_DS_MEF_CFG data;
+} __ATTRIB_PACK__ MEF_CFG_DATA;
+
+typedef struct _HostCmd_DS_DBGS_CFG
+{
+    /** Destination */
+    u8 Destination;
+    /** To air channel */
+    u8 ToAirChan;
+    /** Reserved */
+    u8 reserved;
+    /** Number of entries */
+    u8 En_NumEntries;
+} __ATTRIB_PACK__ HostCmd_DS_DBGS_CFG;
+
+typedef struct _DBGS_ENTRY_DATA
+{
+    /** Mode and mask or ID */
+    u16 ModeAndMaskorID;
+    /** Base or ID */
+    u16 BaseOrID;
+} __ATTRIB_PACK__ DBGS_ENTRY_DATA;
+
+typedef struct _DBGS_CFG_DATA
+{
+    /** Size */
+    u16 size;
+    /** Data */
+    HostCmd_DS_DBGS_CFG data;
+} __ATTRIB_PACK__ DBGS_CFG_DATA;
+
+typedef struct _HostCmd_DS_GET_MEM
+{
+    /** Starting address */
+    u32 StartAddr;
+    /** Length */
+    u16 Len;
+} __ATTRIB_PACK__ HostCmd_DS_GET_MEM;
+
+typedef struct _FW_MEM_DATA
+{
+    /** Size */
+    u16 size;
+    /** Data */
+    HostCmd_DS_GET_MEM data;
+} __ATTRIB_PACK__ FW_MEM_DATA;
+
+typedef struct
+{
+    /** Packet Tx init count */
+    u32 PktInitCnt;
+    /** Packet Tx success count */
+    u32 PktSuccessCnt;
+    /** Packets Tx attempts count */
+    u32 TxAttempts;
+    /** Packet Tx retry failures count */
+    u32 RetryFailure;
+    /** Packet Tx expiry failures count */
+    u32 ExpiryFailure;
+} __ATTRIB_PACK__ HostCmd_DS_TX_PKT_STAT_Entry;
+
+typedef struct
+{
+    /** DS Tx packet statistics */
+    HostCmd_DS_TX_PKT_STAT_Entry StatEntry[HOSTCMD_SUPPORTED_RATES];
+} __ATTRIB_PACK__ HostCmd_DS_TX_PKT_STATS;
+
+/**
+ * @brief 802.11h Local Power Constraint Marvell extended TLV
+ */
+typedef struct
+{
+    MrvlIEtypesHeader_t Header; //!< Marvell TLV header: ID/Len
+    u8 Chan;                    //!< Channel local constraint applies to
+
+    //! Power constraint included in beacons and used by fw to offset 11d info
+    u8 Constraint;
+
+} __ATTRIB_PACK__ MrvlIEtypes_LocalPowerConstraint_t;
+
+/*
+ *
+ * Data structures for driver/firmware command processing
+ *
+ */
+
+//!  TPC Info structure sent in CMD_802_11_TPC_INFO command to firmware
+typedef struct
+{
+    MrvlIEtypes_LocalPowerConstraint_t localConstraint; //!< Local constraint
+    MrvlIEtypes_PowerCapability_t powerCap;     //!< Power Capability
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_TPC_INFO;
+
+//!  TPC Request structure sent in CMD_802_11_TPC_ADAPT_REQ command to firmware
+typedef struct
+{
+    u8 destMac[ETH_ALEN];       //!< Destination STA address 
+    u16 timeout;                //!< Response timeout in ms
+    u8 rateIndex;               //!< IEEE Rate index to send request
+
+} __ATTRIB_PACK__ HostCmd_TpcRequest;
+
+//!  TPC Response structure received from the CMD_802_11_TPC_ADAPT_REQ command
+typedef struct
+{
+    u8 tpcRetCode;              //!< Firmware command result status code
+    s8 txPower;                 //!< Reported TX Power from the TPC Report element
+    s8 linkMargin;              //!< Reported link margin from the TPC Report element
+    s8 rssi;                    //!< RSSI of the received TPC Report frame
+
+} __ATTRIB_PACK__ HostCmd_TpcResponse;
+
+//!  CMD_802_11_TPC_ADAPT_REQ substruct. Union of the TPC request and response
+typedef union
+{
+    HostCmd_TpcRequest req;     //!< Request struct sent to firmware
+    HostCmd_TpcResponse resp;   //!< Response struct received from firmware
+
+} __ATTRIB_PACK__ HostCmd_DS_802_11_TPC_ADAPT_REQ;
+
+//!  CMD_802_11_CHAN_SW_ANN firmware command substructure
+typedef struct
+{
+    u8 switchMode;              //!< Set to 1 for a quiet switch request, no STA tx
+    u8 newChan;                 //!< Requested new channel                       
+    u8 switchCount;             //!< Number of TBTTs until the switch is to occur
+} __ATTRIB_PACK__ HostCmd_DS_802_11_CHAN_SW_ANN;
+
+/**        
+*** @brief Include extra 11h measurement types (not currently supported 
+***                                             in firmware)
+**/
+#define  WLAN_MEAS_EXTRA_11H_TYPES   0
+
+/**        
+*** @brief Include extra 11k measurement types (not currently implemented)
+**/
+#define  WLAN_MEAS_EXTRA_11K_TYPES   0
+
+/**        
+*** @brief Enumeration of measurement types, including max supported 
+***        enum for 11h/11k
+**/
+typedef enum
+{
+    WLAN_MEAS_BASIC = 0,        //!< 11h: Basic
+#if WLAN_MEAS_EXTRA_11H_TYPES
+    /* Not supported in firmware */
+    WLAN_MEAS_CCA = 1,          //!< 11h: CCA
+    WLAN_MEAS_RPI = 2,          //!< 11h: RPI
+#endif
+#if WLAN_MEAS_EXTRA_11K_TYPES
+    /* Future 11k extensions */
+    WLAN_MEAS_CHAN_LOAD = 3,    //!< 11k: Channel Load
+    WLAN_MEAS_NOISE_HIST = 4,   //!< 11k: Noise Histogram 
+    WLAN_MEAS_BEACON = 5,       //!< 11k: Beacon 
+    WLAN_MEAS_FRAME = 6,        //!< 11k: Frame
+    WLAN_MEAS_HIDDEN_NODE = 7,  //!< 11k: Hidden Node
+    WLAN_MEAS_MEDIUM_SENS_HIST = 8,     //!< 11k: Medium Sense Histogram
+    WLAN_MEAS_STA_STATS = 9,    //!< 11k: Station Statistics
+#endif
+
+    WLAN_MEAS_NUM_TYPES,        //!< Number of enumerated measurements
+
+#if WLAN_MEAS_EXTRA_11H_TYPES
+    WLAN_MEAS_11H_MAX_TYPE = WLAN_MEAS_RPI,     //!< Max 11h measurement
+#else
+    WLAN_MEAS_11H_MAX_TYPE = WLAN_MEAS_BASIC,   //!< Max 11h measurement
+#endif
+
+#if WLAN_MEAS_EXTRA_11K_TYPES
+    /* Future 11k extensions */
+    WLAN_MEAS_11K_MAX_TYPE = WLAN_MEAS_STA_STATS,       //!< Max 11k measurement
+#endif
+
+} __ATTRIB_PACK__ MeasType_t;
+
+/**        
+*** @brief Mode octet of the measurement request element (7.3.2.21)
+**/
+typedef struct
+{
+#ifdef BIG_ENDIAN
+    u8 rsvd5_7:3;               //!< Reserved
+    u8 durationMandatory:1;     //!< 11k: duration spec. for meas. is mandatory
+    u8 report:1;                //!< 11h: en/disable report rcpt. of spec. type
+    u8 request:1;               //!< 11h: en/disable requests of specified type
+    u8 enable:1;                //!< 11h: enable report/request bits
+    u8 parallel:1;              //!< 11k: series or parallel with previous meas
+#else
+    u8 parallel:1;              //!< 11k: series or parallel with previous meas
+    u8 enable:1;                //!< 11h: enable report/request bits
+    u8 request:1;               //!< 11h: en/disable requests of specified type
+    u8 report:1;                //!< 11h: en/disable report rcpt. of spec. type
+    u8 durationMandatory:1;     //!< 11k: duration spec. for meas. is mandatory
+    u8 rsvd5_7:3;               //!< Reserved
+#endif
+
+} __ATTRIB_PACK__ MeasReqMode_t;
+
+/**        
+*** @brief Common measurement request structure (7.3.2.21.1 to 7.3.2.21.3)
+**/
+typedef struct
+{
+    u8 channel;                 //!< Channel to measure
+    u64 startTime;              //!< TSF Start time of measurement (0 for immediate)
+    u16 duration;               //!< TU duration of the measurement
+
+} __ATTRIB_PACK__ MeasReqCommonFormat_t;
+
+/**        
+*** @brief Basic measurement request structure (7.3.2.21.1)
+**/
+typedef MeasReqCommonFormat_t MeasReqBasic_t;
+
+/**        
+*** @brief CCA measurement request structure (7.3.2.21.2)
+**/
+typedef MeasReqCommonFormat_t MeasReqCCA_t;
+
+/**        
+*** @brief RPI measurement request structure (7.3.2.21.3)
+**/
+typedef MeasReqCommonFormat_t MeasReqRPI_t;
+
+/**        
+*** @brief Union of the availble measurement request types.  Passed in the 
+***        driver/firmware interface.
+**/
+typedef union
+{
+    MeasReqBasic_t basic;       //!< Basic measurement request
+    MeasReqCCA_t cca;           //!< CCA measurement request
+    MeasReqRPI_t rpi;           //!< RPI measurement request
+
+} MeasRequest_t;
+
+/**        
+*** @brief Mode octet of the measurement report element (7.3.2.22)
+**/
+typedef struct
+{
+#ifdef BIG_ENDIAN
+    u8 rsvd3_7:5;               //!< Reserved
+    u8 refused:1;               //!< Measurement refused
+    u8 incapable:1;             //!< Incapable of performin measurement
+    u8 late:1;                  //!< Start TSF time missed for measurement
+#else
+    u8 late:1;                  //!< Start TSF time missed for measurement
+    u8 incapable:1;             //!< Incapable of performin measurement
+    u8 refused:1;               //!< Measurement refused
+    u8 rsvd3_7:5;               //!< Reserved
+#endif
+
+} __ATTRIB_PACK__ MeasRptMode_t;
+
+/**
+***  @brief Map octet of the basic measurment report (7.3.2.22.1)
+**/
+typedef struct
+{
+#ifdef BIG_ENDIAN
+    u8 rsvd5_7:3;               //!< Reserved
+    u8 unmeasured:1;            //!< Channel is unmeasured
+    u8 radar:1;                 //!< Radar detected on channel
+    u8 unidentifiedSig:1;       //!< Unidentified signal found on channel
+    u8 OFDM_Preamble:1;         //!< OFDM preamble detected on channel
+    u8 BSS:1;                   //!< At least one valid MPDU received on channel
+#else
+    u8 BSS:1;                   //!< At least one valid MPDU received on channel
+    u8 OFDM_Preamble:1;         //!< OFDM preamble detected on channel
+    u8 unidentifiedSig:1;       //!< Unidentified signal found on channel
+    u8 radar:1;                 //!< Radar detected on channel
+    u8 unmeasured:1;            //!< Channel is unmeasured
+    u8 rsvd5_7:3;               //!< Reserved
+#endif
+
+} __ATTRIB_PACK__ MeasRptBasicMap_t;
+
+/**        
+*** @brief Basic measurement report (7.3.2.22.1)
+**/
+typedef struct
+{
+    u8 channel;                 //!< Channel to measured
+    u64 startTime;              //!< Start time (TSF) of measurement
+    u16 duration;               //!< Duration of measurement in TUs
+    MeasRptBasicMap_t map;      //!< Basic measurement report
+
+} __ATTRIB_PACK__ MeasRptBasic_t;
+
+/**        
+*** @brief CCA measurement report (7.3.2.22.2)
+**/
+typedef struct
+{
+    u8 channel;                 //!< Channel to measured            
+    u64 startTime;              //!< Start time (TSF) of measurement
+    u16 duration;               //!< Duration of measurement in TUs 
+    u8 busyFraction;            //!< Fractional duration CCA indicated chan busy
+
+} __ATTRIB_PACK__ MeasRptCCA_t;
+
+/**        
+*** @brief RPI measurement report (7.3.2.22.3)
+**/
+typedef struct
+{
+    u8 channel;                 //!< Channel to measured            
+    u64 startTime;              //!< Start time (TSF) of measurement
+    u16 duration;               //!< Duration of measurement in TUs 
+    u8 density[8];              //!< RPI Density histogram report
+
+} __ATTRIB_PACK__ MeasRptRPI_t;
+
+/**        
+*** @brief Union of the availble measurement report types.  Passed in the 
+***        driver/firmware interface.
+**/
+typedef union
+{
+    MeasRptBasic_t basic;       //!< Basic measurement report
+    MeasRptCCA_t cca;           //!< CCA measurement report
+    MeasRptRPI_t rpi;           //!< RPI measurement report
+
+} MeasReport_t;
+
+/**        
+*** @brief Structure passed to firmware to perform a measurement
+**/
+typedef struct
+{
+    u8 macAddr[ETH_ALEN];       //!< Reporting STA address  
+    u8 dialogToken;             //!< Measurement dialog toke
+    MeasReqMode_t reqMode;      //!< Report mode            
+    MeasType_t measType;        //!< Measurement type       
+    MeasRequest_t req;          //!< Measurement request data
+
+} __ATTRIB_PACK__ HostCmd_DS_MEASUREMENT_REQUEST;
+
+/**        
+*** @brief Structure passed back from firmware with a measurement report,
+***        also can be to send a measurement report to another STA
+**/
+typedef struct
+{
+    u8 macAddr[ETH_ALEN];       //!< Reporting STA address
+    u8 dialogToken;             //!< Measurement dialog token
+    MeasRptMode_t rptMode;      //!< Report mode 
+    MeasType_t measType;        //!< Measurement type
+    MeasReport_t rpt;           //!< Measurement report data
+
+} __ATTRIB_PACK__ HostCmd_DS_MEASUREMENT_REPORT;
+
+/** _HostCmd_DS_COMMAND*/
+struct _HostCmd_DS_COMMAND
+{
+
+    /** Command Header : Command */
+    u16 Command;
+    /** Command Header : Size */
+    u16 Size;
+    /** Command Header : Sequence number */
+    u16 SeqNum;
+    /** Command Header : Result */
+    u16 Result;
+
+    /** Command Body */
+    union
+    {
+        HostCmd_DS_GET_HW_SPEC hwspec;
+        HostCmd_DS_802_11_PS_MODE psmode;
+        HostCmd_DS_802_11_SCAN scan;
+        HostCmd_DS_802_11_SCAN_RSP scanresp;
+        HostCmd_DS_MAC_CONTROL macctrl;
+        HostCmd_DS_802_11_ASSOCIATE associate;
+        HostCmd_DS_802_11_ASSOCIATE_RSP associatersp;
+        HostCmd_DS_802_11_DEAUTHENTICATE deauth;
+        HostCmd_DS_802_11_SET_WEP wep;
+        HostCmd_DS_802_11_AD_HOC_START ads;
+        HostCmd_DS_802_11_AD_HOC_RESULT result;
+        HostCmd_DS_802_11_GET_LOG glog;
+        HostCmd_DS_802_11_SNMP_MIB smib;
+        HostCmd_DS_802_11_RF_TX_POWER txp;
+        HostCmd_DS_802_11_RF_ANTENNA rant;
+        HostCmd_DS_802_11_RATE_ADAPT_RATESET rateset;
+        HostCmd_DS_MAC_MULTICAST_ADR madr;
+        HostCmd_DS_802_11_AD_HOC_JOIN adj;
+        HostCmd_DS_802_11_RADIO_CONTROL radio;
+        HostCmd_DS_802_11_RF_CHANNEL rfchannel;
+        HostCmd_DS_802_11_RSSI rssi;
+        HostCmd_DS_802_11_RSSI_RSP rssirsp;
+        HostCmd_DS_802_11_AD_HOC_STOP adhoc_stop;
+        HostCmd_DS_802_11_MAC_ADDRESS macadd;
+        HostCmd_DS_802_11_KEY_MATERIAL keymaterial;
+        HostCmd_DS_MAC_REG_ACCESS macreg;
+        HostCmd_DS_BBP_REG_ACCESS bbpreg;
+        HostCmd_DS_RF_REG_ACCESS rfreg;
+        HostCmd_DS_802_11_CAL_DATA_EXT caldataext;
+        HostCmd_DS_802_11_HOST_SLEEP_CFG hostsleepcfg;
+        HostCmd_DS_802_11_EEPROM_ACCESS rdeeprom;
+
+        HostCmd_DS_802_11D_DOMAIN_INFO domaininfo;
+        HostCmd_DS_802_11D_DOMAIN_INFO_RSP domaininforesp;
+        HostCmd_DS_802_11_TPC_ADAPT_REQ tpcReq;
+        HostCmd_DS_802_11_TPC_INFO tpcInfo;
+        HostCmd_DS_802_11_CHAN_SW_ANN chan_sw_ann;
+        HostCmd_DS_MEASUREMENT_REQUEST meas_req;
+        HostCmd_DS_MEASUREMENT_REPORT meas_rpt;
+        HostCmd_DS_802_11_BG_SCAN_CONFIG bgscancfg;
+        HostCmd_DS_802_11_BG_SCAN_QUERY bgscanquery;
+        HostCmd_DS_802_11_BG_SCAN_QUERY_RSP bgscanqueryresp;
+        HostCmd_DS_WMM_GET_STATUS getWmmStatus;
+        HostCmd_DS_WMM_ADDTS_REQ addTsReq;
+        HostCmd_DS_WMM_DELTS_REQ delTsReq;
+        HostCmd_DS_WMM_QUEUE_CONFIG queueConfig;
+        HostCmd_DS_WMM_QUEUE_STATS queueStats;
+        HostCmd_DS_WMM_TS_STATUS tsStatus;
+        HostCmd_DS_TX_PKT_STATS txPktStats;
+        HostCmd_DS_802_11_SLEEP_PARAMS sleep_params;
+        HostCmd_DS_802_11_BCA_TIMESHARE bca_timeshare;
+        HostCmd_DS_802_11_INACTIVITY_TIMEOUT inactivity_timeout;
+        HostCmd_DS_802_11_SLEEP_PERIOD ps_sleeppd;
+        HostCmd_DS_802_11_TPC_CFG tpccfg;
+        HostCmd_DS_802_11_LED_CTRL ledgpio;
+        HostCmd_DS_802_11_FW_WAKEUP_METHOD fwwakeupmethod;
+
+        HostCmd_DS_802_11_CRYPTO crypto;
+        HostCmd_TX_RATE_QUERY txrate;
+        HostCmd_DS_GET_TSF gettsf;
+        HostCmd_DS_802_11_IBSS_Status ibssCoalescing;
+        HostCmd_DS_SDIO_PULL_CTRL sdiopullctl;
+        HostCmd_DS_ECL_SYSTEM_CLOCK_CONFIG sysclockcfg;
+        HostCmd_DS_MODULE_TYPE_CONFIG moduletypecfg;
+        HostCmd_DS_VERSION_EXT verext;
+        HostCmd_DS_MEF_CFG mefcfg;
+        HostCmd_DS_DBGS_CFG dbgcfg;
+        HostCmd_DS_GET_MEM getmem;
+    } params;
+} __ATTRIB_PACK__;
+
+/** Find minimum */
+#ifndef MIN
+#define MIN(a,b)		((a) < (b) ? (a) : (b))
+#endif
+
+/** Find maximum */
+#ifndef MAX
+#define MAX(a,b)		((a) > (b) ? (a) : (b))
+#endif
+
+/** Find number of elements */
+#ifndef NELEMENTS
+#define NELEMENTS(x) (sizeof(x)/sizeof(x[0]))
+#endif
+
+/** Buffer Constants */
+
+/*	The size of SQ memory PPA, DPA are 8 DWORDs, that keep the physical
+*	addresses of TxPD buffers. Station has only 8 TxPD available, Whereas
+*	driver has more local TxPDs. Each TxPD on the host memory is associated 
+*	with a Tx control node. The driver maintains 8 RxPD descriptors for 
+*	station firmware to store Rx packet information.
+*
+*	Current version of MAC has a 32x6 multicast address buffer.
+*
+*	802.11b can have up to  14 channels, the driver keeps the
+*	BSSID(MAC address) of each APs or Ad hoc stations it has sensed.
+*/
+
+/** Size of SQ memory PPA */
+#define MRVDRV_SIZE_OF_PPA		0x00000008
+/** Size of SQ memory DPA */
+#define MRVDRV_SIZE_OF_DPA		0x00000008
+/** Number of TxPD in station */
+#define MRVDRV_NUM_OF_TxPD		0x00000020
+/** Numner of command buffers */
+#define MRVDRV_NUM_OF_CMD_BUFFER        10
+/** Size of command buffer */
+#define MRVDRV_SIZE_OF_CMD_BUFFER       (2 * 1024)
+/** Maximum number of BSSIDs */
+#define MRVDRV_MAX_BSSID_LIST		64
+/** 10 seconds */
+#define MRVDRV_TIMER_10S		10000
+/** 5 seconds */
+#define MRVDRV_TIMER_5S			5000
+/** 1 second */
+#define MRVDRV_TIMER_1S			1000
+/** Size of ethernet header */
+#define MRVDRV_ETH_HEADER_SIZE          14
+
+/** Maximum buffer size for ARP filter */
+#define ARP_FILTER_MAX_BUF_SIZE		20
+
+/** WLAN upload size */
+#define	WLAN_UPLD_SIZE			2312
+/** Length of device length */
+#define DEV_NAME_LEN			32
+
+/** Length of ethernet address */
+#ifndef	ETH_ALEN
+#define ETH_ALEN			6
+#endif
+
+/** Misc constants */
+/* This section defines 802.11 specific contants */
+#define SDIO_HEADER_LEN		4
+
+/** Maximum number of region codes */
+#define MRVDRV_MAX_REGION_CODE			7
+
+/** Maximum length of SSID list */
+#define MRVDRV_MAX_SSID_LIST_LENGTH     10
+
+/** Ignore multiple DTIM */
+#define MRVDRV_IGNORE_MULTIPLE_DTIM		0xfffe
+/** Minimum multiple DTIM */
+#define MRVDRV_MIN_MULTIPLE_DTIM		1
+/** Maximum multiple DTIM */
+#define MRVDRV_MAX_MULTIPLE_DTIM		5
+/** Default multiple DTIM */
+#define MRVDRV_DEFAULT_MULTIPLE_DTIM		1
+
+/** Default listen interval */
+#define MRVDRV_DEFAULT_LISTEN_INTERVAL		10
+/** Default local listen interval */
+#define MRVDRV_DEFAULT_LOCAL_LISTEN_INTERVAL		0
+
+/** Number of channels per active scan */
+#define	MRVDRV_CHANNELS_PER_ACTIVE_SCAN		14
+/** Minimum beacon interval */
+#define MRVDRV_MIN_BEACON_INTERVAL		20
+/** Maximum beacon interval */
+#define MRVDRV_MAX_BEACON_INTERVAL		1000
+/** Default beacon interval */
+#define MRVDRV_BEACON_INTERVAL			100
+
+/** Default watchdog timeout */
+#define MRVDRV_DEFAULT_WATCHDOG_TIMEOUT (2 * HZ)
+/** Watchdog timeout for scan */
+#define MRVDRV_SCAN_WATCHDOG_TIMEOUT    (10 * HZ)
+/** Tiemout value for exiting sleep mode */
+#define MRVDRV_DEEP_SLEEP_EXIT_TIMEOUT  (10 * HZ)
+
+/** TxPD Status */
+
+/*	Station firmware use TxPD status field to report final Tx transmit
+*	result, Bit masks are used to present combined situations.
+*/
+
+/** Bit mask for TxPD status field for null packet */
+#define MRVDRV_TxPD_POWER_MGMT_NULL_PACKET 0x01
+/** Bit mask for TxPD status field for last packet */
+#define MRVDRV_TxPD_POWER_MGMT_LAST_PACKET 0x08
+
+/** Tx control node status */
+
+#define MRVDRV_TX_CTRL_NODE_STATUS_IDLE      0x0000
+
+/* Link spped */
+/** Link speed : 1 Mbps */
+#define MRVDRV_LINK_SPEED_1mbps          10000  /* in unit of 100bps */
+/** Link speed : 11 Mbps */
+#define MRVDRV_LINK_SPEED_11mbps         110000
+
+/** RSSI-related defines */
+/*	RSSI constants are used to implement 802.11 RSSI threshold 
+*	indication. if the Rx packet signal got too weak for 5 consecutive
+*	times, miniport driver (driver) will report this event to wrapper
+*/
+
+#define MRVDRV_NF_DEFAULT_SCAN_VALUE		(-96)
+
+/** RTS/FRAG related defines */
+/** Minimum RTS value */
+#define MRVDRV_RTS_MIN_VALUE		0
+/** Maximum RTS value */
+#define MRVDRV_RTS_MAX_VALUE		2347
+/** Minimum FRAG value */
+#define MRVDRV_FRAG_MIN_VALUE		256
+/** Maximum FRAG value */
+#define MRVDRV_FRAG_MAX_VALUE		2346
+
+/** Fixed IE size is 8 bytes time stamp + 2 bytes beacon interval +
+ * 2 bytes cap */
+#define MRVL_FIXED_IE_SIZE      12
+
+/** Host comamnd flag in command */
+#define	CMD_F_HOSTCMD		(1 << 0)
+
+/* to resolve CISCO AP extension */
+/** Space for Variable IE in scan list */
+#define MRVDRV_SCAN_LIST_VAR_IE_SPACE  	256
+/** Checks whether WPA enabled in firmware */
+#define FW_IS_WPA_ENABLED(_adapter) \
+		(_adapter->fwCapInfo & FW_CAPINFO_WPA)
+
+/** WPA capability bit in firmware capability */
+#define FW_CAPINFO_WPA  	(1 << 0)
+/** REQFI capabilities */
+#define WLAN_802_11_AI_REQFI_CAPABILITIES 	1
+/** REQFI listen interval */
+#define WLAN_802_11_AI_REQFI_LISTENINTERVAL 	2
+/** REQFI current AP address */
+#define WLAN_802_11_AI_REQFI_CURRENTAPADDRESS 	4
+
+/** RESFI capabilities */
+#define WLAN_802_11_AI_RESFI_CAPABILITIES 	1
+/** RESFI status code */
+#define WLAN_802_11_AI_RESFI_STATUSCODE 	2
+/** RESFI association ID */
+#define WLAN_802_11_AI_RESFI_ASSOCIATIONID 	4
+
+/** Number of WEP keys */
+#define MRVL_NUM_WEP_KEY		4
+
+/** Support 4 keys per key set */
+#define MRVL_NUM_WPA_KEY_PER_SET        4
+/** WPA Key LENGTH*/
+#define MRVL_MAX_WPA_KEY_LENGTH 	32
+
+/** WPA AES key length */
+#define WPA_AES_KEY_LEN 		16
+/** WPA TKIP key length */
+#define WPA_TKIP_KEY_LEN 		32
+
+/* A few details needed for WEP (Wireless Equivalent Privacy) */
+/** 104 bits */
+#define MAX_WEP_KEY_SIZE	13
+/** 40 bits RC4 - WEP */
+#define MIN_WEP_KEY_SIZE	5
+
+/** RF antenna select 1 */
+#define RF_ANTENNA_1		0x1
+/** RF antenna select 2 */
+#define RF_ANTENNA_2		0x2
+/** RF antenna auto select */
+#define RF_ANTENNA_AUTO		0xFFFF
+
+/** Key information enabled */
+#define KEY_INFO_ENABLED	0x01
+
+/** Beacon Signal to Noise Ratio */
+#define SNR_BEACON		0
+/** RXPD Signal to Noise Ratio */
+#define SNR_RXPD		1
+/** Beacon Noise Floor */
+#define NF_BEACON		2
+/** RXPD Noise Floor */
+#define NF_RXPD			3
+
+/** MACRO DEFINITIONS */
+/** NF calculation */
+#define CAL_NF(NF)			((s32)(-(s32)(NF)))
+/** RSSI calculation */
+#define CAL_RSSI(SNR, NF) 		((s32)((s32)(SNR) + CAL_NF(NF)))
+/** RSSI scan */
+#define SCAN_RSSI(RSSI)			(0x100 - ((u8)(RSSI)))
+
+/** Default factor for calculating beacon average */
+#define DEFAULT_BCN_AVG_FACTOR		8
+/** Default factor for calculating data average */
+#define DEFAULT_DATA_AVG_FACTOR		8
+/** Minimum factor for calculating beacon average */
+#define MIN_BCN_AVG_FACTOR		1
+/** Maximum factor for calculating beacon average */
+#define MAX_BCN_AVG_FACTOR		8
+/** Minimum factor for calculating data average */
+#define MIN_DATA_AVG_FACTOR		1
+/** Maximum factor for calculating data average */
+#define MAX_DATA_AVG_FACTOR		8
+/** Scale used to measure average */
+#define AVG_SCALE			100
+/** Average SNR NF calculations */
+#define CAL_AVG_SNR_NF(AVG, SNRNF, N)         \
+                        (((AVG) == 0) ? ((u16)(SNRNF) * AVG_SCALE) : \
+                        ((((int)(AVG) * (N -1)) + ((u16)(SNRNF) * \
+                        AVG_SCALE))  / N))
+
+/** Success */
+#define WLAN_STATUS_SUCCESS			(0)
+/** Failure */
+#define WLAN_STATUS_FAILURE			(-1)
+/** Not accepted */
+#define WLAN_STATUS_NOT_ACCEPTED                (-2)
+
+/** Maximum number of LEDs */
+#define	MAX_LEDS			3
+/** LED disabled */
+#define	LED_DISABLED			16
+/** LED blinking */
+#define	LED_BLINKING			2
+
+/** Max loop count (* 100ms) for waiting device ready at init time */
+#define MAX_WAIT_DEVICE_READY_COUNT	50
+
+/** S_SWAP : To swap 2 u8 */
+#define S_SWAP(a,b) 	do { \
+				u8  t = SArr[a]; \
+				SArr[a] = SArr[b]; SArr[b] = t; \
+			} while(0)
+
+/** SWAP: swap u8 */
+#define SWAP_U8(a,b)	{u8 t; t=a; a=b; b=t;}
+
+/** SWAP: swap u8 */
+#define SWAP_U16(a,b)	{u16 t; t=a; a=b; b=t;}
+
+#ifdef BIG_ENDIAN
+/** Convert from 16 bit little endian format to CPU format */
+#define wlan_le16_to_cpu(x) le16_to_cpu(x)
+/** Convert from 32 bit little endian format to CPU format */
+#define wlan_le32_to_cpu(x) le32_to_cpu(x)
+/** Convert from 64 bit little endian format to CPU format */
+#define wlan_le64_to_cpu(x) le64_to_cpu(x)
+/** Convert to 16 bit little endian format from CPU format */
+#define wlan_cpu_to_le16(x) cpu_to_le16(x)
+/** Convert to 32 bit little endian format from CPU format */
+#define wlan_cpu_to_le32(x) cpu_to_le32(x)
+/** Convert to 64 bit little endian format from CPU format */
+#define wlan_cpu_to_le64(x) cpu_to_le64(x)
+
+/** Convert TxPD to little endian format from CPU format */
+#define endian_convert_TxPD(x);                                         \
+    {                                                                   \
+        (x)->TxStatus = wlan_cpu_to_le32((x)->TxStatus);                \
+        (x)->TxPacketLength = wlan_cpu_to_le16((x)->TxPacketLength);    \
+        (x)->TxPacketLocation = wlan_cpu_to_le32((x)->TxPacketLocation);\
+        (x)->TxControl = wlan_cpu_to_le32((x)->TxControl);              \
+    }
+
+/** Convert RxPD from little endian format to CPU format */
+#define endian_convert_RxPD(x);                             \
+    {                                                       \
+        (x)->RxStatus = wlan_le16_to_cpu((x)->RxStatus);    \
+        (x)->PktLen = wlan_le16_to_cpu((x)->PktLen);        \
+        (x)->PktOffset = wlan_le32_to_cpu((x)->PktOffset);  \
+    }
+
+/** Convert log from little endian format to CPU format */
+#define endian_convert_GET_LOG(x); { \
+		Adapter->LogMsg.mcastrxframe = wlan_le32_to_cpu(Adapter->LogMsg.mcastrxframe); \
+		Adapter->LogMsg.failed = wlan_le32_to_cpu(Adapter->LogMsg.failed); \
+		Adapter->LogMsg.retry = wlan_le32_to_cpu(Adapter->LogMsg.retry); \
+		Adapter->LogMsg.multiretry = wlan_le32_to_cpu(Adapter->LogMsg.multiretry); \
+		Adapter->LogMsg.framedup = wlan_le32_to_cpu(Adapter->LogMsg.framedup); \
+		Adapter->LogMsg.rtssuccess = wlan_le32_to_cpu(Adapter->LogMsg.rtssuccess); \
+		Adapter->LogMsg.rtsfailure = wlan_le32_to_cpu(Adapter->LogMsg.rtsfailure); \
+		Adapter->LogMsg.ackfailure = wlan_le32_to_cpu(Adapter->LogMsg.ackfailure); \
+		Adapter->LogMsg.rxfrag = wlan_le32_to_cpu(Adapter->LogMsg.rxfrag); \
+		Adapter->LogMsg.mcastrxframe = wlan_le32_to_cpu(Adapter->LogMsg.mcastrxframe); \
+		Adapter->LogMsg.fcserror = wlan_le32_to_cpu(Adapter->LogMsg.fcserror); \
+		Adapter->LogMsg.txframe = wlan_le32_to_cpu(Adapter->LogMsg.txframe); \
+}
+
+#else /* BIG_ENDIAN */
+/** Do nothing */
+#define wlan_le16_to_cpu(x) x
+/** Do nothing */
+#define wlan_le32_to_cpu(x) x
+/** Do nothing */
+#define wlan_le64_to_cpu(x) x
+/** Do nothing */
+#define wlan_cpu_to_le16(x) x
+/** Do nothing */
+#define wlan_cpu_to_le32(x) x
+/** Do nothing */
+#define wlan_cpu_to_le64(x) x
+
+/** Do nothing */
+#define endian_convert_TxPD(x)
+/** Do nothing */
+#define endian_convert_RxPD(x)
+/** Do nothing */
+#define endian_convert_GET_LOG(x)
+#endif /* BIG_ENDIAN */
+
+/** Global Varibale Declaration */
+/** Private data structure of the device */
+typedef struct _wlan_private wlan_private;
+/** Adapter data structure of the device */
+typedef struct _wlan_adapter wlan_adapter;
+/** Host command data structure */
+typedef struct _HostCmd_DS_COMMAND HostCmd_DS_COMMAND;
+
+/** DS frequency list */
+extern u32 DSFreqList[15];
+/** Driver version */
+extern const char driver_version[];
+extern u32 DSFreqList[];
+extern u16 RegionCodeToIndex[MRVDRV_MAX_REGION_CODE];
+
+extern u8 WlanDataRates[WLAN_SUPPORTED_RATES];
+
+extern u8 SupportedRates_B[B_SUPPORTED_RATES];
+extern u8 SupportedRates_G[G_SUPPORTED_RATES];
+extern u8 SupportedRates_A[A_SUPPORTED_RATES];
+extern u8 AdhocRates_A[A_SUPPORTED_RATES];
+
+extern u8 AdhocRates_G[G_SUPPORTED_RATES];
+
+extern u8 AdhocRates_B[4];
+extern wlan_private *wlanpriv;
+
+#ifdef MFG_CMD_SUPPORT
+#define SIOCCFMFG SIOCDEVPRIVATE
+#endif /* MFG_CMD_SUPPORT */
+
+/** ENUM definition*/
+/** SNRNF_TYPE */
+typedef enum _SNRNF_TYPE
+{
+    TYPE_BEACON = 0,
+    TYPE_RXPD,
+    MAX_TYPE_B
+} SNRNF_TYPE;
+
+/** SNRNF_DATA*/
+typedef enum _SNRNF_DATA
+{
+    TYPE_NOAVG = 0,
+    TYPE_AVG,
+    MAX_TYPE_AVG
+} SNRNF_DATA;
+
+/** WLAN_802_11_AUTH_ALG*/
+typedef enum _WLAN_802_11_AUTH_ALG
+{
+    AUTH_ALG_OPEN_SYSTEM = 1,
+    AUTH_ALG_SHARED_KEY = 2,
+    AUTH_ALG_NETWORK_EAP = 8,
+} WLAN_802_11_AUTH_ALG;
+
+/** WLAN_802_11_ENCRYPTION_MODE */
+typedef enum _WLAN_802_11_ENCRYPTION_MODE
+{
+    CIPHER_NONE,
+    CIPHER_WEP40,
+    CIPHER_TKIP,
+    CIPHER_CCMP,
+    CIPHER_WEP104,
+} WLAN_802_11_ENCRYPTION_MODE;
+
+/** WLAN_802_11_POWER_MODE */
+typedef enum _WLAN_802_11_POWER_MODE
+{
+    Wlan802_11PowerModeCAM,
+    Wlan802_11PowerModeMAX_PSP,
+    Wlan802_11PowerModeFast_PSP,
+
+    /*not a real mode, defined as an upper bound */
+    Wlan802_11PowerModeMax
+} WLAN_802_11_POWER_MODE;
+
+/** PS_STATE */
+typedef enum _PS_STATE
+{
+    PS_STATE_FULL_POWER,
+    PS_STATE_AWAKE,
+    PS_STATE_PRE_SLEEP,
+    PS_STATE_SLEEP
+} PS_STATE;
+
+/** DNLD_STATE */
+typedef enum _DNLD_STATE
+{
+    DNLD_RES_RECEIVED,
+    DNLD_DATA_SENT,
+    DNLD_CMD_SENT
+} DNLD_STATE;
+
+/** WLAN_MEDIA_STATE */
+typedef enum _WLAN_MEDIA_STATE
+{
+    WlanMediaStateDisconnected,
+    WlanMediaStateConnected
+} WLAN_MEDIA_STATE;
+
+/** WLAN_802_11_PRIVACY_FILTER */
+typedef enum _WLAN_802_11_PRIVACY_FILTER
+{
+    Wlan802_11PrivFilterAcceptAll,
+    Wlan802_11PrivFilter8021xWEP
+} WLAN_802_11_PRIVACY_FILTER;
+
+/** Hardware status codes */
+typedef enum _WLAN_HARDWARE_STATUS
+{
+    WlanHardwareStatusReady,
+    WlanHardwareStatusInitializing,
+    WlanHardwareStatusReset,
+    WlanHardwareStatusClosing,
+    WlanHardwareStatusNotReady
+} WLAN_HARDWARE_STATUS;
+
+/** WLAN_802_11_AUTHENTICATION_MODE */
+typedef enum _WLAN_802_11_AUTHENTICATION_MODE
+{
+    Wlan802_11AuthModeOpen = 0x00,
+    Wlan802_11AuthModeShared = 0x01,
+    Wlan802_11AuthModeNetworkEAP = 0x80,
+} WLAN_802_11_AUTHENTICATION_MODE;
+
+/** WLAN_802_11_WEP_STATUS */
+typedef enum _WLAN_802_11_WEP_STATUS
+{
+    Wlan802_11WEPEnabled,
+    Wlan802_11WEPDisabled,
+    Wlan802_11WEPKeyAbsent,
+    Wlan802_11WEPNotSupported
+} WLAN_802_11_WEP_STATUS;
+
+/** SNMP_MIB_INDEX_e */
+typedef enum _SNMP_MIB_INDEX_e
+{
+    DesiredBssType_i = 0,
+    OpRateSet_i,
+    BcnPeriod_i,
+    DtimPeriod_i,
+    AssocRspTimeOut_i,
+    RtsThresh_i,
+    ShortRetryLim_i,
+    LongRetryLim_i,
+    FragThresh_i,
+    Dot11D_i,
+    Dot11H_i,
+    ManufId_i,
+    ProdId_i,
+    ManufOui_i,
+    ManufName_i,
+    ManufProdName_i,
+    ManufProdVer_i
+} SNMP_MIB_INDEX_e;
+
+/** KEY_TYPE_ID */
+typedef enum _KEY_TYPE_ID
+{
+    KEY_TYPE_ID_WEP = 0,
+    KEY_TYPE_ID_TKIP,
+    KEY_TYPE_ID_AES
+} KEY_TYPE_ID;
+
+/** KEY_INFO_WEP*/
+typedef enum _KEY_INFO_WEP
+{
+    KEY_INFO_WEP_DEFAULT_KEY = 0x01
+} KEY_INFO_WEP;
+
+/** KEY_INFO_TKIP */
+typedef enum _KEY_INFO_TKIP
+{
+    KEY_INFO_TKIP_MCAST = 0x01,
+    KEY_INFO_TKIP_UNICAST = 0x02,
+    KEY_INFO_TKIP_ENABLED = 0x04
+} KEY_INFO_TKIP;
+
+/** KEY_INFO_AES*/
+typedef enum _KEY_INFO_AES
+{
+    KEY_INFO_AES_MCAST = 0x01,
+    KEY_INFO_AES_UNICAST = 0x02,
+    KEY_INFO_AES_ENABLED = 0x04
+} KEY_INFO_AES;
+
+/** SNMP_MIB_VALUE_e */
+typedef enum _SNMP_MIB_VALUE_e
+{
+    SNMP_MIB_VALUE_INFRA = 1,
+    SNMP_MIB_VALUE_ADHOC
+} SNMP_MIB_VALUE_e;
+
+/** HWRateDropMode */
+typedef enum _HWRateDropMode
+{
+    NO_HW_RATE_DROP,
+    HW_TABLE_RATE_DROP,
+    HW_SINGLE_RATE_DROP
+} HWRateDropMode;
+
+#ifdef __KERNEL__
+extern struct iw_handler_def wlan_handler_def;
+struct iw_statistics *wlan_get_wireless_stats(struct net_device *dev);
+int wlan_do_ioctl(struct net_device *dev, struct ifreq *req, int i);
+#endif
+
+#endif /* _WLAN_FW_H */
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_headers.h b/drivers/net/wireless/8688_wlan/wlan/wlan_headers.h
new file mode 100755
index 0000000..02e6c2d
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_headers.h
@@ -0,0 +1,102 @@
+/** @file wlan_headers.h
+ * 
+ * @brief This file contains all the necessary include file.
+ *
+ * (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change log:
+	05/30/07: Initial creation
+********************************************************/
+
+#ifndef _WLAN_HEADERS_H
+#define _WLAN_HEADERS_H
+
+#ifndef __ATTRIB_ALIGN__
+#define __ATTRIB_ALIGN__ __attribute__((aligned(4)))
+#endif
+
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__ __attribute__ ((packed))
+#endif
+
+/* Linux header files */
+#include        <linux/kernel.h>
+#include        <linux/module.h>
+#include        <linux/init.h>
+#include        <linux/version.h>
+#include        <linux/param.h>
+#include        <linux/delay.h>
+#include        <linux/slab.h>
+#include        <linux/mm.h>
+#include        <linux/types.h>
+#include        <linux/sched.h>
+#include        <linux/timer.h>
+#include        <linux/types.h>
+#include        <linux/ioport.h>
+#include        <linux/pci.h>
+#include        <linux/ctype.h>
+#include        <linux/proc_fs.h>
+#include	<linux/ptrace.h>
+#include	<linux/string.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#include	<linux/config.h>
+#endif
+
+#include	<linux/ioport.h>
+
+/* ASM files */
+#include        <asm/semaphore.h>
+#include        <asm/byteorder.h>
+#include        <asm/irq.h>
+#include        <asm/uaccess.h>
+#include        <asm/io.h>
+#include	<asm/system.h>
+
+/* Net header files */
+#include        <linux/wireless.h>
+#include        <linux/netdevice.h>
+#include        <linux/net.h>
+#include        <linux/ip.h>
+#include        <linux/skbuff.h>
+#include        <linux/if_arp.h>
+#include        <linux/if_ether.h>
+#include        <linux/etherdevice.h>
+#include        <net/arp.h>
+#include        <linux/rtnetlink.h>
+
+/* Wireless header */
+#include        <net/iw_handler.h>
+
+#include    "wlan_linux.h"
+#include    "wlan_fw.h"
+
+#include    "wlan_wmm.h"
+#include    "wlan_11d.h"
+#include    "wlan_meas.h"
+#include    "wlan_11h.h"
+
+#include    "wlan_scan.h"
+#include    "wlan_join.h"
+
+#include    "wlan_drv.h"
+
+#include    "wlan_wext.h"
+#include    "wlan_decl.h"
+#include    "wlan_sdio.h"
+#endif /* _WLAN_HEADERS_H */
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_init.c b/drivers/net/wireless/8688_wlan/wlan/wlan_init.c
new file mode 100755
index 0000000..cd560ca
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_init.c
@@ -0,0 +1,511 @@
+/** @file wlan_init.c
+  * @brief This file contains the initialization for FW
+  * and HW
+  *
+  * (c) Copyright © 2003-2007, Marvell International Ltd. 
+  * 
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	09/28/05: Add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join functions.
+	          Cleanup association response handler initialization.
+	01/06/05: Add FW file read
+	05/08/06: Remove the 2nd GET_HW_SPEC command and TempAddr/PermanentAddr
+	06/30/06: replaced MODULE_PARM(name, type) with module_param(name, type, perm)
+
+********************************************************/
+
+#include	"wlan_headers.h"
+
+#include	<linux/firmware.h>
+
+/* add by feng */
+#include	<linux/mmc/core.h>
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/** Helper name */
+char *helper_name = NULL;
+/** Firmware name */
+char *fw_name = NULL;
+
+module_param(helper_name, charp, 0);
+module_param(fw_name, charp, 0);
+
+#ifdef MFG_CMD_SUPPORT
+int mfgmode = 0;
+module_param(mfgmode, int, 0);
+#endif
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function allocates buffer for the member of adapter
+ *  structure like command buffer and BSSID list.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_allocate_adapter(wlan_private * priv)
+{
+    u32 ulBufSize;
+    wlan_adapter *Adapter = priv->adapter;
+
+    BSSDescriptor_t *pTempScanTable;
+
+    /* Allocate buffer to store the BSSID list */
+    ulBufSize = sizeof(BSSDescriptor_t) * MRVDRV_MAX_BSSID_LIST;
+    if (!(pTempScanTable = kmalloc(ulBufSize, GFP_KERNEL))) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    Adapter->ScanTable = pTempScanTable;
+    memset(Adapter->ScanTable, 0, ulBufSize);
+
+    if (!(Adapter->bgScanConfig =
+          kmalloc(sizeof(HostCmd_DS_802_11_BG_SCAN_CONFIG), GFP_KERNEL))) {
+        return WLAN_STATUS_FAILURE;
+    }
+    Adapter->bgScanConfigSize = sizeof(HostCmd_DS_802_11_BG_SCAN_CONFIG);
+    memset(Adapter->bgScanConfig, 0, Adapter->bgScanConfigSize);
+
+    spin_lock_init(&Adapter->QueueSpinLock);
+    INIT_LIST_HEAD(&Adapter->CmdFreeQ);
+    INIT_LIST_HEAD(&Adapter->CmdPendingQ);
+
+    /* Allocate the command buffers */
+    if (wlan_alloc_cmd_buffer(priv) != WLAN_STATUS_SUCCESS) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    memset(&Adapter->PSConfirmSleep, 0, sizeof(PS_CMD_ConfirmSleep));
+    Adapter->PSConfirmSleep.SeqNum = wlan_cpu_to_le16(++Adapter->SeqNum);
+    Adapter->PSConfirmSleep.Command =
+        wlan_cpu_to_le16(HostCmd_CMD_802_11_PS_MODE);
+    Adapter->PSConfirmSleep.Size =
+        wlan_cpu_to_le16(sizeof(PS_CMD_ConfirmSleep));
+    Adapter->PSConfirmSleep.Result = 0;
+    Adapter->PSConfirmSleep.Action =
+        wlan_cpu_to_le16(HostCmd_SubCmd_Sleep_Confirmed);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function initializes the adapter structure
+ *  and set default value to the member of adapter.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+static void
+wlan_init_adapter(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i;
+
+    Adapter->ScanProbes = 0;
+
+    Adapter->bcn_avg_factor = DEFAULT_BCN_AVG_FACTOR;
+    Adapter->data_avg_factor = DEFAULT_DATA_AVG_FACTOR;
+
+    /* ATIM params */
+    Adapter->AtimWindow = 0;
+    Adapter->ATIMEnabled = FALSE;
+
+    Adapter->MediaConnectStatus = WlanMediaStateDisconnected;
+    memset(Adapter->CurrentAddr, 0xff, ETH_ALEN);
+
+    /* Status variables */
+    Adapter->HardwareStatus = WlanHardwareStatusInitializing;
+
+    /* scan type */
+    Adapter->ScanType = HostCmd_SCAN_TYPE_ACTIVE;
+
+    /* scan mode */
+    Adapter->ScanMode = HostCmd_BSS_TYPE_ANY;
+
+    /* scan time */
+    Adapter->SpecificScanTime = MRVDRV_SPECIFIC_SCAN_CHAN_TIME;
+    Adapter->ActiveScanTime = MRVDRV_ACTIVE_SCAN_CHAN_TIME;
+    Adapter->PassiveScanTime = MRVDRV_PASSIVE_SCAN_CHAN_TIME;
+
+    /* 802.11 specific */
+    Adapter->SecInfo.WEPStatus = Wlan802_11WEPDisabled;
+    for (i = 0; i < sizeof(Adapter->WepKey) / sizeof(Adapter->WepKey[0]); i++)
+        memset(&Adapter->WepKey[i], 0, sizeof(MRVL_WEP_KEY));
+    Adapter->CurrentWepKeyIndex = 0;
+    Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+    Adapter->SecInfo.EncryptionMode = CIPHER_NONE;
+    Adapter->AdhocAESEnabled = FALSE;
+    Adapter->AdhocState = ADHOC_IDLE;
+    Adapter->InfrastructureMode = Wlan802_11Infrastructure;
+
+    Adapter->NumInScanTable = 0;
+    Adapter->pAttemptedBSSDesc = NULL;
+#ifdef REASSOCIATION
+    OS_INIT_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+    Adapter->pBeaconBufEnd = Adapter->beaconBuffer;
+
+    Adapter->HisRegCpy |= HIS_TxDnLdRdy;
+
+    memset(&Adapter->CurBssParams, 0, sizeof(Adapter->CurBssParams));
+
+    /* PnP and power profile */
+    Adapter->SurpriseRemoved = FALSE;
+
+    Adapter->CurrentPacketFilter =
+        HostCmd_ACT_MAC_RX_ON | HostCmd_ACT_MAC_TX_ON;
+
+    Adapter->RadioOn = RADIO_ON;
+#ifdef REASSOCIATION
+#if (WIRELESS_EXT >= 18)
+    Adapter->Reassoc_on = FALSE;
+#else
+    Adapter->Reassoc_on = TRUE;
+#endif
+#endif /* REASSOCIATION */
+    Adapter->TxAntenna = RF_ANTENNA_2;
+    Adapter->RxAntenna = RF_ANTENNA_AUTO;
+
+    Adapter->HWRateDropMode = HW_TABLE_RATE_DROP;
+    Adapter->Is_DataRate_Auto = TRUE;
+    Adapter->BeaconPeriod = MRVDRV_BEACON_INTERVAL;
+
+    Adapter->AdhocChannel = DEFAULT_AD_HOC_CHANNEL;
+    Adapter->AdhocAutoSel = TRUE;
+
+    Adapter->PSMode = Wlan802_11PowerModeCAM;
+    Adapter->MultipleDtim = MRVDRV_DEFAULT_MULTIPLE_DTIM;
+
+    Adapter->ListenInterval = MRVDRV_DEFAULT_LISTEN_INTERVAL;
+
+    Adapter->PSState = PS_STATE_FULL_POWER;
+    Adapter->NeedToWakeup = FALSE;
+    Adapter->LocalListenInterval = 0;   /* default value in firmware will be used */
+    Adapter->fwWakeupMethod = WAKEUP_FW_UNCHANGED;
+
+    Adapter->IsDeepSleep = FALSE;
+    Adapter->IsAutoDeepSleepEnabled = FALSE;
+
+    Adapter->IsEnhancedPSEnabled = FALSE;
+
+    Adapter->bWakeupDevRequired = FALSE;
+    Adapter->WakeupTries = 0;
+    Adapter->bHostSleepConfigured = FALSE;
+    Adapter->HSCfg.conditions = HOST_SLEEP_CFG_CANCEL;
+    Adapter->HSCfg.gpio = 0;
+    Adapter->HSCfg.gap = 0;
+
+    Adapter->DataRate = 0;      // Initially indicate the rate as auto 
+
+    Adapter->adhoc_grate_enabled = FALSE;
+
+    Adapter->IntCounter = Adapter->IntCounterSaved = 0;
+
+    Adapter->gen_null_pkg = TRUE;       /*Enable NULL Pkg generation */
+
+    init_waitqueue_head(&Adapter->cmd_EncKey);
+    init_waitqueue_head(&Adapter->ds_awake_q);
+
+    spin_lock_init(&Adapter->CurrentTxLock);
+    spin_lock_init(&Adapter->driver_lock);
+
+    Adapter->CurrentTxSkb = NULL;
+    Adapter->PktTxCtrl = 0;
+
+    return;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function initializes software
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_init_sw(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /* Allocate adapter structure */
+    if ((ret = wlan_allocate_adapter(priv)) != WLAN_STATUS_SUCCESS) {
+        goto done;
+    }
+
+    /* Initialize adapter structure */
+    wlan_init_adapter(priv);
+
+    /* Initialize the timer for command handling */
+    wlan_initialize_timer(&Adapter->MrvDrvCommandTimer,
+                          wlan_cmd_timeout_func, priv);
+    Adapter->CommandTimerIsSet = FALSE;
+
+#ifdef REASSOCIATION
+    /* Initialize the timer for the reassociation */
+    wlan_initialize_timer(&Adapter->MrvDrvTimer,
+                          wlan_reassoc_timer_func, priv);
+    Adapter->ReassocTimerIsSet = FALSE;
+#endif /* REASSOCIATION */
+
+    /* Initialize 802.11d */
+    wlan_init_11d(priv);
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function initializes firmware
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_init_fw(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    /* download firmware etc. */
+
+    ENTER();
+
+    sbi_disable_host_int(priv);
+
+    umd_dbg("helper_name: %s, fw_name: %s", helper_name, fw_name);
+
+    /* Check if firmware is already running */
+    if (sbi_check_fw_status(priv, 1) == WLAN_STATUS_SUCCESS) {
+        PRINTM(INFO, "FW already running! Skipping firmware download\n");
+    } else {
+        if ((ret =
+             request_firmware(&priv->fw_helper, helper_name,
+                              priv->hotplug_device)) < 0) {
+            PRINTM(FATAL,
+                   "request_firmware() failed (helper), error code = %#x\n",
+                   ret);
+            goto done;
+        }
+
+	umd_dbg("start downloading helper");
+        /* Download the helper */
+        ret = sbi_prog_helper(priv);
+
+        if (ret) {
+            PRINTM(INFO,
+                   "Bootloader in invalid state! Helper download failed!\n");
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        if ((ret =
+             request_firmware(&priv->firmware, fw_name,
+                              priv->hotplug_device)) < 0) {
+            PRINTM(FATAL, "request_firmware() failed, error code = %#x\n",
+                   ret);
+            goto done;
+        }
+
+	umd_dbg("start downloading fw");
+        /* Download the main firmware via the helper firmware */
+        if (sbi_prog_fw_w_helper(priv)) {
+            PRINTM(INFO, "Wlan FW download failed!\n");
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        /* Check if the firmware is downloaded successfully or not */
+        if (sbi_check_fw_status(priv, MAX_FIRMWARE_POLL_TRIES) ==
+            WLAN_STATUS_FAILURE) {
+            PRINTM(FATAL, "FW failed to be active in time!\n");
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+    }
+
+#define RF_REG_OFFSET 0x07
+#define RF_REG_VALUE  0xc8
+
+    sbi_enable_host_int(priv);
+
+#ifdef MFG_CMD_SUPPORT
+    if (mfgmode == 0) {
+#endif
+
+        /*
+         * Read MAC address from HW
+         */
+        memset(Adapter->CurrentAddr, 0xff, ETH_ALEN);
+
+        ret = wlan_prepare_cmd(priv, HostCmd_CMD_GET_HW_SPEC,
+                               0,
+                               HostCmd_OPTION_WAITFORRSP |
+                               HostCmd_OPTION_TIMEOUT, 0, NULL);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_MAC_CONTROL,
+                               0,
+                               HostCmd_OPTION_WAITFORRSP |
+                               HostCmd_OPTION_TIMEOUT, 0,
+                               &Adapter->CurrentPacketFilter);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_FW_WAKE_METHOD,
+                               HostCmd_ACT_GEN_GET,
+                               HostCmd_OPTION_WAITFORRSP |
+                               HostCmd_OPTION_TIMEOUT, 0,
+                               &priv->adapter->fwWakeupMethod);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+#ifdef MFG_CMD_SUPPORT
+    }
+#endif
+
+#ifdef MFG_CMD_SUPPORT
+    if (mfgmode == 0) {
+#endif
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_RATE_ADAPT_RATESET,
+                               HostCmd_ACT_GEN_GET,
+                               HostCmd_OPTION_WAITFORRSP |
+                               HostCmd_OPTION_TIMEOUT, 0, NULL);
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+        priv->adapter->DataRate = 0;
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_RF_TX_POWER,
+                               HostCmd_ACT_GEN_GET,
+                               HostCmd_OPTION_WAITFORRSP |
+                               HostCmd_OPTION_TIMEOUT, 0, NULL);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+#ifdef MFG_CMD_SUPPORT
+    }
+#endif
+
+    Adapter->HardwareStatus = WlanHardwareStatusReady;
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    if (priv->fw_helper) {
+        release_firmware(priv->fw_helper);
+    }
+    if (priv->firmware) {
+        release_firmware(priv->firmware);
+    }
+
+    if (ret != WLAN_STATUS_SUCCESS) {
+        Adapter->HardwareStatus = WlanHardwareStatusNotReady;
+        ret = WLAN_STATUS_FAILURE;
+    }
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function frees the structure of adapter
+ *    
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+void
+wlan_free_adapter(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!Adapter) {
+        PRINTM(INFO, "Why double free adapter?:)\n");
+        return;
+    }
+
+    PRINTM(INFO, "Free Command buffer\n");
+    wlan_free_cmd_buffer(priv);
+
+    PRINTM(INFO, "Free CommandTimer\n");
+    if (Adapter->CommandTimerIsSet) {
+        wlan_cancel_timer(&Adapter->MrvDrvCommandTimer);
+        Adapter->CommandTimerIsSet = FALSE;
+    }
+    FreeTimer(&Adapter->MrvDrvCommandTimer);
+#ifdef REASSOCIATION
+    PRINTM(INFO, "Free MrvDrvTimer\n");
+    if (Adapter->ReassocTimerIsSet) {
+        wlan_cancel_timer(&Adapter->MrvDrvTimer);
+        Adapter->ReassocTimerIsSet = FALSE;
+    }
+    FreeTimer(&Adapter->MrvDrvTimer);
+#endif /* REASSOCIATION */
+
+    if (Adapter->bgScanConfig) {
+        kfree(Adapter->bgScanConfig);
+        Adapter->bgScanConfig = NULL;
+    }
+
+    OS_FREE_LOCK(&Adapter->CurrentTxLock);
+    OS_FREE_LOCK(&Adapter->QueueSpinLock);
+
+    PRINTM(INFO, "Free ScanTable\n");
+    if (Adapter->ScanTable) {
+        kfree(Adapter->ScanTable);
+        Adapter->ScanTable = NULL;
+    }
+
+    PRINTM(INFO, "Free Adapter\n");
+
+    /* Free the adapter object itself */
+    kfree(Adapter);
+    priv->adapter = NULL;
+    LEAVE();
+}
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_join.c b/drivers/net/wireless/8688_wlan/wlan/wlan_join.c
new file mode 100755
index 0000000..8476daa
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_join.c
@@ -0,0 +1,2255 @@
+/** @file wlan_join.c
+ *
+ *  @brief Functions implementing wlan infrastructure and adhoc join routines
+ *
+ *  IOCTL handlers as well as command preperation and response routines
+ *   for sending adhoc start, adhoc join, and association commands
+ *   to the firmware.
+ *  
+ *  (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *   
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change Log:
+    01/11/06: Initial revision. Match new scan code, relocate related functions
+    01/19/06: Fix failure to save adhoc ssid as current after adhoc start
+    03/16/06: Add a semaphore to protect reassociation thread
+
+************************************************************/
+
+#include    "wlan_headers.h"
+
+/**
+ *  @brief This function finds out the common rates between rate1 and rate2.
+ *
+ * It will fill common rates in rate1 as output if found.
+ *
+ * NOTE: Setting the MSB of the basic rates need to be taken
+ *   care, either before or after calling this function
+ *
+ *  @param Adapter     A pointer to wlan_adapter structure
+ *  @param rate1       the buffer which keeps input and output
+ *  @param rate1_size  the size of rate1 buffer
+ *  @param rate2       the buffer which keeps rate2
+ *  @param rate2_size  the size of rate2 buffer.
+ *
+ *  @return            WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+get_common_rates(wlan_adapter * Adapter, u8 * rate1,
+                 int rate1_size, u8 * rate2, int rate2_size)
+{
+    u8 *ptr = rate1;
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 *tmp = NULL;
+    int i, j;
+
+    if (!(tmp = kmalloc(rate1_size, GFP_KERNEL))) {
+        PRINTM(WARN, "Allocate buffer for common rates failed\n");
+        return -ENOMEM;
+    }
+
+    memcpy(tmp, rate1, rate1_size);
+    memset(rate1, 0, rate1_size);
+
+    for (i = 0; rate2[i] && i < rate2_size; i++) {
+        for (j = 0; tmp[j] && j < rate1_size; j++) {
+            /* Check common rate, excluding the bit for basic rate */
+            if ((rate2[i] & 0x7F) == (tmp[j] & 0x7F)) {
+                *rate1++ = tmp[j];
+                break;
+            }
+        }
+    }
+
+    HEXDUMP("rate1 (AP) Rates", tmp, rate1_size);
+    HEXDUMP("rate2 (Card) Rates", rate2, rate2_size);
+    HEXDUMP("Common Rates", ptr, rate1 - ptr);
+    PRINTM(INFO, "Tx DataRate is set to 0x%X\n", Adapter->DataRate);
+
+    if (!Adapter->Is_DataRate_Auto) {
+        while (*ptr) {
+            if ((*ptr & 0x7f) == Adapter->DataRate) {
+                ret = WLAN_STATUS_SUCCESS;
+                goto done;
+            }
+            ptr++;
+        }
+        PRINTM(MSG, "Previously set fixed data rate %#x isn't "
+               "compatible with the network.\n", Adapter->DataRate);
+
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    kfree(tmp);
+    return ret;
+}
+
+/**
+ *  @brief Create the intersection of the rates supported by a target BSS and
+ *         our Adapter settings for use in an assoc/join command.
+ *
+ *  @param Adapter       A pointer to wlan_adapter structure
+ *  @param pBSSDesc      BSS Descriptor whose rates are used in the setup
+ *  @param pOutRates     Output: Octet array of rates common between the BSS
+ *                       and the Adapter supported rates settings
+ *  @param pOutRatesSize Output: Number of rates/octets set in pOutRates
+ *
+ *  @return              WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ *
+ */
+static int
+setup_rates_from_bssdesc(wlan_adapter * Adapter,
+                         BSSDescriptor_t * pBSSDesc,
+                         u8 * pOutRates, int *pOutRatesSize)
+{
+    u8 *card_rates;
+    int card_rates_size;
+
+    ENTER();
+
+    memcpy(pOutRates, pBSSDesc->SupportedRates, WLAN_SUPPORTED_RATES);
+
+    switch (pBSSDesc->bss_band) {
+    case BAND_B:
+    case BAND_G:
+        PRINTM(INFO, "Setup BG-Band Rates: %d\n", pBSSDesc->bss_band);
+        card_rates = SupportedRates_G;
+        card_rates_size = sizeof(SupportedRates_G);
+        break;
+
+    case BAND_A:
+        PRINTM(INFO, "Setup A-Band Rates: %d\n", pBSSDesc->bss_band);
+        card_rates = SupportedRates_A;
+        card_rates_size = sizeof(SupportedRates_A);
+        break;
+
+    default:
+        PRINTM(INFO, "Invalid band setting: %d\n", pBSSDesc->bss_band);
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    if (get_common_rates(Adapter, pOutRates, WLAN_SUPPORTED_RATES,
+                         card_rates, card_rates_size)) {
+        *pOutRatesSize = 0;
+        PRINTM(INFO, "get_common_rates failed\n");
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    *pOutRatesSize = MIN(strlen(pOutRates), WLAN_SUPPORTED_RATES);
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Convert band to radio type used in channel TLV
+ *
+ *  @param scanBand  Band enumeration to convert to a channel TLV radio type
+ *
+ *  @return          Radio type designator for use in a channel TLV
+ *
+ */
+static u8
+band_to_radio_type(u8 band)
+{
+    u8 retRadioType;
+
+    switch (band) {
+    case BAND_A:
+        retRadioType = HostCmd_SCAN_RADIO_TYPE_A;
+        break;
+    case BAND_B:
+    case BAND_G:
+    default:
+        retRadioType = HostCmd_SCAN_RADIO_TYPE_BG;
+        break;
+    }
+
+    return retRadioType;
+}
+
+/**
+ *  @brief Retrieve the association response
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_assoc_rsp_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int copySize;
+
+    /*
+     * Set the amount to copy back to the application as the minimum of the
+     *   available assoc resp data or the buffer provided by the application
+     */
+    copySize = MIN(Adapter->assocRspSize, wrq->u.data.length);
+
+    /* Copy the (re)association response back to the application */
+    if (copy_to_user(wrq->u.data.pointer, Adapter->assocRspBuffer, copySize)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    /* Returned copy length */
+    wrq->u.data.length = copySize;
+
+    /* Reset assoc buffer */
+    Adapter->assocRspSize = 0;
+
+    /* No error on return */
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Set an opaque block of Marvell TLVs for insertion into the
+ *         association command
+ *
+ *  Pass an opaque block of data, expected to be Marvell TLVs, to the driver
+ *    for eventual passthrough to the firmware in an associate/join
+ *    (and potentially start) command.
+ *
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_mrvl_tlv_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    /* If the passed length is zero, reset the buffer */
+    if (wrq->u.data.length == 0) {
+        Adapter->mrvlAssocTlvBufferLen = 0;
+    } else {
+        /*
+         * Verify that the passed length is not larger than the available
+         *   space remaining in the buffer
+         */
+        if (wrq->u.data.length < (sizeof(Adapter->mrvlAssocTlvBuffer)
+                                  - Adapter->mrvlAssocTlvBufferLen)) {
+            /* Append the passed data to the end of the mrvlAssocTlvBuffer */
+            if (copy_from_user(Adapter->mrvlAssocTlvBuffer
+                               + Adapter->mrvlAssocTlvBufferLen,
+                               wrq->u.data.pointer, wrq->u.data.length)) {
+                PRINTM(INFO, "Copy from user failed\n");
+                return -EFAULT;
+            }
+
+            /* Increment the stored buffer length by the size passed */
+            Adapter->mrvlAssocTlvBufferLen += wrq->u.data.length;
+        } else {
+            /* Passed data does not fit in the remaining buffer space */
+            ret = WLAN_STATUS_FAILURE;
+        }
+    }
+
+    /* Return WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE */
+    return ret;
+}
+
+/**
+ *  @brief Stop Adhoc Network
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_do_adhocstop_ioctl(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+        ret = wlan_disconnect(priv);
+    } else {
+        LEAVE();
+        return -ENOTSUPP;
+    }
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Set essid
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int
+wlan_set_essid(struct net_device *dev, struct iw_request_info *info,
+               struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    WLAN_802_11_SSID reqSSID;
+    int i;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    /* Clear any past association response stored for application retrieval */
+    Adapter->assocRspSize = 0;
+
+#ifdef REASSOCIATION
+    // cancel re-association timer if there's one
+    if (Adapter->ReassocTimerIsSet == TRUE) {
+        wlan_cancel_timer(&Adapter->MrvDrvTimer);
+        Adapter->ReassocTimerIsSet = FALSE;
+    }
+
+    if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+        PRINTM(ERROR, "Acquire semaphore error, wlan_set_essid\n");
+        return -EBUSY;
+    }
+#endif /* REASSOCIATION */
+
+    /* Check the size of the string */
+    if (dwrq->length > IW_ESSID_MAX_SIZE + 1) {
+        ret = -E2BIG;
+        goto setessid_ret;
+    }
+
+    memset(&reqSSID, 0, sizeof(WLAN_802_11_SSID));
+
+    /*
+     * Check if we asked for `any' or 'particular'
+     */
+    if (!dwrq->flags) {
+        if (wlan_find_best_network_ssid(priv, &reqSSID)) {
+            PRINTM(INFO, "Could not find best network\n");
+            ret = WLAN_STATUS_SUCCESS;
+            goto setessid_ret;
+        }
+    } else {
+        /* Set the SSID */
+#if WIRELESS_EXT > 20
+        reqSSID.SsidLength = dwrq->length;
+#else
+        reqSSID.SsidLength = dwrq->length - 1;
+#endif
+        memcpy(reqSSID.Ssid, extra, reqSSID.SsidLength);
+
+    }
+
+    PRINTM(INFO, "Requested new SSID = %s\n",
+           (reqSSID.SsidLength > 0) ? (char *) reqSSID.Ssid : "NULL");
+
+    if (!reqSSID.SsidLength || reqSSID.Ssid[0] < 0x20) {
+        PRINTM(INFO, "Invalid SSID - aborting set_essid\n");
+        ret = -EINVAL;
+        goto setessid_ret;
+    }
+
+    if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+        /* infrastructure mode */
+        PRINTM(INFO, "SSID requested = %s\n", reqSSID.Ssid);
+
+        if ((dwrq->flags & IW_ENCODE_INDEX) > 1) {
+            i = (dwrq->flags & IW_ENCODE_INDEX) - 1;    /* convert to 0 based */
+
+            PRINTM(INFO, "Request SSID by index = %d\n", i);
+
+            if (i > Adapter->NumInScanTable) {
+                /* Failed to find in table since index is > current max. */
+                i = -EINVAL;
+            }
+        } else {
+            wlan_cmd_specific_scan_ssid(priv, &reqSSID);
+            i = wlan_find_ssid_in_list(Adapter,
+                                       &reqSSID,
+                                       NULL, Wlan802_11Infrastructure);
+        }
+
+        if (i >= 0) {
+            PRINTM(INFO, "SSID found in scan list ... associating...\n");
+
+            ret = wlan_associate(priv, &Adapter->ScanTable[i]);
+
+            if (ret) {
+                goto setessid_ret;
+            }
+        } else {                /* i >= 0 */
+            ret = i;            /* return -ENETUNREACH, passed from wlan_find_ssid_in_list */
+            goto setessid_ret;
+        }
+    } else {
+        /* ad hoc mode */
+        /* If the requested SSID matches current SSID return */
+        if (!wlan_ssid_cmp
+            (&Adapter->CurBssParams.BSSDescriptor.Ssid, &reqSSID)) {
+            ret = WLAN_STATUS_SUCCESS;
+            goto setessid_ret;
+        }
+
+        /*
+         * Exit Adhoc mode
+         */
+        PRINTM(INFO, "Sending Adhoc Stop\n");
+        ret = wlan_disconnect(priv);
+
+        if (ret) {
+            goto setessid_ret;
+        }
+
+        Adapter->AdhocLinkSensed = FALSE;
+
+        if ((dwrq->flags & IW_ENCODE_INDEX) > 1) {
+            i = (dwrq->flags & IW_ENCODE_INDEX) - 1;    /* 0 based */
+            if (i > Adapter->NumInScanTable) {
+                /* Failed to find in table since index is > current max. */
+                i = -EINVAL;
+            }
+        } else {
+            /* Scan for the network */
+            wlan_cmd_specific_scan_ssid(priv, &reqSSID);
+
+            /* Search for the requested SSID in the scan table */
+            i = wlan_find_ssid_in_list(Adapter, &reqSSID, NULL,
+                                       Wlan802_11IBSS);
+        }
+
+        if (i >= 0) {
+            PRINTM(INFO, "SSID found at %d in List, so join\n", i);
+            wlan_join_adhoc(priv, &Adapter->ScanTable[i]);
+        } else {
+            /* else send START command */
+            PRINTM(INFO, "SSID not found in list, "
+                   "so creating adhoc with ssid = %s\n", reqSSID.Ssid);
+
+            wlan_start_adhoc(priv, &reqSSID);
+        }                       /* end of else (START command) */
+    }                           /* end of else (Ad hoc mode) */
+
+    /*
+     * The MediaConnectStatus change can be removed later when
+     *   the ret code is being properly returned.
+     */
+    /* Check to see if we successfully connected */
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        ret = WLAN_STATUS_SUCCESS;
+    } else {
+        ret = -ENETDOWN;
+    }
+
+  setessid_ret:
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Connect to the AP or Ad-hoc Network with specific bssid
+ *
+ * NOTE: Scan should be issued by application before this function is called
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param awrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
+             struct sockaddr *awrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    const u8 bcast[ETH_ALEN] = { 255, 255, 255, 255, 255, 255 };
+    u8 reqBSSID[ETH_ALEN];
+    int i;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    /* Clear any past association response stored for application retrieval */
+    Adapter->assocRspSize = 0;
+
+    if (awrq->sa_family != ARPHRD_ETHER)
+        return -EINVAL;
+
+    PRINTM(INFO, "ASSOC: WAP: sa_data: %02x:%02x:%02x:%02x:%02x:%02x\n",
+           (u8) awrq->sa_data[0], (u8) awrq->sa_data[1],
+           (u8) awrq->sa_data[2], (u8) awrq->sa_data[3],
+           (u8) awrq->sa_data[4], (u8) awrq->sa_data[5]);
+
+#ifdef REASSOCIATION
+    // cancel re-association timer if there's one
+    if (Adapter->ReassocTimerIsSet == TRUE) {
+        wlan_cancel_timer(&Adapter->MrvDrvTimer);
+        Adapter->ReassocTimerIsSet = FALSE;
+    }
+#endif /* REASSOCIATION */
+
+    if (!memcmp(bcast, awrq->sa_data, ETH_ALEN)) {
+        i = wlan_find_best_ssid_in_list(Adapter);
+    } else {
+        //check if we already assoicate to the AP           
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            if (memcmp
+                (awrq->sa_data,
+                 Adapter->CurBssParams.BSSDescriptor.MacAddress,
+                 ETH_ALEN) == 0)
+                return WLAN_STATUS_SUCCESS;
+        }
+        memcpy(reqBSSID, awrq->sa_data, ETH_ALEN);
+
+        PRINTM(INFO, "ASSOC: WAP: Bssid = %02x:%02x:%02x:%02x:%02x:%02x\n",
+               reqBSSID[0], reqBSSID[1], reqBSSID[2],
+               reqBSSID[3], reqBSSID[4], reqBSSID[5]);
+
+        /* Search for index position in list for requested MAC */
+        i = wlan_find_bssid_in_list(Adapter, reqBSSID,
+                                    Adapter->InfrastructureMode);
+    }
+
+    if (i < 0) {
+        PRINTM(INFO, "ASSOC: WAP: MAC address not found in BSSID List\n");
+        return -ENETUNREACH;
+    }
+
+    if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+        ret = wlan_associate(priv, &Adapter->ScanTable[i]);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    } else {
+        /* Exit Adhoc mode */
+        ret = wlan_disconnect(priv);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+        Adapter->AdhocLinkSensed = FALSE;
+
+        wlan_join_adhoc(priv, &Adapter->ScanTable[i]);
+    }
+
+    /* Check to see if we successfully connected */
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        ret = WLAN_STATUS_SUCCESS;
+    } else {
+        ret = -ENETDOWN;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Associated to a specific BSS discovered in a scan
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param pBSSDesc  Pointer to the BSS descriptor to associate with.
+ *
+ *  @return          WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+int
+wlan_associate(wlan_private * priv, BSSDescriptor_t * pBSSDesc)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int enableData = TRUE;
+    union iwreq_data wrqu;
+    int ret;
+    IEEEtypes_AssocRsp_t *pAssocRsp;
+    u8 currentBSSID[ETH_ALEN];
+    int reassocAttempt = FALSE;
+
+    ENTER();
+
+    /* Return error if the Adapter or table entry is not marked as infra */
+    if ((Adapter->InfrastructureMode != Wlan802_11Infrastructure)
+        || (pBSSDesc->InfrastructureMode != Wlan802_11Infrastructure)) {
+        LEAVE();
+        return -EINVAL;
+    }
+
+    memcpy(&currentBSSID,
+           &Adapter->CurBssParams.BSSDescriptor.MacAddress,
+           sizeof(currentBSSID));
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        reassocAttempt = TRUE;
+        PRINTM(INFO, "Attempting reassociation, stopping wmm queues\n");
+        wmm_stop_queue(priv);
+    }
+
+    /* Clear any past association response stored for application retrieval */
+    Adapter->assocRspSize = 0;
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_ASSOCIATE,
+                           0, HostCmd_OPTION_WAITFORRSP, 0, pBSSDesc);
+
+    if (Adapter->wmm.enabled) {
+        /* Don't re-enable carrier until we get the WMM_GET_STATUS event */
+        enableData = FALSE;
+    } else {
+        /* Since WMM is not enabled, setup the queues with the defaults */
+        wmm_setup_queues(priv);
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+
+        if (reassocAttempt
+            && (memcmp(&currentBSSID,
+                       &Adapter->CurBssParams.BSSDescriptor.MacAddress,
+                       sizeof(currentBSSID)) == 0)) {
+
+            /* Reassociation attempt failed, still associated to old AP,
+             **   no need to wait for WMM notification to restart data
+             */
+            enableData = TRUE;
+        }
+        if (enableData) {
+            PRINTM(INFO, "Post association, re-enabling data flow\n");
+            wmm_start_queue(priv);
+            os_carrier_on(priv);
+            os_start_queue(priv);
+        }
+    } else {
+        PRINTM(INFO, "Post association, stopping data flow\n");
+        os_carrier_off(priv);
+        os_stop_queue(priv);
+    }
+
+    memcpy(wrqu.ap_addr.sa_data,
+           &Adapter->CurBssParams.BSSDescriptor.MacAddress, ETH_ALEN);
+    wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+
+    pAssocRsp = (IEEEtypes_AssocRsp_t *) Adapter->assocRspBuffer;
+
+    if (ret || pAssocRsp->StatusCode) {
+        ret = -ENETUNREACH;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Associated to a specific indexed entry in the ScanTable
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param tableIdx  Index into the ScanTable to associate to, index parameter
+ *                   base value is 1.  No scanning is done before the 
+ *                   association attempt.
+ *
+ *  @return          WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+int
+wlan_associate_to_table_idx(wlan_private * priv, int tableIdx)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret;
+
+    ENTER();
+
+#ifdef REASSOCIATION
+    if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+        PRINTM(ERROR, "Acquire semaphore error\n");
+        return -EBUSY;
+    }
+#endif
+
+    PRINTM(INFO, "ASSOC: iwpriv: Index = %d, NumInScanTable = %d\n",
+           tableIdx, Adapter->NumInScanTable);
+
+    /* Check index in table, subtract 1 if within range and call association
+     *   sub-function.  ScanTable[] is 0 based, parameter is 1 based to
+     *   conform with IW_ENCODE_INDEX flag parameter passing in iwconfig/iwlist
+     */
+    if (tableIdx && (tableIdx <= Adapter->NumInScanTable)) {
+        ret = wlan_associate(priv, &Adapter->ScanTable[tableIdx - 1]);
+    } else {
+        ret = -EINVAL;
+    }
+
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+    LEAVE();
+
+    return ret;
+}
+
+/**
+ *  @brief Start an Adhoc Network
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param AdhocSSID    The ssid of the Adhoc Network
+ *  @return             WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+int
+wlan_start_adhoc(wlan_private * priv, WLAN_802_11_SSID * AdhocSSID)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if ((Adapter->adhoc_start_band == BAND_A) && (Adapter->AdhocAutoSel)) {
+        Adapter->AdhocChannel = wlan_11h_get_adhoc_start_channel(priv);
+
+        /*
+         ** Check if the region and channel requires a channel availability
+         **   check.
+         */
+        if (wlan_11h_radar_detect_required(priv, Adapter->AdhocChannel)) {
+            /*
+             ** Radar detection is required for this channel, make sure
+             **   11h is activated in the firmware
+             */
+            wlan_11h_activate(priv, TRUE);
+
+            /* Check for radar on the channel */
+            if (wlan_11h_radar_detected(priv, Adapter->AdhocChannel)) {
+                LEAVE();
+                return WLAN_STATUS_FAILURE;
+            }
+        }
+    }
+
+    PRINTM(INFO, "Adhoc Channel = %d\n", priv->adapter->AdhocChannel);
+    PRINTM(INFO, "CurBssParams.channel = %d\n",
+           priv->adapter->CurBssParams.BSSDescriptor.Channel);
+    PRINTM(INFO, "CurBssParams.band = %d\n",
+           priv->adapter->CurBssParams.band);
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_AD_HOC_START,
+                           0, HostCmd_OPTION_WAITFORRSP, 0, AdhocSSID);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Join an adhoc network found in a previous scan
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param pBSSDesc     Pointer to a BSS descriptor found in a previous scan
+ *                      to attempt to join
+ *
+ *  @return             WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+int
+wlan_join_adhoc(wlan_private * priv, BSSDescriptor_t * pBSSDesc)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    PRINTM(INFO, "wlan_join_adhoc: CurBss.ssid =%s\n",
+           Adapter->CurBssParams.BSSDescriptor.Ssid.Ssid);
+    PRINTM(INFO, "wlan_join_adhoc: CurBss.ssid_len =%u\n",
+           Adapter->CurBssParams.BSSDescriptor.Ssid.SsidLength);
+    PRINTM(INFO, "wlan_join_adhoc: ssid =%s\n", pBSSDesc->Ssid.Ssid);
+    PRINTM(INFO, "wlan_join_adhoc: ssid len =%u\n",
+           pBSSDesc->Ssid.SsidLength);
+
+    /* check if the requested SSID is already joined */
+    if (Adapter->CurBssParams.BSSDescriptor.Ssid.SsidLength
+        && !wlan_ssid_cmp(&pBSSDesc->Ssid,
+                          &Adapter->CurBssParams.BSSDescriptor.Ssid)
+        && (Adapter->CurBssParams.BSSDescriptor.InfrastructureMode ==
+            Wlan802_11IBSS)) {
+
+        PRINTM(INFO,
+               "ADHOC_J_CMD: New ad-hoc SSID is the same as current, "
+               "not attempting to re-join");
+
+        return WLAN_STATUS_FAILURE;
+    }
+
+    PRINTM(INFO, "CurBssParams.channel = %d\n",
+           Adapter->CurBssParams.BSSDescriptor.Channel);
+    PRINTM(INFO, "CurBssParams.band = %c\n", Adapter->CurBssParams.band);
+
+    // store the SSID info temporarily
+    memset(&Adapter->AttemptedSSIDBeforeScan, 0, sizeof(WLAN_802_11_SSID));
+    memcpy(&Adapter->AttemptedSSIDBeforeScan,
+           &pBSSDesc->Ssid, sizeof(WLAN_802_11_SSID));
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_AD_HOC_JOIN,
+                           0, HostCmd_OPTION_WAITFORRSP, 0, pBSSDesc);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Send Deauthentication Request or Stop the AdHoc network depending on mode
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @return          WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+int
+wlan_disconnect(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    struct sockaddr saddr;
+    int ret = WLAN_STATUS_SUCCESS;
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+            memcpy((void *) saddr.sa_data,
+                   (void *) &Adapter->CurBssParams.BSSDescriptor.MacAddress,
+                   ETH_ALEN);
+            ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_DEAUTHENTICATE,
+                                   0, HostCmd_OPTION_WAITFORRSP,
+                                   0, (void *) &saddr);
+
+        } else if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+            ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_AD_HOC_STOP,
+                                   0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+        }
+    }
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Set Idle Off
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlanidle_off(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    const u8 zeroMac[] = { 0, 0, 0, 0, 0, 0 };
+    int i;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+            if (memcmp(Adapter->PreviousBSSID, zeroMac, sizeof(zeroMac)) != 0) {
+
+                PRINTM(INFO, "Previous SSID = %s\n",
+                       Adapter->PreviousSSID.Ssid);
+                PRINTM(INFO, "Previous BSSID = "
+                       "%02x:%02x:%02x:%02x:%02x:%02x:\n",
+                       Adapter->PreviousBSSID[0], Adapter->PreviousBSSID[1],
+                       Adapter->PreviousBSSID[2], Adapter->PreviousBSSID[3],
+                       Adapter->PreviousBSSID[4], Adapter->PreviousBSSID[5]);
+
+                i = wlan_find_ssid_in_list(Adapter,
+                                           &Adapter->PreviousSSID,
+                                           Adapter->PreviousBSSID,
+                                           Adapter->InfrastructureMode);
+
+                if (i < 0) {
+                    wlan_cmd_specific_scan_bssid(priv,
+                                                 Adapter->PreviousBSSID);
+                    i = wlan_find_ssid_in_list(Adapter,
+                                               &Adapter->PreviousSSID,
+                                               Adapter->PreviousBSSID,
+                                               Adapter->InfrastructureMode);
+                }
+
+                if (i < 0) {
+                    /* If the BSSID could not be found, try just the SSID */
+                    i = wlan_find_ssid_in_list(Adapter,
+                                               &Adapter->PreviousSSID,
+                                               NULL,
+                                               Adapter->InfrastructureMode);
+                }
+
+                if (i < 0) {
+                    wlan_cmd_specific_scan_ssid(priv, &Adapter->PreviousSSID);
+                    i = wlan_find_ssid_in_list(Adapter,
+                                               &Adapter->PreviousSSID,
+                                               NULL,
+                                               Adapter->InfrastructureMode);
+                }
+
+                if (i >= 0) {
+                    ret = wlan_associate(priv, &Adapter->ScanTable[i]);
+                }
+            }
+        } else if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+            ret = wlan_prepare_cmd(priv,
+                                   HostCmd_CMD_802_11_AD_HOC_START,
+                                   0, HostCmd_OPTION_WAITFORRSP,
+                                   0, &Adapter->PreviousSSID);
+        }
+    }
+    /* else it is connected */
+
+    PRINTM(INFO, "\nwlanidle is off");
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Set Idle On
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlanidle_on(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+            PRINTM(INFO, "Previous SSID = %s\n", Adapter->PreviousSSID.Ssid);
+            memcpy(&Adapter->PreviousSSID,
+                   &Adapter->CurBssParams.BSSDescriptor.Ssid,
+                   sizeof(WLAN_802_11_SSID));
+            wlan_disconnect(priv);
+
+        } else if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+            ret = wlan_disconnect(priv);
+        }
+
+    }
+#ifdef REASSOCIATION
+    if (Adapter->ReassocTimerIsSet == TRUE) {
+        wlan_cancel_timer(&Adapter->MrvDrvTimer);
+        Adapter->ReassocTimerIsSet = FALSE;
+    }
+#endif /* REASSOCIATION */
+
+    PRINTM(INFO, "\nwlanidle is on");
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Append a generic IE as a passthrough TLV to a TLV buffer.
+ *
+ *  This function is called from the network join command prep. routine. 
+ *    If the IE buffer has been setup by the application, this routine appends
+ *    the buffer as a passthrough TLV type to the request.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param ppBuffer pointer to command buffer pointer
+ *
+ *  @return         bytes added to the buffer
+ */
+static int
+wlan_cmd_append_generic_ie(wlan_private * priv, u8 ** ppBuffer)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int retLen = 0;
+    MrvlIEtypesHeader_t ieHeader;
+
+    /* Null Checks */
+    if (ppBuffer == 0)
+        return 0;
+    if (*ppBuffer == 0)
+        return 0;
+
+    /*
+     * If there is a generic ie buffer setup, append it to the return
+     *   parameter buffer pointer.
+     */
+    if (Adapter->genIeBufferLen) {
+        PRINTM(INFO, "append generic %d to %p\n", Adapter->genIeBufferLen,
+               *ppBuffer);
+
+        /* Wrap the generic IE buffer with a passthrough TLV type */
+        ieHeader.Type = wlan_cpu_to_le16(TLV_TYPE_PASSTHROUGH);
+        ieHeader.Len = wlan_cpu_to_le16(Adapter->genIeBufferLen);
+        memcpy(*ppBuffer, &ieHeader, sizeof(ieHeader));
+
+        /* Increment the return size and the return buffer pointer param */
+        *ppBuffer += sizeof(ieHeader);
+        retLen += sizeof(ieHeader);
+
+        /* Copy the generic IE buffer to the output buffer, advance pointer */
+        memcpy(*ppBuffer, Adapter->genIeBuffer, Adapter->genIeBufferLen);
+
+        /* Increment the return size and the return buffer pointer param */
+        *ppBuffer += Adapter->genIeBufferLen;
+        retLen += Adapter->genIeBufferLen;
+
+        /* Reset the generic IE buffer */
+        Adapter->genIeBufferLen = 0;
+    }
+
+    /* return the length appended to the buffer */
+    return retLen;
+}
+
+/**
+ *  @brief Append any application provided Marvell TLVs to a TLV buffer.
+ *
+ *  This function is called from the network join command prep. routine. 
+ *    If the Marvell TLV buffer has been setup by the application, this routine
+ *    appends the buffer to the request.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param ppBuffer pointer to command buffer pointer
+ *
+ *  @return         bytes added to the buffer
+ */
+static int
+wlan_cmd_append_marvell_tlv(wlan_private * priv, u8 ** ppBuffer)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int retLen = 0;
+
+    /* Null Checks */
+    if (ppBuffer == 0)
+        return 0;
+    if (*ppBuffer == 0)
+        return 0;
+
+    /*
+     * If there is a Marvell TLV buffer setup, append it to the return
+     *   parameter buffer pointer.
+     */
+    if (Adapter->mrvlAssocTlvBufferLen) {
+        PRINTM(INFO, "append tlv %d to %p\n",
+               Adapter->mrvlAssocTlvBufferLen, *ppBuffer);
+
+        /* Copy the TLV buffer to the output buffer, advance pointer */
+        memcpy(*ppBuffer,
+               Adapter->mrvlAssocTlvBuffer, Adapter->mrvlAssocTlvBufferLen);
+
+        /* Increment the return size and the return buffer pointer param */
+        *ppBuffer += Adapter->mrvlAssocTlvBufferLen;
+        retLen += Adapter->mrvlAssocTlvBufferLen;
+
+        /* Reset the Marvell TLV buffer */
+        Adapter->mrvlAssocTlvBufferLen = 0;
+    }
+
+    /* return the length appended to the buffer */
+    return retLen;
+}
+
+/**
+ *  @brief Append TSF tracking info from the scan table for the target AP
+ *
+ *  This function is called from the network join command prep. routine. 
+ *    The TSF table TSF sent to the firmware contians two TSF values:
+ *      - the TSF of the target AP from its previous beacon/probe response
+ *      - the TSF timestamp of our local MAC at the time we observed the
+ *        beacon/probe response.
+ *
+ *    The firmware uses the timestamp values to set an initial TSF value
+ *      in the MAC for the new association after a reassociation attempt.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param ppBuffer A pointer to command buffer pointer
+ *  @param pBSSDesc A pointer to the BSS Descriptor from the scan table of
+ *                  the AP we are trying to join
+ *
+ *  @return         bytes added to the buffer
+ */
+static int
+wlan_cmd_append_tsf_tlv(wlan_private * priv, u8 ** ppBuffer,
+                        BSSDescriptor_t * pBSSDesc)
+{
+    MrvlIEtypes_TsfTimestamp_t tsfTlv;
+    u64 tsfVal;
+
+    /* Null Checks */
+    if (ppBuffer == 0)
+        return 0;
+    if (*ppBuffer == 0)
+        return 0;
+
+    tsfTlv.Header.Type = wlan_cpu_to_le16(TLV_TYPE_TSFTIMESTAMP);
+    tsfTlv.Header.Len = wlan_cpu_to_le16(2 * sizeof(tsfVal));
+
+    memcpy(*ppBuffer, &tsfTlv, sizeof(tsfTlv.Header));
+    *ppBuffer += sizeof(tsfTlv.Header);
+
+    /* TSF timestamp from the firmware TSF when the bcn/prb rsp was received */
+    tsfVal = wlan_cpu_to_le64(pBSSDesc->networkTSF);
+    memcpy(*ppBuffer, &tsfVal, sizeof(tsfVal));
+    *ppBuffer += sizeof(tsfVal);
+
+    memcpy(&tsfVal, pBSSDesc->TimeStamp, sizeof(tsfVal));
+
+    PRINTM(INFO, "ASSOC: TSF offset calc: %016llx - %016llx\n",
+           tsfVal, pBSSDesc->networkTSF);
+
+    tsfVal = wlan_cpu_to_le64(tsfVal);
+    memcpy(*ppBuffer, &tsfVal, sizeof(tsfVal));
+    *ppBuffer += sizeof(tsfVal);
+
+    return (sizeof(tsfTlv.Header) + (2 * sizeof(tsfVal)));
+}
+
+/**
+ *  @brief This function prepares command of deauthenticate.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param cmd      A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf Void cast of MAC Address to deauth
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_deauthenticate(wlan_private * priv,
+                               HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    HostCmd_DS_802_11_DEAUTHENTICATE *pDeauth = &cmd->params.deauth;
+    struct sockaddr *p_saddr = (struct sockaddr *) pdata_buf;
+
+    ENTER();
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_DEAUTHENTICATE);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_DEAUTHENTICATE) + S_DS_GEN);
+
+    /* set AP MAC address */
+    memcpy(pDeauth->MacAddr, p_saddr->sa_data, ETH_ALEN);
+
+    /* Reason code 3 = Station is leaving */
+#define REASON_CODE_STA_LEAVING 3
+    pDeauth->ReasonCode = wlan_cpu_to_le16(REASON_CODE_STA_LEAVING);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of association.
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param cmd       A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf Void cast of BSSDescriptor_t from the scan table to assoc
+ *  @return          WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_associate(wlan_private * priv,
+                          HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_ASSOCIATE *pAsso = &cmd->params.associate;
+    int ret = WLAN_STATUS_SUCCESS;
+    BSSDescriptor_t *pBSSDesc;
+    WLAN_802_11_RATES rates;
+    int ratesSize;
+    u8 *pos;
+    u16 TmpCap;
+    MrvlIEtypes_SsIdParamSet_t *pSsidTlv;
+    MrvlIEtypes_PhyParamSet_t *pPhyTlv;
+    MrvlIEtypes_SsParamSet_t *pSsTlv;
+    MrvlIEtypes_RatesParamSet_t *pRatesTlv;
+    MrvlIEtypes_AuthType_t *pAuthTlv;
+    MrvlIEtypes_RsnParamSet_t *pRsnTlv;
+    MrvlIEtypes_ChanListParamSet_t *pChanTlv;
+
+    ENTER();
+
+    pBSSDesc = (BSSDescriptor_t *) pdata_buf;
+    pos = (u8 *) pAsso;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_ASSOCIATE);
+
+    /* Save so we know which BSS Desc to use in the response handler */
+    Adapter->pAttemptedBSSDesc = pBSSDesc;
+
+    memcpy(pAsso->PeerStaAddr,
+           pBSSDesc->MacAddress, sizeof(pAsso->PeerStaAddr));
+    pos += sizeof(pAsso->PeerStaAddr);
+
+    /* set the listen interval */
+    pAsso->ListenInterval = wlan_cpu_to_le16(Adapter->ListenInterval);
+
+    pos += sizeof(pAsso->CapInfo);
+    pos += sizeof(pAsso->ListenInterval);
+    pos += sizeof(pAsso->Reserved1);
+
+    pSsidTlv = (MrvlIEtypes_SsIdParamSet_t *) pos;
+    pSsidTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_SSID);
+    pSsidTlv->Header.Len = pBSSDesc->Ssid.SsidLength;
+    memcpy(pSsidTlv->SsId, pBSSDesc->Ssid.Ssid, pSsidTlv->Header.Len);
+    pos += sizeof(pSsidTlv->Header) + pSsidTlv->Header.Len;
+    pSsidTlv->Header.Len = wlan_cpu_to_le16(pSsidTlv->Header.Len);
+
+    pPhyTlv = (MrvlIEtypes_PhyParamSet_t *) pos;
+    pPhyTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_PHY_DS);
+    pPhyTlv->Header.Len = sizeof(pPhyTlv->fh_ds.DsParamSet);
+    memcpy(&pPhyTlv->fh_ds.DsParamSet,
+           &pBSSDesc->PhyParamSet.DsParamSet.CurrentChan,
+           sizeof(pPhyTlv->fh_ds.DsParamSet));
+    pos += sizeof(pPhyTlv->Header) + pPhyTlv->Header.Len;
+    pPhyTlv->Header.Len = wlan_cpu_to_le16(pPhyTlv->Header.Len);
+
+    pSsTlv = (MrvlIEtypes_SsParamSet_t *) pos;
+    pSsTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_CF);
+    pSsTlv->Header.Len = sizeof(pSsTlv->cf_ibss.CfParamSet);
+    pos += sizeof(pSsTlv->Header) + pSsTlv->Header.Len;
+    pSsTlv->Header.Len = wlan_cpu_to_le16(pSsTlv->Header.Len);
+
+    /* Get the common rates supported between the driver and the BSS Desc */
+    if (setup_rates_from_bssdesc(Adapter, pBSSDesc, rates, &ratesSize)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Setup the Rates TLV in the association command */
+    pRatesTlv = (MrvlIEtypes_RatesParamSet_t *) pos;
+    pRatesTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_RATES);
+    pRatesTlv->Header.Len = wlan_cpu_to_le16(ratesSize);
+    memcpy(pRatesTlv->Rates, rates, ratesSize);
+    pos += sizeof(pRatesTlv->Header) + ratesSize;
+    PRINTM(INFO, "ASSOC_CMD: Rates size = %d\n", ratesSize);
+
+    /* Add the Authentication type to be used for Auth frames if needed */
+    pAuthTlv = (MrvlIEtypes_AuthType_t *) pos;
+    pAuthTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_AUTH_TYPE);
+    pAuthTlv->Header.Len = sizeof(pAuthTlv->AuthType);
+    pAuthTlv->AuthType = Adapter->SecInfo.AuthenticationMode;
+    pos += sizeof(pAuthTlv->Header) + pAuthTlv->Header.Len;
+    pAuthTlv->Header.Len = wlan_cpu_to_le16(pAuthTlv->Header.Len);
+
+    /* Append a channel TLV for the channel the attempted AP was found on */
+    pChanTlv = (MrvlIEtypes_ChanListParamSet_t *) pos;
+    pChanTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_CHANLIST);
+    pChanTlv->Header.Len = wlan_cpu_to_le16(sizeof(ChanScanParamSet_t));
+
+    memset(pChanTlv->ChanScanParam, 0x00, sizeof(ChanScanParamSet_t));
+    pChanTlv->ChanScanParam[0].ChanNumber =
+        (pBSSDesc->PhyParamSet.DsParamSet.CurrentChan);
+    PRINTM(INFO, "Assoc: TLV Chan = %d\n",
+           pChanTlv->ChanScanParam[0].ChanNumber);
+
+    pChanTlv->ChanScanParam[0].RadioType
+        = band_to_radio_type(pBSSDesc->bss_band);
+
+    PRINTM(INFO, "Assoc: TLV Band = %d\n",
+           pChanTlv->ChanScanParam[0].RadioType);
+    pos += sizeof(pChanTlv->Header) + sizeof(ChanScanParamSet_t);
+
+    if (!Adapter->wps.SessionEnable) {
+        if (Adapter->SecInfo.WPAEnabled || Adapter->SecInfo.WPA2Enabled) {
+            pRsnTlv = (MrvlIEtypes_RsnParamSet_t *) pos;
+            pRsnTlv->Header.Type = (u16) Adapter->Wpa_ie[0];    /* WPA_IE or WPA2_IE */
+            pRsnTlv->Header.Type = pRsnTlv->Header.Type & 0x00FF;
+            pRsnTlv->Header.Type = wlan_cpu_to_le16(pRsnTlv->Header.Type);
+            pRsnTlv->Header.Len = (u16) Adapter->Wpa_ie[1];
+            pRsnTlv->Header.Len = pRsnTlv->Header.Len & 0x00FF;
+            if (pRsnTlv->Header.Len <= (sizeof(Adapter->Wpa_ie) - 2)) {
+                memcpy(pRsnTlv->RsnIE, &Adapter->Wpa_ie[2],
+                       pRsnTlv->Header.Len);
+            } else {
+                ret = WLAN_STATUS_FAILURE;
+                goto done;
+            }
+            HEXDUMP("ASSOC_CMD: RSN IE", (u8 *) pRsnTlv,
+                    sizeof(pRsnTlv->Header) + pRsnTlv->Header.Len);
+            pos += sizeof(pRsnTlv->Header) + pRsnTlv->Header.Len;
+            pRsnTlv->Header.Len = wlan_cpu_to_le16(pRsnTlv->Header.Len);
+        }
+    }
+
+    wlan_wmm_process_association_req(priv, &pos, &pBSSDesc->wmmIE);
+
+    wlan_cmd_append_generic_ie(priv, &pos);
+
+    wlan_cmd_append_marvell_tlv(priv, &pos);
+
+    wlan_cmd_append_tsf_tlv(priv, &pos, pBSSDesc);
+
+    if (wlan_parse_dnld_countryinfo_11d(priv)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /*
+     * Call 11h join API after capability bits are set so adhoc/infra 11h
+     * behavior can be properly triggered.  pos modified if data is appended
+     */
+    wlan_11h_process_join(priv, &pos, &pAsso->CapInfo,
+                          pBSSDesc->PhyParamSet.DsParamSet.CurrentChan,
+                          &pBSSDesc->wlan_11h_bss_info);
+
+    cmd->Size = wlan_cpu_to_le16((u16) (pos - (u8 *) pAsso) + S_DS_GEN);
+
+    /* set the Capability info at last */
+    memcpy(&TmpCap, &pBSSDesc->Cap, sizeof(pAsso->CapInfo));
+    TmpCap &= CAPINFO_MASK;
+    PRINTM(INFO, "ASSOC_CMD: TmpCap=%4X CAPINFO_MASK=%4X\n",
+           TmpCap, CAPINFO_MASK);
+    TmpCap = wlan_cpu_to_le16(TmpCap);
+    memcpy(&pAsso->CapInfo, &TmpCap, sizeof(pAsso->CapInfo));
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function prepares command of ad_hoc_start.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param cmd      A pointer to HostCmd_DS_COMMAND structure
+ *  @param pssid    A pointer to WLAN_802_11_SSID structure
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_ad_hoc_start(wlan_private * priv,
+                             HostCmd_DS_COMMAND * cmd, void *pssid)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_AD_HOC_START *adhs = &cmd->params.ads;
+    int ret = WLAN_STATUS_SUCCESS;
+    int cmdAppendSize = 0;
+    int i;
+    u16 TmpCap;
+    BSSDescriptor_t *pBSSDesc;
+    MrvlIEtypes_ChanListParamSet_t *pChanTlv;
+    MrvlIEtypes_RsnParamSet_t *pRsnTlv;
+    u8 *pos;
+    pos = (u8 *) adhs + sizeof(HostCmd_DS_802_11_AD_HOC_START);
+
+    ENTER();
+
+    if (!Adapter) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);
+
+    pBSSDesc = &Adapter->CurBssParams.BSSDescriptor;
+    Adapter->pAttemptedBSSDesc = pBSSDesc;
+
+    /*
+     * Fill in the parameters for 2 data structures:
+     *   1. HostCmd_DS_802_11_AD_HOC_START Command
+     *   2. pBSSDesc
+     *
+     * Driver will fill up SSID, BSSType,IBSS param, Physical Param,
+     *   probe delay, and Cap info.
+     *
+     * Firmware will fill up beacon period, Basic rates
+     *   and operational rates.
+     */
+
+    memset(adhs->SSID, 0, MRVDRV_MAX_SSID_LENGTH);
+
+    memcpy(adhs->SSID, ((WLAN_802_11_SSID *) pssid)->Ssid,
+           ((WLAN_802_11_SSID *) pssid)->SsidLength);
+
+    PRINTM(INFO, "ADHOC_S_CMD: SSID = %s\n", adhs->SSID);
+
+    memset(pBSSDesc->Ssid.Ssid, 0, MRVDRV_MAX_SSID_LENGTH);
+    memcpy(pBSSDesc->Ssid.Ssid,
+           ((WLAN_802_11_SSID *) pssid)->Ssid,
+           ((WLAN_802_11_SSID *) pssid)->SsidLength);
+
+    pBSSDesc->Ssid.SsidLength = ((WLAN_802_11_SSID *) pssid)->SsidLength;
+
+    /* set the BSS type */
+    adhs->BSSType = HostCmd_BSS_TYPE_IBSS;
+    pBSSDesc->InfrastructureMode = Wlan802_11IBSS;
+    adhs->BeaconPeriod = wlan_cpu_to_le16(Adapter->BeaconPeriod);
+    pBSSDesc->BeaconPeriod = Adapter->BeaconPeriod;
+
+    /* set Physical param set */
+#define DS_PARA_IE_ID   3
+#define DS_PARA_IE_LEN  1
+
+    adhs->PhyParamSet.DsParamSet.ElementId = DS_PARA_IE_ID;
+    adhs->PhyParamSet.DsParamSet.Len = DS_PARA_IE_LEN;
+    if (Adapter->adhoc_start_band == BAND_A)
+        Adapter->AdhocChannel = wlan_11h_get_adhoc_start_channel(priv);
+    Adapter->AdhocAutoSel = TRUE;
+    if (!get_cfp_by_band_and_channel
+        (Adapter->adhoc_start_band, (u16) Adapter->AdhocChannel,
+         Adapter->region_channel)) {
+        CHANNEL_FREQ_POWER *cfp;
+        cfp = get_cfp_by_band_and_channel(Adapter->adhoc_start_band,
+                                          FIRST_VALID_CHANNEL,
+                                          Adapter->region_channel);
+        if (cfp)
+            Adapter->AdhocChannel = cfp->Channel;
+    }
+
+    ASSERT(Adapter->AdhocChannel);
+
+    PRINTM(INFO, "ADHOC_S_CMD: Creating ADHOC on Channel %d\n",
+           Adapter->AdhocChannel);
+
+    Adapter->CurBssParams.BSSDescriptor.Channel = Adapter->AdhocChannel;
+    Adapter->CurBssParams.band = Adapter->adhoc_start_band;
+
+    pBSSDesc->Channel = Adapter->AdhocChannel;
+    adhs->PhyParamSet.DsParamSet.CurrentChan = Adapter->AdhocChannel;
+
+    memcpy(&pBSSDesc->PhyParamSet,
+           &adhs->PhyParamSet, sizeof(IEEEtypes_PhyParamSet_t));
+
+    pBSSDesc->NetworkTypeInUse = Wlan802_11DS;
+
+    /* set IBSS param set */
+#define IBSS_PARA_IE_ID   6
+#define IBSS_PARA_IE_LEN  2
+
+    adhs->SsParamSet.IbssParamSet.ElementId = IBSS_PARA_IE_ID;
+    adhs->SsParamSet.IbssParamSet.Len = IBSS_PARA_IE_LEN;
+    adhs->SsParamSet.IbssParamSet.AtimWindow
+        = wlan_cpu_to_le16(Adapter->AtimWindow);
+    pBSSDesc->ATIMWindow = Adapter->AtimWindow;
+    memcpy(&pBSSDesc->SsParamSet,
+           &adhs->SsParamSet, sizeof(IEEEtypes_SsParamSet_t));
+
+    /* set Capability info */
+    adhs->Cap.Ess = 0;
+    adhs->Cap.Ibss = 1;
+    pBSSDesc->Cap.Ibss = 1;
+
+    /* set up privacy in pBSSDesc */
+    if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled
+        || Adapter->AdhocAESEnabled || Adapter->SecInfo.WPAEnabled) {
+
+#define AD_HOC_CAP_PRIVACY_ON 1
+        PRINTM(INFO, "ADHOC_S_CMD: WEPStatus set, Privacy to WEP\n");
+        pBSSDesc->Privacy = Wlan802_11PrivFilter8021xWEP;
+        adhs->Cap.Privacy = AD_HOC_CAP_PRIVACY_ON;
+    } else {
+        PRINTM(INFO, "ADHOC_S_CMD: WEPStatus NOT set, Setting "
+               "Privacy to ACCEPT ALL\n");
+        pBSSDesc->Privacy = Wlan802_11PrivFilterAcceptAll;
+    }
+
+    memset(adhs->DataRate, 0, sizeof(adhs->DataRate));
+
+    if (Adapter->adhoc_start_band == BAND_A) {
+        memcpy(adhs->DataRate, AdhocRates_A,
+               MIN(sizeof(adhs->DataRate), sizeof(AdhocRates_A)));
+    } else if (Adapter->adhoc_start_band == BAND_G ||
+               Adapter->adhoc_grate_enabled == TRUE) {
+        memcpy(adhs->DataRate, AdhocRates_G,
+               MIN(sizeof(adhs->DataRate), sizeof(AdhocRates_G)));
+        if (Adapter->
+            CurrentPacketFilter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON) {
+            ret =
+                wlan_prepare_cmd(priv, HostCmd_CMD_MAC_CONTROL, 0,
+                                 HostCmd_OPTION_WAITFORRSP, 0,
+                                 &Adapter->CurrentPacketFilter);
+            if (ret) {
+                PRINTM(INFO, "ADHOC_S_CMD: G Protection config failed\n");
+                ret = WLAN_STATUS_FAILURE;
+                goto done;
+            }
+        }
+    } else if (Adapter->adhoc_start_band == BAND_B) {
+        memcpy(adhs->DataRate, AdhocRates_B,
+               MIN(sizeof(adhs->DataRate), sizeof(AdhocRates_B)));
+    }
+
+    /* Find the last non zero */
+    for (i = 0; i < sizeof(adhs->DataRate) && adhs->DataRate[i]; i++);
+
+    Adapter->CurBssParams.NumOfRates = i;
+
+    /* Copy the ad-hoc creating rates into Current BSS state structure */
+    memcpy(&Adapter->CurBssParams.DataRates,
+           &adhs->DataRate, Adapter->CurBssParams.NumOfRates);
+
+    PRINTM(INFO, "ADHOC_S_CMD: Rates=%02x %02x %02x %02x \n",
+           adhs->DataRate[0], adhs->DataRate[1],
+           adhs->DataRate[2], adhs->DataRate[3]);
+
+    PRINTM(INFO, "ADHOC_S_CMD: AD HOC Start command is ready\n");
+
+    if (Adapter->is_multiband) {
+        /* Append a channel TLV */
+        pChanTlv = (MrvlIEtypes_ChanListParamSet_t *) pos;
+        pChanTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_CHANLIST);
+        pChanTlv->Header.Len = wlan_cpu_to_le16(sizeof(ChanScanParamSet_t));
+
+        memset(pChanTlv->ChanScanParam, 0x00, sizeof(ChanScanParamSet_t));
+        pChanTlv->ChanScanParam[0].ChanNumber =
+            Adapter->CurBssParams.BSSDescriptor.Channel;
+
+        PRINTM(INFO, "ADHOC_S_CMD: TLV Chan = %d\n",
+               pChanTlv->ChanScanParam[0].ChanNumber);
+
+        pChanTlv->ChanScanParam[0].RadioType
+            = band_to_radio_type(Adapter->CurBssParams.band);
+
+        PRINTM(INFO, "ADHOC_S_CMD: TLV Band = %d\n",
+               pChanTlv->ChanScanParam[0].RadioType);
+        pos += sizeof(pChanTlv->Header) + sizeof(ChanScanParamSet_t);
+        cmdAppendSize +=
+            sizeof(pChanTlv->Header) + sizeof(ChanScanParamSet_t);
+    }
+
+    if (wlan_create_dnld_countryinfo_11d(priv)) {
+        PRINTM(INFO, "ADHOC_S_CMD: dnld_countryinfo_11d failed\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /*
+     * Call 11h start API to add any 11h flags/elements as TLV parameters
+     */
+    cmdAppendSize += wlan_11h_process_start(priv, &pos, &adhs->Cap,
+                                            Adapter->AdhocChannel,
+                                            &pBSSDesc->wlan_11h_bss_info);
+
+    if (Adapter->SecInfo.WPAEnabled) {
+        pRsnTlv = (MrvlIEtypes_RsnParamSet_t *) pos;
+        pRsnTlv->Header.Type = (u16) Adapter->Wpa_ie[0];        /* WPA_IE or WPA2_IE */
+        pRsnTlv->Header.Type = pRsnTlv->Header.Type & 0x00FF;
+        pRsnTlv->Header.Type = wlan_cpu_to_le16(pRsnTlv->Header.Type);
+        pRsnTlv->Header.Len = (u16) Adapter->Wpa_ie[1];
+        pRsnTlv->Header.Len = pRsnTlv->Header.Len & 0x00FF;
+        if (pRsnTlv->Header.Len <= (sizeof(Adapter->Wpa_ie) - 2)) {
+            memcpy(pRsnTlv->RsnIE, &Adapter->Wpa_ie[2], pRsnTlv->Header.Len);
+        } else {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        HEXDUMP("ADHOC_JOIN: RSN IE", (u8 *) pRsnTlv,
+                sizeof(pRsnTlv->Header) + pRsnTlv->Header.Len);
+        pos += sizeof(pRsnTlv->Header) + pRsnTlv->Header.Len;
+        cmdAppendSize += sizeof(pRsnTlv->Header) + pRsnTlv->Header.Len;
+        pRsnTlv->Header.Len = wlan_cpu_to_le16(pRsnTlv->Header.Len);
+    }
+
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_AD_HOC_START)
+                                 + S_DS_GEN + cmdAppendSize);
+
+    memcpy(&TmpCap, &adhs->Cap, sizeof(u16));
+    TmpCap = wlan_cpu_to_le16(TmpCap);
+    memcpy(&adhs->Cap, &TmpCap, sizeof(u16));
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function prepares command of ad_hoc_stop.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param cmd      A pointer to HostCmd_DS_COMMAND structure
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_ad_hoc_stop(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_STOP);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_AD_HOC_STOP)
+                                 + S_DS_GEN);
+
+    if (wlan_11h_is_active(priv)) {
+        wlan_11h_activate(priv, FALSE);
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of ad_hoc_join.
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param cmd       A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf Void cast of BSSDescriptor_t from the scan table to join
+ *
+ *  @return          WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_ad_hoc_join(wlan_private * priv,
+                            HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_AD_HOC_JOIN *pAdHocJoin = &cmd->params.adj;
+    BSSDescriptor_t *pBSSDesc = (BSSDescriptor_t *) pdata_buf;
+    int cmdAppendSize = 0;
+    int ret = WLAN_STATUS_SUCCESS;
+    WLAN_802_11_RATES rates;
+    int ratesSize;
+    u16 TmpCap;
+    u16 CurrentPacketFilter;
+    MrvlIEtypes_ChanListParamSet_t *pChanTlv;
+    MrvlIEtypes_RsnParamSet_t *pRsnTlv;
+    u8 *pos;
+    pos = (u8 *) pAdHocJoin + sizeof(HostCmd_DS_802_11_AD_HOC_JOIN);
+
+    ENTER();
+
+#define USE_G_PROTECTION	0x02
+    if (pBSSDesc->ERPFlags & USE_G_PROTECTION) {
+        CurrentPacketFilter =
+            Adapter->
+            CurrentPacketFilter | HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON;
+        ret =
+            wlan_prepare_cmd(priv, HostCmd_CMD_MAC_CONTROL, 0,
+                             HostCmd_OPTION_WAITFORRSP, 0,
+                             &CurrentPacketFilter);
+        if (ret) {
+            PRINTM(INFO, "ADHOC_S_CMD: G Protection config failed\n");
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+    }
+    Adapter->pAttemptedBSSDesc = pBSSDesc;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_JOIN);
+
+    pAdHocJoin->BssDescriptor.BSSType = HostCmd_BSS_TYPE_IBSS;
+
+    pAdHocJoin->BssDescriptor.BeaconPeriod
+        = wlan_cpu_to_le16(pBSSDesc->BeaconPeriod);
+
+    memcpy(&pAdHocJoin->BssDescriptor.BSSID, &pBSSDesc->MacAddress, ETH_ALEN);
+
+    memcpy(&pAdHocJoin->BssDescriptor.SSID,
+           &pBSSDesc->Ssid.Ssid, pBSSDesc->Ssid.SsidLength);
+
+    memcpy(&pAdHocJoin->BssDescriptor.PhyParamSet,
+           &pBSSDesc->PhyParamSet, sizeof(IEEEtypes_PhyParamSet_t));
+
+    memcpy(&pAdHocJoin->BssDescriptor.SsParamSet,
+           &pBSSDesc->SsParamSet, sizeof(IEEEtypes_SsParamSet_t));
+
+    memcpy(&TmpCap, &pBSSDesc->Cap, sizeof(IEEEtypes_CapInfo_t));
+
+    TmpCap &= CAPINFO_MASK;
+
+    PRINTM(INFO, "ADHOC_J_CMD: TmpCap=%4X CAPINFO_MASK=%4X\n",
+           TmpCap, CAPINFO_MASK);
+    memcpy(&pAdHocJoin->BssDescriptor.Cap, &TmpCap,
+           sizeof(IEEEtypes_CapInfo_t));
+
+    /* information on BSSID descriptor passed to FW */
+    PRINTM(INFO,
+           "ADHOC_J_CMD: BSSID = %02x-%02x-%02x-%02x-%02x-%02x, SSID = %s\n",
+           pAdHocJoin->BssDescriptor.BSSID[0],
+           pAdHocJoin->BssDescriptor.BSSID[1],
+           pAdHocJoin->BssDescriptor.BSSID[2],
+           pAdHocJoin->BssDescriptor.BSSID[3],
+           pAdHocJoin->BssDescriptor.BSSID[4],
+           pAdHocJoin->BssDescriptor.BSSID[5],
+           pAdHocJoin->BssDescriptor.SSID);
+
+    /* Get the common rates supported between the driver and the BSS Desc */
+    if (setup_rates_from_bssdesc(Adapter, pBSSDesc, rates, &ratesSize)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Copy Data Rates from the Rates recorded in scan response */
+    memset(pAdHocJoin->BssDescriptor.DataRates, 0,
+           sizeof(pAdHocJoin->BssDescriptor.DataRates));
+    memcpy(pAdHocJoin->BssDescriptor.DataRates, rates, ratesSize);
+
+    /* Copy the adhoc join rates into Current BSS state structure */
+    Adapter->CurBssParams.NumOfRates = ratesSize;
+    memcpy(&Adapter->CurBssParams.DataRates, rates, ratesSize);
+
+    /* Copy the channel information */
+    Adapter->CurBssParams.BSSDescriptor.Channel = pBSSDesc->Channel;
+    Adapter->CurBssParams.band = pBSSDesc->bss_band;
+
+    if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled
+        || Adapter->AdhocAESEnabled) {
+        pAdHocJoin->BssDescriptor.Cap.Privacy = AD_HOC_CAP_PRIVACY_ON;
+    }
+
+    if (Adapter->PSMode == Wlan802_11PowerModeMAX_PSP) {
+        /* wake up first */
+        WLAN_802_11_POWER_MODE LocalPSMode;
+
+        LocalPSMode = Wlan802_11PowerModeCAM;
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_PS_MODE,
+                               HostCmd_ACT_GEN_SET, 0, 0, &LocalPSMode);
+
+        if (ret) {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+    }
+
+    if (Adapter->is_multiband) {
+        /* Append a channel TLV */
+        pChanTlv = (MrvlIEtypes_ChanListParamSet_t *) pos;
+        pChanTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_CHANLIST);
+        pChanTlv->Header.Len = wlan_cpu_to_le16(sizeof(ChanScanParamSet_t));
+
+        memset(pChanTlv->ChanScanParam, 0x00, sizeof(ChanScanParamSet_t));
+        pChanTlv->ChanScanParam[0].ChanNumber =
+            (pBSSDesc->PhyParamSet.DsParamSet.CurrentChan);
+        PRINTM(INFO, "ADHOC_J_CMD: TLV Chan = %d\n",
+               pChanTlv->ChanScanParam[0].ChanNumber);
+
+        pChanTlv->ChanScanParam[0].RadioType
+            = band_to_radio_type(pBSSDesc->bss_band);
+
+        PRINTM(INFO, "ADHOC_J_CMD: TLV Band = %d\n",
+               pChanTlv->ChanScanParam[0].RadioType);
+        pos += sizeof(pChanTlv->Header) + sizeof(ChanScanParamSet_t);
+        cmdAppendSize +=
+            sizeof(pChanTlv->Header) + sizeof(ChanScanParamSet_t);
+    }
+
+    if (wlan_parse_dnld_countryinfo_11d(priv)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /*
+     * Call 11h join API after capability bits are set so
+     *   adhoc/infra 11h behavior can be properly triggered.
+     *   pos modified if data is appended
+     */
+    cmdAppendSize += wlan_11h_process_join(priv, &pos,
+                                           &pAdHocJoin->BssDescriptor.Cap,
+                                           pBSSDesc->Channel,
+                                           &pBSSDesc->wlan_11h_bss_info);
+
+    if (Adapter->SecInfo.WPAEnabled) {
+        pRsnTlv = (MrvlIEtypes_RsnParamSet_t *) pos;
+        pRsnTlv->Header.Type = (u16) Adapter->Wpa_ie[0];        /* WPA_IE or WPA2_IE */
+        pRsnTlv->Header.Type = pRsnTlv->Header.Type & 0x00FF;
+        pRsnTlv->Header.Type = wlan_cpu_to_le16(pRsnTlv->Header.Type);
+        pRsnTlv->Header.Len = (u16) Adapter->Wpa_ie[1];
+        pRsnTlv->Header.Len = pRsnTlv->Header.Len & 0x00FF;
+        if (pRsnTlv->Header.Len <= (sizeof(Adapter->Wpa_ie) - 2)) {
+            memcpy(pRsnTlv->RsnIE, &Adapter->Wpa_ie[2], pRsnTlv->Header.Len);
+        } else {
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        HEXDUMP("ADHOC_JOIN: RSN IE", (u8 *) pRsnTlv,
+                sizeof(pRsnTlv->Header) + pRsnTlv->Header.Len);
+        pos += sizeof(pRsnTlv->Header) + pRsnTlv->Header.Len;
+        cmdAppendSize += sizeof(pRsnTlv->Header) + pRsnTlv->Header.Len;
+        pRsnTlv->Header.Len = wlan_cpu_to_le16(pRsnTlv->Header.Len);
+    }
+
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_AD_HOC_JOIN)
+                                 + S_DS_GEN + cmdAppendSize);
+
+    memcpy(&TmpCap, &pAdHocJoin->BssDescriptor.Cap,
+           sizeof(IEEEtypes_CapInfo_t));
+    TmpCap = wlan_cpu_to_le16(TmpCap);
+
+    memcpy(&pAdHocJoin->BssDescriptor.Cap,
+           &TmpCap, sizeof(IEEEtypes_CapInfo_t));
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Association firmware command response handler
+ *
+ *   The response buffer for the association command has the following
+ *      memory layout.
+ *
+ *   For cases where an association response was not received (indicated
+ *      by the CapInfo and AId field):
+ *
+ *     .------------------------------------------------------------.
+ *     |  Header(4 * sizeof(u16)):  Standard command response hdr   |
+ *     .------------------------------------------------------------.
+ *     |  CapInfo/Error Return(u16):                                |
+ *     |           0xFFFF(-1): Internal error                       |
+ *     |           0xFFFE(-2): Authentication unhandled message     |
+ *     |           0xFFFD(-3): Authentication refused               |
+ *     |           0xFFFC(-4): Timeout waiting for AP response      |
+ *     .------------------------------------------------------------.
+ *     |  StatusCode(u16):                                          |
+ *     |        If CapInfo is -1:                                   |
+ *     |           An internal firmware failure prevented the       |
+ *     |           command from being processed.  The StatusCode    |
+ *     |           will be set to 1.                                |
+ *     |                                                            |
+ *     |        If CapInfo is -2:                                   |
+ *     |           An authentication frame was received but was     |
+ *     |           not handled by the firmware.  IEEE Status        |
+ *     |           code for the failure is returned.                |
+ *     |                                                            |
+ *     |        If CapInfo is -3:                                   |
+ *     |           An authentication frame was received and the     |
+ *     |           StatusCode is the IEEE Status reported in the    |
+ *     |           response.                                        |
+ *     |                                                            |
+ *     |        If CapInfo is -4:                                   |
+ *     |           (1) Association response timeout                 |
+ *     |           (2) Authentication response timeout              |
+ *     .------------------------------------------------------------.
+ *     |  AId(u16): 0xFFFF                                          |
+ *     .------------------------------------------------------------.
+ *
+ *
+ *   For cases where an association response was received, the IEEE 
+ *     standard association response frame is returned:
+ *
+ *     .------------------------------------------------------------.
+ *     |  Header(4 * sizeof(u16)):  Standard command response hdr   |
+ *     .------------------------------------------------------------.
+ *     |  CapInfo(u16): IEEE Capability                             |
+ *     .------------------------------------------------------------.
+ *     |  StatusCode(u16): IEEE Status Code                         |
+ *     .------------------------------------------------------------.
+ *     |  AId(u16): IEEE Association ID                             |
+ *     .------------------------------------------------------------.
+ *     |  IEEE IEs(variable): Any received IEs comprising the       |
+ *     |                      remaining portion of a received       |
+ *     |                      association response frame.           |
+ *     .------------------------------------------------------------.
+ *
+ *  For simplistic handling, the StatusCode field can be used to determine
+ *    an association success (0) or failure (non-zero).
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_associate(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    IEEEtypes_AssocRsp_t *pAssocRsp;
+    BSSDescriptor_t *pBSSDesc;
+    WLAN_802_11_RATES rates;
+    int ratesSize;
+
+    ENTER();
+
+    pAssocRsp = (IEEEtypes_AssocRsp_t *) & resp->params;
+
+    HEXDUMP("ASSOC_RESP:", (void *) &resp->params,
+            wlan_le16_to_cpu(resp->Size) - S_DS_GEN);
+
+    Adapter->assocRspSize = MIN(wlan_le16_to_cpu(resp->Size) - S_DS_GEN,
+                                sizeof(Adapter->assocRspBuffer));
+
+    memcpy(Adapter->assocRspBuffer, &resp->params, Adapter->assocRspSize);
+
+    if (pAssocRsp->StatusCode) {
+        priv->adapter->dbg.num_cmd_assoc_failure++;
+        PRINTM(CMND, "ASSOC_RESP: Association Failed, "
+               "status code = %d, error = %d\n",
+               pAssocRsp->StatusCode, *(short *) &pAssocRsp->Capability);
+
+        ret = WLAN_STATUS_FAILURE;
+
+        goto done;
+    }
+
+    /* Send a Media Connected event, according to the Spec */
+    Adapter->MediaConnectStatus = WlanMediaStateConnected;
+
+    /* Set the attempted BSSID Index to current */
+    pBSSDesc = Adapter->pAttemptedBSSDesc;
+
+    PRINTM(INFO, "ASSOC_RESP: %s\n", pBSSDesc->Ssid.Ssid);
+
+    /* Make a copy of current BSSID descriptor */
+    memcpy(&Adapter->CurBssParams.BSSDescriptor,
+           pBSSDesc, sizeof(BSSDescriptor_t));
+
+    /* update CurBssParams */
+    Adapter->CurBssParams.BSSDescriptor.Channel
+        = pBSSDesc->PhyParamSet.DsParamSet.CurrentChan;
+    Adapter->CurBssParams.band = pBSSDesc->bss_band;
+
+    if (setup_rates_from_bssdesc(Adapter, pBSSDesc, rates, &ratesSize)) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Copy the infra. association rates into Current BSS state structure */
+    Adapter->CurBssParams.NumOfRates = ratesSize;
+    memcpy(&Adapter->CurBssParams.DataRates, rates, ratesSize);
+
+    /* Adjust the timestamps in the scan table to be relative to the newly
+     *   associated AP's TSF
+     */
+    wlan_scan_update_tsf_timestamps(priv, pBSSDesc);
+
+    if (pBSSDesc->wmmIE.VendHdr.ElementId == WMM_IE) {
+        Adapter->CurBssParams.wmm_enabled = TRUE;
+    } else {
+        Adapter->CurBssParams.wmm_enabled = FALSE;
+    }
+
+    if (Adapter->wmm.required && Adapter->CurBssParams.wmm_enabled) {
+        Adapter->wmm.enabled = TRUE;
+    } else {
+        Adapter->wmm.enabled = FALSE;
+    }
+
+    Adapter->CurBssParams.wmm_uapsd_enabled = FALSE;
+
+    if (Adapter->wmm.enabled == TRUE) {
+        Adapter->CurBssParams.wmm_uapsd_enabled
+            = pBSSDesc->wmmIE.QoSInfo.QosUAPSD;
+    }
+
+    PRINTM(INFO, "ASSOC_RESP: CurrentPacketFilter is %x\n",
+           Adapter->CurrentPacketFilter);
+
+    if (Adapter->SecInfo.WPAEnabled || Adapter->SecInfo.WPA2Enabled)
+        Adapter->IsGTK_SET = FALSE;
+
+    Adapter->SNR[TYPE_RXPD][TYPE_AVG] = 0;
+    Adapter->NF[TYPE_RXPD][TYPE_AVG] = 0;
+
+    memset(Adapter->rawSNR, 0x00, sizeof(Adapter->rawSNR));
+    memset(Adapter->rawNF, 0x00, sizeof(Adapter->rawNF));
+    Adapter->nextSNRNF = 0;
+    Adapter->numSNRNF = 0;
+
+    priv->adapter->dbg.num_cmd_assoc_success++;
+    PRINTM(INFO, "ASSOC_RESP: Associated \n");
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function handles the command response of deauthenticate
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_deauthenticate(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    Adapter->dbg.num_cmd_deauth++;
+    if (memcmp(resp->params.deauth.MacAddr,
+               &Adapter->CurBssParams.BSSDescriptor.MacAddress,
+               sizeof(resp->params.deauth.MacAddr)) == 0) {
+        wlan_reset_connect_state(priv);
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of ad_hoc_start and
+ *  ad_hoc_join
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_ad_hoc(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 Command = resp->Command;
+    u16 Result = resp->Result;
+    HostCmd_DS_802_11_AD_HOC_RESULT *pAdHocResult;
+    union iwreq_data wrqu;
+    BSSDescriptor_t *pBSSDesc;
+
+    ENTER();
+
+    pAdHocResult = &resp->params.result;
+
+    pBSSDesc = Adapter->pAttemptedBSSDesc;
+
+    /*
+     * Join result code 0 --> SUCCESS
+     */
+    if (Result) {
+        PRINTM(INFO, "ADHOC_RESP Failed\n");
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            wlan_reset_connect_state(priv);
+        }
+
+        memset(&Adapter->CurBssParams.BSSDescriptor,
+               0x00, sizeof(Adapter->CurBssParams.BSSDescriptor));
+
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /* Send a Media Connected event, according to the Spec */
+    Adapter->MediaConnectStatus = WlanMediaStateConnected;
+
+    if (Command == HostCmd_CMD_802_11_AD_HOC_START) {
+        PRINTM(INFO, "ADHOC_S_RESP  %s\n", pBSSDesc->Ssid.Ssid);
+
+        /* Update the created network descriptor with the new BSSID */
+        memcpy(pBSSDesc->MacAddress, pAdHocResult->BSSID, ETH_ALEN);
+
+        Adapter->AdhocState = ADHOC_STARTED;
+    } else {
+        /*
+         * Now the join cmd should be successful
+         * If BSSID has changed use SSID to compare instead of BSSID
+         */
+        PRINTM(INFO, "ADHOC_J_RESP  %s\n", pBSSDesc->Ssid.Ssid);
+
+        /* Make a copy of current BSSID descriptor, only needed for join since
+         *   the current descriptor is already being used for adhoc start
+         */
+        memcpy(&Adapter->CurBssParams.BSSDescriptor,
+               pBSSDesc, sizeof(BSSDescriptor_t));
+
+        Adapter->AdhocState = ADHOC_JOINED;
+    }
+
+    memset(&wrqu, 0, sizeof(wrqu));
+    memcpy(wrqu.ap_addr.sa_data,
+           &Adapter->CurBssParams.BSSDescriptor.MacAddress, ETH_ALEN);
+    wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+
+    PRINTM(INFO, "ADHOC_RESP: Channel = %d\n", Adapter->AdhocChannel);
+    PRINTM(INFO, "ADHOC_RESP: BSSID = %02x:%02x:%02x:%02x:%02x:%02x\n",
+           Adapter->CurBssParams.BSSDescriptor.MacAddress[0],
+           Adapter->CurBssParams.BSSDescriptor.MacAddress[1],
+           Adapter->CurBssParams.BSSDescriptor.MacAddress[2],
+           Adapter->CurBssParams.BSSDescriptor.MacAddress[3],
+           Adapter->CurBssParams.BSSDescriptor.MacAddress[4],
+           Adapter->CurBssParams.BSSDescriptor.MacAddress[5]);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function handles the command response of ad_hoc_stop
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_ad_hoc_stop(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    ENTER();
+
+    wlan_reset_connect_state(priv);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+#ifdef REASSOCIATION
+/**
+ *  @brief This function handles re-association. it is triggered
+ *  by re-assoc timer.
+ *
+ *  @param data    A pointer to wlan_thread structure
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+int
+wlan_reassociation_thread(void *data)
+{
+    wlan_thread *thread = data;
+    wlan_private *priv = thread->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    wait_queue_t wait;
+    int i;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    wlan_activate_thread(thread);
+    init_waitqueue_entry(&wait, current);
+
+    current->flags |= PF_NOFREEZE;
+
+    for (;;) {
+        add_wait_queue(&thread->waitQ, &wait);
+        OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
+
+        PRINTM(INFO, "Reassoc: Thread sleeping...\n");
+
+        schedule();
+
+        OS_SET_THREAD_STATE(TASK_RUNNING);
+        remove_wait_queue(&thread->waitQ, &wait);
+
+        if (Adapter->SurpriseRemoved) {
+            break;
+        }
+
+        if (kthread_should_stop()) {
+            break;
+        }
+
+        PRINTM(INFO, "Reassoc: Thread waking up...\n");
+
+        if (Adapter->InfrastructureMode != Wlan802_11Infrastructure ||
+            Adapter->HardwareStatus != WlanHardwareStatusReady) {
+            PRINTM(MSG, "Reassoc: mode or hardware status is not correct\n");
+            continue;
+        }
+
+        /* The semaphore is used to avoid reassociation thread and 
+           wlan_set_scan/wlan_set_essid interrupting each other.
+           Reassociation should be disabled completely by application if 
+           wlan_set_user_scan_ioctl/wlan_set_wap is used.
+         */
+        if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+            PRINTM(ERROR, "Acquire semaphore error, reassociation thread\n");
+            goto settimer;
+        }
+
+        if (Adapter->MediaConnectStatus != WlanMediaStateDisconnected) {
+            OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+            PRINTM(MSG, "Reassoc: Adapter->MediaConnectStatus is wrong\n");
+            continue;
+        }
+
+        PRINTM(INFO, "Reassoc: Required ESSID: %s\n",
+               Adapter->PreviousSSID.Ssid);
+
+        PRINTM(INFO, "Reassoc: Performing Active Scan @ %lu\n",
+               os_time_get());
+        wlan_cmd_specific_scan_ssid(priv, &Adapter->PreviousSSID);
+        if (Adapter->SurpriseRemoved)
+            break;
+        i = wlan_find_ssid_in_list(Adapter,
+                                   &Adapter->PreviousSSID,
+                                   Adapter->PreviousBSSID,
+                                   Adapter->InfrastructureMode);
+
+        if (i < 0) {
+            /* If the SSID could not be found, try just the SSID */
+            i = wlan_find_ssid_in_list(Adapter,
+                                       &Adapter->PreviousSSID,
+                                       NULL, Adapter->InfrastructureMode);
+        }
+
+        if (i >= 0) {
+            if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled) {
+                ret = wlan_prepare_cmd(priv,
+                                       HostCmd_CMD_802_11_SET_WEP,
+                                       HostCmd_ACT_ADD,
+                                       HostCmd_OPTION_WAITFORRSP, 0, NULL);
+                if (ret)
+                    PRINTM(INFO, "Ressoc: Fail to set WEP KEY\n");
+            }
+            wlan_associate(priv, &Adapter->ScanTable[i]);
+        }
+
+        OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+
+      settimer:
+        if (Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+            PRINTM(INFO, "Reassoc: No AP found or assoc failed."
+                   "Restarting re-assoc Timer @ %lu\n", os_time_get());
+
+            Adapter->ReassocTimerIsSet = TRUE;
+            wlan_mod_timer(&Adapter->MrvDrvTimer, MRVDRV_TIMER_10S);
+        }
+    }
+
+    wlan_deactivate_thread(thread);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function triggers re-association by waking up
+ *  re-assoc thread.
+ *  
+ *  @param FunctionContext    A pointer to FunctionContext
+ *  @return 	   n/a
+ */
+void
+wlan_reassoc_timer_func(void *FunctionContext)
+{
+    wlan_private *priv = (wlan_private *) FunctionContext;
+    wlan_adapter *Adapter = priv->adapter;
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    PRINTM(INFO, "MrvDrvReassocTimer fired.\n");
+    Adapter->ReassocTimerIsSet = FALSE;
+    if (Adapter->PSState != PS_STATE_FULL_POWER) {
+        /* wait until Exit_PS command returns */
+        Adapter->ReassocTimerIsSet = TRUE;
+        wlan_mod_timer(&Adapter->MrvDrvTimer, MRVDRV_TIMER_1S);
+        PRINTM(INFO, "MrvDrvTimerFunction(PSState=%d) waiting"
+               "for Exit_PS done\n", Adapter->PSState);
+        LEAVE();
+        return;
+    }
+
+    PRINTM(INFO, "Waking Up the Reassoc Thread\n");
+
+    wake_up_interruptible(&priv->ReassocThread.waitQ);
+
+    LEAVE();
+    return;
+}
+#endif /* REASSOCIATION */
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_join.h b/drivers/net/wireless/8688_wlan/wlan/wlan_join.h
new file mode 100755
index 0000000..cf6c277
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_join.h
@@ -0,0 +1,94 @@
+/** @file wlan_join.h
+ *
+ *  @brief Interface for the wlan infrastructure and adhoc join routines
+ *
+ *  Driver interface functions and type declarations for the join module
+ *    implemented in wlan_join.c.  Process all start/join requests for
+ *    both adhoc and infrastructure networks
+ *    
+ *  (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *     
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change Log:
+    01/11/06: Initial revision. Match new scan code, relocate related functions
+
+************************************************************/
+
+#ifndef _WLAN_JOIN_H
+#define _WLAN_JOIN_H
+
+//! Size of buffer allocated to store the association response from firmware
+#define MRVDRV_ASSOC_RSP_BUF_SIZE  500
+
+//! Size of buffer allocated to store IEs passed to firmware in the assoc req
+#define MRVDRV_GENIE_BUF_SIZE      256
+
+//! Size of buffer allocated to store TLVs passed to firmware in the assoc req
+#define MRVDRV_ASSOC_TLV_BUF_SIZE  256
+
+extern int wlan_cmd_802_11_authenticate(wlan_private * priv,
+                                        HostCmd_DS_COMMAND * cmd,
+                                        void *pdata_buf);
+extern int wlan_cmd_802_11_ad_hoc_join(wlan_private * priv,
+                                       HostCmd_DS_COMMAND * cmd,
+                                       void *pdata_buf);
+extern int wlan_cmd_802_11_ad_hoc_stop(wlan_private * priv,
+                                       HostCmd_DS_COMMAND * cmd);
+extern int wlan_cmd_802_11_ad_hoc_start(wlan_private * priv,
+                                        HostCmd_DS_COMMAND * cmd,
+                                        void *pssid);
+extern int wlan_cmd_802_11_deauthenticate(wlan_private * priv,
+                                          HostCmd_DS_COMMAND * cmd,
+                                          void *pdata_buf);
+extern int wlan_cmd_802_11_associate(wlan_private * priv,
+                                     HostCmd_DS_COMMAND * cmd,
+                                     void *pdata_buf);
+extern int wlan_ret_802_11_authenticate(wlan_private * priv,
+                                        HostCmd_DS_COMMAND * resp);
+extern int wlan_ret_802_11_ad_hoc(wlan_private * priv,
+                                  HostCmd_DS_COMMAND * resp);
+extern int wlan_ret_802_11_ad_hoc_stop(wlan_private * priv,
+                                       HostCmd_DS_COMMAND * resp);
+extern int wlan_ret_802_11_deauthenticate(wlan_private * priv,
+                                          HostCmd_DS_COMMAND * resp);
+extern int wlan_ret_802_11_associate(wlan_private * priv,
+                                     HostCmd_DS_COMMAND * resp);
+
+extern int wlan_associate(wlan_private * priv, BSSDescriptor_t * pBSSDesc);
+extern int wlan_associate_to_table_idx(wlan_private * priv, int tableIdx);
+
+extern int wlanidle_on(wlan_private * priv);
+extern int wlanidle_off(wlan_private * priv);
+
+extern int wlan_do_adhocstop_ioctl(wlan_private * priv);
+extern int wlan_reassociation_thread(void *data);
+
+extern int wlan_start_adhoc(wlan_private * priv,
+                            WLAN_802_11_SSID * AdhocSSID);
+extern int wlan_join_adhoc(wlan_private * priv, BSSDescriptor_t * pBSSDesc);
+extern int wlan_disconnect(wlan_private * priv);
+
+extern int wlan_do_adhocstop_ioctl(wlan_private * priv);
+extern int wlan_get_assoc_rsp_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_set_mrvl_tlv_ioctl(wlan_private * priv, struct iwreq *wrq);
+
+#ifdef __KERNEL__
+extern int wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
+                        struct sockaddr *awrq, char *extra);
+#endif
+
+#endif
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_linux.h b/drivers/net/wireless/8688_wlan/wlan/wlan_linux.h
new file mode 100755
index 0000000..06c68bf
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_linux.h
@@ -0,0 +1,464 @@
+/** @file wlan_linux.h
+ *  @brief This file contains Linux OS related definitions and declarations
+ *     
+ * (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change log:
+	05/30/07: Initial creation
+********************************************************/
+
+#ifndef _WLAN_LINUX_H
+#define _WLAN_LINUX_H
+
+/** True */
+#ifndef	TRUE
+#define TRUE			1
+#endif
+/** False */
+#ifndef	FALSE
+#define	FALSE			0
+#endif
+
+/** Bit definitions */
+#define BIT(x)	(1 << (x))
+
+#ifndef __KERNEL__
+/** Character, 1 byte */
+typedef char s8;
+/** Unsigned character, 1 byte */
+typedef unsigned char u8;
+
+/** Short integer */
+typedef signed short s16;
+/** Unsigned short integer */
+typedef unsigned short u16;
+
+/** Long integer */
+typedef signed long s32;
+/** Unsigned long ineteger */
+typedef unsigned long u32;
+
+/** Long long integer */
+typedef signed long long s64;
+/** Unsigned long long integer */
+typedef unsigned long long u64;
+
+/** Unsigned long integer */
+typedef u32 dma_addr_t;
+/** Unsigned long integer */
+typedef u32 dma64_addr_t;
+#endif
+
+/* Dma addresses are 32-bits wide.  */
+#ifndef __ATTRIB_ALIGN__
+#define __ATTRIB_ALIGN__ __attribute__((aligned(4)))
+#endif
+
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__ __attribute__ ((packed))
+#endif
+
+/** Debug Macro definition*/
+#ifdef	DEBUG_LEVEL1
+
+extern u32 drvdbg;
+extern u32 ifdbg;
+
+/* Debug message control bit definition for drvdbg */
+#define	DBG_MSG		BIT(0)
+#define DBG_FATAL	BIT(1)
+#define DBG_ERROR	BIT(2)
+#define DBG_DATA	BIT(3)
+#define DBG_CMND	BIT(4)
+#define DBG_EVENT	BIT(5)
+#define DBG_INTR	BIT(6)
+
+#define DBG_DAT_D	BIT(16)
+#define DBG_CMD_D	BIT(17)
+#define DBG_FW_D	BIT(18)
+
+#define DBG_ENTRY	BIT(28)
+#define DBG_WARN	BIT(29)
+#define DBG_INFO	BIT(30)
+
+/* Debug message control bit definition for ifdbg */
+#define DBG_IF_D	BIT(0)
+
+#ifdef	DEBUG_LEVEL2
+#define	PRINTM_INFO(msg...)  {if (drvdbg & DBG_INFO) printk(KERN_DEBUG msg);}
+#define	PRINTM_WARN(msg...)  {if (drvdbg & DBG_WARN) printk(KERN_DEBUG msg);}
+#define	PRINTM_ENTRY(msg...) {if (drvdbg & DBG_ENTRY) printk(KERN_DEBUG msg);}
+#else
+#define	PRINTM_INFO(msg...)  do {} while (0)
+#define	PRINTM_WARN(msg...)  do {} while (0)
+#define	PRINTM_ENTRY(msg...) do {} while (0)
+#endif /* DEBUG_LEVEL2 */
+
+#define	PRINTM_FW_D(msg...)  {if (drvdbg & DBG_FW_D) printk(KERN_DEBUG msg);}
+#define	PRINTM_CMD_D(msg...) {if (drvdbg & DBG_CMD_D) printk(KERN_DEBUG msg);}
+#define	PRINTM_DAT_D(msg...) {if (drvdbg & DBG_DAT_D) printk(KERN_DEBUG msg);}
+
+#define	PRINTM_INTR(msg...)  {if (drvdbg & DBG_INTR) printk(KERN_DEBUG msg);}
+#define	PRINTM_EVENT(msg...) {if (drvdbg & DBG_EVENT) printk(msg);}
+#define	PRINTM_CMND(msg...)  {if (drvdbg & DBG_CMND) printk(KERN_DEBUG msg);}
+#define	PRINTM_DATA(msg...)  {if (drvdbg & DBG_DATA) printk(KERN_DEBUG msg);}
+#define	PRINTM_ERROR(msg...) {if (drvdbg & DBG_ERROR) printk(KERN_DEBUG msg);}
+#define	PRINTM_FATAL(msg...) {if (drvdbg & DBG_FATAL) printk(KERN_DEBUG msg);}
+#define	PRINTM_MSG(msg...)   {if (drvdbg & DBG_MSG) printk(KERN_ALERT msg);}
+
+#define	PRINTM_IF_D(msg...)  {if (ifdbg & DBG_IF_D) printk(KERN_DEBUG msg);}
+
+#define	PRINTM(level,msg...) PRINTM_##level(msg)
+
+#else
+
+#define	PRINTM(level,msg...) do {} while (0)
+
+#endif /* DEBUG_LEVEL1 */
+
+/** Wait until a condition becomes true */
+#define ASSERT(cond)						\
+do {								\
+	if (!(cond))						\
+		PRINTM(INFO, "ASSERT: %s, %s:%i\n",		\
+		       __FUNCTION__, __FILE__, __LINE__);	\
+} while(0)
+
+/** Log enrty point for debugging */
+#define	ENTER()			PRINTM(ENTRY, "Enter: %s, %s:%i\n", __FUNCTION__, \
+							__FILE__, __LINE__)
+/** Log exit point for debugging */
+#define	LEAVE()			PRINTM(ENTRY, "Leave: %s, %s:%i\n", __FUNCTION__, \
+							__FILE__, __LINE__)
+
+#if defined(DEBUG_LEVEL1) && defined(__KERNEL__)
+#define DBG_DUMP_BUF_LEN 	64
+#define MAX_DUMP_PER_LINE	16
+#define MAX_DATA_DUMP_LEN	48
+
+static inline void
+hexdump(char *prompt, u8 * buf, int len)
+{
+    int i;
+    char dbgdumpbuf[DBG_DUMP_BUF_LEN];
+    char *ptr = dbgdumpbuf;
+
+    printk(KERN_DEBUG "%s:\n", prompt);
+    for (i = 1; i <= len; i++) {
+        ptr += sprintf(ptr, "%02x ", *buf);
+        buf++;
+        if (i % MAX_DUMP_PER_LINE == 0) {
+            *ptr = 0;
+            printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+            ptr = dbgdumpbuf;
+        }
+    }
+    if (len % MAX_DUMP_PER_LINE) {
+        *ptr = 0;
+        printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+    }
+}
+
+#define DBG_HEXDUMP_CMD_D(x,y,z)    {if (drvdbg & DBG_CMD_D) hexdump(x,y,z);}
+#define DBG_HEXDUMP_DAT_D(x,y,z)    {if (drvdbg & DBG_DAT_D) hexdump(x,y,z);}
+#define DBG_HEXDUMP_IF_D(x,y,z)     {if (ifdbg & DBG_IF_D) hexdump(x,y,z);}
+#define DBG_HEXDUMP_FW_D(x,y,z)     {if (drvdbg & DBG_FW_D) hexdump(x,y,z);}
+#define	DBG_HEXDUMP(level,x,y,z)    DBG_HEXDUMP_##level(x,y,z)
+
+#else
+/** Do nothing since debugging is not turned on */
+#define DBG_HEXDUMP(level,x,y,z)    do {} while (0)
+#endif
+
+#if defined(DEBUG_LEVEL2) && defined(__KERNEL__)
+#define HEXDUMP(x,y,z)              {if (drvdbg & DBG_INFO) hexdump(x,y,z);}
+#else
+/** Do nothing since debugging is not turned on */
+#define HEXDUMP(x,y,z)              do {} while (0)
+#endif
+
+/*
+ * Typedefs
+ */
+
+/** Long */
+typedef long LONG;
+/** Unsigned long long */
+typedef unsigned long long ULONGLONG;
+/** WLAN object ID as unsigned long */
+typedef u32 WLAN_OID;
+
+/** Char */
+typedef char CHAR;
+/** Pointer to a char */
+typedef char *PCHAR;
+/** Pointer to an unsigned char */
+typedef u8 *PUCHAR;
+/** Pointer to an unsigned short */
+typedef u16 *PUSHORT;
+/** Pointer to a long */
+typedef long *PLONG;
+/** Pointer to a long */
+typedef PLONG LONG_PTR;
+/** Pointer to an unsigned long */
+typedef u32 *ULONG_PTR;
+/** Pointer to an unsigned long */
+typedef u32 *Pu32;
+/** Unsigned int */
+typedef unsigned int UINT;
+/** Pointer to an unsigned int */
+typedef UINT *PUINT;
+/** Void */
+typedef void VOID;
+/** Void pointer */
+typedef VOID *PVOID;
+/** Wlan status as int */
+typedef int WLAN_STATUS;
+/** Unsigned char */
+typedef u8 BOOLEAN;
+/** Pointer to an unsigned char */
+typedef BOOLEAN *PBOOLEAN;
+/** Pointer to a driver object as a void pointer */
+typedef PVOID PDRIVER_OBJECT;
+/** Pointer to a unicoded string as pointer to an unsigned char */
+typedef PUCHAR PUNICODE_STRING;
+/** Long long */
+typedef long long LONGLONG;
+/** Pointer to a long long */
+typedef LONGLONG *PLONGLONG;
+/** Pointer to an unsigned long long */
+typedef unsigned long long *PULONGLONG;
+/** An ANSI string as pointer to an unsigned char */
+typedef PUCHAR ANSI_STRING;
+/** Pointer to an ANSI string as pointer to a pointer to an unsigned char */
+typedef ANSI_STRING *PANSI_STRING;
+/** Unsigned short */
+typedef unsigned short WCHAR;
+/** Pointer to an unsigned short */
+typedef WCHAR *PWCHAR;
+/** Pointer to an unsigned short */
+typedef WCHAR *LPWCH;
+/** Pointer to an unsigned short */
+typedef WCHAR *PWCH;
+/** Pointer to an unsigned short */
+typedef WCHAR *NWPSTR;
+/** Pointer to an unsigned short */
+typedef WCHAR *LPWSTR;
+/** Pointer to an unsigned short */
+typedef WCHAR *PWSTR;
+/** Semaphore structure */
+typedef struct semaphore SEMAPHORE;
+
+#ifdef __KERNEL__
+typedef irqreturn_t IRQ_RET_TYPE;
+#define IRQ_RET		return IRQ_HANDLED
+
+/*
+ * OS macro definitions
+ */
+
+#define os_time_get()	jiffies
+
+extern unsigned long driver_flags;
+#define OS_INT_DISABLE(x,y)	spin_lock_irqsave(&(x->adapter->driver_lock), y)
+#define	OS_INT_RESTORE(x,y)	spin_unlock_irqrestore(&(x->adapter->driver_lock), y); \
+			x->adapter->driver_lock = SPIN_LOCK_UNLOCKED
+
+#define UpdateTransStart(dev) { \
+	dev->trans_start = jiffies; \
+}
+
+#define OS_SET_THREAD_STATE(x)		set_current_state(x)
+
+#define MODULE_GET	try_module_get(THIS_MODULE)
+#define MODULE_PUT	module_put(THIS_MODULE)
+
+#define OS_INIT_SEMAPHORE(x)    	init_MUTEX(x)
+#define OS_ACQ_SEMAPHORE_BLOCK(x)	down_interruptible(x)
+#define OS_ACQ_SEMAPHORE_NOBLOCK(x)	down_trylock(x)
+#define OS_REL_SEMAPHORE(x) 		up(x)
+
+/* Definitions below are needed for other OS like threadx */
+#define	TX_DISABLE
+#define TX_RESTORE
+#define	ConfigureThreadPriority()
+#define OS_INTERRUPT_SAVE_AREA
+#define OS_FREE_LOCK(x)
+#define TX_EVENT_FLAGS_SET(x, y, z)
+
+#define os_wait_interruptible_timeout(waitq, cond, timeout) \
+	wait_event_interruptible_timeout(waitq, cond, timeout)
+
+static inline void
+os_sched_timeout(u32 millisec)
+{
+    set_current_state(TASK_INTERRUPTIBLE);
+
+    schedule_timeout((millisec * HZ) / 1000);
+}
+
+static inline u32
+get_utimeofday(void)
+{
+    struct timeval t;
+    u32 ut;
+
+    do_gettimeofday(&t);
+    ut = (u32) t.tv_sec * 1000000 + ((u32) t.tv_usec);
+    return ut;
+}
+
+/*
+ * OS timer specific
+ */
+
+typedef struct __WLAN_DRV_TIMER
+{
+    struct timer_list tl;
+    void (*timer_function) (void *context);
+    void *function_context;
+    UINT time_period;
+    BOOLEAN timer_is_periodic;
+    BOOLEAN timer_is_canceled;
+} __ATTRIB_PACK__ WLAN_DRV_TIMER, *PWLAN_DRV_TIMER;
+
+static inline void
+wlan_timer_handler(unsigned long fcontext)
+{
+    PWLAN_DRV_TIMER timer = (PWLAN_DRV_TIMER) fcontext;
+
+    timer->timer_function(timer->function_context);
+
+    if (timer->timer_is_periodic == TRUE) {
+        mod_timer(&timer->tl, jiffies + ((timer->time_period * HZ) / 1000));
+    }
+}
+
+static inline void
+wlan_initialize_timer(PWLAN_DRV_TIMER timer,
+                      void (*TimerFunction) (void *context),
+                      void *FunctionContext)
+{
+    // first, setup the timer to trigger the wlan_timer_handler proxy
+    init_timer(&timer->tl);
+    timer->tl.function = wlan_timer_handler;
+    timer->tl.data = (u32) timer;
+
+    // then tell the proxy which function to call and what to pass it       
+    timer->timer_function = TimerFunction;
+    timer->function_context = FunctionContext;
+    timer->timer_is_canceled = FALSE;
+}
+
+static inline void
+wlan_set_timer(PWLAN_DRV_TIMER timer, UINT MillisecondPeriod)
+{
+    timer->time_period = MillisecondPeriod;
+    timer->timer_is_periodic = FALSE;
+    timer->tl.expires = jiffies + (MillisecondPeriod * HZ) / 1000;
+    add_timer(&timer->tl);
+    timer->timer_is_canceled = FALSE;
+}
+
+static inline void
+wlan_mod_timer(PWLAN_DRV_TIMER timer, UINT MillisecondPeriod)
+{
+    timer->time_period = MillisecondPeriod;
+    timer->timer_is_periodic = FALSE;
+    mod_timer(&timer->tl, jiffies + (MillisecondPeriod * HZ) / 1000);
+    timer->timer_is_canceled = FALSE;
+}
+
+static inline void
+wlan_set_periodic_timer(PWLAN_DRV_TIMER timer, UINT MillisecondPeriod)
+{
+    timer->time_period = MillisecondPeriod;
+    timer->timer_is_periodic = TRUE;
+    timer->tl.expires = jiffies + (MillisecondPeriod * HZ) / 1000;
+    add_timer(&timer->tl);
+    timer->timer_is_canceled = FALSE;
+}
+
+#define	FreeTimer(x)	do {} while (0)
+
+static inline void
+wlan_cancel_timer(WLAN_DRV_TIMER * timer)
+{
+    del_timer(&timer->tl);
+    timer->timer_is_canceled = TRUE;
+}
+
+/*
+ * OS Thread Specific
+ */
+
+#include	<linux/kthread.h>
+
+typedef struct
+{
+    struct task_struct *task;
+    wait_queue_head_t waitQ;
+    pid_t pid;
+    void *priv;
+} wlan_thread;
+
+static inline void
+wlan_activate_thread(wlan_thread * thr)
+{
+        /** Record the thread pid */
+    thr->pid = current->pid;
+
+        /** Initialize the wait queue */
+    init_waitqueue_head(&thr->waitQ);
+}
+
+static inline void
+wlan_deactivate_thread(wlan_thread * thr)
+{
+    ENTER();
+
+    /* Reset the pid */
+    thr->pid = 0;
+    LEAVE();
+}
+
+static inline void
+wlan_create_thread(int (*wlanfunc) (void *), wlan_thread * thr, char *name)
+{
+    thr->task = kthread_run(wlanfunc, thr, "%s", name);
+}
+
+static inline int
+wlan_terminate_thread(wlan_thread * thr)
+{
+    ENTER();
+
+    /* Check if the thread is active or not */
+    if (!thr->pid) {
+        PRINTM(INFO, "Thread does not exist\n");
+        return -1;
+    }
+    kthread_stop(thr->task);
+
+    LEAVE();
+    return 0;
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* _WLAN_LINUX_H */
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_main.c b/drivers/net/wireless/8688_wlan/wlan/wlan_main.c
new file mode 100755
index 0000000..024a3a3
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_main.c
@@ -0,0 +1,1267 @@
+/** @file wlan_main.c
+  *  
+  * @brief This file contains the major functions in WLAN
+  * driver. It includes init, exit, open, close and main
+  * thread etc..
+  * 
+  * (c) Copyright © 2003-2007, Marvell International Ltd. 
+  *   
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/**
+  * @mainpage M-WLAN Linux Driver
+  *
+  * @section overview_sec Overview
+  *
+  * The M-WLAN is a Linux reference driver for Marvell
+  * 802.11 (a/b/g) WLAN chipset.
+  * 
+  * @section copyright_sec Copyright
+  *
+  * Copyright © Marvell International Ltd. and/or its affiliates, 2003-2007
+  *
+  */
+/********************************************************
+Change log:
+    09/30/05: Add Doxygen format comments
+    12/09/05: Add TX_QUEUE support  
+    01/05/06: Add kernel 2.6.x support  
+    01/11/06: Conditionalize new scan/join functions.
+    01/12/06: Add TxLockFlag for UAPSD power save mode 
+              and Proprietary Periodic sleep support
+********************************************************/
+
+#include    "wlan_headers.h"
+#include	"wlan_sdio.h"
+
+const char driver_version[] =
+    "sd8688-%s-" DRIVER_RELEASE_VERSION "-(" "FP" FPNUM ")"
+#ifdef	DEBUG_LEVEL2
+    "-dbg"
+#endif
+    " ";
+
+/********************************************************
+        Local Variables
+********************************************************/
+
+/** 100mW */
+#define WLAN_TX_PWR_DEFAULT     20
+/** 100mW */
+#define WLAN_TX_PWR_US_DEFAULT      20
+/** 50mW */
+#define WLAN_TX_PWR_JP_DEFAULT      16
+/** 100mW */
+#define WLAN_TX_PWR_FR_100MW        20
+/** 100mW */
+#define WLAN_TX_PWR_EMEA_DEFAULT    20
+
+/* Format { Channel, Frequency (MHz), MaxTxPower } */
+/* Band: 'B/G', Region: USA FCC/Canada IC */
+static CHANNEL_FREQ_POWER channel_freq_power_US_BG[] = {
+    {1, 2412, WLAN_TX_PWR_US_DEFAULT},
+    {2, 2417, WLAN_TX_PWR_US_DEFAULT},
+    {3, 2422, WLAN_TX_PWR_US_DEFAULT},
+    {4, 2427, WLAN_TX_PWR_US_DEFAULT},
+    {5, 2432, WLAN_TX_PWR_US_DEFAULT},
+    {6, 2437, WLAN_TX_PWR_US_DEFAULT},
+    {7, 2442, WLAN_TX_PWR_US_DEFAULT},
+    {8, 2447, WLAN_TX_PWR_US_DEFAULT},
+    {9, 2452, WLAN_TX_PWR_US_DEFAULT},
+    {10, 2457, WLAN_TX_PWR_US_DEFAULT},
+    {11, 2462, WLAN_TX_PWR_US_DEFAULT}
+};
+
+/* Band: 'B/G', Region: Europe ETSI */
+static CHANNEL_FREQ_POWER channel_freq_power_EU_BG[] = {
+    {1, 2412, WLAN_TX_PWR_EMEA_DEFAULT},
+    {2, 2417, WLAN_TX_PWR_EMEA_DEFAULT},
+    {3, 2422, WLAN_TX_PWR_EMEA_DEFAULT},
+    {4, 2427, WLAN_TX_PWR_EMEA_DEFAULT},
+    {5, 2432, WLAN_TX_PWR_EMEA_DEFAULT},
+    {6, 2437, WLAN_TX_PWR_EMEA_DEFAULT},
+    {7, 2442, WLAN_TX_PWR_EMEA_DEFAULT},
+    {8, 2447, WLAN_TX_PWR_EMEA_DEFAULT},
+    {9, 2452, WLAN_TX_PWR_EMEA_DEFAULT},
+    {10, 2457, WLAN_TX_PWR_EMEA_DEFAULT},
+    {11, 2462, WLAN_TX_PWR_EMEA_DEFAULT},
+    {12, 2467, WLAN_TX_PWR_EMEA_DEFAULT},
+    {13, 2472, WLAN_TX_PWR_EMEA_DEFAULT}
+};
+
+/* Band: 'B/G', Region: Spain */
+static CHANNEL_FREQ_POWER channel_freq_power_SPN_BG[] = {
+    {10, 2457, WLAN_TX_PWR_DEFAULT},
+    {11, 2462, WLAN_TX_PWR_DEFAULT}
+};
+
+/* Band: 'B/G', Region: France */
+static CHANNEL_FREQ_POWER channel_freq_power_FR_BG[] = {
+    {10, 2457, WLAN_TX_PWR_FR_100MW},
+    {11, 2462, WLAN_TX_PWR_FR_100MW},
+    {12, 2467, WLAN_TX_PWR_FR_100MW},
+    {13, 2472, WLAN_TX_PWR_FR_100MW}
+};
+
+/* Band: 'B/G', Region: Japan */
+static CHANNEL_FREQ_POWER channel_freq_power_JPN41_BG[] = {
+    {1, 2412, WLAN_TX_PWR_JP_DEFAULT},
+    {2, 2417, WLAN_TX_PWR_JP_DEFAULT},
+    {3, 2422, WLAN_TX_PWR_JP_DEFAULT},
+    {4, 2427, WLAN_TX_PWR_JP_DEFAULT},
+    {5, 2432, WLAN_TX_PWR_JP_DEFAULT},
+    {6, 2437, WLAN_TX_PWR_JP_DEFAULT},
+    {7, 2442, WLAN_TX_PWR_JP_DEFAULT},
+    {8, 2447, WLAN_TX_PWR_JP_DEFAULT},
+    {9, 2452, WLAN_TX_PWR_JP_DEFAULT},
+    {10, 2457, WLAN_TX_PWR_JP_DEFAULT},
+    {11, 2462, WLAN_TX_PWR_JP_DEFAULT},
+    {12, 2467, WLAN_TX_PWR_JP_DEFAULT},
+    {13, 2472, WLAN_TX_PWR_JP_DEFAULT}
+};
+
+/* Band: 'B/G', Region: Japan */
+static CHANNEL_FREQ_POWER channel_freq_power_JPN40_BG[] = {
+    {14, 2484, WLAN_TX_PWR_JP_DEFAULT}
+};
+
+/* Band: 'A', Region: USA FCC, Canada IC, Spain, France */
+static CHANNEL_FREQ_POWER channel_freq_power_A[] = {
+    {36, 5180, WLAN_TX_PWR_US_DEFAULT},
+    {40, 5200, WLAN_TX_PWR_US_DEFAULT},
+    {44, 5220, WLAN_TX_PWR_US_DEFAULT},
+    {48, 5240, WLAN_TX_PWR_US_DEFAULT},
+    {52, 5260, WLAN_TX_PWR_US_DEFAULT},
+    {56, 5280, WLAN_TX_PWR_US_DEFAULT},
+    {60, 5300, WLAN_TX_PWR_US_DEFAULT},
+    {64, 5320, WLAN_TX_PWR_US_DEFAULT},
+#if defined(FCC_DFS_APPROVAL) && defined(ENABLE_802_11H)
+    /* FCC_DFS_APPROVAL place holder -- remove when appropriate */
+    {100, 5500, WLAN_TX_PWR_US_DEFAULT},
+    {104, 5520, WLAN_TX_PWR_US_DEFAULT},
+    {108, 5540, WLAN_TX_PWR_US_DEFAULT},
+    {112, 5560, WLAN_TX_PWR_US_DEFAULT},
+    {116, 5580, WLAN_TX_PWR_US_DEFAULT},
+    {120, 5600, WLAN_TX_PWR_US_DEFAULT},
+    {124, 5620, WLAN_TX_PWR_US_DEFAULT},
+    {128, 5640, WLAN_TX_PWR_US_DEFAULT},
+    {132, 5660, WLAN_TX_PWR_US_DEFAULT},
+    {136, 5680, WLAN_TX_PWR_US_DEFAULT},
+    {140, 5700, WLAN_TX_PWR_US_DEFAULT},
+#endif
+    {149, 5745, WLAN_TX_PWR_US_DEFAULT},
+    {153, 5765, WLAN_TX_PWR_US_DEFAULT},
+    {157, 5785, WLAN_TX_PWR_US_DEFAULT},
+    {161, 5805, WLAN_TX_PWR_US_DEFAULT},
+    {165, 5825, WLAN_TX_PWR_US_DEFAULT}
+};
+
+/* Band: 'A', Region: Europe ETSI */
+static CHANNEL_FREQ_POWER channel_freq_power_EU_A[] = {
+    {36, 5180, WLAN_TX_PWR_EMEA_DEFAULT},
+    {40, 5200, WLAN_TX_PWR_EMEA_DEFAULT},
+    {44, 5220, WLAN_TX_PWR_EMEA_DEFAULT},
+    {48, 5240, WLAN_TX_PWR_EMEA_DEFAULT},
+    {52, 5260, WLAN_TX_PWR_EMEA_DEFAULT},
+    {56, 5280, WLAN_TX_PWR_EMEA_DEFAULT},
+    {60, 5300, WLAN_TX_PWR_EMEA_DEFAULT},
+    {64, 5320, WLAN_TX_PWR_EMEA_DEFAULT},
+    {100, 5500, WLAN_TX_PWR_EMEA_DEFAULT},
+    {104, 5520, WLAN_TX_PWR_EMEA_DEFAULT},
+    {108, 5540, WLAN_TX_PWR_EMEA_DEFAULT},
+    {112, 5560, WLAN_TX_PWR_EMEA_DEFAULT},
+    {116, 5580, WLAN_TX_PWR_EMEA_DEFAULT},
+    {120, 5600, WLAN_TX_PWR_EMEA_DEFAULT},
+    {124, 5620, WLAN_TX_PWR_EMEA_DEFAULT},
+    {128, 5640, WLAN_TX_PWR_EMEA_DEFAULT},
+    {132, 5660, WLAN_TX_PWR_EMEA_DEFAULT},
+    {136, 5680, WLAN_TX_PWR_EMEA_DEFAULT},
+    {140, 5700, WLAN_TX_PWR_EMEA_DEFAULT}
+};
+
+/* Band: 'A', Region: Japan */
+static CHANNEL_FREQ_POWER channel_freq_power_JPN_A[] = {
+    {8, 5040, WLAN_TX_PWR_JP_DEFAULT},
+    {12, 5060, WLAN_TX_PWR_JP_DEFAULT},
+    {16, 5080, WLAN_TX_PWR_JP_DEFAULT},
+    {34, 5170, WLAN_TX_PWR_JP_DEFAULT},
+    {38, 5190, WLAN_TX_PWR_JP_DEFAULT},
+    {42, 5210, WLAN_TX_PWR_JP_DEFAULT},
+    {46, 5230, WLAN_TX_PWR_JP_DEFAULT},
+};
+
+/**
+ * the structure for channel, frequency and power
+ */
+typedef struct _region_cfp_table
+{
+    /** Region */
+    u8 region;
+    /** Frequency/Power */
+    CHANNEL_FREQ_POWER *cfp_BG;
+    /** No BG flag */
+    int cfp_no_BG;
+    /** Frequency/Power for band A */
+    CHANNEL_FREQ_POWER *cfp_A;
+    /** No A flag */
+    int cfp_no_A;
+} region_cfp_table_t;
+
+/**
+ * the structure for the mapping between region and CFP
+ */
+static region_cfp_table_t region_cfp_table[] = {
+    {0x10,                      /*US FCC */
+     channel_freq_power_US_BG,
+     sizeof(channel_freq_power_US_BG) / sizeof(CHANNEL_FREQ_POWER),
+     channel_freq_power_A,
+     sizeof(channel_freq_power_A) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x20,                      /*CANADA IC */
+     channel_freq_power_US_BG,
+     sizeof(channel_freq_power_US_BG) / sizeof(CHANNEL_FREQ_POWER),
+     channel_freq_power_A,
+     sizeof(channel_freq_power_A) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x30, /*EU*/ channel_freq_power_EU_BG,
+     sizeof(channel_freq_power_EU_BG) / sizeof(CHANNEL_FREQ_POWER),
+     channel_freq_power_EU_A,
+     sizeof(channel_freq_power_EU_A) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x31, /*SPAIN*/ channel_freq_power_SPN_BG,
+     sizeof(channel_freq_power_SPN_BG) / sizeof(CHANNEL_FREQ_POWER),
+     channel_freq_power_A,
+     sizeof(channel_freq_power_A) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x32, /*FRANCE*/ channel_freq_power_FR_BG,
+     sizeof(channel_freq_power_FR_BG) / sizeof(CHANNEL_FREQ_POWER),
+     channel_freq_power_A,
+     sizeof(channel_freq_power_A) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x40, /*JAPAN*/ channel_freq_power_JPN40_BG,
+     sizeof(channel_freq_power_JPN40_BG) / sizeof(CHANNEL_FREQ_POWER),
+     channel_freq_power_JPN_A,
+     sizeof(channel_freq_power_JPN_A) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+    {0x41, /*JAPAN*/ channel_freq_power_JPN41_BG,
+     sizeof(channel_freq_power_JPN41_BG) / sizeof(CHANNEL_FREQ_POWER),
+     channel_freq_power_JPN_A,
+     sizeof(channel_freq_power_JPN_A) / sizeof(CHANNEL_FREQ_POWER),
+     }
+    ,
+/*Add new region here */
+};
+
+/********************************************************
+        Global Variables
+********************************************************/
+
+/**
+ * the rates supported by the card
+ */
+u8 WlanDataRates[WLAN_SUPPORTED_RATES] =
+    { 0x02, 0x04, 0x0B, 0x16, 0x00, 0x0C, 0x12,
+    0x18, 0x24, 0x30, 0x48, 0x60, 0x6C, 0x00
+};
+
+/**
+ * the rates supported in B mode
+ */
+u8 SupportedRates_B[B_SUPPORTED_RATES] =
+    { 0x82, 0x84, 0x0b, 0x16, 0, 0, 0, 0 };
+
+/**
+ * the rates supported in G mode
+ */
+u8 SupportedRates_G[G_SUPPORTED_RATES] =
+    { 0x82, 0x84, 0x8b, 0x0c, 0x12, 0x96, 0x18, 0x24,
+    0x30, 0x48, 0x60, 0x6c, 0
+};
+
+/**
+ * the rates supported in A mode
+ */
+u8 SupportedRates_A[A_SUPPORTED_RATES] =
+    { 0x8c, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6c, 0 };
+
+/**
+ * the rates supported in A mode for ad-hoc
+ */
+u8 AdhocRates_A[A_SUPPORTED_RATES] =
+    { 0x8c, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6c, 0 };
+
+/**
+ * the rates supported for ad-hoc G mode
+ */
+u8 AdhocRates_G[G_SUPPORTED_RATES] =
+    { 0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6c,
+0 };
+
+/**
+ * the rates supported for ad-hoc B mode
+ */
+u8 AdhocRates_B[4] = { 0x82, 0x84, 0x8b, 0x96 };
+
+/**
+ * the global variable of a pointer to wlan_private
+ * structure variable
+ */
+wlan_private *wlanpriv = NULL;
+
+u32 DSFreqList[15] = {
+    0, 2412000, 2417000, 2422000, 2427000, 2432000, 2437000, 2442000,
+    2447000, 2452000, 2457000, 2462000, 2467000, 2472000, 2484000
+};
+
+/**
+ * the table to keep region code
+ */
+u16 RegionCodeToIndex[MRVDRV_MAX_REGION_CODE] =
+    { 0x10, 0x20, 0x30, 0x31, 0x32, 0x40, 0x41 };
+
+/********************************************************
+        Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function opens the network device
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+static int
+wlan_open(struct net_device *dev)
+{
+    wlan_private *priv = (wlan_private *) dev->priv;
+    wlan_adapter *adapter = priv->adapter;
+
+    ENTER();
+
+    // On some systems the device open handler will be called before HW ready.
+    // Use the following flag check and wait function to work around the issue.
+    {
+        int i = 0;
+
+        while ((adapter->HardwareStatus != WlanHardwareStatusReady) &&
+               (i < MAX_WAIT_DEVICE_READY_COUNT)) {
+            i++;
+            os_sched_timeout(100);
+        }
+        if (i >= MAX_WAIT_DEVICE_READY_COUNT) {
+            PRINTM(FATAL, "HW not ready, wlan_open() return failure\n");
+            LEAVE();
+            return WLAN_STATUS_FAILURE;
+        }
+    }
+
+    if (MODULE_GET == 0)
+        return WLAN_STATUS_FAILURE;
+
+    priv->open = TRUE;
+
+    if ((adapter->MediaConnectStatus == WlanMediaStateConnected)
+        && (adapter->InfrastructureMode != Wlan802_11IBSS
+            || adapter->AdhocLinkSensed == TRUE))
+        os_carrier_on(priv);
+    else
+        os_carrier_off(priv);
+
+    os_start_queue(priv);
+    wmm_start_queue(priv);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function closes the network device
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+static int
+wlan_close(struct net_device *dev)
+{
+    wlan_private *priv = dev->priv;
+
+    ENTER();
+
+    if (priv->adapter)
+        wlan_clean_txrx(priv);
+
+    MODULE_PUT;
+
+    priv->open = FALSE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles packet transmission
+ *  
+ *  @param skb     A pointer to sk_buff structure
+ *  @param dev     A pointer to net_device structure
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+    int ret;
+    wlan_private *priv = dev->priv;
+
+    ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    PRINTM(DATA, "Data <= kernel\n");
+
+    if (wlan_tx_packet(priv, skb)) {
+        /* Transmit failed */
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function handles the timeout of packet
+ *  transmission
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return        n/a
+ */
+static void
+wlan_tx_timeout(struct net_device *dev)
+{
+    wlan_private *priv = (wlan_private *) dev->priv;
+
+    ENTER();
+
+    PRINTM(DATA, "Tx timeout\n");
+    UpdateTransStart(dev);
+
+    priv->adapter->dbg.num_tx_timeout++;
+
+    priv->adapter->IntCounter++;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function returns the network statistics
+ *  
+ *  @param dev     A pointer to wlan_private structure
+ *  @return        A pointer to net_device_stats structure
+ */
+static struct net_device_stats *
+wlan_get_stats(struct net_device *dev)
+{
+    wlan_private *priv = (wlan_private *) dev->priv;
+
+    return &priv->stats;
+}
+
+/** 
+ *  @brief This function sets the MAC address to firmware.
+ *  
+ *  @param dev     A pointer to wlan_private structure
+ *  @param addr    MAC address to set
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_set_mac_address(struct net_device *dev, void *addr)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = (wlan_private *) dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    struct sockaddr *pHwAddr = (struct sockaddr *) addr;
+
+    ENTER();
+
+    memset(Adapter->CurrentAddr, 0, ETH_ALEN);
+
+    /* dev->dev_addr is 8 bytes */
+    HEXDUMP("dev->dev_addr:", dev->dev_addr, ETH_ALEN);
+
+    HEXDUMP("addr:", pHwAddr->sa_data, ETH_ALEN);
+    memcpy(Adapter->CurrentAddr, pHwAddr->sa_data, ETH_ALEN);
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_MAC_ADDRESS,
+                           HostCmd_ACT_GEN_SET,
+                           HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    if (ret) {
+        PRINTM(INFO, "set mac address failed.\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    HEXDUMP("Adapter->MacAddr:", Adapter->CurrentAddr, ETH_ALEN);
+    memcpy(dev->dev_addr, Adapter->CurrentAddr, ETH_ALEN);
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function sets multicast addresses to firmware
+ *  
+ *  @param dev     A pointer to net_device structure
+ *  @return        n/a
+ */
+static void
+wlan_set_multicast_list(struct net_device *dev)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int OldPacketFilter;
+
+    ENTER();
+
+    OldPacketFilter = Adapter->CurrentPacketFilter;
+
+    if (dev->flags & IFF_PROMISC) {
+        PRINTM(INFO, "Enable Promiscuous mode\n");
+        Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_PROMISCUOUS_ENABLE;
+        Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;
+    } else {
+        /* Multicast */
+        Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_PROMISCUOUS_ENABLE;
+
+        if (dev->flags & IFF_ALLMULTI || dev->mc_count >
+            MRVDRV_MAX_MULTICAST_LIST_SIZE) {
+            PRINTM(INFO, "Enabling All Multicast!\n");
+            Adapter->CurrentPacketFilter |=
+                HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;
+        } else {
+            Adapter->CurrentPacketFilter &=
+                ~HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;
+
+            if (!dev->mc_count) {
+                PRINTM(INFO, "No multicast addresses - "
+                       "disabling multicast!\n");
+
+            } else {
+                int i;
+
+                Adapter->NumOfMulticastMACAddr =
+                    wlan_copy_mcast_addr(Adapter, dev);
+
+                PRINTM(INFO, "Multicast addresses: %d\n", dev->mc_count);
+
+                for (i = 0; i < dev->mc_count; i++) {
+                    PRINTM(INFO, "Multicast address %d:"
+                           "%x %x %x %x %x %x\n", i,
+                           Adapter->MulticastList[i][0],
+                           Adapter->MulticastList[i][1],
+                           Adapter->MulticastList[i][2],
+                           Adapter->MulticastList[i][3],
+                           Adapter->MulticastList[i][4],
+                           Adapter->MulticastList[i][5]);
+                }
+                /* set multicast addresses to firmware */
+                wlan_prepare_cmd(priv, HostCmd_CMD_MAC_MULTICAST_ADR,
+                                 HostCmd_ACT_GEN_SET, 0, 0, NULL);
+            }
+        }
+    }
+
+    if (Adapter->CurrentPacketFilter != OldPacketFilter) {
+        wlan_prepare_cmd(priv,
+                         HostCmd_CMD_MAC_CONTROL,
+                         0, 0, 0, &Adapter->CurrentPacketFilter);
+    }
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function hanldes the major job in WLAN driver.
+ *  it handles the event generated by firmware, rx data received
+ *  from firmware and tx data sent from kernel.
+ *  
+ *  @param data    A pointer to wlan_thread structure
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+static int
+wlan_service_main_thread(void *data)
+{
+    wlan_thread *thread = data;
+    wlan_private *priv = thread->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    wait_queue_t wait;
+    u8 ireg = 0;
+    unsigned long driver_flags;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    wlan_activate_thread(thread);
+
+    init_waitqueue_entry(&wait, current);
+
+    current->flags |= PF_NOFREEZE;
+
+    wlan_meas_init(priv);
+
+    PRINTM(INFO, "11H: init 11H\n");
+    wlan_11h_init(priv);
+
+    wmm_init(priv);
+
+    for (;;) {
+#define MAX_MAIN_THREAD_LOOPS (10000)
+        if (++Adapter->main_thread_loops > MAX_MAIN_THREAD_LOOPS) {
+            panic("main-thread dead loop detected: %u\n"
+                  "IntCnt=%d\n"
+                  "Adapter->HisRegCpy=%#x\n"
+                  "CurCmd=%p CmdPending=%s\n"
+                  "Connect=%s\n"
+                  "CurTxSkb=%p dnld_sent=%d\n"
+                  "IsDeepSleep=%d\n"
+                  "PSMode=%d PSState=%d\n"
+                  "WakeupDevReq=%d\n"
+                  "HS_Activated=%d\n"
+                  "WakeupTries=%d\n", Adapter->main_thread_loops,
+                  Adapter->IntCounter,
+                  Adapter->HisRegCpy,
+                  Adapter->CurCmd,
+                  list_empty(&Adapter->CmdPendingQ) ? "N" : "Y",
+                  (Adapter->MediaConnectStatus ==
+                   WlanMediaStateConnected) ? "Y" : "N",
+                  Adapter->CurrentTxSkb, priv->wlan_dev.dnld_sent,
+                  Adapter->IsDeepSleep, Adapter->PSMode, Adapter->PSState,
+                  Adapter->bWakeupDevRequired, Adapter->HS_Activated,
+                  Adapter->WakeupTries);
+        }
+
+        add_wait_queue(&thread->waitQ, &wait);
+        OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
+
+        TX_DISABLE;
+
+        if ((Adapter->WakeupTries) ||
+            (Adapter->PSState == PS_STATE_SLEEP
+             && !Adapter->bWakeupDevRequired) ||
+            (!Adapter->IntCounter &&
+             Adapter->PSState == PS_STATE_PRE_SLEEP) ||
+            (!Adapter->IntCounter
+             && (priv->wlan_dev.dnld_sent || Adapter->TxLockFlag
+                 || wmm_lists_empty(priv) || wmm_is_queue_stopped(priv))
+             && (priv->wlan_dev.dnld_sent || !Adapter->CurrentTxSkb)
+             && (priv->wlan_dev.dnld_sent || Adapter->CurCmd ||
+                 list_empty(&Adapter->CmdPendingQ))
+            )
+            ) {
+            PRINTM(INFO, "main-thread sleeping... "
+                   "HS_Act=%s WakeupReq=%s Conn=%s PS_Mode=%d PS_State=%d\n",
+                   (Adapter->HS_Activated) ? "Y" : "N",
+                   (Adapter->bWakeupDevRequired) ? "Y" : "N",
+                   (Adapter->MediaConnectStatus) ? "Y" : "N",
+                   Adapter->PSMode, Adapter->PSState);
+
+            TX_RESTORE;
+            Adapter->main_thread_loops = 0;
+            schedule();
+            PRINTM(INFO, "main-thread waking up: IntCnt=%d "
+                   "CurCmd=%s CmdPending=%s\n"
+                   "                       Connect=%s "
+                   "CurTxSkb=%s dnld_sent=%d\n",
+                   Adapter->IntCounter,
+                   (Adapter->CurCmd) ? "Y" : "N",
+                   list_empty(&Adapter->CmdPendingQ) ? "N" : "Y",
+                   (Adapter->MediaConnectStatus) ? "Y" : "N",
+                   (Adapter->CurrentTxSkb) ? "Y" : "N",
+                   priv->wlan_dev.dnld_sent);
+        } else {
+            TX_RESTORE;
+        }
+
+        OS_SET_THREAD_STATE(TASK_RUNNING);
+        remove_wait_queue(&thread->waitQ, &wait);
+
+        if (kthread_should_stop() || Adapter->SurpriseRemoved) {
+            PRINTM(INFO, "main-thread: break from main thread: "
+                   "SurpriseRemoved=0x%x\n", Adapter->SurpriseRemoved);
+            break;
+        }
+
+        if (Adapter->IntCounter) {
+            OS_INT_DISABLE(priv, driver_flags);
+            Adapter->IntCounter = 0;
+            OS_INT_RESTORE(priv, driver_flags);
+
+		/*
+            if (sbi_get_int_status(priv, &ireg)) {
+                PRINTM(ERROR,
+                       "main-thread: reading HOST_INT_STATUS_REG failed\n");
+                continue;
+            }
+            OS_INT_DISABLE(priv, driver_flags);
+            Adapter->HisRegCpy |= ireg;
+            OS_INT_RESTORE(priv, driver_flags);
+            PRINTM(INTR, "INT: status = 0x%x\n", Adapter->HisRegCpy);
+	    */
+        } else if (Adapter->bWakeupDevRequired) {
+            Adapter->WakeupTries++;
+            PRINTM(CMND,
+                   "Wakeup device... WakeupReq=%s Conn=%s PS_Mode=%d PS_State=%d\n",
+                   (Adapter->bWakeupDevRequired) ? "Y" : "N",
+                   (priv->adapter->MediaConnectStatus) ? "Y" : "N",
+                   priv->adapter->PSMode, priv->adapter->PSState);
+
+            /* Wake up device */
+            if (sbi_exit_deep_sleep(priv))
+                PRINTM(MSG, "main-thread: wakeup dev failed\n");
+            continue;
+        }
+
+        /* Command response? */
+        if (Adapter->HisRegCpy & HIS_CmdUpLdRdy) {
+            OS_INT_DISABLE(priv, driver_flags);
+            Adapter->HisRegCpy &= ~HIS_CmdUpLdRdy;
+            OS_INT_RESTORE(priv, driver_flags);
+
+            wlan_process_cmdresp(priv);
+        }
+
+        /* Any Card Event */
+        if (Adapter->HisRegCpy & HIS_CardEvent) {
+            OS_INT_DISABLE(priv, driver_flags);
+            Adapter->HisRegCpy &= ~HIS_CardEvent;
+            OS_INT_RESTORE(priv, driver_flags);
+
+            wlan_process_event(priv);
+        }
+
+        /* Check if we need to confirm Sleep Request received previously */
+        if (Adapter->PSState == PS_STATE_PRE_SLEEP) {
+            if (!priv->wlan_dev.dnld_sent && !Adapter->CurCmd) {
+                ASSERT(Adapter->MediaConnectStatus ==
+                       WlanMediaStateConnected);
+                wlan_ps_cond_check(priv, (u16) Adapter->PSMode);
+            }
+        }
+
+        /* The PS state is changed during processing of 
+         * Sleep Request event above 
+         */
+        if ((Adapter->PSState == PS_STATE_SLEEP)
+            || (Adapter->PSState == PS_STATE_PRE_SLEEP)) {
+            continue;
+        }
+
+        if (Adapter->IsDeepSleep)
+            continue;
+
+        /* The HS_Activated flag is changed during processing of 
+           HS_Activate command resp */
+        /* We cannot send command or data if HS_Activated and 
+           WakeupDevRequired are TRUE */
+        if (Adapter->HS_Activated && Adapter->bWakeupDevRequired) {
+            PRINTM(INFO, "main-thread: cannot send command or data, "
+                   "HS_Activated=%d\n", Adapter->HS_Activated);
+            continue;
+        }
+
+        /* Execute the next command */
+        if (!priv->wlan_dev.dnld_sent && !Adapter->CurCmd) {
+            wlan_exec_next_cmd(priv);
+        }
+
+        if (!priv->wlan_dev.dnld_sent
+            && !wmm_lists_empty(priv) && !wmm_is_queue_stopped(priv)) {
+            if ((Adapter->PSState == PS_STATE_FULL_POWER)
+                || (Adapter->sleep_period.period == 0)
+                || (Adapter->TxLockFlag == FALSE)) {
+                wmm_process_tx(priv);
+            }
+        }
+
+    }
+
+    wlan_deactivate_thread(thread);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ * @brief This function adds the card. it will probe the
+ * card, allocate the wlan_priv and initialize the device. 
+ *  
+ *  @param card    A pointer to card
+ *  @return        A pointer to wlan_private structure
+ */
+static wlan_private *
+wlan_add_card(void *card)
+{
+    struct net_device *dev = NULL;
+    wlan_private *priv = NULL;
+
+    ENTER();
+
+    /* Allocate an Ethernet device and register it */
+    if (!(dev = alloc_etherdev(sizeof(wlan_private)))) {
+        PRINTM(MSG, "Init ethernet device failed!\n");
+        return NULL;
+    }
+
+    priv = dev->priv;
+
+    /* allocate buffer for wlan_adapter */
+    if (!(priv->adapter = kmalloc(sizeof(wlan_adapter), GFP_KERNEL))) {
+        PRINTM(MSG, "Allocate buffer for wlan_adapter failed!\n");
+        goto err_kmalloc;
+    }
+
+    /* init wlan_adapter */
+    memset(priv->adapter, 0, sizeof(wlan_adapter));
+
+    priv->wlan_dev.netdev = dev;
+    priv->wlan_dev.card = card;
+    ((struct sdio_mmc_card *) card)->priv = priv;
+    wlanpriv = priv;
+
+    //SET_MODULE_OWNER(dev);
+
+    /* Setup the OS Interface to our functions */
+    dev->open = wlan_open;
+    dev->hard_start_xmit = wlan_hard_start_xmit;
+    dev->stop = wlan_close;
+    dev->do_ioctl = wlan_do_ioctl;
+    dev->set_mac_address = wlan_set_mac_address;
+
+    dev->tx_timeout = wlan_tx_timeout;
+    dev->get_stats = wlan_get_stats;
+    dev->watchdog_timeo = MRVDRV_DEFAULT_WATCHDOG_TIMEOUT;
+    dev->hard_header_len += sizeof(TxPD);
+    dev->hard_header_len += SDIO_HEADER_LEN;
+
+#ifdef  WIRELESS_EXT
+#if WIRELESS_EXT < 21
+    dev->get_wireless_stats = wlan_get_wireless_stats;
+#endif
+    dev->wireless_handlers = (struct iw_handler_def *) &wlan_handler_def;
+#endif
+#define NETIF_F_DYNALLOC 16
+    dev->features |= NETIF_F_DYNALLOC;
+    dev->flags |= IFF_BROADCAST | IFF_MULTICAST;
+    dev->set_multicast_list = wlan_set_multicast_list;
+
+    /* init SW */
+    if (wlan_init_sw(priv)) {
+        PRINTM(FATAL, "Software Init Failed\n");
+        goto err_kmalloc;
+    }
+
+    PRINTM(INFO, "Starting kthread...\n");
+    priv->MainThread.priv = priv;
+    wlan_create_thread(wlan_service_main_thread,
+                       &priv->MainThread, "wlan_main_service");
+
+    ConfigureThreadPriority();
+
+#ifdef REASSOCIATION
+    priv->ReassocThread.priv = priv;
+    wlan_create_thread(wlan_reassociation_thread,
+                       &priv->ReassocThread, "wlan_reassoc_service");
+#endif /* REASSOCIATION */
+
+    while ((priv->MainThread.pid == 0)
+#ifdef REASSOCIATION
+           || (priv->ReassocThread.pid == 0)
+#endif
+        ) {
+        os_sched_timeout(2);
+    }
+
+    /*
+     * Register the device. Fillup the private data structure with
+     * relevant information from the card and request for the required
+     * IRQ. 
+     */
+
+    if (sbi_register_dev(priv) < 0) {
+        PRINTM(FATAL, "Failed to register wlan device!\n");
+        goto err_registerdev;
+    }
+
+    SET_NETDEV_DEV(dev, priv->hotplug_device);
+
+    /* init FW and HW */
+    if (wlan_init_fw(priv)) {
+        PRINTM(FATAL, "Firmware Init Failed\n");
+        goto err_init_fw;
+    }
+
+    if (register_netdev(dev)) {
+        printk(KERN_ERR "Cannot register network device!\n");
+        goto err_init_fw;
+    }
+    PRINTM(WARN, "%s: Marvell Wlan 802.11 Adapter "
+           "revision 0x%02X at IRQ %i\n", dev->name,
+           priv->adapter->chip_rev, dev->irq);
+
+#ifdef CONFIG_PROC_FS
+    wlan_proc_entry(priv, dev);
+#ifdef PROC_DEBUG
+    wlan_debug_entry(priv, dev);
+#endif
+#endif /* CPNFIG_PROC_FS */
+
+    LEAVE();
+    return priv;
+
+  err_init_fw:
+    sbi_unregister_dev(priv);
+
+  err_registerdev:
+    priv->adapter->SurpriseRemoved = TRUE;
+    if (priv->MainThread.pid) {
+        /* Stop the thread servicing the interrupts */
+        wake_up_interruptible(&priv->MainThread.waitQ);
+    }
+#ifdef REASSOCIATION
+    if (priv->ReassocThread.pid) {
+        wake_up_interruptible(&priv->ReassocThread.waitQ);
+    }
+#endif /* REASSOCIATION */
+
+    //waiting for main thread quit
+    while (priv->MainThread.pid
+#ifdef REASSOCIATION
+           || priv->ReassocThread.pid
+#endif
+        ) {
+        os_sched_timeout(2);
+    }
+  err_kmalloc:
+    wlan_free_adapter(priv);
+    priv->wlan_dev.netdev = NULL;
+    free_netdev(dev);
+    ((struct sdio_mmc_card *) card)->priv = NULL;
+    wlanpriv = NULL;
+
+    LEAVE();
+    return NULL;
+}
+
+/** 
+ *  @brief This function removes the card.
+ *  
+ *  @param card    A pointer to card
+ *  @return        WLAN_STATUS_SUCCESS
+ */
+static int
+wlan_remove_card(void *card)
+{
+    wlan_private *priv = wlanpriv;
+    wlan_adapter *Adapter = NULL;
+    struct net_device *dev;
+    union iwreq_data wrqu;
+    ulong flags;
+    ENTER();
+
+    if (!priv || !(Adapter = priv->adapter)) {
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+    Adapter->SurpriseRemoved = TRUE;
+    if (Adapter->ReassocTimerIsSet == TRUE) {
+        wlan_cancel_timer(&Adapter->MrvDrvTimer);
+        Adapter->ReassocTimerIsSet = FALSE;
+    }
+    if (Adapter->CurCmd) {
+        PRINTM(INFO, "Wake up current cmdwait_q\n");
+        Adapter->CurCmdRetCode = WLAN_STATUS_FAILURE;
+        wlan_insert_cmd_to_free_q(priv, Adapter->CurCmd);
+        spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+        Adapter->CurCmd = NULL;
+        spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+    }
+    if (priv->MainThread.pid) {
+        /* Stop the thread servicing the interrupts */
+        wake_up_interruptible(&priv->MainThread.waitQ);
+    }
+#ifdef REASSOCIATION
+    if (priv->ReassocThread.pid) {
+        wake_up_interruptible(&priv->ReassocThread.waitQ);
+    }
+#endif /* REASSOCIATION */
+
+    /* waiting for thread quit */
+    while (priv->MainThread.pid
+#ifdef REASSOCIATION
+           || priv->ReassocThread.pid
+#endif
+        ) {
+        os_sched_timeout(1);
+    }
+
+    dev = priv->wlan_dev.netdev;
+
+    if (Adapter->IsDeepSleep == TRUE) {
+        Adapter->IsDeepSleep = FALSE;
+        wake_up_interruptible(&Adapter->ds_awake_q);
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        Adapter->MediaConnectStatus = WlanMediaStateDisconnected;
+        memset(wrqu.ap_addr.sa_data, 0xaa, ETH_ALEN);
+        wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+        wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+        wlan_clean_txrx(priv);
+    }
+#ifdef CONFIG_PROC_FS
+#ifdef PROC_DEBUG
+    wlan_debug_remove(priv);
+#endif
+    wlan_proc_remove(priv);
+#endif
+
+    PRINTM(INFO, "unregester dev\n");
+    sbi_unregister_dev(priv);
+
+    PRINTM(INFO, "Free Adapter\n");
+    wlan_free_adapter(priv);
+
+    /* Last reference is our one */
+    PRINTM(INFO, "refcnt = %d\n", atomic_read(&dev->refcnt));
+
+    PRINTM(INFO, "netdev_finish_unregister: %s%s.\n", dev->name,
+           (dev->features & NETIF_F_DYNALLOC) ? "" : ", old style");
+
+    unregister_netdev(dev);
+
+    PRINTM(INFO, "Unregister finish\n");
+
+    priv->wlan_dev.netdev = NULL;
+    free_netdev(dev);
+    wlanpriv = NULL;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/********************************************************
+        Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function finds the CFP in 
+ *  region_cfp_table based on region and band parameter.
+ *  
+ *  @param region  The region code
+ *  @param band    The band
+ *  @param cfp_no  A pointer to CFP number
+ *  @return        A pointer to CFP
+ */
+CHANNEL_FREQ_POWER *
+wlan_get_region_cfp_table(u8 region, u8 band, int *cfp_no)
+{
+    int i;
+
+    ENTER();
+
+    for (i = 0; i < sizeof(region_cfp_table) / sizeof(region_cfp_table_t);
+         i++) {
+        PRINTM(INFO, "region_cfp_table[i].region=%d\n",
+               region_cfp_table[i].region);
+        if (region_cfp_table[i].region == region) {
+            if (band & (BAND_B | BAND_G)) {
+                *cfp_no = region_cfp_table[i].cfp_no_BG;
+                LEAVE();
+                return region_cfp_table[i].cfp_BG;
+            } else {
+                if (band & BAND_A) {
+                    *cfp_no = region_cfp_table[i].cfp_no_A;
+                    LEAVE();
+                    return region_cfp_table[i].cfp_A;
+                } else {
+                    PRINTM(INFO, "Error Band[%x]\n", band);
+                    LEAVE();
+                    return NULL;
+                }
+            }
+        }
+    }
+
+    LEAVE();
+    return NULL;
+}
+
+/** 
+ *  @brief This function sets region table. 
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param region  The region code
+ *  @param band    The band
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_set_regiontable(wlan_private * priv, u8 region, u8 band)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i = 0;
+
+    CHANNEL_FREQ_POWER *cfp;
+    int cfp_no;
+
+    ENTER();
+
+    memset(Adapter->region_channel, 0, sizeof(Adapter->region_channel));
+
+    if (band & (BAND_B | BAND_G)) {
+        cfp = wlan_get_region_cfp_table(region, BAND_G | BAND_B, &cfp_no);
+        if (cfp != NULL) {
+            Adapter->region_channel[i].NrCFP = cfp_no;
+            Adapter->region_channel[i].CFP = cfp;
+        } else {
+            PRINTM(INFO, "wrong region code %#x in Band B-G\n", region);
+            return WLAN_STATUS_FAILURE;
+        }
+        Adapter->region_channel[i].Valid = TRUE;
+        Adapter->region_channel[i].Region = region;
+        Adapter->region_channel[i].Band = (band & BAND_G) ? BAND_G : BAND_B;
+        i++;
+    }
+    if (band & BAND_A) {
+        cfp = wlan_get_region_cfp_table(region, BAND_A, &cfp_no);
+        if (cfp != NULL) {
+            Adapter->region_channel[i].NrCFP = cfp_no;
+            Adapter->region_channel[i].CFP = cfp;
+        } else {
+            PRINTM(INFO, "wrong region code %#x in Band A\n", region);
+            return WLAN_STATUS_FAILURE;
+        }
+        Adapter->region_channel[i].Valid = TRUE;
+        Adapter->region_channel[i].Region = region;
+        Adapter->region_channel[i].Band = BAND_A;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the interrupt. it will change PS
+ *  state if applicable. it will wake up main_thread to handle
+ *  the interrupt event as well.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return        n/a
+ */
+void
+wlan_interrupt(wlan_private * priv)
+{
+
+    priv->adapter->IntCounter++;
+
+    PRINTM(INTR, "*\n");
+
+    priv->adapter->WakeupTries = 0;
+	/* masked by feng, for there is no such support for setting bus freq */
+    //if (priv->adapter->bWakeupDevRequired)
+     //   sd_set_busclock((psd_device) priv->wlan_dev.card, 0);   /* default clock frequency */
+
+    if (priv->adapter->PSState == PS_STATE_SLEEP) {
+        priv->adapter->PSState = PS_STATE_AWAKE;
+    }
+
+    //wake_up_interruptible(&priv->MainThread.waitQ);
+}
+
+/** 
+ *  @brief This function initializes module.
+ *  
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_init_module(void)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (sbi_register(wlan_add_card, wlan_remove_card, NULL) == NULL) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function cleans module
+ *  
+ *  @return        n/a
+ */
+static void
+wlan_cleanup_module(void)
+{
+    wlan_private *priv = wlanpriv;
+    wlan_adapter *Adapter = NULL;
+
+    ENTER();
+
+    if (!priv || !priv->adapter)
+        goto exit;
+
+    Adapter = priv->adapter;
+
+    Adapter->IsAutoDeepSleepEnabled = FALSE;
+    if (Adapter->IsDeepSleep == TRUE) {
+        sbi_exit_deep_sleep(priv);
+        if (Adapter->IsDeepSleep == TRUE) {
+            if (os_wait_interruptible_timeout(Adapter->ds_awake_q,
+                                              !Adapter->IsDeepSleep,
+                                              MRVDRV_DEEP_SLEEP_EXIT_TIMEOUT)
+                == 0) {
+                PRINTM(MSG, "ds_awake_q: timer expired\n");
+            }
+        }
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected)
+        wlan_disconnect(priv);
+
+    /* Disable interrupts on the card */
+    sbi_disable_host_int(priv);
+
+  exit:
+    sbi_unregister();
+
+    LEAVE();
+}
+
+module_init(wlan_init_module);
+module_exit(wlan_cleanup_module);
+
+MODULE_DESCRIPTION("M-WLAN Driver");
+MODULE_AUTHOR("Marvell International Ltd.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_meas.c b/drivers/net/wireless/8688_wlan/wlan/wlan_meas.c
new file mode 100755
index 0000000..55a496c
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_meas.c
@@ -0,0 +1,700 @@
+/**
+ * @file wlan_meas.c
+ *
+ *  @brief Implementation of measurement interface code with the app/firmware
+ *
+ *  Driver implementation for sending and retrieving measurement requests
+ *    and responses. 
+ *  
+ *  Current use is limited to 802.11h.
+ *
+ *  Requires use of the following preprocessor define:
+ *    - ENABLE_MEAS
+ *
+ *  @sa wlan_meas.h
+ *  
+ *  (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+
+/*****************************************************************************/
+/*  Change Log:
+** 
+**      9/30/05: Initial revision            
+**
+**
+*/
+/*****************************************************************************/
+
+/*
+** Include(s)
+*/
+#include "wlan_headers.h"
+
+/*
+** Macros
+*/
+
+/*
+** Constants
+*/
+
+//! Default measurement duration when not provided by the application
+#define WLAN_MEAS_DEFAULT_MEAS_DURATION    1000U        /* TUs */
+
+#ifdef DEBUG_LEVEL2
+//! String descriptions of the different measurement enums.  Debug display
+static const char *measTypeStr[WLAN_MEAS_NUM_TYPES] = {
+    "basic",
+#if WLAN_MEAS_EXTRA_11H_TYPES
+    "cca",
+    "rpi",
+#endif
+#if WLAN_MEAS_EXTRA_11K_TYPES
+    /* 11k additions */
+    "chnld",
+    "nzhst",
+    "beacn",
+    "frame",
+    "hidnd",
+    "msenh",
+    "stast"
+#endif
+};
+
+/** 
+*** wlan_meas_get_meas_type_str
+**
+**  @brief Retrieve the measurement string representation of a measType enum
+**
+**  Used for debug display only
+**
+**  @param measType Measurement type enumeration input for string lookup
+** 
+**  @return         Constant string representing measurement type
+*/
+static const char *
+wlan_meas_get_meas_type_str(MeasType_t measType)
+{
+    if (measType <= WLAN_MEAS_11H_MAX_TYPE) {
+        return measTypeStr[measType];
+    }
+
+    return "Invld";
+}
+#endif
+
+/**
+*** wlan_meas_dump_meas_req
+**
+**  @brief Debug print display of the input measurement request
+**
+**  @param pMeasReq  Pointer to the measurement request to dispaly
+**
+**  @return          void
+*/
+static void
+wlan_meas_dump_meas_req(const HostCmd_DS_MEASUREMENT_REQUEST * pMeasReq)
+{
+    PRINTM(INFO, "Meas: Req: ------------------------------\n");
+
+    PRINTM(INFO, "Meas: Req: macAddr: %02x:%02x:%02x:%02x:%02x:%02x\n",
+           pMeasReq->macAddr[0],
+           pMeasReq->macAddr[1],
+           pMeasReq->macAddr[2],
+           pMeasReq->macAddr[3], pMeasReq->macAddr[4], pMeasReq->macAddr[5]);
+
+    PRINTM(INFO, "Meas: Req:  dlgTkn: %d\n", pMeasReq->dialogToken);
+    PRINTM(INFO, "Meas: Req:    mode: dm[%c] rpt[%c] req[%c]\n",
+           pMeasReq->reqMode.durationMandatory ? 'X' : ' ',
+           pMeasReq->reqMode.report ? 'X' : ' ',
+           pMeasReq->reqMode.request ? 'X' : ' ');
+    PRINTM(INFO, "Meas: Req:        : en[%c] par[%c]\n",
+           pMeasReq->reqMode.enable ? 'X' : ' ',
+           pMeasReq->reqMode.parallel ? 'X' : ' ');
+    PRINTM(INFO, "Meas: Req: measTyp: %s\n",
+           wlan_meas_get_meas_type_str(pMeasReq->measType));
+
+    switch (pMeasReq->measType) {
+    case WLAN_MEAS_BASIC:
+#if WLAN_MEAS_EXTRA_11H_TYPES
+        /* Not supported in firmware */
+    case WLAN_MEAS_CCA:
+    case WLAN_MEAS_RPI:
+#endif
+        /* Lazy cheat, fields of bas, cca, rpi union match on the request */
+        PRINTM(INFO, "Meas: Req: chan: %u\n", pMeasReq->req.basic.channel);
+        PRINTM(INFO, "Meas: Req: strt: %llu\n",
+               wlan_le64_to_cpu(pMeasReq->req.basic.startTime));
+        PRINTM(INFO, "Meas: Req:  dur: %u\n",
+               wlan_le16_to_cpu(pMeasReq->req.basic.duration));
+        break;
+    default:
+        PRINTM(INFO, "Meas: Req: <unhandled>\n");
+        break;
+    }
+
+    PRINTM(INFO, "Meas: Req: ------------------------------\n");
+}
+
+/**
+*** wlan_meas_dump_meas_rpt
+**
+**  @brief Debug print display of the input measurement report
+**
+**  @param pMeasRpt  Pointer to measurement report to display
+**
+**  @return          void
+*/
+static void
+wlan_meas_dump_meas_rpt(const HostCmd_DS_MEASUREMENT_REPORT * pMeasRpt)
+{
+    PRINTM(INFO, "Meas: Rpt: ------------------------------\n");
+    PRINTM(INFO, "Meas: Rpt: macAddr: %02x:%02x:%02x:%02x:%02x:%02x\n",
+           pMeasRpt->macAddr[0],
+           pMeasRpt->macAddr[1],
+           pMeasRpt->macAddr[2],
+           pMeasRpt->macAddr[3], pMeasRpt->macAddr[4], pMeasRpt->macAddr[5]);
+
+    PRINTM(INFO, "Meas: Rpt:  dlgTkn: %d\n", pMeasRpt->dialogToken);
+
+    PRINTM(INFO, "Meas: Rpt: rptMode: (%x): Rfs[%c] ICp[%c] Lt[%c]\n",
+           *(u8 *) & pMeasRpt->rptMode,
+           pMeasRpt->rptMode.refused ? 'X' : ' ',
+           pMeasRpt->rptMode.incapable ? 'X' : ' ',
+           pMeasRpt->rptMode.late ? 'X' : ' ');
+
+    PRINTM(INFO, "Meas: Rpt: measTyp: %s\n",
+           wlan_meas_get_meas_type_str(pMeasRpt->measType));
+
+    switch (pMeasRpt->measType) {
+    case WLAN_MEAS_BASIC:
+        PRINTM(INFO, "Meas: Rpt: chan: %u\n", pMeasRpt->rpt.basic.channel);
+        PRINTM(INFO, "Meas: Rpt: strt: %llu\n",
+               wlan_le64_to_cpu(pMeasRpt->rpt.basic.startTime));
+        PRINTM(INFO, "Meas: Rpt:  dur: %u\n",
+               wlan_le16_to_cpu(pMeasRpt->rpt.basic.duration));
+        PRINTM(INFO, "Meas: Rpt:  bas: (%x): unmsd[%c], radar[%c]\n",
+               *(u8 *) & (pMeasRpt->rpt.basic.map),
+               pMeasRpt->rpt.basic.map.unmeasured ? 'X' : ' ',
+               pMeasRpt->rpt.basic.map.radar ? 'X' : ' ');
+        PRINTM(INFO, "Meas: Rpt:  bas: unidSig[%c] ofdm[%c] bss[%c]\n",
+               pMeasRpt->rpt.basic.map.unidentifiedSig ? 'X' : ' ',
+               pMeasRpt->rpt.basic.map.OFDM_Preamble ? 'X' : ' ',
+               pMeasRpt->rpt.basic.map.BSS ? 'X' : ' ');
+        break;
+#if WLAN_MEAS_EXTRA_11H_TYPES
+        /* Not supported in firmware */
+    case WLAN_MEAS_CCA:
+        PRINTM(INFO, "Meas: Rpt: chan: %u\n", pMeasRpt->rpt.cca.channel);
+        PRINTM(INFO, "Meas: Rpt: strt: %llu\n",
+               wlan_le64_to_cpu(pMeasRpt->rpt.cca.startTime));
+        PRINTM(INFO, "Meas: Rpt:  dur: %u\n",
+               wlan_le16_to_cpu(pMeasRpt->rpt.cca.duration));
+        PRINTM(INFO, "Meas: Rpt:  cca: busy fraction = %u\n",
+               pMeasRpt->rpt.cca.busyFraction);
+        break;
+    case WLAN_MEAS_RPI:
+        PRINTM(INFO, "Meas: Rpt: chan: %u\n", pMeasRpt->rpt.rpi.channel);
+        PRINTM(INFO, "Meas: Rpt: strt: %llu\n",
+               wlan_le64_to_cpu(pMeasRpt->rpt.rpi.startTime));
+        PRINTM(INFO, "Meas: Rpt:  dur: %u\n",
+               wlan_le16_to_cpu(pMeasRpt->rpt.rpi.duration));
+        PRINTM(INFO, "Meas: Rpt:  rpi: 0:%u, 1:%u, 2:%u, 3:%u\n",
+               pMeasRpt->rpt.rpi.density[0],
+               pMeasRpt->rpt.rpi.density[1],
+               pMeasRpt->rpt.rpi.density[2], pMeasRpt->rpt.rpi.density[3]);
+        PRINTM(INFO, "Meas: Rpt:  rpi: 4:%u, 5:%u, 6:%u, 7:%u\n",
+               pMeasRpt->rpt.rpi.density[4],
+               pMeasRpt->rpt.rpi.density[5],
+               pMeasRpt->rpt.rpi.density[6], pMeasRpt->rpt.rpi.density[7]);
+        break;
+#endif
+#if WLAN_MEAS_EXTRA_11K_TYPES
+        /* Future 11k measurement addditions */
+    case WLAN_MEAS_CHAN_LOAD:
+    case WLAN_MEAS_NOISE_HIST:
+    case WLAN_MEAS_BEACON:
+    case WLAN_MEAS_FRAME:
+    case WLAN_MEAS_HIDDEN_NODE:
+    case WLAN_MEAS_MEDIUM_SENS_HIST:
+    case WLAN_MEAS_STA_STATS:
+#endif
+    default:
+        PRINTM(INFO, "Meas: Rpt: <unhandled>\n");
+        break;
+    }
+
+    PRINTM(INFO, "Meas: Rpt: ------------------------------\n");
+}
+
+/**
+*** wlan_meas_cmdresp_get_report
+**
+**  @brief Retrieve a measurement report from the firmware
+** 
+**  Callback from command processing when a measurement report is received
+**    from the firmware.  Perform the following when a report is received:
+**
+**   -# Debug display the report if compiled with the appropriate flags
+**   -# If we are pending on a specific measurement report token, and it 
+**      matches the received report's token, store the report and wake up
+**      any pending threads
+**
+**  @param priv Private driver information structure
+**  @param resp HostCmd_DS_COMMAND struct returned from the firmware command
+**              passing a HostCmd_DS_MEASUREMENT_REPORT structure.    
+**
+**  @return     WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+*/
+static int
+wlan_meas_cmdresp_get_report(wlan_private * priv,
+                             const HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    const HostCmd_DS_MEASUREMENT_REPORT *pMeasRpt = &resp->params.meas_rpt;
+
+    ENTER();
+
+    PRINTM(INFO, "Meas: Rpt: %#x-%u, Seq=%u, Ret=%u\n",
+           resp->Command, resp->Size, resp->SeqNum, resp->Result);
+
+    /* 
+     ** Debug display the measurement report
+     */
+    wlan_meas_dump_meas_rpt(pMeasRpt);
+
+    /*
+     ** Check if we are pending on a measurement report and it matches 
+     **  the dialog token of the received report:
+     */
+    if (Adapter->stateMeas.meas_rpt_pend_on
+        && Adapter->stateMeas.meas_rpt_pend_on == pMeasRpt->dialogToken) {
+        PRINTM(INFO, "Meas: Rpt: RCV'd Pend on meas #%d\n",
+               Adapter->stateMeas.meas_rpt_pend_on);
+
+        /*
+         ** Clear the pending report indicator
+         */
+        Adapter->stateMeas.meas_rpt_pend_on = 0;
+
+        /*
+         ** Copy the received report into the measurement state for retrieval
+         */
+        memcpy(&Adapter->stateMeas.meas_rpt_returned, pMeasRpt,
+               sizeof(Adapter->stateMeas.meas_rpt_returned));
+
+        /*
+         ** Wake up any threads pending on the wait queue
+         */
+        wake_up_interruptible(&Adapter->stateMeas.meas_rpt_waitQ);
+    }
+
+    LEAVE();
+
+    return 0;
+}
+
+/**
+*** wlan_meas_cmd_request
+**
+**  @brief Prepare CMD_MEASURMENT_REPORT firmware command
+**
+**  @param priv     Private driver information structure
+**  @param pCmdPtr  Output parameter: Pointer to the command being prepared 
+**                  for the firmware
+**  @param pInfoBuf HostCmd_DS_MEASUREMENT_REQUEST passed as void data block
+**
+**  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+*/
+static int
+wlan_meas_cmd_request(wlan_private * priv,
+                      HostCmd_DS_COMMAND * pCmdPtr, const void *pInfoBuf)
+{
+    const HostCmd_DS_MEASUREMENT_REQUEST *pMeasReq = pInfoBuf;
+
+    ENTER();
+
+    pCmdPtr->Command = HostCmd_CMD_MEASUREMENT_REQUEST;
+    pCmdPtr->Size = sizeof(HostCmd_DS_MEASUREMENT_REQUEST) + S_DS_GEN;
+
+    memcpy(&pCmdPtr->params.meas_req, pMeasReq,
+           sizeof(pCmdPtr->params.meas_req));
+
+    PRINTM(INFO, "Meas: Req: %#x-%u, Seq=%u, Ret=%u\n",
+           pCmdPtr->Command, pCmdPtr->Size, pCmdPtr->SeqNum, pCmdPtr->Result);
+
+    wlan_meas_dump_meas_req(pMeasReq);
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+*** wlan_meas_cmd_get_report
+**
+**  @brief  Retrieve a measurement report from the firmware
+**
+**  The firmware will send a EVENT_MEAS_REPORT_RDY event when it 
+**    completes or receives a measurement report.  The event response
+**    handler will then start a HostCmd_CMD_MEASUREMENT_REPORT firmware command
+**    which gets completed for transmission to the firmware in this routine.
+**
+**  @param priv    Private driver information structure
+**  @param pCmdPtr Output parameter: Pointer to the command being prepared 
+**                 for the firmware
+**
+**  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+*/
+static int
+wlan_meas_cmd_get_report(wlan_private * priv, HostCmd_DS_COMMAND * pCmdPtr)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    pCmdPtr->Command = HostCmd_CMD_MEASUREMENT_REPORT;
+    pCmdPtr->Size = sizeof(HostCmd_DS_MEASUREMENT_REPORT) + S_DS_GEN;
+
+    memset(&pCmdPtr->params.meas_rpt, 0x00, sizeof(pCmdPtr->params.meas_rpt));
+
+    /*
+     ** Set the meas_rpt.macAddr to our mac address to get a meas report,
+     **   setting the mac to another STA address instructs the firmware
+     **   to transmit this measurement report frame instead
+     */
+    memcpy(pCmdPtr->params.meas_rpt.macAddr, Adapter->CurrentAddr,
+           sizeof(pCmdPtr->params.meas_rpt.macAddr));
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+*** wlan_meas_init
+**
+**  @brief Initialize any needed structures for the measurement code
+**
+**  @param priv  Private driver information structure
+**
+**  @return      void
+*/
+void
+wlan_meas_init(wlan_private * priv)
+{
+    init_waitqueue_head(&priv->adapter->stateMeas.meas_rpt_waitQ);
+}
+
+/** 
+*** wlan_meas_util_send_req
+** 
+**  @brief Send the input measurement request to the firmware.
+**
+**  If the dialog token in the measurement request is set to 0, the function
+**    will use an local static auto-incremented token in the measurement
+**    request.  This ensures the dialog token is always set.
+**
+**  If wait_for_resp_timeout is set, the function will block its return on 
+**     a timeout or returned measurement report that matches the request's
+**     dialog token. 
+**
+**  @param priv                  Private driver information structure
+**  @param pMeasReq              Pointer to the measurement request to send
+**  @param wait_for_resp_timeout Timeout value of the measurement request
+**                               in ms.
+**  @param pMeasRpt              Output parameter: Pointer for the resulting
+**                               measurement report
+**
+**  @return
+**    - 0 for success
+**    - -ETIMEDOUT if the measurement report does not return before
+**      the timeout expires
+**    - Error return from wlan_prepare_cmd routine otherwise
+*/
+int
+wlan_meas_util_send_req(wlan_private * priv,
+                        HostCmd_DS_MEASUREMENT_REQUEST * pMeasReq,
+                        int wait_for_resp_timeout,
+                        HostCmd_DS_MEASUREMENT_REPORT * pMeasRpt)
+{
+    static u8 autoDialogTok = 0;
+    wlan_meas_state_t *pMeasState = &priv->adapter->stateMeas;
+    int ret;
+    uint calcTimeout;
+
+    ENTER();
+
+    /*
+     **  If dialogTok was set to 0 or not provided, autoset
+     */
+    pMeasReq->dialogToken = (pMeasReq->dialogToken ?
+                             pMeasReq->dialogToken : ++autoDialogTok);
+
+    /*
+     ** Check for rollover of the dialog token.  Avoid using 0 as a token.
+     */
+    pMeasReq->dialogToken = (pMeasReq->dialogToken ?
+                             pMeasReq->dialogToken : 1);
+
+    /*
+     ** If the request is to pend waiting for the result, set the dialog token
+     **   of this measurement request in the state structure.  The measurement
+     **   report handling routines can then check the incoming measurement
+     **   reports for a match with this dialog token.  
+     */
+    if (wait_for_resp_timeout) {
+        pMeasState->meas_rpt_pend_on = pMeasReq->dialogToken;
+        PRINTM(INFO, "Meas: Req: START Pend on meas #%d\n",
+               pMeasReq->dialogToken);
+    }
+
+    /*
+     ** Send the measurement request to the firmware
+     */
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_MEASUREMENT_REQUEST,
+                           HostCmd_ACT_GEN_SET,
+                           HostCmd_OPTION_WAITFORRSP, 0, (void *) pMeasReq);
+
+    /*
+     ** If the measurement request was sent successfully, and the function
+     **   must wait for the report, suspend execution until the meas_rpt_pend_on
+     **   variable in the state structure has been reset to 0 by the report
+     **   handling routines.
+     */
+    if (ret == 0 && wait_for_resp_timeout) {
+        /* Add ~25% overhead to the timeout for firmware overhead */
+        calcTimeout = wait_for_resp_timeout + (wait_for_resp_timeout >> 2);
+
+        PRINTM(INFO, "Meas: Req: TIMEOUT set to %d ms\n", calcTimeout);
+
+        /* 10 ticks extra for the driver overhead - helps with small meas */
+        calcTimeout = (calcTimeout * HZ) / 1000 + 10;
+
+        PRINTM(INFO, "Meas: Req: TIMEOUT set to %d ticks\n", calcTimeout);
+
+        os_wait_interruptible_timeout(pMeasState->meas_rpt_waitQ,
+                                      pMeasState->meas_rpt_pend_on == 0,
+                                      calcTimeout);
+
+        if (pMeasState->meas_rpt_pend_on) {
+            PRINTM(INFO, "Meas: Req: TIMEOUT Pend on meas #%d\n",
+                   pMeasReq->dialogToken);
+            ret = -ETIMEDOUT;
+        } else {
+            PRINTM(INFO, "Meas: Req: DONE Pend on meas #%d\n",
+                   pMeasReq->dialogToken);
+            memcpy(pMeasRpt, &pMeasState->meas_rpt_returned,
+                   sizeof(HostCmd_DS_MEASUREMENT_REPORT));
+        }
+    }
+
+    /*
+     ** The measurement request failed or we are not waiting for a response.
+     **   In either case, the rpt_pend_on variable should be zero.
+     */
+    pMeasState->meas_rpt_pend_on = 0;
+
+    LEAVE();
+
+    return ret;
+}
+
+/**
+*** wlan_meas_cmd_process
+**
+**  @brief  Prepare the HostCmd_DS_Command structure for a measurement command.
+**
+**  Use the Command field to determine if the command being set up is for
+**     11h and call one of the local command handlers accordingly for:
+**
+**        - HostCmd_CMD_MEASUREMENT_REQUEST
+**        - HostCmd_CMD_MEASUREMENT_REPORT
+**
+**  @param priv     Private driver information structure
+**  @param pCmdPtr  Output parameter: Pointer to the command being prepared 
+**                  for the firmware
+**  @param pInfoBuf Void buffer passthrough with data necessary for a
+**                  specific command type
+**
+**  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+**
+**  @sa wlan_meas_cmd_request
+**  @sa wlan_meas_cmd_get_report
+*/
+int
+wlan_meas_cmd_process(wlan_private * priv,
+                      HostCmd_DS_COMMAND * pCmdPtr, const void *pInfoBuf)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    switch (pCmdPtr->Command) {
+    case HostCmd_CMD_MEASUREMENT_REQUEST:
+        ret = wlan_meas_cmd_request(priv, pCmdPtr, pInfoBuf);
+        break;
+    case HostCmd_CMD_MEASUREMENT_REPORT:
+        ret = wlan_meas_cmd_get_report(priv, pCmdPtr);
+        break;
+    default:
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    pCmdPtr->Command = wlan_cpu_to_le16(pCmdPtr->Command);
+    pCmdPtr->Size = wlan_cpu_to_le16(pCmdPtr->Size);
+
+    return ret;
+}
+
+/**
+*** wlan_meas_cmdresp_process
+**
+**  @brief Handle the command response from the firmware for a measurement 
+**         command
+**
+**  Use the Command field to determine if the command response being
+**    is for meas.  Call the local command response handler accordingly for:
+**
+**        - HostCmd_CMD_802_MEASUREMENT_REQUEST
+**        - HostCmd_CMD_802_MEASUREMENT_REPORT
+**
+**  @param priv Private driver information structure
+**  @param resp HostCmd_DS_COMMAND struct returned from the firmware command
+**
+**  @return     WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+*/
+int
+wlan_meas_cmdresp_process(wlan_private * priv,
+                          const HostCmd_DS_COMMAND * resp)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    switch (resp->Command) {
+    case HostCmd_CMD_MEASUREMENT_REQUEST:
+        PRINTM(INFO, "Meas: Req Resp: Sz=%u, Seq=%u, Ret=%u\n",
+               resp->Size, resp->SeqNum, resp->Result);
+
+        break;
+    case HostCmd_CMD_MEASUREMENT_REPORT:
+        ret = wlan_meas_cmdresp_get_report(priv, resp);
+        break;
+    default:
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    return ret;
+}
+
+/**
+*** wlan_meas_ioctl_send_req
+**
+**  @brief Send a measurment request to the firmware from the application
+**
+**  Process an IOCTL from the application for a measurement request.  The
+**    application thread will be blocked while the measurement completes or
+**    times out.
+**
+**  If the measurement is a success, the measurement report will be copied
+**    back to the user space.
+**
+**  @param priv Private driver information structure
+**  @param wrq  Input/Output parameter: OS IOCTL passed structure containing:
+**                 - HostCmd_DS_MEASUREMENT_REQUEST on input
+**                 - HostCmd_DS_MEASUREMENT_REQUEST on output 
+**
+**  @return
+**    - 0 for success
+**    - -EFAULT if memory copy from user space failes
+**    - Error return from wlan_meas_util_send_req routine otherwise
+*/
+int
+wlan_meas_ioctl_send_req(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_MEASUREMENT_REQUEST measReq;
+    HostCmd_DS_MEASUREMENT_REPORT measRpt;
+    int wait_for_resp_timeout = 0;
+    int ret = 0;
+    u8 zeroMac[] = { 0, 0, 0, 0, 0, 0 };
+
+    ENTER();
+
+    memset(&measReq, 0x00, sizeof(measReq));
+    memset(&measRpt, 0x00, sizeof(measRpt));
+
+    if (copy_from_user(&measReq, wrq->u.data.pointer, sizeof(measReq)) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "Meas: ioctl_send_req: copy from user failed\n");
+        return -EFAULT;
+    }
+
+    /*
+     ** If measDuration was set to 0, set to default
+     */
+    if (measReq.req.basic.duration == 0) {
+        measReq.req.basic.duration = WLAN_MEAS_DEFAULT_MEAS_DURATION;
+    }
+    measReq.req.basic.duration = wlan_cpu_to_le16(measReq.req.basic.duration);
+
+    /*
+     ** Provide a timeout time for the measurement based on the duration.
+     */
+    wait_for_resp_timeout = measReq.req.basic.duration;
+
+    /*
+     ** If the measChannel was set to 0 or not provided, re-sync the 
+     **   Channel field in Adapter struct for use in the request
+     */
+    if (measReq.req.basic.channel == 0) {
+        wlan_prepare_cmd(priv, HostCmd_CMD_802_11_RF_CHANNEL,
+                         HostCmd_OPT_802_11_RF_CHANNEL_GET,
+                         HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+        measReq.req.basic.channel
+            = Adapter->CurBssParams.BSSDescriptor.Channel;
+    }
+
+    if (memcmp(measReq.macAddr, zeroMac, sizeof(zeroMac)) == 0) {
+        /*
+         ** Set the measReq.macAddr to our mac address if it was not provided
+         */
+        memcpy(measReq.macAddr, Adapter->CurrentAddr,
+               sizeof(measReq.macAddr));
+    }
+
+    /*
+     ** Finish setup of the measurement request and send to the firmware
+     */
+    ret = wlan_meas_util_send_req(priv, &measReq,
+                                  wait_for_resp_timeout, &measRpt);
+
+    if (ret == 0) {
+        /*
+         ** The request was sent successfully and the report received and stored
+         **   in the measurement state before execution returned from
+         **   the wlan_send_meas_req function.
+         */
+        wrq->u.data.length = sizeof(measRpt);
+        if (copy_to_user(wrq->u.data.pointer, &measRpt, wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+
+    return ret;
+}
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_meas.h b/drivers/net/wireless/8688_wlan/wlan/wlan_meas.h
new file mode 100755
index 0000000..e27bf3d
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_meas.h
@@ -0,0 +1,93 @@
+/**
+ *  @file wlan_meas.h
+ *
+ *  @brief Interface for the measurement module implemented in wlan_meas.c
+ *
+ *  Driver interface functions and type declarations for the measurement module
+ *    implemented in wlan_meas.c
+ *  
+ *  @sa wlan_meas.c
+ *
+ *  (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+
+/*****************************************************************************/
+/*  Change Log:
+** 
+**      9/30/05: Initial revision            
+**
+**
+*/
+/*****************************************************************************/
+
+#ifndef _WLAN_MEAS_H
+#define _WLAN_MEAS_H
+
+#include  "wlan_fw.h"
+
+#ifdef __KERNEL__               /* state is only used in the driver, exempt from app code */
+/**
+*** @brief Driver measurement state held in wlan_priv structure
+**  
+**  Used to record a measurement request that the driver is pending on 
+**    the result (received measurement report).
+*/
+typedef struct
+{
+    /**
+    *** Dialog token of a pending measurement request/report.  Used to
+    ***   block execution while waiting for the specific dialog token
+    **/
+    u8 meas_rpt_pend_on;
+
+    /**
+    *** Measurement report received from the firmware that we were pending on
+    **/
+    HostCmd_DS_MEASUREMENT_REPORT meas_rpt_returned;
+
+    /**
+    *** OS wait queue used to suspend the requesting thread
+    **/
+    wait_queue_head_t meas_rpt_waitQ;
+
+} wlan_meas_state_t;
+
+/* Initialize the measurement code on startup */
+extern void wlan_meas_init(wlan_private * priv);
+
+/* Send a given measurement request to the firmware, report back the result */
+extern int
+wlan_meas_util_send_req(wlan_private * priv,
+                        HostCmd_DS_MEASUREMENT_REQUEST * pMeasReq,
+                        int wait_for_resp_timeout,
+                        HostCmd_DS_MEASUREMENT_REPORT * pMeasRpt);
+
+/* Setup a measurement command before it is sent to the firmware */
+extern int wlan_meas_cmd_process(wlan_private * priv,
+                                 HostCmd_DS_COMMAND * pCmdPtr,
+                                 const void *pInfoBuf);
+
+/* Handle a given measurement command response from the firmware */
+extern int wlan_meas_cmdresp_process(wlan_private * priv,
+                                     const HostCmd_DS_COMMAND * resp);
+
+/* Process an application ioctl for sending a measurement request */
+extern int wlan_meas_ioctl_send_req(wlan_private * priv, struct iwreq *wrq);
+
+#endif /* WLANCONFIG */
+
+#endif
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_proc.c b/drivers/net/wireless/8688_wlan/wlan/wlan_proc.c
new file mode 100755
index 0000000..c3047c3
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_proc.c
@@ -0,0 +1,223 @@
+/** @file wlan_proc.c
+  * @brief This file contains functions for proc fin proc file.
+  * 
+  * (c) Copyright © 2003-2006, Marvell International Ltd. 
+  *
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	10/04/05: Add Doxygen format comments
+	01/05/06: Add kernel 2.6.x support	
+	
+********************************************************/
+#include 	"wlan_headers.h"
+
+#ifdef CONFIG_PROC_FS
+/********************************************************
+		Local Variables
+********************************************************/
+
+static char *szModes[] = {
+    "Ad-hoc",
+    "Managed",
+    "Auto",
+    "Unknown"
+};
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief proc read function
+ *
+ *  @param page	   pointer to buffer
+ *  @param start   read data starting position
+ *  @param offset  offset
+ *  @param count   counter 
+ *  @param eof     end of file flag
+ *  @param data    data to output
+ *  @return 	   number of output data
+ */
+static int
+wlan_proc_read(char *page, char **start, off_t offset,
+               int count, int *eof, void *data)
+{
+    int i;
+    char *p = page;
+    struct net_device *netdev = data;
+    struct dev_mc_list *mcptr = netdev->mc_list;
+    char fmt[64];
+    wlan_private *priv = netdev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    ulong flags;
+
+    if (offset != 0) {
+        *eof = 1;
+        goto exit;
+    }
+
+    get_version(Adapter, fmt, sizeof(fmt) - 1);
+
+    p += sprintf(p, "driver_name = " "\"wlan\"\n");
+    p += sprintf(p, "driver_version = %s", fmt);
+    p += sprintf(p, "\nInterfaceName=\"%s\"\n", netdev->name);
+    p += sprintf(p, "Mode=\"%s\"\n", szModes[Adapter->InfrastructureMode]);
+    p += sprintf(p, "State=\"%s\"\n",
+                 ((Adapter->MediaConnectStatus ==
+                   WlanMediaStateDisconnected) ? "Disconnected" :
+                  "Connected"));
+    p += sprintf(p, "MACAddress=\"%02x:%02x:%02x:%02x:%02x:%02x\"\n",
+                 netdev->dev_addr[0], netdev->dev_addr[1],
+                 netdev->dev_addr[2], netdev->dev_addr[3],
+                 netdev->dev_addr[4], netdev->dev_addr[5]);
+
+    p += sprintf(p, "MCCount=\"%d\"\n", netdev->mc_count);
+    p += sprintf(p, "ESSID=\"%s\"\n",
+                 (u8 *) Adapter->CurBssParams.BSSDescriptor.Ssid.Ssid);
+    p += sprintf(p, "Channel=\"%d\"\n",
+                 Adapter->CurBssParams.BSSDescriptor.Channel);
+    p += sprintf(p, "region_code = \"%02x\"\n", (u32) Adapter->RegionCode);
+
+    /*
+     * Put out the multicast list 
+     */
+    for (i = 0; i < netdev->mc_count; i++) {
+        p += sprintf(p,
+                     "MCAddr[%d]=\"%02x:%02x:%02x:%02x:%02x:%02x\"\n",
+                     i,
+                     mcptr->dmi_addr[0], mcptr->dmi_addr[1],
+                     mcptr->dmi_addr[2], mcptr->dmi_addr[3],
+                     mcptr->dmi_addr[4], mcptr->dmi_addr[5]);
+
+        mcptr = mcptr->next;
+    }
+    p += sprintf(p, "num_tx_bytes = %lu\n", priv->stats.tx_bytes);
+    p += sprintf(p, "num_rx_bytes = %lu\n", priv->stats.rx_bytes);
+    p += sprintf(p, "num_tx_pkts = %lu\n", priv->stats.tx_packets);
+    p += sprintf(p, "num_rx_pkts = %lu\n", priv->stats.rx_packets);
+    p += sprintf(p, "num_tx_pkts_dropped = %lu\n", priv->stats.tx_dropped);
+    p += sprintf(p, "num_rx_pkts_dropped = %lu\n", priv->stats.rx_dropped);
+    p += sprintf(p, "num_tx_pkts_err = %lu\n", priv->stats.tx_errors);
+    p += sprintf(p, "num_rx_pkts_err = %lu\n", priv->stats.rx_errors);
+    p += sprintf(p, "carrier %s\n",
+                 ((netif_carrier_ok(priv->wlan_dev.netdev)) ? "on" : "off"));
+    p += sprintf(p, "tx queue %s\n",
+                 ((netif_queue_stopped(priv->wlan_dev.netdev)) ? "stopped" :
+                  "started"));
+
+    spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
+    if (Adapter->CurCmd) {
+        HostCmd_DS_COMMAND *CmdPtr =
+            (HostCmd_DS_COMMAND *) Adapter->CurCmd->BufVirtualAddr;
+        p += sprintf(p, "CurCmd ID = 0x%x, 0x%x\n",
+                     wlan_cpu_to_le16(CmdPtr->Command),
+                     wlan_cpu_to_le16(*(u16 *) ((u8 *) CmdPtr + S_DS_GEN)));
+    } else {
+        p += sprintf(p, "CurCmd NULL\n");
+    }
+    spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
+
+  exit:
+    return (p - page);
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief create wlan proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @param dev     pointer net_device
+ *  @return 	   N/A
+ */
+void
+wlan_proc_entry(wlan_private * priv, struct net_device *dev)
+{
+
+    struct proc_dir_entry *r;
+
+    PRINTM(INFO, "Creating Proc Interface\n");
+    if (!priv->proc_mwlan) {
+        priv->proc_mwlan = proc_mkdir("mwlan", init_net.proc_net);
+        if (!priv->proc_mwlan)
+            return;
+        priv->proc_entry = proc_mkdir(dev->name, priv->proc_mwlan);
+
+        if (priv->proc_entry) {
+            r = create_proc_read_entry("info", 0, priv->proc_entry,
+                                       wlan_proc_read, dev);
+        }
+    }
+}
+
+/** 
+ *  @brief remove proc file
+ *
+ *  @param priv	   pointer wlan_private
+ *  @return 	   N/A
+ */
+void
+wlan_proc_remove(wlan_private * priv)
+{
+    if (priv->proc_mwlan) {
+        if (priv->proc_entry) {
+            remove_proc_entry("info", priv->proc_entry);
+        }
+        remove_proc_entry(priv->wlan_dev.netdev->name, priv->proc_mwlan);
+        remove_proc_entry("mwlan", init_net.proc_net);
+    }
+}
+
+/** 
+ *  @brief convert string to number
+ *
+ *  @param s   	   pointer to numbered string
+ *  @return 	   converted number from string s
+ */
+int
+string_to_number(char *s)
+{
+    int r = 0;
+    int base = 0;
+
+    if ((strncmp(s, "0x", 2) == 0) || (strncmp(s, "0X", 2) == 0))
+        base = 16;
+    else
+        base = 10;
+    if (base == 16)
+        s += 2;
+    for (s = s; *s != 0; s++) {
+        if ((*s >= 48) && (*s <= 57))
+            r = (r * base) + (*s - 48);
+        else if ((*s >= 65) && (*s <= 70))
+            r = (r * base) + (*s - 55);
+        else if ((*s >= 97) && (*s <= 102))
+            r = (r * base) + (*s - 87);
+        else
+            break;
+    }
+
+    return r;
+}
+
+#endif
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_rx.c b/drivers/net/wireless/8688_wlan/wlan/wlan_rx.c
new file mode 100755
index 0000000..8d3f664
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_rx.c
@@ -0,0 +1,315 @@
+/** @file wlan_rx.c
+  * @brief This file contains the handling of RX in wlan
+  * driver.
+  * 
+  * (c) Copyright © 2003-2006, Marvell International Ltd.  
+  *   
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	09/28/05: Add Doxygen format comments
+	12/09/05: ADD Sliding window SNR/NF Average Calculation support
+	
+********************************************************/
+
+#include	"wlan_headers.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+typedef struct
+{
+    /** Ethernet header destination address */
+    u8 dest_addr[ETH_ALEN];
+    /** Ethernet header source address */
+    u8 src_addr[ETH_ALEN];
+    /** Ethernet header length */
+    u16 h803_len;
+
+} __ATTRIB_PACK__ Eth803Hdr_t;
+
+typedef struct
+{
+    /** LLC DSAP */
+    u8 llc_dsap;
+    /** LLC SSAP */
+    u8 llc_ssap;
+    /** LLC CTRL */
+    u8 llc_ctrl;
+    /** SNAP OUI */
+    u8 snap_oui[3];
+    /** SNAP type */
+    u16 snap_type;
+
+} __ATTRIB_PACK__ Rfc1042Hdr_t;
+
+typedef struct
+{
+    /** Etherner header */
+    Eth803Hdr_t eth803_hdr;
+    /** RFC 1042 header */
+    Rfc1042Hdr_t rfc1042_hdr;
+
+} __ATTRIB_PACK__ RxPacketHdr_t;
+
+typedef struct
+{
+    /** Ethernet II header destination address */
+    u8 dest_addr[ETH_ALEN];
+    /** Ethernet II header source address */
+    u8 src_addr[ETH_ALEN];
+    /** Ethernet II header length */
+    u16 ethertype;
+
+} __ATTRIB_PACK__ EthII_Hdr_t;
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function computes the AvgSNR .
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   AvgSNR
+ */
+static u8
+wlan_get_data_avg_snr(wlan_private * priv)
+{
+    u8 i;
+    u16 temp = 0;
+    wlan_adapter *Adapter = priv->adapter;
+    if (Adapter->numSNRNF == 0)
+        return 0;
+    for (i = 0; i < Adapter->numSNRNF; i++)
+        temp += Adapter->rawSNR[i];
+    return (u8) (temp / Adapter->numSNRNF);
+
+}
+
+/** 
+ *  @brief This function computes the AvgNF
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   AvgNF
+ */
+static u8
+wlan_get_data_avg_nf(wlan_private * priv)
+{
+    u8 i;
+    u16 temp = 0;
+    wlan_adapter *Adapter = priv->adapter;
+    if (Adapter->numSNRNF == 0)
+        return 0;
+    for (i = 0; i < Adapter->numSNRNF; i++)
+        temp += Adapter->rawNF[i];
+    return (u8) (temp / Adapter->numSNRNF);
+
+}
+
+/** 
+ *  @brief This function save the raw SNR/NF to our internel buffer
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param pRxPD   A pointer to RxPD structure of received packet
+ *  @return 	   n/a
+ */
+static void
+wlan_save_data_snr_nf(wlan_private * priv, RxPD * pRxPD)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    if (Adapter->numSNRNF < Adapter->data_avg_factor)
+        Adapter->numSNRNF++;
+    Adapter->rawSNR[Adapter->nextSNRNF] = pRxPD->SNR;
+    Adapter->rawNF[Adapter->nextSNRNF] = pRxPD->NF;
+    Adapter->nextSNRNF++;
+    if (Adapter->nextSNRNF >= Adapter->data_avg_factor)
+        Adapter->nextSNRNF = 0;
+    return;
+}
+
+/** 
+ *  @brief This function computes the RSSI in received packet.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param pRxPD   A pointer to RxPD structure of received packet
+ *  @return 	   n/a
+ */
+static void
+wlan_compute_rssi(wlan_private * priv, RxPD * pRxPD)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, "RxPD: SNR = %d, NF = %d\n", pRxPD->SNR, pRxPD->NF);
+
+    Adapter->SNR[TYPE_RXPD][TYPE_NOAVG] = pRxPD->SNR;
+    Adapter->NF[TYPE_RXPD][TYPE_NOAVG] = pRxPD->NF;
+    wlan_save_data_snr_nf(priv, pRxPD);
+
+    Adapter->RxPDAge = os_time_get();
+    Adapter->RxPDRate = pRxPD->RxRate;
+
+    Adapter->SNR[TYPE_RXPD][TYPE_AVG] =
+        wlan_get_data_avg_snr(priv) * AVG_SCALE;
+    Adapter->NF[TYPE_RXPD][TYPE_AVG] = wlan_get_data_avg_nf(priv) * AVG_SCALE;
+    PRINTM(INFO, "SNR-avg = %d, NF-avg = %d\n",
+           Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+           Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+
+    Adapter->RSSI[TYPE_RXPD][TYPE_NOAVG] =
+        CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_NOAVG],
+                 Adapter->NF[TYPE_RXPD][TYPE_NOAVG]);
+
+    Adapter->RSSI[TYPE_RXPD][TYPE_AVG] =
+        CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+                 Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+    LEAVE();
+}
+
+/********************************************************
+		Global functions
+********************************************************/
+
+/**
+ *  @brief This function processes received packet and forwards it
+ *  to kernel/upper layer
+ *  
+ *  @param priv    A pointer to wlan_private
+ *  @param skb     A pointer to skb which includes the received packet
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_process_rx_packet(wlan_private * priv, struct sk_buff *skb)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    RxPacketHdr_t *pRxPkt;
+    RxPD *pRxPD;
+
+    int hdrChop;
+    EthII_Hdr_t *pEthHdr;
+    u32 u32SkbLen = skb->len;
+
+    const u8 rfc1042_eth_hdr[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+
+    ENTER();
+
+    pRxPD = (RxPD *) skb->data;
+    pRxPkt = (RxPacketHdr_t *) ((u8 *) pRxPD + pRxPD->PktOffset);
+
+    DBG_HEXDUMP(DAT_D, "Rx", skb->data, MIN(skb->len, MAX_DATA_DUMP_LEN));
+
+    endian_convert_RxPD(pRxPD);
+
+#define RX_PKT_TYPE_DEBUG  0xEF
+#define DBG_TYPE_SMALL  2
+#define SIZE_OF_DBG_STRUCT 4
+    if (pRxPD->RxPacketType == RX_PKT_TYPE_DEBUG) {
+        u8 dbgType;
+        dbgType = *(u8 *) & pRxPkt->eth803_hdr;
+        if (dbgType == DBG_TYPE_SMALL) {
+            PRINTM(FW_D, "\n");
+            DBG_HEXDUMP(FW_D, "FWDBG",
+                        (char *) ((u8 *) & pRxPkt->eth803_hdr +
+                                  SIZE_OF_DBG_STRUCT), pRxPD->PktLen);
+            PRINTM(FW_D, "FWDBG::\n");
+        }
+        kfree_skb(skb);
+        goto done;
+    }
+
+    if (skb->len < (ETH_HLEN + 8 + pRxPD->PktOffset)) {
+        PRINTM(ERROR, "RX Error: FRAME RECEIVED WITH BAD LENGTH\n");
+        priv->stats.rx_length_errors++;
+        ret = WLAN_STATUS_SUCCESS;
+        kfree_skb(skb);
+        goto done;
+    }
+
+    PRINTM(INFO, "RX Data: skb->len - pRxPD->PktOffset = %d - %d = %d\n",
+           skb->len, pRxPD->PktOffset, skb->len - pRxPD->PktOffset);
+
+    HEXDUMP("RX Data: Dest", pRxPkt->eth803_hdr.dest_addr,
+            sizeof(pRxPkt->eth803_hdr.dest_addr));
+    HEXDUMP("RX Data: Src", pRxPkt->eth803_hdr.src_addr,
+            sizeof(pRxPkt->eth803_hdr.src_addr));
+
+    if (memcmp(&pRxPkt->rfc1042_hdr,
+               rfc1042_eth_hdr, sizeof(rfc1042_eth_hdr)) == 0) {
+        /* 
+         *  Replace the 803 header and rfc1042 header (llc/snap) with an 
+         *    EthernetII header, keep the src/dst and snap_type (ethertype)
+         *
+         *  The firmware only passes up SNAP frames converting
+         *    all RX Data from 802.11 to 802.2/LLC/SNAP frames.
+         *
+         *  To create the Ethernet II, just move the src, dst address right
+         *    before the snap_type.
+         */
+        pEthHdr = (EthII_Hdr_t *)
+            ((u8 *) & pRxPkt->eth803_hdr
+             + sizeof(pRxPkt->eth803_hdr) + sizeof(pRxPkt->rfc1042_hdr)
+             - sizeof(pRxPkt->eth803_hdr.dest_addr)
+             - sizeof(pRxPkt->eth803_hdr.src_addr)
+             - sizeof(pRxPkt->rfc1042_hdr.snap_type));
+
+        memcpy(pEthHdr->src_addr, pRxPkt->eth803_hdr.src_addr,
+               sizeof(pEthHdr->src_addr));
+        memcpy(pEthHdr->dest_addr, pRxPkt->eth803_hdr.dest_addr,
+               sizeof(pEthHdr->dest_addr));
+
+        /* Chop off the RxPD + the excess memory from the 802.2/llc/snap header
+         *   that was removed 
+         */
+        hdrChop = (u8 *) pEthHdr - (u8 *) pRxPD;
+    } else {
+        HEXDUMP("RX Data: LLC/SNAP",
+                (u8 *) & pRxPkt->rfc1042_hdr, sizeof(pRxPkt->rfc1042_hdr));
+
+        /* Chop off the RxPD */
+        hdrChop = (u8 *) & pRxPkt->eth803_hdr - (u8 *) pRxPD;
+    }
+
+    /* Chop off the leading header bytes so the skb points to the start of 
+     *   either the reconstructed EthII frame or the 802.2/llc/snap frame
+     */
+    skb_pull(skb, hdrChop);
+
+    u32SkbLen = skb->len;
+    wlan_compute_rssi(priv, pRxPD);
+
+    if (os_upload_rx_packet(priv, skb)) {
+        PRINTM(ERROR, "RX Error: os_upload_rx_packet" " returns failure\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    priv->stats.rx_bytes += u32SkbLen;
+    priv->stats.rx_packets++;
+
+    PRINTM(DATA, "Data => kernel\n");
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    LEAVE();
+
+    return (ret);
+}
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_scan.c b/drivers/net/wireless/8688_wlan/wlan/wlan_scan.c
new file mode 100755
index 0000000..187ace1
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_scan.c
@@ -0,0 +1,3542 @@
+/** @file wlan_scan.c
+ *
+ *  @brief Functions implementing wlan scan IOCTL and firmware command APIs
+ *
+ *  IOCTL handlers as well as command preperation and response routines
+ *   for sending scan commands to the firmware.
+ *
+ *  (c) Copyright © 2003-2007, Marvell International Ltd.  
+ *   
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change Log:
+    01/11/06: Initial revision. New scan code, relocate related functions
+    01/19/06: Update specific scan routines to discard old results for adhoc
+    01/31/06: Add support for selectively enabling the FW Scan channel filter
+
+************************************************************/
+
+#include    "wlan_headers.h"
+
+/********************************************************
+    Local Constants
+********************************************************/
+
+//! Approximate amount of data needed to pass a scan result back to iwlist
+#define MAX_SCAN_CELL_SIZE  (IW_EV_ADDR_LEN             \
+                             + MRVDRV_MAX_SSID_LENGTH   \
+                             + IW_EV_UINT_LEN           \
+                             + IW_EV_FREQ_LEN           \
+                             + IW_EV_QUAL_LEN           \
+                             + MRVDRV_MAX_SSID_LENGTH   \
+                             + IW_EV_PARAM_LEN          \
+                             + 40)      /* 40 for WPAIE */
+
+//! Memory needed to store a max sized Channel List TLV for a firmware scan
+#define CHAN_TLV_MAX_SIZE  (sizeof(MrvlIEtypesHeader_t)                  \
+                            + (MRVDRV_MAX_CHANNELS_PER_SPECIFIC_SCAN     \
+                               * sizeof(ChanScanParamSet_t)))
+
+//! Memory needed to store a max number/size WildCard SSID TLV for a firmware scan
+#define WILDCARD_SSID_TLV_MAX_SIZE  \
+		(MRVDRV_MAX_SSID_LIST_LENGTH  * (sizeof(MrvlIEtypes_WildCardSsIdParamSet_t) + MRVDRV_MAX_SSID_LENGTH))
+
+//! Maximum memory needed for a wlan_scan_cmd_config with all TLVs at max
+#define MAX_SCAN_CFG_ALLOC (sizeof(wlan_scan_cmd_config)        \
+                            + sizeof(MrvlIEtypes_NumProbes_t)   \
+                            + CHAN_TLV_MAX_SIZE                 \
+                            + WILDCARD_SSID_TLV_MAX_SIZE)
+
+//! The maximum number of channels the firmware can scan per command
+#define MRVDRV_MAX_CHANNELS_PER_SPECIFIC_SCAN   14
+
+/**
+ * @brief Number of channels to scan per firmware scan command issuance.
+ *
+ *  Number restricted to prevent hitting the limit on the amount of scan data
+ *  returned in a single firmware scan command.
+ */
+#define MRVDRV_CHANNELS_PER_SCAN_CMD   4
+
+//! Macro to enable/disable SSID checking before storing a scan table
+#ifdef DISCARD_BAD_SSID
+#define CHECK_SSID_IS_VALID(x) ssid_valid(&bssidEntry.Ssid)
+#else
+#define CHECK_SSID_IS_VALID(x) TRUE
+#endif
+
+/********************************************************
+    Local Variables and Types
+********************************************************/
+
+/**
+ * @brief Interally used to send a configured scan cmd between driver routines
+ */
+typedef union
+{
+    wlan_scan_cmd_config config;        //!< Scan configuration (variable length)
+    u8 configAllocBuf[MAX_SCAN_CFG_ALLOC];      //!< Max allocated block
+} wlan_scan_cmd_config_tlv;
+
+/**
+ *  @brief Check if a scanned network compatible with the driver settings
+ *
+ *   WEP     WPA     WPA2    ad-hoc  encrypt                      Network
+ * enabled enabled  enabled   AES     mode   Privacy  WPA  WPA2  Compatible
+ *    0       0        0       0      NONE      0      0    0   yes No security
+ *    0       1        0       0       x        1x     1    x   yes WPA
+ *    0       0        1       0       x        1x     x    1   yes WPA2
+ *    0       0        0       1      NONE      1      0    0   yes Ad-hoc AES
+ *
+ *    1       0        0       0      NONE      1      0    0   yes Static WEP
+ *    0       0        0       0     !=NONE     1      0    0   yes Dynamic WEP
+ *
+ *
+ *  @param Adapter A pointer to wlan_adapter
+ *  @param index   Index in ScanTable to check against current driver settings
+ *  @param mode    Network mode: Infrastructure or IBSS
+ *
+ *  @return        Index in ScanTable, or error code if negative
+ */
+static int
+wlan_is_network_compatible(wlan_adapter * Adapter, int index, int mode)
+{
+    BSSDescriptor_t *pBSSDesc;
+
+    ENTER();
+
+    pBSSDesc = &Adapter->ScanTable[index];
+
+    /* Don't check for compatibility if roaming */
+    if ((Adapter->MediaConnectStatus == WlanMediaStateConnected)
+        && (Adapter->InfrastructureMode == Wlan802_11Infrastructure)
+        && (pBSSDesc->InfrastructureMode == Wlan802_11Infrastructure)) {
+        LEAVE();
+        return index;
+    }
+
+    if (Adapter->wps.SessionEnable == TRUE) {
+        PRINTM(INFO, "Return success directly in WPS period\n");
+        LEAVE();
+        return index;
+    }
+
+    if (pBSSDesc->InfrastructureMode == mode) {
+        if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+            && !Adapter->SecInfo.WPAEnabled
+            && !Adapter->SecInfo.WPA2Enabled
+            && ((!pBSSDesc->pWpaIE) ||
+                ((*(pBSSDesc->pWpaIE)).VendHdr.ElementId != WPA_IE))
+            && ((!pBSSDesc->pRsnIE) ||
+                ((*(pBSSDesc->pRsnIE)).IeeeHdr.ElementId != RSN_IE))
+            && !Adapter->AdhocAESEnabled &&
+            Adapter->SecInfo.EncryptionMode == CIPHER_NONE &&
+            !pBSSDesc->Privacy) {
+            /* no security */
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled
+                   && !Adapter->SecInfo.WPAEnabled
+                   && !Adapter->SecInfo.WPA2Enabled
+                   && !Adapter->AdhocAESEnabled && pBSSDesc->Privacy) {
+            /* static WEP enabled */
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+                   && Adapter->SecInfo.WPAEnabled
+                   && !Adapter->SecInfo.WPA2Enabled
+                   && ((pBSSDesc->pWpaIE) &&
+                       ((*(pBSSDesc->pWpaIE)).VendHdr.ElementId == WPA_IE))
+                   && !Adapter->AdhocAESEnabled
+                   /* Privacy bit may NOT be set in some APs like LinkSys WRT54G
+                      && pBSSDesc->Privacy */
+            ) {
+            /* WPA enabled */
+            PRINTM(INFO,
+                   "wlan_is_network_compatible() WPA: index=%d wpa_ie=%#x "
+                   "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s EncMode=%#x "
+                   "privacy=%#x\n", index,
+                   (pBSSDesc->pWpaIE) ? (*(pBSSDesc->pWpaIE)).VendHdr.
+                   ElementId : 0,
+                   (pBSSDesc->pRsnIE) ? (*(pBSSDesc->pRsnIE)).IeeeHdr.
+                   ElementId : 0,
+                   (Adapter->SecInfo.WEPStatus ==
+                    Wlan802_11WEPEnabled) ? "e" : "d",
+                   (Adapter->SecInfo.WPAEnabled) ? "e" : "d",
+                   (Adapter->SecInfo.WPA2Enabled) ? "e" : "d",
+                   Adapter->SecInfo.EncryptionMode, pBSSDesc->Privacy);
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+                   && !Adapter->SecInfo.WPAEnabled
+                   && Adapter->SecInfo.WPA2Enabled
+                   && ((pBSSDesc->pRsnIE) &&
+                       ((*(pBSSDesc->pRsnIE)).IeeeHdr.ElementId == RSN_IE))
+                   && !Adapter->AdhocAESEnabled
+                   /* Privacy bit may NOT be set in some APs like LinkSys WRT54G
+                      && pBSSDesc->Privacy */
+            ) {
+            /* WPA2 enabled */
+            PRINTM(INFO,
+                   "wlan_is_network_compatible() WPA2: index=%d wpa_ie=%#x "
+                   "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s EncMode=%#x "
+                   "privacy=%#x\n", index,
+                   (pBSSDesc->pWpaIE) ? (*(pBSSDesc->pWpaIE)).VendHdr.
+                   ElementId : 0,
+                   (pBSSDesc->pRsnIE) ? (*(pBSSDesc->pRsnIE)).IeeeHdr.
+                   ElementId : 0,
+                   (Adapter->SecInfo.WEPStatus ==
+                    Wlan802_11WEPEnabled) ? "e" : "d",
+                   (Adapter->SecInfo.WPAEnabled) ? "e" : "d",
+                   (Adapter->SecInfo.WPA2Enabled) ? "e" : "d",
+                   Adapter->SecInfo.EncryptionMode, pBSSDesc->Privacy);
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+                   && !Adapter->SecInfo.WPAEnabled
+                   && !Adapter->SecInfo.WPA2Enabled
+                   && ((!pBSSDesc->pWpaIE) ||
+                       ((*(pBSSDesc->pWpaIE)).VendHdr.ElementId != WPA_IE))
+                   && ((!pBSSDesc->pRsnIE) ||
+                       ((*(pBSSDesc->pRsnIE)).IeeeHdr.ElementId != RSN_IE))
+                   && Adapter->AdhocAESEnabled &&
+                   Adapter->SecInfo.EncryptionMode == CIPHER_NONE &&
+                   pBSSDesc->Privacy) {
+            /* Ad-hoc AES enabled */
+            LEAVE();
+            return index;
+        } else if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPDisabled
+                   && !Adapter->SecInfo.WPAEnabled
+                   && !Adapter->SecInfo.WPA2Enabled
+                   && ((!pBSSDesc->pWpaIE) ||
+                       ((*(pBSSDesc->pWpaIE)).VendHdr.ElementId != WPA_IE))
+                   && ((!pBSSDesc->pRsnIE) ||
+                       ((*(pBSSDesc->pRsnIE)).IeeeHdr.ElementId != RSN_IE))
+                   && !Adapter->AdhocAESEnabled &&
+                   Adapter->SecInfo.EncryptionMode != CIPHER_NONE &&
+                   pBSSDesc->Privacy) {
+            /* dynamic WEP enabled */
+            PRINTM(INFO, "wlan_is_network_compatible() dynamic WEP: index=%d "
+                   "wpa_ie=%#x wpa2_ie=%#x EncMode=%#x privacy=%#x\n",
+                   index,
+                   (pBSSDesc->pWpaIE) ? (*(pBSSDesc->pWpaIE)).VendHdr.
+                   ElementId : 0,
+                   (pBSSDesc->pRsnIE) ? (*(pBSSDesc->pRsnIE)).IeeeHdr.
+                   ElementId : 0, Adapter->SecInfo.EncryptionMode,
+                   pBSSDesc->Privacy);
+            LEAVE();
+            return index;
+        }
+
+        /* security doesn't match */
+        PRINTM(INFO,
+               "wlan_is_network_compatible() FAILED: index=%d wpa_ie=%#x "
+               "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s EncMode=%#x privacy=%#x\n",
+               index,
+               (pBSSDesc->pWpaIE) ? (*(pBSSDesc->pWpaIE)).VendHdr.
+               ElementId : 0,
+               (pBSSDesc->pRsnIE) ? (*(pBSSDesc->pRsnIE)).IeeeHdr.
+               ElementId : 0,
+               (Adapter->SecInfo.WEPStatus ==
+                Wlan802_11WEPEnabled) ? "e" : "d",
+               (Adapter->SecInfo.WPAEnabled) ? "e" : "d",
+               (Adapter->SecInfo.WPA2Enabled) ? "e" : "d",
+               Adapter->SecInfo.EncryptionMode, pBSSDesc->Privacy);
+        LEAVE();
+        return -ECONNREFUSED;
+    }
+
+    /* mode doesn't match */
+    LEAVE();
+    return -ENETUNREACH;
+}
+
+/**
+ *  @brief This function validates a SSID as being able to be printed
+ *
+ *  @param pSsid   SSID structure to validate
+ *
+ *  @return        TRUE or FALSE
+ */
+static BOOLEAN
+ssid_valid(WLAN_802_11_SSID * pSsid)
+{
+    int ssidIdx;
+
+    for (ssidIdx = 0; ssidIdx < pSsid->SsidLength; ssidIdx++) {
+        if (!isprint(pSsid->Ssid[ssidIdx])) {
+            return FALSE;
+        }
+    }
+
+    return TRUE;
+}
+
+/**
+ *  @brief Post process the scan table after a new scan command has completed
+ *
+ *  Inspect each entry of the scan table and try to find an entry that
+ *    matches our current associated/joined network from the scan.  If
+ *    one is found, update the stored copy of the BSSDescriptor for our
+ *    current network.
+ *
+ *  Debug dump the current scan table contents if compiled accordingly.
+ *
+ *  @param priv   A pointer to wlan_private structure
+ *
+ *  @return       void
+ */
+static void
+wlan_scan_process_results(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i;
+    int foundCurrent;
+
+    foundCurrent = FALSE;
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        Adapter->CurBssParams.BSSDescriptor.pWpaIE = NULL;
+        Adapter->CurBssParams.BSSDescriptor.wpaOffset = 0;
+        Adapter->CurBssParams.BSSDescriptor.pRsnIE = NULL;
+        Adapter->CurBssParams.BSSDescriptor.rsnOffset = 0;
+        Adapter->CurBssParams.BSSDescriptor.pWpsIE = NULL;
+        Adapter->CurBssParams.BSSDescriptor.wpsOffset = 0;
+        Adapter->CurBssParams.BSSDescriptor.pBeaconBuf = NULL;
+        Adapter->CurBssParams.BSSDescriptor.beaconBufSize = 0;
+        Adapter->CurBssParams.BSSDescriptor.beaconBufSizeMax = 0;
+        i = wlan_find_ssid_in_list(Adapter,
+                                   &Adapter->CurBssParams.BSSDescriptor.Ssid,
+                                   Adapter->CurBssParams.BSSDescriptor.
+                                   MacAddress, Adapter->InfrastructureMode);
+
+        if (i >= 0) {
+            PRINTM(INFO, "Found current ssid/bssid in list @ index #%d\n", i);
+            /* Make a copy of current BSSID descriptor */
+            memcpy(&Adapter->CurBssParams.BSSDescriptor,
+                   &Adapter->ScanTable[i],
+                   sizeof(Adapter->CurBssParams.BSSDescriptor));
+        }
+    }
+
+    for (i = 0; i < Adapter->NumInScanTable; i++) {
+        PRINTM(INFO, "Scan:(%02d) %02x:%02x:%02x:%02x:%02x:%02x, "
+               "RSSI[%03d], SSID[%s]\n",
+               i,
+               Adapter->ScanTable[i].MacAddress[0],
+               Adapter->ScanTable[i].MacAddress[1],
+               Adapter->ScanTable[i].MacAddress[2],
+               Adapter->ScanTable[i].MacAddress[3],
+               Adapter->ScanTable[i].MacAddress[4],
+               Adapter->ScanTable[i].MacAddress[5],
+               (s32) Adapter->ScanTable[i].Rssi,
+               Adapter->ScanTable[i].Ssid.Ssid);
+    }
+}
+
+/**
+ *  @brief Create a channel list for the driver to scan based on region info
+ *
+ *  Use the driver region/band information to construct a comprehensive list
+ *    of channels to scan.  This routine is used for any scan that is not
+ *    provided a specific channel list to scan.
+ *
+ *  @param priv          A pointer to wlan_private structure
+ *  @param scanChanList  Output parameter: Resulting channel list to scan
+ *  @param filteredScan  Flag indicating whether or not a BSSID or SSID filter
+ *                       is being sent in the command to firmware.  Used to 
+ *                       increase the number of channels sent in a scan
+ *                       command and to disable the firmware channel scan
+ *                       filter.
+ *
+ *  @return              void
+ */
+static void
+wlan_scan_create_channel_list(wlan_private * priv,
+                              ChanScanParamSet_t * scanChanList,
+                              BOOLEAN filteredScan)
+{
+
+    wlan_adapter *Adapter = priv->adapter;
+    REGION_CHANNEL *scanRegion;
+    CHANNEL_FREQ_POWER *cfp;
+    int rgnIdx;
+    int chanIdx;
+    int nextChan;
+    u8 scanType;
+
+    chanIdx = 0;
+
+    /* Set the default scan type to the user specified type, will later
+     *   be changed to passive on a per channel basis if restricted by
+     *   regulatory requirements (11d or 11h)
+     */
+    scanType = Adapter->ScanType;
+
+    for (rgnIdx = 0; rgnIdx < NELEMENTS(Adapter->region_channel); rgnIdx++) {
+        if (wlan_get_state_11d(priv) == ENABLE_11D &&
+            Adapter->MediaConnectStatus != WlanMediaStateConnected) {
+            /* Scan all the supported chan for the first scan */
+            if (!Adapter->universal_channel[rgnIdx].Valid)
+                continue;
+            scanRegion = &Adapter->universal_channel[rgnIdx];
+
+            /* clear the parsed_region_chan for the first scan */
+            memset(&Adapter->parsed_region_chan, 0x00,
+                   sizeof(Adapter->parsed_region_chan));
+        } else {
+            if (!Adapter->region_channel[rgnIdx].Valid)
+                continue;
+            scanRegion = &Adapter->region_channel[rgnIdx];
+        }
+
+        for (nextChan = 0;
+             nextChan < scanRegion->NrCFP; nextChan++, chanIdx++) {
+
+            cfp = scanRegion->CFP + nextChan;
+
+            if (wlan_get_state_11d(priv) == ENABLE_11D) {
+                scanType =
+                    wlan_get_scan_type_11d(cfp->Channel,
+                                           &Adapter->parsed_region_chan);
+            }
+
+            switch (scanRegion->Band) {
+            case BAND_A:
+                scanChanList[chanIdx].RadioType = HostCmd_SCAN_RADIO_TYPE_A;
+                if (wlan_11h_radar_detect_required(priv, cfp->Channel)) {
+                    scanType = HostCmd_SCAN_TYPE_PASSIVE;
+                }
+                break;
+            case BAND_B:
+            case BAND_G:
+            default:
+                scanChanList[chanIdx].RadioType = HostCmd_SCAN_RADIO_TYPE_BG;
+                break;
+            }
+
+            if (scanType == HostCmd_SCAN_TYPE_PASSIVE) {
+                scanChanList[chanIdx].MaxScanTime =
+                    wlan_cpu_to_le16(Adapter->PassiveScanTime);
+                scanChanList[chanIdx].ChanScanMode.PassiveScan = TRUE;
+            } else {
+                scanChanList[chanIdx].MaxScanTime =
+                    wlan_cpu_to_le16(Adapter->ActiveScanTime);
+                scanChanList[chanIdx].ChanScanMode.PassiveScan = FALSE;
+            }
+
+            scanChanList[chanIdx].ChanNumber = cfp->Channel;
+
+            if (filteredScan) {
+                scanChanList[chanIdx].MaxScanTime =
+                    wlan_cpu_to_le16(Adapter->SpecificScanTime);
+                scanChanList[chanIdx].ChanScanMode.DisableChanFilt = TRUE;
+            }
+        }
+    }
+}
+
+/**
+ *  @brief Construct a wlan_scan_cmd_config structure to use in issue scan cmds
+ *
+ *  Application layer or other functions can invoke wlan_scan_networks
+ *    with a scan configuration supplied in a wlan_ioctl_user_scan_cfg struct.
+ *    This structure is used as the basis of one or many wlan_scan_cmd_config
+ *    commands that are sent to the command processing module and sent to
+ *    firmware.
+ *
+ *  Create a wlan_scan_cmd_config based on the following user supplied
+ *    parameters (if present):
+ *             - SSID filter
+ *             - BSSID filter
+ *             - Number of Probes to be sent
+ *             - Channel list
+ *
+ *  If the SSID or BSSID filter is not present, disable/clear the filter.
+ *  If the number of probes is not set, use the adapter default setting
+ *  Qualify the channel
+ *
+ *  @param priv             A pointer to wlan_private structure
+ *  @param pUserScanIn      NULL or pointer to scan configuration parameters
+ *  @param pScanCfgOut      Output parameter: Resulting scan configuration
+ *  @param ppChanTlvOut     Output parameter: Pointer to the start of the
+ *                          channel TLV portion of the output scan config
+ *  @param pScanChanList    Output parameter: Pointer to the resulting channel
+ *                          list to scan
+ *  @param pMaxChanPerScan  Output parameter: Number of channels to scan for
+ *                          each issuance of the firmware scan command
+ *  @param pFilteredScan    Output parameter: Flag indicating whether or not
+ *                          a BSSID or SSID filter is being sent in the
+ *                          command to firmware.  Used to increase the number
+ *                          of channels sent in a scan command and to 
+ *                          disable the firmware channel scan filter.
+ *  @param pScanCurrentOnly Output parameter: Flag indicating whether or not
+ *                          we are only scanning our current active channel
+ *
+ *  @return                 void
+ */
+static void
+wlan_scan_setup_scan_config(wlan_private * priv,
+                            const wlan_ioctl_user_scan_cfg * pUserScanIn,
+                            wlan_scan_cmd_config * pScanCfgOut,
+                            MrvlIEtypes_ChanListParamSet_t ** ppChanTlvOut,
+                            ChanScanParamSet_t * pScanChanList,
+                            int *pMaxChanPerScan,
+                            BOOLEAN * pFilteredScan,
+                            BOOLEAN * pScanCurrentOnly)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    const u8 zeroMac[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
+    MrvlIEtypes_NumProbes_t *pNumProbesTlv;
+    u8 *pTlvPos;
+    u16 numProbes;
+    u16 ssidLen;
+    int chanIdx;
+    int scanType;
+    int scanDur;
+    int channel;
+    int radioType;
+    int ssidIdx;
+    BOOLEAN ssidFilter;
+
+    MrvlIEtypes_WildCardSsIdParamSet_t *pWildCardSsidTlv;
+
+    /* The tlvBufferLen is calculated for each scan command.  The TLVs added
+     *   in this routine will be preserved since the routine that sends
+     *   the command will append channelTLVs at *ppChanTlvOut.  The difference
+     *   between the *ppChanTlvOut and the tlvBuffer start will be used
+     *   to calculate the size of anything we add in this routine.
+     */
+    pScanCfgOut->tlvBufferLen = 0;
+
+    /* Running tlv pointer.  Assigned to ppChanTlvOut at end of function
+     *  so later routines know where channels can be added to the command buf
+     */
+    pTlvPos = pScanCfgOut->tlvBuffer;
+
+    /* Initialize the scan as un-filtered; the flag is later set to
+     *   TRUE below if a SSID or BSSID filter is sent in the command
+     */
+    *pFilteredScan = FALSE;
+
+    /* Initialize the scan as not being only on the current channel.  If
+     *   the channel list is customized, only contains one channel, and
+     *   is the active channel, this is set true and data flow is not halted.
+     */
+    *pScanCurrentOnly = FALSE;
+
+    if (pUserScanIn) {
+
+        /* Default the ssidFilter flag to TRUE, set false under certain 
+         *   wildcard conditions and qualified by the existence of an SSID 
+         *   list before marking the scan as filtered
+         */
+        ssidFilter = TRUE;
+
+        /* Set the bss type scan filter, use Adapter setting if unset */
+        pScanCfgOut->bssType = (pUserScanIn->bssType ? pUserScanIn->bssType :
+                                Adapter->ScanMode);
+
+        /* Set the number of probes to send, use Adapter setting if unset */
+        numProbes = (pUserScanIn->numProbes ? pUserScanIn->numProbes :
+                     Adapter->ScanProbes);
+
+        /*
+         * Set the BSSID filter to the incoming configuration,
+         *   if non-zero.  If not set, it will remain disabled (all zeros).
+         */
+        memcpy(pScanCfgOut->specificBSSID,
+               pUserScanIn->specificBSSID,
+               sizeof(pScanCfgOut->specificBSSID));
+
+        for (ssidIdx = 0; ((ssidIdx < NELEMENTS(pUserScanIn->ssidList))
+                           && (*pUserScanIn->ssidList[ssidIdx].ssid
+                               || pUserScanIn->ssidList[ssidIdx].maxLen));
+             ssidIdx++) {
+
+            ssidLen = strlen(pUserScanIn->ssidList[ssidIdx].ssid) + 1;
+
+            pWildCardSsidTlv = (MrvlIEtypes_WildCardSsIdParamSet_t *) pTlvPos;
+            pWildCardSsidTlv->Header.Type
+                = wlan_cpu_to_le16(TLV_TYPE_WILDCARDSSID);
+            pWildCardSsidTlv->Header.Len
+                = ssidLen + sizeof(pWildCardSsidTlv->MaxSsidLength);
+            pWildCardSsidTlv->MaxSsidLength
+                = pUserScanIn->ssidList[ssidIdx].maxLen;
+
+            memcpy(pWildCardSsidTlv->SsId,
+                   pUserScanIn->ssidList[ssidIdx].ssid, ssidLen);
+
+            pTlvPos += (sizeof(pWildCardSsidTlv->Header)
+                        + pWildCardSsidTlv->Header.Len);
+
+            pWildCardSsidTlv->Header.Len
+                = wlan_cpu_to_le16(pWildCardSsidTlv->Header.Len);
+
+            PRINTM(INFO, "Scan: ssidList[%d]: %s, %d\n",
+                   ssidIdx,
+                   pWildCardSsidTlv->SsId, pWildCardSsidTlv->MaxSsidLength);
+
+            /* Empty wildcard ssid with a maxlen will match many or potentially
+             *   all SSIDs (maxlen == 32), therefore do not treat the scan
+             *   as filtered.
+             */
+            if ((ssidLen == 0) && pWildCardSsidTlv->MaxSsidLength) {
+                ssidFilter = FALSE;
+            }
+        }
+
+        /*
+         *  The default number of channels sent in the command is low to
+         *    ensure the response buffer from the firmware does not truncate
+         *    scan results.  That is not an issue with an SSID or BSSID
+         *    filter applied to the scan results in the firmware.
+         */
+        if ((ssidIdx && ssidFilter)
+            || memcmp(pScanCfgOut->specificBSSID, &zeroMac, sizeof(zeroMac))) {
+            *pFilteredScan = TRUE;
+        }
+
+    } else {
+        pScanCfgOut->bssType = Adapter->ScanMode;
+        numProbes = Adapter->ScanProbes;
+    }
+
+    /*
+     *  If a specific BSSID or SSID is used, the number of channels in the 
+     *  scan command will be increased to the absolute maximum.
+     */
+    if (*pFilteredScan)
+        *pMaxChanPerScan = MRVDRV_MAX_CHANNELS_PER_SPECIFIC_SCAN;
+    else
+        *pMaxChanPerScan = MRVDRV_CHANNELS_PER_SCAN_CMD;
+
+    /* If the input config or adapter has the number of Probes set, add tlv */
+    if (numProbes) {
+
+        PRINTM(INFO, "Scan: numProbes = %d\n", numProbes);
+
+        pNumProbesTlv = (MrvlIEtypes_NumProbes_t *) pTlvPos;
+        pNumProbesTlv->Header.Type = wlan_cpu_to_le16(TLV_TYPE_NUMPROBES);
+        pNumProbesTlv->Header.Len = sizeof(pNumProbesTlv->NumProbes);
+        pNumProbesTlv->NumProbes = wlan_cpu_to_le16(numProbes);
+
+        pTlvPos += sizeof(pNumProbesTlv->Header) + pNumProbesTlv->Header.Len;
+
+        pNumProbesTlv->Header.Len =
+            wlan_cpu_to_le16(pNumProbesTlv->Header.Len);
+    }
+
+    /*
+     * Set the output for the channel TLV to the address in the tlv buffer
+     *   past any TLVs that were added in this fuction (SSID, numProbes).
+     *   Channel TLVs will be added past this for each scan command, preserving
+     *   the TLVs that were previously added.
+     */
+    *ppChanTlvOut = (MrvlIEtypes_ChanListParamSet_t *) pTlvPos;
+
+    if (pUserScanIn && pUserScanIn->chanList[0].chanNumber) {
+
+        PRINTM(INFO, "Scan: Using supplied channel list\n");
+
+        for (chanIdx = 0;
+             chanIdx < WLAN_IOCTL_USER_SCAN_CHAN_MAX
+             && pUserScanIn->chanList[chanIdx].chanNumber; chanIdx++) {
+
+            channel = pUserScanIn->chanList[chanIdx].chanNumber;
+            (pScanChanList + chanIdx)->ChanNumber = channel;
+
+            radioType = pUserScanIn->chanList[chanIdx].radioType;
+            (pScanChanList + chanIdx)->RadioType = radioType;
+
+            scanType = pUserScanIn->chanList[chanIdx].scanType;
+
+            /* Prevent active scanning on a radar controlled channel */
+            if (radioType == HostCmd_SCAN_RADIO_TYPE_A) {
+                if (wlan_11h_radar_detect_required(priv, channel)) {
+                    scanType = HostCmd_SCAN_TYPE_PASSIVE;
+                }
+            }
+            if (scanType == HostCmd_SCAN_TYPE_PASSIVE) {
+                (pScanChanList + chanIdx)->ChanScanMode.PassiveScan = TRUE;
+            } else {
+                (pScanChanList + chanIdx)->ChanScanMode.PassiveScan = FALSE;
+            }
+
+            if (pUserScanIn->chanList[chanIdx].scanTime) {
+                scanDur = pUserScanIn->chanList[chanIdx].scanTime;
+            } else {
+                if (scanType == HostCmd_SCAN_TYPE_PASSIVE) {
+                    scanDur = Adapter->PassiveScanTime;
+                } else if (*pFilteredScan) {
+                    scanDur = Adapter->SpecificScanTime;
+                } else {
+                    scanDur = Adapter->ActiveScanTime;
+                }
+            }
+
+            (pScanChanList + chanIdx)->MinScanTime =
+                wlan_cpu_to_le16(scanDur);
+            (pScanChanList + chanIdx)->MaxScanTime =
+                wlan_cpu_to_le16(scanDur);
+        }
+
+        /* Check if we are only scanning the current channel */
+        if ((chanIdx == 1)
+            && (pUserScanIn->chanList[0].chanNumber
+                == priv->adapter->CurBssParams.BSSDescriptor.Channel)) {
+            *pScanCurrentOnly = TRUE;
+            PRINTM(INFO, "Scan: Scanning current channel only");
+        }
+
+    } else {
+        PRINTM(INFO, "Scan: Creating full region channel list\n");
+        wlan_scan_create_channel_list(priv, pScanChanList, *pFilteredScan);
+    }
+}
+
+/**
+ *  @brief Construct and send multiple scan config commands to the firmware
+ *
+ *  Previous routines have created a wlan_scan_cmd_config with any requested
+ *   TLVs.  This function splits the channel TLV into maxChanPerScan lists
+ *   and sends the portion of the channel TLV along with the other TLVs
+ *   to the wlan_cmd routines for execution in the firmware.
+ *
+ *  @param priv            A pointer to wlan_private structure
+ *  @param maxChanPerScan  Maximum number channels to be included in each
+ *                         scan command sent to firmware
+ *  @param filteredScan    Flag indicating whether or not a BSSID or SSID
+ *                         filter is being used for the firmware command
+ *                         scan command sent to firmware
+ *  @param pScanCfgOut     Scan configuration used for this scan.
+ *  @param pChanTlvOut     Pointer in the pScanCfgOut where the channel TLV
+ *                         should start.  This is past any other TLVs that
+ *                         must be sent down in each firmware command.
+ *  @param pScanChanList   List of channels to scan in maxChanPerScan segments
+ *
+ *  @return                WLAN_STATUS_SUCCESS or error return otherwise
+ */
+static int
+wlan_scan_channel_list(wlan_private * priv,
+                       int maxChanPerScan,
+                       BOOLEAN filteredScan,
+                       wlan_scan_cmd_config * pScanCfgOut,
+                       MrvlIEtypes_ChanListParamSet_t * pChanTlvOut,
+                       ChanScanParamSet_t * pScanChanList)
+{
+    ChanScanParamSet_t *pTmpChan;
+    ChanScanParamSet_t *pStartChan;
+    u8 scanBand;
+    int doneEarly;
+    int tlvIdx;
+    int totalscantime;
+    int ret;
+
+    ENTER();
+
+    if (pScanCfgOut == 0 || pChanTlvOut == 0 || pScanChanList == 0) {
+        PRINTM(INFO, "Scan: Null detect: %p, %p, %p\n",
+               pScanCfgOut, pChanTlvOut, pScanChanList);
+        return WLAN_STATUS_FAILURE;
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+
+    pChanTlvOut->Header.Type = wlan_cpu_to_le16(TLV_TYPE_CHANLIST);
+
+    /* Set the temp channel struct pointer to the start of the desired list */
+    pTmpChan = pScanChanList;
+
+    /* Loop through the desired channel list, sending a new firmware scan
+     *   commands for each maxChanPerScan channels (or for 1,6,11 individually
+     *   if configured accordingly)
+     */
+    while (pTmpChan->ChanNumber) {
+
+        tlvIdx = 0;
+        totalscantime = 0;
+        pChanTlvOut->Header.Len = 0;
+        scanBand = pTmpChan->RadioType;
+        pStartChan = pTmpChan;
+        doneEarly = FALSE;
+
+        /* Construct the Channel TLV for the scan command.  Continue to
+         *  insert channel TLVs until:
+         *    - the tlvIdx hits the maximum configured per scan command
+         *    - the next channel to insert is 0 (end of desired channel list)
+         *    - doneEarly is set (controlling individual scanning of 1,6,11)
+         */
+        while (tlvIdx < maxChanPerScan && pTmpChan->ChanNumber && !doneEarly) {
+
+            PRINTM(INFO, "Scan: Chan(%3d), Radio(%d), Mode(%d,%d), Dur(%d)\n",
+                   pTmpChan->ChanNumber,
+                   pTmpChan->RadioType,
+                   pTmpChan->ChanScanMode.PassiveScan,
+                   pTmpChan->ChanScanMode.DisableChanFilt,
+                   pTmpChan->MaxScanTime);
+
+            /* Copy the current channel TLV to the command being prepared */
+            memcpy(pChanTlvOut->ChanScanParam + tlvIdx,
+                   pTmpChan, sizeof(pChanTlvOut->ChanScanParam));
+
+            /* Increment the TLV header length by the size appended */
+            pChanTlvOut->Header.Len += sizeof(pChanTlvOut->ChanScanParam);
+
+            /*
+             *  The tlv buffer length is set to the number of bytes of the
+             *    between the channel tlv pointer and the start of the
+             *    tlv buffer.  This compensates for any TLVs that were appended
+             *    before the channel list.
+             */
+            pScanCfgOut->tlvBufferLen = ((u8 *) pChanTlvOut
+                                         - pScanCfgOut->tlvBuffer);
+
+            /*  Add the size of the channel tlv header and the data length */
+            pScanCfgOut->tlvBufferLen += (sizeof(pChanTlvOut->Header)
+                                          + pChanTlvOut->Header.Len);
+
+            /* Increment the index to the channel tlv we are constructing */
+            tlvIdx++;
+
+            /* Count the total scan time per command */
+            totalscantime += pTmpChan->MaxScanTime;
+
+            doneEarly = FALSE;
+
+            /* Stop the loop if the *current* channel is in the 1,6,11 set
+             *   and we are not filtering on a BSSID or SSID.
+             */
+            if (!filteredScan && (pTmpChan->ChanNumber == 1
+                                  || pTmpChan->ChanNumber == 6
+                                  || pTmpChan->ChanNumber == 11)) {
+                doneEarly = TRUE;
+            }
+
+            /* Increment the tmp pointer to the next channel to be scanned */
+            pTmpChan++;
+
+            /* Stop the loop if the *next* channel is in the 1,6,11 set.
+             *  This will cause it to be the only channel scanned on the next
+             *  interation
+             */
+            if (!filteredScan && (pTmpChan->ChanNumber == 1
+                                  || pTmpChan->ChanNumber == 6
+                                  || pTmpChan->ChanNumber == 11)) {
+                doneEarly = TRUE;
+            }
+        }
+
+        /* The total scan time should be less than scan command timeout value */
+        if (totalscantime > MRVDRV_MAX_TOTAL_SCAN_TIME) {
+            PRINTM(MSG,
+                   "Total scan time %d ms is over limit (%d ms), scan skipped\n",
+                   totalscantime, MRVDRV_MAX_TOTAL_SCAN_TIME);
+            ret = WLAN_STATUS_FAILURE;
+            break;
+        }
+
+        pChanTlvOut->Header.Len = wlan_cpu_to_le16(pChanTlvOut->Header.Len);
+
+        priv->adapter->pScanChannels = pStartChan;
+
+        /* Send the scan command to the firmware with the specified cfg */
+        ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_SCAN, 0,
+                               HostCmd_OPTION_WAITFORRSP, 0, pScanCfgOut);
+
+        if (ret)
+            break;
+    }
+
+    LEAVE();
+
+    if (ret) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Internal function used to start a scan based on an input config
+ *
+ *  Use the input user scan configuration information when provided in
+ *    order to send the appropriate scan commands to firmware to populate or
+ *    update the internal driver scan table
+ *
+ *  @param priv          A pointer to wlan_private structure
+ *  @param pUserScanIn   Pointer to the input configuration for the requested
+ *                       scan.
+ *
+ *  @return              WLAN_STATUS_SUCCESS or < 0 if error
+ */
+static int
+wlan_scan_networks(wlan_private * priv,
+                   const wlan_ioctl_user_scan_cfg * pUserScanIn)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    MrvlIEtypes_ChanListParamSet_t *pChanTlvOut;
+
+    ChanScanParamSet_t scanChanList[WLAN_IOCTL_USER_SCAN_CHAN_MAX];
+    wlan_scan_cmd_config_tlv *scanCfgOut = NULL;
+    BOOLEAN keepPreviousScan;
+    BOOLEAN filteredScan;
+    BOOLEAN scanCurrentChanOnly;
+    int maxChanPerScan;
+    int ret;
+
+    ENTER();
+
+    scanCfgOut =
+        (wlan_scan_cmd_config_tlv *) kmalloc(sizeof(wlan_scan_cmd_config_tlv),
+                                             GFP_KERNEL);
+    if (!scanCfgOut) {
+        PRINTM(ERROR, "Memory allocation for scancfgOut failed!\n");
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    memset(scanChanList, 0x00, sizeof(scanChanList));
+    memset(scanCfgOut, 0x00, sizeof(wlan_scan_cmd_config_tlv));
+
+    keepPreviousScan = FALSE;
+
+    wlan_scan_setup_scan_config(priv,
+                                pUserScanIn,
+                                &scanCfgOut->config,
+                                &pChanTlvOut,
+                                scanChanList,
+                                &maxChanPerScan,
+                                &filteredScan, &scanCurrentChanOnly);
+
+    if (pUserScanIn) {
+        keepPreviousScan = pUserScanIn->keepPreviousScan;
+    }
+
+    if (keepPreviousScan == FALSE) {
+        memset(Adapter->ScanTable, 0x00,
+               sizeof(BSSDescriptor_t) * MRVDRV_MAX_BSSID_LIST);
+        Adapter->NumInScanTable = 0;
+        Adapter->pBeaconBufEnd = Adapter->beaconBuffer;
+    }
+
+    /* Keep the data path active if we are only scanning our current channel */
+    if (!scanCurrentChanOnly) {
+        PRINTM(INFO, "Scan: WMM Queue stop\n");
+        priv->wlan_dev.netdev->watchdog_timeo = MRVDRV_SCAN_WATCHDOG_TIMEOUT;
+        /* If WMM queues are in use, only stop the internal data queues */
+        wmm_stop_queue(priv);
+    }
+
+    ret = wlan_scan_channel_list(priv,
+                                 maxChanPerScan,
+                                 filteredScan,
+                                 &scanCfgOut->config,
+                                 pChanTlvOut, scanChanList);
+
+    /*  Process the resulting scan table:
+     *    - Remove any bad ssids
+     *    - Update our current BSS information from scan data
+     */
+    if (!ret)
+        wlan_scan_process_results(priv);
+
+    PRINTM(INFO, "Scan: WMM Queue start\n");
+
+    priv->wlan_dev.netdev->watchdog_timeo = MRVDRV_DEFAULT_WATCHDOG_TIMEOUT;
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        wmm_start_queue(priv);
+    }
+    os_carrier_on(priv);
+    os_start_queue(priv);
+    kfree(scanCfgOut);
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Create a brief scan resp to relay basic BSS info to the app layer
+ *
+ *  When the beacon/probe response has not been buffered, use the saved BSS
+ *    information available to provide a minimum response for the application
+ *    ioctl retrieval routines.  Include:
+ *        - Timestamp
+ *        - Beacon Period
+ *        - Capabilities (including WMM Element if available)
+ *        - SSID
+ *
+ *  @param ppBuffer  Output parameter: Buffer used to create basic scan rsp
+ *  @param pBSSDesc  Pointer to a BSS entry in the scan table to create
+ *                   scan response from for delivery to the application layer
+ *
+ *  @return          void
+ */
+static void
+wlan_scan_create_brief_table_entry(u8 ** ppBuffer, BSSDescriptor_t * pBSSDesc)
+{
+    u8 *pTmpBuf = *ppBuffer;
+    u8 tmpSSIDHdr[2];
+    u8 ieLen = 0;
+
+    if (copy_to_user(pTmpBuf, pBSSDesc->TimeStamp,
+                     sizeof(pBSSDesc->TimeStamp))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += sizeof(pBSSDesc->TimeStamp);
+
+    if (copy_to_user(pTmpBuf, &pBSSDesc->BeaconPeriod,
+                     sizeof(pBSSDesc->BeaconPeriod))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += sizeof(pBSSDesc->BeaconPeriod);
+
+    if (copy_to_user(pTmpBuf, &pBSSDesc->Cap, sizeof(pBSSDesc->Cap))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += sizeof(pBSSDesc->Cap);
+
+    tmpSSIDHdr[0] = 0;          /* Element ID for SSID is zero */
+    tmpSSIDHdr[1] = pBSSDesc->Ssid.SsidLength;
+    if (copy_to_user(pTmpBuf, tmpSSIDHdr, sizeof(tmpSSIDHdr))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += sizeof(tmpSSIDHdr);
+
+    if (copy_to_user(pTmpBuf, pBSSDesc->Ssid.Ssid, pBSSDesc->Ssid.SsidLength)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return;
+    }
+    pTmpBuf += pBSSDesc->Ssid.SsidLength;
+
+    if (pBSSDesc->wmmIE.VendHdr.ElementId == WMM_IE) {
+        ieLen = sizeof(IEEEtypes_Header_t) + pBSSDesc->wmmIE.VendHdr.Len;
+        if (copy_to_user(pTmpBuf, &pBSSDesc->wmmIE, ieLen)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return;
+        }
+
+        pTmpBuf += ieLen;
+    }
+
+    if (pBSSDesc->pWpaIE) {
+        if ((*(pBSSDesc->pWpaIE)).VendHdr.ElementId == WPA_IE) {
+            ieLen =
+                sizeof(IEEEtypes_Header_t) +
+                (*(pBSSDesc->pWpaIE)).VendHdr.Len;
+            if (copy_to_user(pTmpBuf, pBSSDesc->pWpaIE, ieLen)) {
+                PRINTM(INFO, "Copy to user failed\n");
+                return;
+            }
+        }
+
+        pTmpBuf += ieLen;
+    }
+
+    if (pBSSDesc->pRsnIE) {
+        if ((*(pBSSDesc->pRsnIE)).IeeeHdr.ElementId == RSN_IE) {
+            ieLen =
+                sizeof(IEEEtypes_Header_t) +
+                (*(pBSSDesc->pRsnIE)).IeeeHdr.Len;
+            if (copy_to_user(pTmpBuf, pBSSDesc->pRsnIE, ieLen)) {
+                PRINTM(INFO, "Copy to user failed\n");
+                return;
+            }
+        }
+
+        pTmpBuf += ieLen;
+    }
+
+    *ppBuffer = pTmpBuf;
+}
+
+/**
+ *  @brief Inspect the scan response buffer for pointers to expected TLVs
+ *
+ *  TLVs can be included at the end of the scan response BSS information.
+ *    Parse the data in the buffer for pointers to TLVs that can potentially
+ *    be passed back in the response
+ *
+ *  @param pTlv        Pointer to the start of the TLV buffer to parse
+ *  @param tlvBufSize  Size of the TLV buffer
+ *  @param ppTsfTlv    Output parameter: Pointer to the TSF TLV if found
+ *
+ *  @return            void
+ */
+static void
+wlan_ret_802_11_scan_get_tlv_ptrs(MrvlIEtypes_Data_t * pTlv,
+                                  int tlvBufSize,
+                                  MrvlIEtypes_TsfTimestamp_t ** ppTsfTlv)
+{
+    MrvlIEtypes_Data_t *pCurrentTlv;
+    int tlvBufLeft;
+    u16 tlvType;
+    u16 tlvLen;
+
+    pCurrentTlv = pTlv;
+    tlvBufLeft = tlvBufSize;
+    *ppTsfTlv = NULL;
+
+    PRINTM(INFO, "SCAN_RESP: tlvBufSize = %d\n", tlvBufSize);
+    HEXDUMP("SCAN_RESP: TLV Buf", (u8 *) pTlv, tlvBufSize);
+
+    while (tlvBufLeft >= sizeof(MrvlIEtypesHeader_t)) {
+        tlvType = wlan_le16_to_cpu(pCurrentTlv->Header.Type);
+        tlvLen = wlan_le16_to_cpu(pCurrentTlv->Header.Len);
+
+        switch (tlvType) {
+        case TLV_TYPE_TSFTIMESTAMP:
+            PRINTM(INFO, "SCAN_RESP: TSF Timestamp TLV, len = %d\n", tlvLen);
+            *ppTsfTlv = (MrvlIEtypes_TsfTimestamp_t *) pCurrentTlv;
+            break;
+
+        default:
+            PRINTM(INFO, "SCAN_RESP: Unhandled TLV = %d\n", tlvType);
+            /* Give up, this seems corrupted */
+            return;
+        }                       /* switch */
+
+        tlvBufLeft -= (sizeof(pTlv->Header) + tlvLen);
+        pCurrentTlv = (MrvlIEtypes_Data_t *) (pCurrentTlv->Data + tlvLen);
+    }                           /* while */
+}
+
+/**
+ *  @brief Interpret a BSS scan response returned from the firmware
+ *
+ *  Parse the various fixed fields and IEs passed back for a a BSS probe
+ *   response or beacon from the scan command.  Record information as needed
+ *   in the scan table BSSDescriptor_t for that entry.
+ *
+ *  @param pBSSEntry    Output parameter: Pointer to the BSS Entry
+ *  @param pBeaconInfo  Pointer to the Beacon information
+ *  @param bytesLeft    Number of bytes left to parse
+ *
+ *  @return             WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_interpret_bss_desc_with_ie(BSSDescriptor_t * pBSSEntry,
+                                u8 ** pBeaconInfo, int *bytesLeft)
+{
+    IEEEtypes_ElementId_e elemID;
+    IEEEtypes_FhParamSet_t *pFH;
+    IEEEtypes_DsParamSet_t *pDS;
+    IEEEtypes_CfParamSet_t *pCF;
+    IEEEtypes_IbssParamSet_t *pIbss;
+    IEEEtypes_CapInfo_t *pCap;
+    WLAN_802_11_FIXED_IEs fixedIE;
+    u8 *pCurrentPtr;
+    u8 *pRate;
+    u8 elemLen;
+    u16 totalIeLen;
+    u8 bytesToCopy;
+    u8 rateSize;
+    u16 beaconSize;
+    BOOLEAN foundDataRateIE;
+    int bytesLeftForCurrentBeacon;
+    IEEEtypes_ERPInfo_t *pERPInfo;
+
+    IEEEtypes_VendorSpecific_t *pVendorIe;
+    const u8 wpa_oui[4] = { 0x00, 0x50, 0xf2, 0x01 };
+    const u8 wmm_oui[4] = { 0x00, 0x50, 0xf2, 0x02 };
+    const u8 wps_oui[4] = { 0x00, 0x50, 0xf2, 0x04 };
+
+    IEEEtypes_CountryInfoSet_t *pcountryinfo;
+
+    ENTER();
+
+    foundDataRateIE = FALSE;
+    rateSize = 0;
+    beaconSize = 0;
+
+    if (*bytesLeft >= sizeof(beaconSize)) {
+        /* Extract & convert beacon size from the command buffer */
+        memcpy(&beaconSize, *pBeaconInfo, sizeof(beaconSize));
+        beaconSize = wlan_le16_to_cpu(beaconSize);
+        *bytesLeft -= sizeof(beaconSize);
+        *pBeaconInfo += sizeof(beaconSize);
+    }
+
+    if (beaconSize == 0 || beaconSize > *bytesLeft) {
+
+        *pBeaconInfo += *bytesLeft;
+        *bytesLeft = 0;
+
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /* Initialize the current working beacon pointer for this BSS iteration */
+    pCurrentPtr = *pBeaconInfo;
+
+    /* Advance the return beacon pointer past the current beacon */
+    *pBeaconInfo += beaconSize;
+    *bytesLeft -= beaconSize;
+
+    bytesLeftForCurrentBeacon = beaconSize;
+
+    memcpy(pBSSEntry->MacAddress, pCurrentPtr, ETH_ALEN);
+    PRINTM(INFO, "InterpretIE: AP MAC Addr-%02x:%02x:%02x:%02x:%02x:%02x\n",
+           pBSSEntry->MacAddress[0], pBSSEntry->MacAddress[1],
+           pBSSEntry->MacAddress[2], pBSSEntry->MacAddress[3],
+           pBSSEntry->MacAddress[4], pBSSEntry->MacAddress[5]);
+
+    pCurrentPtr += ETH_ALEN;
+    bytesLeftForCurrentBeacon -= ETH_ALEN;
+
+    if (bytesLeftForCurrentBeacon < 12) {
+        PRINTM(INFO, "InterpretIE: Not enough bytes left\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    /*
+     * next 4 fields are RSSI, time stamp, beacon interval,
+     *   and capability information
+     */
+
+    /* RSSI is 1 byte long */
+    pBSSEntry->Rssi = wlan_le32_to_cpu((LONG) (*pCurrentPtr));
+    PRINTM(INFO, "InterpretIE: RSSI=%02X\n", *pCurrentPtr);
+    pCurrentPtr += 1;
+    bytesLeftForCurrentBeacon -= 1;
+
+    /*
+     *  The RSSI is not part of the beacon/probe response.  After we have
+     *    advanced pCurrentPtr past the RSSI field, save the remaining
+     *    data for use at the application layer
+     */
+    pBSSEntry->pBeaconBuf = pCurrentPtr;
+    pBSSEntry->beaconBufSize = bytesLeftForCurrentBeacon;
+
+    /* time stamp is 8 bytes long */
+    memcpy(fixedIE.Timestamp, pCurrentPtr, 8);
+    memcpy(pBSSEntry->TimeStamp, pCurrentPtr, 8);
+    pCurrentPtr += 8;
+    bytesLeftForCurrentBeacon -= 8;
+
+    /* beacon interval is 2 bytes long */
+    memcpy(&fixedIE.BeaconInterval, pCurrentPtr, 2);
+    pBSSEntry->BeaconPeriod = wlan_le16_to_cpu(fixedIE.BeaconInterval);
+    pCurrentPtr += 2;
+    bytesLeftForCurrentBeacon -= 2;
+
+    /* capability information is 2 bytes long */
+    memcpy(&fixedIE.Capabilities, pCurrentPtr, 2);
+    PRINTM(INFO, "InterpretIE: fixedIE.Capabilities=0x%X\n",
+           fixedIE.Capabilities);
+    fixedIE.Capabilities = wlan_le16_to_cpu(fixedIE.Capabilities);
+    pCap = (IEEEtypes_CapInfo_t *) & fixedIE.Capabilities;
+    memcpy(&pBSSEntry->Cap, pCap, sizeof(IEEEtypes_CapInfo_t));
+    pCurrentPtr += 2;
+    bytesLeftForCurrentBeacon -= 2;
+
+    /* rest of the current buffer are IE's */
+    PRINTM(INFO, "InterpretIE: IELength for this AP = %d\n",
+           bytesLeftForCurrentBeacon);
+
+    HEXDUMP("InterpretIE: IE info", (u8 *) pCurrentPtr,
+            bytesLeftForCurrentBeacon);
+
+    if (pCap->Privacy) {
+        PRINTM(INFO, "InterpretIE: AP WEP enabled\n");
+        pBSSEntry->Privacy = Wlan802_11PrivFilter8021xWEP;
+    } else {
+        pBSSEntry->Privacy = Wlan802_11PrivFilterAcceptAll;
+    }
+
+    if (pCap->Ibss == 1) {
+        pBSSEntry->InfrastructureMode = Wlan802_11IBSS;
+    } else {
+        pBSSEntry->InfrastructureMode = Wlan802_11Infrastructure;
+    }
+
+    if (pCap->SpectrumMgmt == 1) {
+        PRINTM(INFO, "InterpretIE: 11h- Spectrum Management "
+               "capability bit found\n");
+        pBSSEntry->wlan_11h_bss_info.sensed11h = 1;
+    }
+
+    /* process variable IE */
+    while (bytesLeftForCurrentBeacon >= 2) {
+        elemID = (IEEEtypes_ElementId_e) (*((u8 *) pCurrentPtr));
+        elemLen = *((u8 *) pCurrentPtr + 1);
+        totalIeLen = elemLen + sizeof(IEEEtypes_Header_t);
+
+        if (bytesLeftForCurrentBeacon < elemLen) {
+            PRINTM(INFO, "InterpretIE: Error in processing IE, "
+                   "bytes left < IE length\n");
+            bytesLeftForCurrentBeacon = 0;
+            continue;
+        }
+
+        switch (elemID) {
+
+        case SSID:
+            pBSSEntry->Ssid.SsidLength = elemLen;
+            memcpy(pBSSEntry->Ssid.Ssid, (pCurrentPtr + 2), elemLen);
+            PRINTM(INFO, "InterpretIE: Ssid: %-32s\n", pBSSEntry->Ssid.Ssid);
+            break;
+
+        case SUPPORTED_RATES:
+            memcpy(pBSSEntry->DataRates, pCurrentPtr + 2, elemLen);
+            memcpy(pBSSEntry->SupportedRates, pCurrentPtr + 2, elemLen);
+            HEXDUMP("InterpretIE: SupportedRates:",
+                    pBSSEntry->SupportedRates, elemLen);
+            rateSize = elemLen;
+            foundDataRateIE = TRUE;
+            break;
+
+        case FH_PARAM_SET:
+            pFH = (IEEEtypes_FhParamSet_t *) pCurrentPtr;
+            pBSSEntry->NetworkTypeInUse = Wlan802_11FH;
+            memcpy(&pBSSEntry->PhyParamSet.FhParamSet, pFH,
+                   sizeof(IEEEtypes_FhParamSet_t));
+            pBSSEntry->PhyParamSet.FhParamSet.DwellTime
+                =
+                wlan_le16_to_cpu(pBSSEntry->PhyParamSet.FhParamSet.DwellTime);
+            break;
+
+        case DS_PARAM_SET:
+            pDS = (IEEEtypes_DsParamSet_t *) pCurrentPtr;
+
+            pBSSEntry->NetworkTypeInUse = Wlan802_11DS;
+            pBSSEntry->Channel = pDS->CurrentChan;
+
+            memcpy(&pBSSEntry->PhyParamSet.DsParamSet, pDS,
+                   sizeof(IEEEtypes_DsParamSet_t));
+            break;
+
+        case CF_PARAM_SET:
+            pCF = (IEEEtypes_CfParamSet_t *) pCurrentPtr;
+            memcpy(&pBSSEntry->SsParamSet.CfParamSet, pCF,
+                   sizeof(IEEEtypes_CfParamSet_t));
+            break;
+
+        case IBSS_PARAM_SET:
+            pIbss = (IEEEtypes_IbssParamSet_t *) pCurrentPtr;
+            pBSSEntry->ATIMWindow = wlan_le32_to_cpu(pIbss->AtimWindow);
+            memcpy(&pBSSEntry->SsParamSet.IbssParamSet, pIbss,
+                   sizeof(IEEEtypes_IbssParamSet_t));
+            break;
+
+            /* Handle Country Info IE */
+        case COUNTRY_INFO:
+            pcountryinfo = (IEEEtypes_CountryInfoSet_t *) pCurrentPtr;
+
+            if (pcountryinfo->Len < sizeof(pcountryinfo->CountryCode)
+                || pcountryinfo->Len > 254) {
+                PRINTM(INFO, "InterpretIE: 11D- Err "
+                       "CountryInfo len =%d min=%d max=254\n",
+                       pcountryinfo->Len, sizeof(pcountryinfo->CountryCode));
+                LEAVE();
+                return WLAN_STATUS_FAILURE;
+            }
+
+            memcpy(&pBSSEntry->CountryInfo,
+                   pcountryinfo, pcountryinfo->Len + 2);
+            HEXDUMP("InterpretIE: 11D- CountryInfo:",
+                    (u8 *) pcountryinfo, (u32) (pcountryinfo->Len + 2));
+            break;
+        case ERP_INFO:
+            pERPInfo = (IEEEtypes_ERPInfo_t *) pCurrentPtr;
+            pBSSEntry->ERPFlags = pERPInfo->ERPFlags;
+            break;
+        case POWER_CONSTRAINT:
+        case POWER_CAPABILITY:
+        case TPC_REPORT:
+        case CHANNEL_SWITCH_ANN:
+        case QUIET:
+        case IBSS_DFS:
+        case SUPPORTED_CHANNELS:
+        case TPC_REQUEST:
+            wlan_11h_process_bss_elem(&pBSSEntry->wlan_11h_bss_info,
+                                      pCurrentPtr);
+            break;
+        case EXTENDED_SUPPORTED_RATES:
+            /*
+             * only process extended supported rate
+             * if data rate is already found.
+             * data rate IE should come before
+             * extended supported rate IE
+             */
+            if (foundDataRateIE) {
+                if ((elemLen + rateSize) > WLAN_SUPPORTED_RATES) {
+                    bytesToCopy = (WLAN_SUPPORTED_RATES - rateSize);
+                } else {
+                    bytesToCopy = elemLen;
+                }
+
+                pRate = (u8 *) pBSSEntry->DataRates;
+                pRate += rateSize;
+                memcpy(pRate, pCurrentPtr + 2, bytesToCopy);
+
+                pRate = (u8 *) pBSSEntry->SupportedRates;
+                pRate += rateSize;
+                memcpy(pRate, pCurrentPtr + 2, bytesToCopy);
+            }
+            HEXDUMP("InterpretIE: ExtSupportedRates:",
+                    pBSSEntry->SupportedRates, elemLen + rateSize);
+            break;
+
+        case VENDOR_SPECIFIC_221:
+            pVendorIe = (IEEEtypes_VendorSpecific_t *) pCurrentPtr;
+
+            if (!memcmp(pVendorIe->VendHdr.Oui, wpa_oui, sizeof(wpa_oui))) {
+                pBSSEntry->pWpaIE =
+                    (IEEEtypes_VendorSpecific_t *) pCurrentPtr;
+                pBSSEntry->wpaOffset = pCurrentPtr - pBSSEntry->pBeaconBuf;
+                pBSSEntry->pWpaIE =
+                    (IEEEtypes_VendorSpecific_t *) (pBSSEntry->pBeaconBuf +
+                                                    pBSSEntry->wpaOffset);
+                HEXDUMP("InterpretIE: Resp WPA_IE", (u8 *) pBSSEntry->pWpaIE,
+                        ((*(pBSSEntry->pWpaIE)).VendHdr.Len +
+                         sizeof(IEEEtypes_Header_t)));
+            } else
+                if (!memcmp(pVendorIe->VendHdr.Oui, wmm_oui, sizeof(wmm_oui)))
+            {
+                if (totalIeLen == sizeof(IEEEtypes_WmmParameter_t)
+                    || totalIeLen == sizeof(IEEEtypes_WmmInfo_t)) {
+
+                    /* Only accept and copy the WMM IE if it matches
+                     *  the size expected for the WMM Info IE or the
+                     *  WMM Parameter IE.
+                     */
+                    memcpy((u8 *) & pBSSEntry->wmmIE, pCurrentPtr,
+                           totalIeLen);
+                    HEXDUMP("InterpretIE: Resp WMM_IE",
+                            (u8 *) & pBSSEntry->wmmIE, totalIeLen);
+                }
+            } else if (!memcmp(pVendorIe->VendHdr.Oui,
+                               wps_oui, sizeof(wps_oui))) {
+                pBSSEntry->pWpsIE =
+                    (IEEEtypes_VendorSpecific_t *) pCurrentPtr;
+                pBSSEntry->wpsOffset = pCurrentPtr - pBSSEntry->pBeaconBuf;
+                pBSSEntry->pWpsIE =
+                    (IEEEtypes_VendorSpecific_t *) (pBSSEntry->pBeaconBuf +
+                                                    pBSSEntry->wpsOffset);
+                HEXDUMP("InterpretIE: Resp WPS_IE", (u8 *) pBSSEntry->pWpsIE,
+                        totalIeLen);
+            }
+            break;
+        case RSN_IE:
+            pBSSEntry->pRsnIE = (IEEEtypes_Generic_t *) pCurrentPtr;
+            pBSSEntry->rsnOffset = pCurrentPtr - pBSSEntry->pBeaconBuf;
+            pBSSEntry->pRsnIE =
+                (IEEEtypes_Generic_t *) (pBSSEntry->pBeaconBuf +
+                                         pBSSEntry->rsnOffset);
+            HEXDUMP("InterpretIE: Resp RSN_IE", (u8 *) pBSSEntry->pRsnIE,
+                    (*(pBSSEntry->pRsnIE)).IeeeHdr.Len +
+                    sizeof(IEEEtypes_Header_t));
+            break;
+        }
+
+        pCurrentPtr += elemLen + 2;
+
+        /* need to account for IE ID and IE Len */
+        bytesLeftForCurrentBeacon -= (elemLen + 2);
+
+    }                           /* while (bytesLeftForCurrentBeacon > 2) */
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Compare two SSIDs
+ *
+ *  @param ssid1    A pointer to ssid to compare
+ *  @param ssid2    A pointer to ssid to compare
+ *
+ *  @return         0--ssid is same, otherwise is different
+ */
+int
+wlan_ssid_cmp(WLAN_802_11_SSID * ssid1, WLAN_802_11_SSID * ssid2)
+{
+    if (!ssid1 || !ssid2)
+        return -1;
+
+    if (ssid1->SsidLength != ssid2->SsidLength)
+        return -1;
+
+    return memcmp(ssid1->Ssid, ssid2->Ssid, ssid1->SsidLength);
+}
+
+/**
+ *  @brief This function finds a specific compatible BSSID in the scan list
+ *
+ *  @param Adapter  A pointer to wlan_adapter
+ *  @param bssid    BSSID to find in the scan list
+ *  @param mode     Network mode: Infrastructure or IBSS
+ *
+ *  @return         index in BSSID list, or error return code (< 0)
+ */
+int
+wlan_find_bssid_in_list(wlan_adapter * Adapter, u8 * bssid, int mode)
+{
+    int ret = -ENETUNREACH;
+    int i;
+
+    if (!bssid)
+        return -EFAULT;
+
+    PRINTM(INFO, "FindBSSID: Num of BSSIDs = %d\n", Adapter->NumInScanTable);
+
+    /* Look through the scan table for a compatible match. The ret return
+     *   variable will be equal to the index in the scan table (greater
+     *   than zero) if the network is compatible.  The loop will continue
+     *   past a matched bssid that is not compatible in case there is an
+     *   AP with multiple SSIDs assigned to the same BSSID
+     */
+    for (i = 0; ret < 0 && i < Adapter->NumInScanTable; i++) {
+        if (!memcmp(Adapter->ScanTable[i].MacAddress, bssid, ETH_ALEN)) {
+            switch (mode) {
+            case Wlan802_11Infrastructure:
+            case Wlan802_11IBSS:
+                ret = wlan_is_network_compatible(Adapter, i, mode);
+                break;
+            default:
+                ret = i;
+                break;
+            }
+        }
+    }
+
+    if (ret >= 0) {
+        if (find_cfp_by_band_and_channel
+            (Adapter, Adapter->ScanTable[ret].bss_band,
+             Adapter->ScanTable[ret].Channel) == NULL) {
+            ret = -ENETUNREACH;
+        }
+    }
+    return ret;
+}
+
+/**
+ *  @brief This function finds ssid in ssid list.
+ *
+ *  @param Adapter      A pointer to wlan_adapter
+ *  @param ssid         SSID to find in the list
+ *  @param bssid        BSSID to qualify the SSID selection (if provided)
+ *  @param mode         Network mode: Infrastructure or IBSS
+ *
+ *  @return         index in BSSID list
+ */
+int
+wlan_find_ssid_in_list(wlan_adapter * Adapter, WLAN_802_11_SSID * ssid,
+                       u8 * bssid, int mode)
+{
+    int net = -ENETUNREACH;
+    u8 bestrssi = 0;
+    int i, j;
+
+    PRINTM(INFO, "Num of Entries in Table = %d\n", Adapter->NumInScanTable);
+
+    /* Loop through the table until the maximum is reached or until a match
+     *   is found based on the bssid field comparison 
+     */
+    for (i = 0;
+         i < Adapter->NumInScanTable && (bssid == NULL || (bssid && net < 0));
+         i++) {
+
+        if (!wlan_ssid_cmp(&Adapter->ScanTable[i].Ssid, ssid) &&
+            ((bssid == NULL)
+             || !memcmp(Adapter->ScanTable[i].MacAddress, bssid, ETH_ALEN))) {
+            switch (mode) {
+            case Wlan802_11Infrastructure:
+            case Wlan802_11IBSS:
+                j = wlan_is_network_compatible(Adapter, i, mode);
+
+                if (j >= 0) {
+                    if (SCAN_RSSI(Adapter->ScanTable[i].Rssi) > bestrssi) {
+                        bestrssi = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+                        net = i;
+                    }
+                } else {
+                    if (net == -ENETUNREACH) {
+                        net = j;
+                    }
+                }
+                break;
+            case Wlan802_11AutoUnknown:
+            default:
+                /* Do not check compatibility if the mode requested is 
+                 *   AutoUnknown.  Allows generic find to work without 
+                 *   verifying against the Adapter security settings
+                 */
+                if (SCAN_RSSI(Adapter->ScanTable[i].Rssi) > bestrssi) {
+                    bestrssi = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+                    net = i;
+                }
+                break;
+            }
+        }
+    }
+    if (net >= 0) {
+        if (find_cfp_by_band_and_channel
+            (Adapter, Adapter->ScanTable[net].bss_band,
+             Adapter->ScanTable[net].Channel) == NULL) {
+            net = -ENETUNREACH;
+        }
+    }
+    return net;
+}
+
+/**
+ *  @brief This function finds the best SSID in the Scan List
+ *
+ *  Search the scan table for the best SSID that also matches the current
+ *   adapter network preference (infrastructure or adhoc)
+ *
+ *  @param Adapter  A pointer to wlan_adapter
+ *
+ *  @return         index in BSSID list
+ */
+int
+wlan_find_best_ssid_in_list(wlan_adapter * Adapter)
+{
+    int mode = Adapter->InfrastructureMode;
+    int bestnet = -ENETUNREACH;
+    u8 bestrssi = 0;
+    int i;
+
+    ENTER();
+
+    PRINTM(INFO, "Num of BSSIDs = %d\n", Adapter->NumInScanTable);
+
+    for (i = 0; i < Adapter->NumInScanTable; i++) {
+        switch (mode) {
+        case Wlan802_11Infrastructure:
+        case Wlan802_11IBSS:
+            if (wlan_is_network_compatible(Adapter, i, mode) >= 0) {
+                if (SCAN_RSSI(Adapter->ScanTable[i].Rssi) > bestrssi) {
+                    bestrssi = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+                    bestnet = i;
+                }
+            }
+            break;
+        case Wlan802_11AutoUnknown:
+        default:
+            if (SCAN_RSSI(Adapter->ScanTable[i].Rssi) > bestrssi) {
+                bestrssi = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+                bestnet = i;
+            }
+            break;
+        }
+    }
+
+    LEAVE();
+    return bestnet;
+}
+
+/**
+ *  @brief Find the AP with specific ssid in the scan list
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param pSSID        A pointer to AP's ssid
+ *
+ *  @return             WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int
+wlan_find_best_network_ssid(wlan_private * priv, WLAN_802_11_SSID * pSSID)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    BSSDescriptor_t *pReqBSSID;
+    int i;
+
+    ENTER();
+
+    memset(pSSID, 0, sizeof(WLAN_802_11_SSID));
+
+    wlan_scan_networks(priv, NULL);
+
+    i = wlan_find_best_ssid_in_list(Adapter);
+
+    if (i >= 0) {
+
+        pReqBSSID = &Adapter->ScanTable[i];
+        memcpy(pSSID, &pReqBSSID->Ssid, sizeof(WLAN_802_11_SSID));
+
+        /* Make sure we are in the right mode */
+        if (Adapter->InfrastructureMode == Wlan802_11AutoUnknown) {
+            Adapter->InfrastructureMode = pReqBSSID->InfrastructureMode;
+
+            ret = wlan_prepare_cmd(priv,
+                                   HostCmd_CMD_802_11_SNMP_MIB,
+                                   HostCmd_ACT_GEN_SET,
+                                   HostCmd_OPTION_WAITFORRSP,
+                                   DesiredBssType_i, NULL);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+        }
+    }
+
+    if (!pSSID->SsidLength) {
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Convert radio type scan paramter to a band config used in join cmd
+ *
+ *  @param radioType Scan parameter indicating the radio used for a channel
+ *                   in a scan command.
+ *
+ *  @return          Band type conversion of scanBand used in join/assoc cmds
+ *
+ */
+static u8
+radio_type_to_band(u8 radioType)
+{
+    u8 retBand;
+
+    switch (radioType) {
+    case HostCmd_SCAN_RADIO_TYPE_A:
+        retBand = BAND_A;
+        break;
+    case HostCmd_SCAN_RADIO_TYPE_BG:
+    default:
+        retBand = BAND_G;
+        break;
+    }
+
+    return retBand;
+}
+
+/**
+ *  @brief Delete a specific indexed entry from the scan table.
+ *
+ *  Delete the scan table entry indexed by tableIdx.  Compact the remaining
+ *    entries and adjust any buffering of beacon/probe response data
+ *    if needed.
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param tableIdx   Scan table entry index to delete from the table
+ *
+ *  @return           void
+ *
+ *  @pre              tableIdx must be an index to a valid entry
+ */
+static void
+wlan_scan_delete_table_entry(wlan_private * priv, int tableIdx)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int delIdx;
+    uint beaconBufAdj;
+    u8 *pBeaconBuf;
+
+    /* Shift the saved beacon buffer data for the scan table back over the
+     *   entry being removed.  Update the end of buffer pointer.  Save the 
+     *   deleted buffer allocation size for pointer adjustments for entries
+     *   compacted after the deleted index.
+     */
+    beaconBufAdj = Adapter->ScanTable[tableIdx].beaconBufSizeMax;
+
+    PRINTM(INFO, "Scan: Delete Entry %d, beacon buffer removal = %d bytes\n",
+           tableIdx, beaconBufAdj);
+
+    /* Check if the table entry had storage allocated for its beacon */
+    if (beaconBufAdj) {
+        pBeaconBuf = Adapter->ScanTable[tableIdx].pBeaconBuf;
+
+        /* Remove the entry's buffer space, decrement the table end pointer
+         *   by the amount we are removing 
+         */
+        Adapter->pBeaconBufEnd -= beaconBufAdj;
+
+        PRINTM(INFO,
+               "Scan: Delete Entry %d, compact data: %p <- %p (sz = %d)\n",
+               tableIdx,
+               pBeaconBuf,
+               pBeaconBuf + beaconBufAdj,
+               Adapter->pBeaconBufEnd - pBeaconBuf);
+
+        /* Compact data storage.  Copy all data after the deleted entry's
+         *   end address (pBeaconBuf + beaconBufAdj) back to the original
+         *   start address (pBeaconBuf).
+         *
+         * Scan table entries affected by the move will have their entry
+         *   pointer adjusted below.
+         *
+         * Use memmove since the dest/src memory regions overlap.
+         */
+        memmove(pBeaconBuf,
+                pBeaconBuf + beaconBufAdj,
+                Adapter->pBeaconBufEnd - pBeaconBuf);
+    }
+
+    PRINTM(INFO, "Scan: Delete Entry %d, NumInScanTable = %d\n",
+           tableIdx, Adapter->NumInScanTable);
+
+    /* Shift all of the entries after the tableIdx back by one, compacting
+     *   the table and removing the requested entry
+     */
+    for (delIdx = tableIdx; (delIdx + 1) < Adapter->NumInScanTable; delIdx++) {
+        /* Copy the next entry over this one */
+        memcpy(Adapter->ScanTable + delIdx,
+               Adapter->ScanTable + delIdx + 1, sizeof(BSSDescriptor_t));
+
+        /* Adjust this entry's pointer to its beacon buffer based on the 
+         *   removed/compacted entry from the deleted index.  Don't decrement
+         *   if the buffer pointer is NULL (no data stored for this entry).
+         */
+        if (Adapter->ScanTable[delIdx].pBeaconBuf) {
+            Adapter->ScanTable[delIdx].pBeaconBuf -= beaconBufAdj;
+            if (Adapter->ScanTable[delIdx].pWpaIE) {
+                Adapter->ScanTable[delIdx].pWpaIE =
+                    (IEEEtypes_VendorSpecific_t *)
+                    (Adapter->ScanTable[delIdx].pBeaconBuf +
+                     Adapter->ScanTable[delIdx].wpaOffset);
+            }
+            if (Adapter->ScanTable[delIdx].pRsnIE) {
+                Adapter->ScanTable[delIdx].pRsnIE = (IEEEtypes_Generic_t *)
+                    (Adapter->ScanTable[delIdx].pBeaconBuf +
+                     Adapter->ScanTable[delIdx].rsnOffset);
+            }
+            if (Adapter->ScanTable[delIdx].pWpsIE) {
+                Adapter->ScanTable[delIdx].pWpsIE =
+                    (IEEEtypes_VendorSpecific_t *)
+                    (Adapter->ScanTable[delIdx].pBeaconBuf +
+                     Adapter->ScanTable[delIdx].wpsOffset);
+            }
+        }
+    }
+
+    /* The last entry is invalid now that it has been deleted or moved back */
+    memset(Adapter->ScanTable + Adapter->NumInScanTable - 1,
+           0x00, sizeof(BSSDescriptor_t));
+
+    Adapter->NumInScanTable--;
+}
+
+/**
+ *  @brief Delete all occurrences of a given SSID from the scan table
+ *
+ *  Iterate through the scan table and delete all entries that match a given
+ *    SSID.  Compact the remaining scan table entries.
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param pDelSSID   Pointer to an SSID struct to use in deleting all
+ *                    matching SSIDs from the scan table
+ *
+ *  @return           WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ *
+ */
+static int
+wlan_scan_delete_ssid_table_entry(wlan_private * priv,
+                                  WLAN_802_11_SSID * pDelSSID)
+{
+    int tableIdx;
+    int retval = WLAN_STATUS_FAILURE;
+
+    ENTER();
+
+    PRINTM(INFO, "Scan: Delete Ssid Entry: %-32s\n", pDelSSID->Ssid);
+
+    /* If the requested SSID is found in the table, delete it.  Then keep
+     *   searching the table for multiple entires for the SSID until no
+     *   more are found 
+     */
+    while ((tableIdx = wlan_find_ssid_in_list(priv->adapter,
+                                              pDelSSID,
+                                              NULL,
+                                              Wlan802_11AutoUnknown)) >= 0) {
+        PRINTM(INFO, "Scan: Delete Ssid Entry: Found Idx = %d\n", tableIdx);
+        retval = WLAN_STATUS_SUCCESS;
+        wlan_scan_delete_table_entry(priv, tableIdx);
+    }
+
+    LEAVE();
+
+    return retval;
+}
+
+/**
+ *  @brief Scan Network
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param vwrq         A pointer to iw_param structure
+ *  @param extra        A pointer to extra data buf
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_scan(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    union iwreq_data wrqu;
+#if WIRELESS_EXT >= 18
+    struct iw_scan_req *req;
+    struct iw_point *dwrq = (struct iw_point *) vwrq;
+    wlan_ioctl_user_scan_cfg scanCfg;
+#endif
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+#ifdef REASSOCIATION
+    if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+        PRINTM(ERROR, "Acquire semaphore error, wlan_set_scan\n");
+        return -EBUSY;
+    }
+#endif
+#if WIRELESS_EXT >= 18
+    if ((dwrq->flags & IW_SCAN_THIS_ESSID) &&
+        (dwrq->length == sizeof(struct iw_scan_req))) {
+        req = (struct iw_scan_req *) extra;
+        if (req->essid_len <= MRVDRV_MAX_SSID_LENGTH) {
+            memset(&scanCfg, 0x00, sizeof(scanCfg));
+            memcpy(scanCfg.ssidList[0].ssid, (u8 *) req->essid,
+                   req->essid_len);
+            if (!wlan_scan_networks(priv, &scanCfg)) {
+                memset(&wrqu, 0, sizeof(union iwreq_data));
+                wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu,
+                                    NULL);
+            }
+        }
+    } else {
+#endif
+        if (!wlan_scan_networks(priv, NULL)) {
+            memset(&wrqu, 0, sizeof(union iwreq_data));
+            wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu,
+                                NULL);
+        }
+#if WIRELESS_EXT >= 18
+    }
+#endif
+
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+
+    if (Adapter->SurpriseRemoved)
+        return WLAN_STATUS_FAILURE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Send a scan command for all available channels filtered on a spec
+ *
+ *  @param priv             A pointer to wlan_private structure
+ *  @param pRequestedSSID   A pointer to AP's ssid
+ *
+ *  @return                WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+int
+wlan_cmd_specific_scan_ssid(wlan_private * priv,
+                            WLAN_802_11_SSID * pRequestedSSID)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_user_scan_cfg scanCfg;
+
+    ENTER();
+
+    if (pRequestedSSID == NULL) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    wlan_scan_delete_ssid_table_entry(priv, pRequestedSSID);
+
+    memset(&scanCfg, 0x00, sizeof(scanCfg));
+
+    memcpy(scanCfg.ssidList[0].ssid,
+           pRequestedSSID->Ssid, pRequestedSSID->SsidLength);
+    scanCfg.keepPreviousScan = TRUE;
+
+    wlan_scan_networks(priv, &scanCfg);
+
+    if (Adapter->SurpriseRemoved)
+        return WLAN_STATUS_FAILURE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief scan an AP with specific BSSID
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param bssid     A pointer to AP's bssid
+ *
+ *  @return          WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+int
+wlan_cmd_specific_scan_bssid(wlan_private * priv, u8 * bssid)
+{
+    wlan_ioctl_user_scan_cfg scanCfg;
+
+    ENTER();
+
+    if (bssid == NULL) {
+        return WLAN_STATUS_FAILURE;
+    }
+
+    memset(&scanCfg, 0x00, sizeof(scanCfg));
+    memcpy(scanCfg.specificBSSID, bssid, sizeof(scanCfg.specificBSSID));
+    scanCfg.keepPreviousScan = TRUE;
+
+    wlan_scan_networks(priv, &scanCfg);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief  Retrieve the scan table entries via wireless tools IOCTL call
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_scan(struct net_device *dev, struct iw_request_info *info,
+              struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    char *current_ev = extra;
+    char *end_buf = extra + IW_SCAN_MAX_DATA;
+    CHANNEL_FREQ_POWER *cfp;
+    BSSDescriptor_t *pScanTable;
+    char *current_val;          /* For rates */
+    struct iw_event iwe;        /* Temporary buffer */
+    int i;
+    int j;
+
+    u8 buf[16 + 256 * 2];
+    u8 *ptr;
+    u8 *pRawData;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        return -EBUSY;
+    }
+
+    if (dwrq->length)
+        end_buf = extra + dwrq->length;
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        PRINTM(INFO, "Current Ssid: %-32s\n",
+               Adapter->CurBssParams.BSSDescriptor.Ssid.Ssid);
+    }
+
+    PRINTM(INFO, "Scan: Get: NumInScanTable = %d\n", Adapter->NumInScanTable);
+
+#if WIRELESS_EXT > 13
+    /* The old API using SIOCGIWAPLIST had a hard limit of IW_MAX_AP.
+     * The new API using SIOCGIWSCAN is only limited by buffer size
+     * WE-14 -> WE-16 the buffer is limited to IW_SCAN_MAX_DATA bytes
+     * which is 4096.
+     */
+    for (i = 0; i < Adapter->NumInScanTable; i++) {
+        if ((current_ev + MAX_SCAN_CELL_SIZE) >= end_buf) {
+            PRINTM(INFO, "i=%d break out: current_ev=%p end_buf=%p "
+                   "MAX_SCAN_CELL_SIZE=%d\n",
+                   i, current_ev, end_buf, MAX_SCAN_CELL_SIZE);
+            ret = -E2BIG;
+            break;
+        }
+
+        pScanTable = &Adapter->ScanTable[i];
+
+        PRINTM(INFO, "i=%d  Ssid: %-32s\n", i, pScanTable->Ssid.Ssid);
+
+        cfp = find_cfp_by_band_and_channel(Adapter,
+                                           pScanTable->bss_band,
+                                           (u16) pScanTable->Channel);
+        if (!cfp) {
+            PRINTM(INFO, "Invalid channel number %d\n", pScanTable->Channel);
+            continue;
+        }
+
+        if (ssid_valid(&Adapter->ScanTable[i].Ssid) == FALSE) {
+            continue;
+        }
+
+        /* First entry *MUST* be the AP MAC address */
+        iwe.cmd = SIOCGIWAP;
+        iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+        memcpy(iwe.u.ap_addr.sa_data,
+               &Adapter->ScanTable[i].MacAddress, ETH_ALEN);
+
+        iwe.len = IW_EV_ADDR_LEN;
+        current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, iwe.len);
+
+        //Add the ESSID
+        iwe.u.data.length = Adapter->ScanTable[i].Ssid.SsidLength;
+
+        if (iwe.u.data.length > 32) {
+            iwe.u.data.length = 32;
+        }
+
+        iwe.cmd = SIOCGIWESSID;
+        iwe.u.essid.flags = (i + 1) & IW_ENCODE_INDEX;
+        iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+        current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe,
+                                          (s8 *) Adapter->ScanTable[i].Ssid.
+                                          Ssid);
+
+        //Add mode
+        iwe.cmd = SIOCGIWMODE;
+        if (Adapter->ScanTable[i].InfrastructureMode == Wlan802_11IBSS)
+            iwe.u.mode = IW_MODE_ADHOC;
+        else if (Adapter->ScanTable[i].InfrastructureMode ==
+                 Wlan802_11Infrastructure)
+            iwe.u.mode = IW_MODE_MASTER;
+        else
+            iwe.u.mode = IW_MODE_AUTO;
+
+        iwe.len = IW_EV_UINT_LEN;
+        current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, iwe.len);
+
+        //frequency
+        iwe.cmd = SIOCGIWFREQ;
+        iwe.u.freq.m = (long) cfp->Freq * 100000;
+        iwe.u.freq.e = 1;
+        iwe.len = IW_EV_FREQ_LEN;
+        current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, iwe.len);
+
+        /* Add quality statistics */
+        iwe.cmd = IWEVQUAL;
+        iwe.u.qual.level = SCAN_RSSI(Adapter->ScanTable[i].Rssi);
+        iwe.u.qual.qual = 0;
+        if (Adapter->NF[TYPE_BEACON][TYPE_NOAVG] == 0) {
+            iwe.u.qual.noise = MRVDRV_NF_DEFAULT_SCAN_VALUE;
+        } else {
+            iwe.u.qual.noise = CAL_NF(Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+        }
+        if ((Adapter->InfrastructureMode == Wlan802_11IBSS) &&
+            !wlan_ssid_cmp(&Adapter->CurBssParams.BSSDescriptor.Ssid,
+                           &Adapter->ScanTable[i].Ssid)
+            && Adapter->AdhocState == ADHOC_STARTED) {
+            ret = wlan_prepare_cmd(priv,
+                                   HostCmd_CMD_802_11_RSSI,
+                                   0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+            iwe.u.qual.level =
+                CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+                         Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+        }
+
+        iwe.len = IW_EV_QUAL_LEN;
+        current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, iwe.len);
+
+        /* Add encryption capability */
+        iwe.cmd = SIOCGIWENCODE;
+        if (Adapter->ScanTable[i].Privacy) {
+            iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+        } else {
+            iwe.u.data.flags = IW_ENCODE_DISABLED;
+        }
+        iwe.u.data.length = 0;
+        iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+        current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, NULL);
+
+        current_val = current_ev + IW_EV_LCP_LEN;
+
+        iwe.cmd = SIOCGIWRATE;
+
+        iwe.u.bitrate.fixed = 0;
+        iwe.u.bitrate.disabled = 0;
+        iwe.u.bitrate.value = 0;
+
+        /* Bit rate given in 500 kb/s units (+ 0x80) */
+        for (j = 0; j < sizeof(Adapter->ScanTable[i].SupportedRates); j++) {
+            if (Adapter->ScanTable[i].SupportedRates[j] == 0) {
+                break;
+            }
+
+            iwe.u.bitrate.value = (Adapter->ScanTable[i].SupportedRates[j]
+                                   & 0x7f) * 500000;
+            iwe.len = IW_EV_PARAM_LEN;
+            current_val =
+                iwe_stream_add_value(current_ev, current_val, end_buf, &iwe,
+                                     iwe.len);
+
+        }
+        if ((Adapter->ScanTable[i].InfrastructureMode == Wlan802_11IBSS) &&
+            !wlan_ssid_cmp(&Adapter->CurBssParams.BSSDescriptor.Ssid,
+                           &Adapter->ScanTable[i].Ssid)
+            && Adapter->AdhocState == ADHOC_STARTED) {
+            iwe.u.bitrate.value = 22 * 500000;
+            iwe.len = IW_EV_PARAM_LEN;
+            current_val =
+                iwe_stream_add_value(current_ev, current_val, end_buf, &iwe,
+                                     iwe.len);
+        }
+
+        /* Check if an event is added */
+        if ((current_val - current_ev) > IW_EV_PARAM_LEN)
+            current_ev = current_val;
+
+        /* Beacon Interval */
+        memset(&iwe, 0, sizeof(iwe));
+        memset(buf, 0, sizeof(buf));
+        ptr = buf;
+        ptr +=
+            sprintf(ptr, "Beacon interval=%d",
+                    Adapter->ScanTable[i].BeaconPeriod);
+
+        iwe.u.data.length = strlen(buf);
+        iwe.cmd = IWEVCUSTOM;
+        iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+        current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+        current_val = current_ev + IW_EV_LCP_LEN + strlen(buf);
+
+        if (Adapter->ScanTable[i].pRsnIE) {
+            if ((*(Adapter->ScanTable[i].pRsnIE)).IeeeHdr.ElementId == RSN_IE) {
+                pRawData = (u8 *) Adapter->ScanTable[i].pRsnIE;
+                memset(&iwe, 0, sizeof(iwe));
+                memset(buf, 0, sizeof(buf));
+                ptr = buf;
+#if WIRELESS_EXT >= 18
+                memcpy(buf, pRawData,
+                       (*(Adapter->ScanTable[i].pRsnIE)).IeeeHdr.Len + 2);
+                iwe.cmd = IWEVGENIE;
+                iwe.u.data.length =
+                    (*(Adapter->ScanTable[i].pRsnIE)).IeeeHdr.Len + 2;
+#else
+                ptr += sprintf(ptr, "rsn_ie=");
+
+                for (j = 0;
+                     j < ((*(Adapter->ScanTable[i].pRsnIE)).IeeeHdr.Len
+                          + sizeof(IEEEtypes_Header_t)); j++) {
+                    ptr += sprintf(ptr, "%02x", *(pRawData + j));
+                }
+                iwe.u.data.length = strlen(buf);
+
+                PRINTM(INFO, "iwe.u.data.length %d\n", iwe.u.data.length);
+                PRINTM(INFO, "WPA2 BUF: %s \n", buf);
+                iwe.cmd = IWEVCUSTOM;
+#endif
+                iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+                current_ev =
+                    iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+                current_val = current_ev + IW_EV_LCP_LEN + strlen(buf);
+            }
+        }
+        if (Adapter->ScanTable[i].pWpaIE) {
+            if ((*(Adapter->ScanTable[i].pWpaIE)).VendHdr.ElementId == WPA_IE) {
+                pRawData = (u8 *) Adapter->ScanTable[i].pWpaIE;
+                memset(&iwe, 0, sizeof(iwe));
+                memset(buf, 0, sizeof(buf));
+                ptr = buf;
+#if WIRELESS_EXT >= 18
+                memcpy(buf, pRawData,
+                       (*(Adapter->ScanTable[i].pWpaIE)).VendHdr.Len + 2);
+                iwe.cmd = IWEVGENIE;
+                iwe.u.data.length =
+                    (*(Adapter->ScanTable[i].pWpaIE)).VendHdr.Len + 2;
+#else
+                ptr += sprintf(ptr, "wpa_ie=");
+
+                for (j = 0;
+                     j < ((*(Adapter->ScanTable[i].pWpaIE)).VendHdr.Len
+                          + sizeof(IEEEtypes_Header_t)); j++) {
+                    ptr += sprintf(ptr, "%02x", *(pRawData + j));
+                }
+                iwe.u.data.length = strlen(buf);
+
+                PRINTM(INFO, "iwe.u.data.length %d\n", iwe.u.data.length);
+                PRINTM(INFO, "WPA BUF: %s \n", buf);
+
+                iwe.cmd = IWEVCUSTOM;
+#endif
+                iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+                current_ev =
+                    iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+                current_val = current_ev + IW_EV_LCP_LEN + strlen(buf);
+            }
+        }
+        if (Adapter->ScanTable[i].pWpsIE) {
+            if ((*(Adapter->ScanTable[i].pWpsIE)).VendHdr.ElementId == WPS_IE) {
+                pRawData = (u8 *) Adapter->ScanTable[i].pWpsIE;
+                memset(&iwe, 0, sizeof(iwe));
+                memset(buf, 0, sizeof(buf));
+                ptr = buf;
+                ptr += sprintf(ptr, "wps_ie=");
+
+                for (j = 0;
+                     j < ((*(Adapter->ScanTable[i].pWpsIE)).VendHdr.Len
+                          + sizeof(IEEEtypes_Header_t)); j++) {
+                    ptr += sprintf(ptr, "%02x", *(pRawData + j));
+                }
+                iwe.u.data.length = strlen(buf);
+
+                PRINTM(INFO, "iwe.u.data.length %d\n", iwe.u.data.length);
+                PRINTM(INFO, "WPS BUF: %s \n", buf);
+
+                iwe.cmd = IWEVCUSTOM;
+                iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+                current_ev =
+                    iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+                current_val = current_ev + IW_EV_LCP_LEN + strlen(buf);
+            }
+        }
+
+        if (Adapter->ScanTable[i].wmmIE.VendHdr.ElementId == WMM_IE) {
+            pRawData = (u8 *) & Adapter->ScanTable[i].wmmIE;
+            memset(&iwe, 0, sizeof(iwe));
+            memset(buf, 0, sizeof(buf));
+            ptr = buf;
+            ptr += sprintf(ptr, "wmm_ie=");
+
+            for (j = 0;
+                 j < (Adapter->ScanTable[i].wmmIE.VendHdr.Len
+                      + sizeof(IEEEtypes_Header_t)); j++) {
+                ptr += sprintf(ptr, "%02x", *(pRawData + j));
+            }
+            iwe.u.data.length = strlen(buf);
+
+            PRINTM(INFO, "iwe.u.data.length %d\n", iwe.u.data.length);
+            PRINTM(INFO, "WMM BUF: %s \n", buf);
+
+            iwe.cmd = IWEVCUSTOM;
+            iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+            current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+            current_val = current_ev + IW_EV_LCP_LEN + strlen(buf);
+        }
+#if WIRELESS_EXT > 14
+        memset(&iwe, 0, sizeof(iwe));
+        memset(buf, 0, sizeof(buf));
+        ptr = buf;
+        ptr += sprintf(ptr, "band=");
+
+        memset(&iwe, 0, sizeof(iwe));
+
+        if (Adapter->ScanTable[i].bss_band == BAND_A) {
+            ptr += sprintf(ptr, "a");
+        } else {
+            ptr += sprintf(ptr, "bg");
+        }
+
+        iwe.u.data.length = strlen(buf);
+
+        PRINTM(INFO, "iwe.u.data.length %d\n", iwe.u.data.length);
+        PRINTM(INFO, "BUF: %s \n", buf);
+
+        iwe.cmd = IWEVCUSTOM;
+        iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+        current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+        current_val = current_ev + IW_EV_LCP_LEN + strlen(buf);
+#endif
+
+        current_val = current_ev + IW_EV_LCP_LEN;
+
+        /*
+         * Check if we added any event
+         */
+        if ((current_val - current_ev) > IW_EV_LCP_LEN)
+            current_ev = current_val;
+    }
+
+    dwrq->length = (current_ev - extra);
+    dwrq->flags = 0;
+
+    LEAVE();
+#endif
+    return ret;
+}
+
+/** 
+ *  @brief Create a wlan_ioctl_get_scan_table_entry for a given BSS 
+ *         Descriptor for inclusion in the ioctl response to the user space
+ *         application.
+ *
+ *
+ *  @param priv      A pointer to wlan_private structure
+ *  @param pBSSDesc  Pointer to a BSS entry in the scan table to form
+ *                   scan response from for delivery to the application layer
+ *  @param ppBuffer  Output parameter: Buffer used to output scan return struct
+ *  @param pSpaceLeft Output parameter: Number of bytes available in the 
+ *                    response buffer.
+ *
+ *  @return WLAN_STATUS_SUCCESS, or < 0 with IOCTL error code
+ */
+static int
+wlan_get_scan_table_ret_entry(wlan_private * priv,
+                              BSSDescriptor_t * pBSSDesc,
+                              u8 ** ppBuffer, int *pSpaceLeft)
+{
+    wlan_adapter *Adapter;
+    wlan_ioctl_get_scan_table_entry *pRspEntry;
+    wlan_ioctl_get_scan_table_entry tmpRspEntry;
+    int spaceNeeded;
+    u8 *pCurrent;
+    int variableSize;
+
+    const int fixedSize = (sizeof(tmpRspEntry.fixedFieldLength)
+                           + sizeof(tmpRspEntry.fixedFields)
+                           + sizeof(tmpRspEntry.bssInfoLength));
+
+    ENTER();
+
+    Adapter = priv->adapter;
+    pCurrent = *ppBuffer;
+
+    /* The variable size returned is the stored beacon size */
+    variableSize = pBSSDesc->beaconBufSize;
+
+    /* If we stored a beacon and its size was zero, set the variable
+     *  size return value to the size of the brief scan response 
+     *  wlan_scan_create_brief_table_entry creates.  Also used if 
+     *  we are not configured to store beacons in the first place
+     */
+    if (variableSize == 0) {
+        variableSize = pBSSDesc->Ssid.SsidLength + 2;
+        variableSize += (sizeof(pBSSDesc->BeaconPeriod)
+                         + sizeof(pBSSDesc->TimeStamp)
+                         + sizeof(pBSSDesc->Cap));
+        if (pBSSDesc->wmmIE.VendHdr.ElementId == WMM_IE) {
+            variableSize += (sizeof(IEEEtypes_Header_t)
+                             + pBSSDesc->wmmIE.VendHdr.Len);
+        }
+
+        if (pBSSDesc->pWpaIE) {
+            if ((*(pBSSDesc->pWpaIE)).VendHdr.ElementId == WPA_IE) {
+                variableSize += (sizeof(IEEEtypes_Header_t)
+                                 + (*(pBSSDesc->pWpaIE)).VendHdr.Len);
+            }
+        }
+
+        if (pBSSDesc->pRsnIE) {
+            if ((*(pBSSDesc->pRsnIE)).IeeeHdr.ElementId == RSN_IE) {
+                variableSize += (sizeof(IEEEtypes_Header_t)
+                                 + (*(pBSSDesc->pRsnIE)).IeeeHdr.Len);
+            }
+        }
+    }
+
+    spaceNeeded = fixedSize + variableSize;
+
+    PRINTM(INFO, "GetScanTable: need(%d), left(%d)\n",
+           spaceNeeded, *pSpaceLeft);
+
+    if (spaceNeeded >= *pSpaceLeft) {
+        *pSpaceLeft = 0;
+        LEAVE();
+        return -E2BIG;
+    }
+
+    *pSpaceLeft -= spaceNeeded;
+
+    tmpRspEntry.fixedFieldLength = sizeof(pRspEntry->fixedFields);
+
+    memcpy(tmpRspEntry.fixedFields.bssid,
+           pBSSDesc->MacAddress, sizeof(pRspEntry->fixedFields.bssid));
+
+    tmpRspEntry.fixedFields.rssi = pBSSDesc->Rssi;
+    tmpRspEntry.fixedFields.channel = pBSSDesc->Channel;
+    tmpRspEntry.fixedFields.networkTSF = pBSSDesc->networkTSF;
+    tmpRspEntry.bssInfoLength = variableSize;
+
+    /*
+     *  Copy fixed fields to user space
+     */
+    if (copy_to_user(pCurrent, &tmpRspEntry, fixedSize)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    pCurrent += fixedSize;
+
+    if (pBSSDesc->pBeaconBuf) {
+        /*
+         *  Copy variable length elements to user space
+         */
+        if (copy_to_user(pCurrent, pBSSDesc->pBeaconBuf,
+                         pBSSDesc->beaconBufSize)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+        pCurrent += pBSSDesc->beaconBufSize;
+    } else {
+        wlan_scan_create_brief_table_entry(&pCurrent, pBSSDesc);
+    }
+
+    *ppBuffer = pCurrent;
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Retrieve the scan response/beacon table
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_scan_table_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter;
+    BSSDescriptor_t *pBSSDesc;
+    wlan_ioctl_get_scan_table_info *pRspInfo;
+    int retcode;
+    int retlen;
+    int spaceLeft;
+    u8 *pCurrent;
+    u8 *pBufferEnd;
+    u32 scanStart;
+    u32 numScansDone;
+
+    numScansDone = 0;
+    retcode = WLAN_STATUS_SUCCESS;
+    Adapter = priv->adapter;
+
+    if (copy_from_user(&scanStart,
+                       wrq->u.data.pointer, sizeof(scanStart)) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "GetScanTable: copy from user failed\n");
+        return -EFAULT;
+    }
+
+    pRspInfo = (wlan_ioctl_get_scan_table_info *) wrq->u.data.pointer;
+    pCurrent = pRspInfo->scan_table_entry_buffer;
+    pBufferEnd = wrq->u.data.pointer + wrq->u.data.length - 1;
+    spaceLeft = pBufferEnd - pCurrent;
+
+    PRINTM(INFO, "GetScanTable: scanStart req = %d\n", scanStart);
+    PRINTM(INFO, "GetScanTable: length avail = %d\n", wrq->u.data.length);
+
+    if (scanStart == 0) {
+        PRINTM(INFO, "GetScanTable: get current BSS Descriptor\n");
+
+        /* Use to get current association saved descriptor */
+        pBSSDesc = &Adapter->CurBssParams.BSSDescriptor;
+
+        retcode = wlan_get_scan_table_ret_entry(priv,
+                                                pBSSDesc,
+                                                &pCurrent, &spaceLeft);
+
+        if (retcode == WLAN_STATUS_SUCCESS) {
+            numScansDone = 1;
+        }
+
+    } else {
+        scanStart--;
+
+        while (spaceLeft
+               && (scanStart + numScansDone < Adapter->NumInScanTable)
+               && (retcode == WLAN_STATUS_SUCCESS)) {
+
+            pBSSDesc = &Adapter->ScanTable[scanStart + numScansDone];
+
+            PRINTM(INFO, "GetScanTable: get current BSS Descriptor [%d]\n",
+                   scanStart + numScansDone);
+
+            retcode = wlan_get_scan_table_ret_entry(priv,
+                                                    pBSSDesc,
+                                                    &pCurrent, &spaceLeft);
+
+            if (retcode == WLAN_STATUS_SUCCESS) {
+                numScansDone++;
+            }
+        }
+    }
+
+    pRspInfo->scanNumber = numScansDone;
+    retlen = pCurrent - (u8 *) wrq->u.data.pointer;
+
+    wrq->u.data.length = retlen;
+
+    /* Return retcode (EFAULT or E2BIG) in the case where no scan results were
+     *   successfully encoded.
+     */
+    return (numScansDone ? WLAN_STATUS_SUCCESS : retcode);
+}
+
+/**
+ *  @brief Update the scan entry TSF timestamps to reflect a new association
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param pNewBssDesc  A pointer to the newly associated AP's scan table entry
+ *
+ *  @return             void
+ */
+void
+wlan_scan_update_tsf_timestamps(wlan_private * priv,
+                                BSSDescriptor_t * pNewBssDesc)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int tableIdx;
+    u64 newTsfBase;
+    s64 tsfDelta;
+
+    memcpy(&newTsfBase, pNewBssDesc->TimeStamp, sizeof(newTsfBase));
+
+    tsfDelta = newTsfBase - pNewBssDesc->networkTSF;
+
+    PRINTM(INFO, "TSF: Update TSF timestamps, 0x%016llx -> 0x%016llx\n",
+           pNewBssDesc->networkTSF, newTsfBase);
+
+    for (tableIdx = 0; tableIdx < Adapter->NumInScanTable; tableIdx++) {
+        Adapter->ScanTable[tableIdx].networkTSF += tsfDelta;
+    }
+}
+
+/**
+ *  @brief Private IOCTL entry to perform an app configured immediate scan
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure containing the
+ *                      wlan_ioctl_user_scan_cfg requesting this scan
+ *
+ *  @return             0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_set_user_scan_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_user_scan_cfg scanReq;
+    int retcode;
+    union iwreq_data wrqu;
+
+#ifdef REASSOCIATION
+    if (OS_ACQ_SEMAPHORE_BLOCK(&priv->adapter->ReassocSem)) {
+        PRINTM(ERROR, "Acquire semaphore error, wlan_extscan_ioctl\n");
+        return -EBUSY;
+    }
+#endif
+
+    memset(&scanReq, 0x00, sizeof(scanReq));
+
+    if (copy_from_user(&scanReq,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length, sizeof(scanReq))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "SetUserScan: copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        retcode = wlan_scan_networks(priv, &scanReq);
+
+        memset(&wrqu, 0x00, sizeof(union iwreq_data));
+        wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu, NULL);
+    }
+
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&priv->adapter->ReassocSem);
+#endif
+
+    return retcode;
+}
+
+/**
+ *  @brief Prepare a scan command to be sent to the firmware
+ *
+ *  Use the wlan_scan_cmd_config sent to the command processing module in
+ *   the wlan_prepare_cmd to configure a HostCmd_DS_802_11_SCAN command
+ *   struct to send to firmware.
+ *
+ *  The fixed fields specifying the BSS type and BSSID filters as well as a
+ *   variable number/length of TLVs are sent in the command to firmware.
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param cmd        A pointer to HostCmd_DS_COMMAND structure to be sent to
+ *                    firmware with the HostCmd_DS_801_11_SCAN structure
+ *  @param pdata_buf  Void pointer cast of a wlan_scan_cmd_config struct used
+ *                    to set the fields/TLVs for the command sent to firmware
+ *
+ *  @return           WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ *
+ *  @sa wlan_scan_create_channel_list
+ */
+int
+wlan_cmd_802_11_scan(wlan_private * priv,
+                     HostCmd_DS_COMMAND * cmd, void *pdata_buf)
+{
+    HostCmd_DS_802_11_SCAN *pScan = &cmd->params.scan;
+    wlan_scan_cmd_config *pScanCfg;
+
+    ENTER();
+
+    pScanCfg = (wlan_scan_cmd_config *) pdata_buf;
+
+    /* Set fixed field variables in scan command */
+    pScan->BSSType = pScanCfg->bssType;
+    memcpy(pScan->BSSID, pScanCfg->specificBSSID, sizeof(pScan->BSSID));
+    memcpy(pScan->TlvBuffer, pScanCfg->tlvBuffer, pScanCfg->tlvBufferLen);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_SCAN);
+
+    /* Size is equal to the sizeof(fixed portions) + the TLV len + header */
+    cmd->Size = wlan_cpu_to_le16(sizeof(pScan->BSSType)
+                                 + sizeof(pScan->BSSID)
+                                 + pScanCfg->tlvBufferLen + S_DS_GEN);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Store a beacon or probe response for a BSS returned in the scan
+ *  
+ *  Store a new scan response or an update for a previous scan response.  New
+ *    entries need to verify that they do not exceed the total amount of 
+ *    memory allocated for the table.
+
+ *  Replacement entries need to take into consideration the amount of space 
+ *    currently allocated for the beacon/probe response and adjust the entry
+ *    as needed.  
+ *
+ *  A small amount of extra pad (SCAN_BEACON_ENTRY_PAD) is generally reserved
+ *    for an entry in case it is a beacon since a probe response for the
+ *    network will by larger per the standard.  This helps to reduce the 
+ *    amount of memory copying to fit a new probe response into an entry 
+ *    already occupied by a network's previously stored beacon.
+ *
+ *  @param priv       A pointer to wlan_private structure
+ *  @param beaconIdx  Index in the scan table to store this entry; may be
+ *                    replacing an older duplicate entry for this BSS
+ *  @param numInTable Number of entries currently in the table
+ *  @param pNewBeacon Pointer to the new beacon/probe response to save
+ *
+ *  @return           void
+ */
+void
+wlan_ret_802_11_scan_store_beacon(wlan_private * priv,
+                                  int beaconIdx,
+                                  int numInTable,
+                                  BSSDescriptor_t * pNewBeacon)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u8 *pBcnStore;
+    int newBcnSize;
+    int oldBcnSize;
+    int bcnSpace;
+    int adjIdx;
+
+    if (Adapter->ScanTable[beaconIdx].pBeaconBuf != NULL) {
+
+        newBcnSize = pNewBeacon->beaconBufSize;
+        oldBcnSize = Adapter->ScanTable[beaconIdx].beaconBufSize;
+        bcnSpace = Adapter->ScanTable[beaconIdx].beaconBufSizeMax;
+        pBcnStore = Adapter->ScanTable[beaconIdx].pBeaconBuf;
+
+        /* Set the max to be the same as current entry unless changed below */
+        pNewBeacon->beaconBufSizeMax = bcnSpace;
+
+        if (newBcnSize == oldBcnSize) {
+            /*
+             * Beacon is the same size as the previous entry.
+             *   Replace the previous contents with the scan result
+             */
+            memcpy(pBcnStore,
+                   pNewBeacon->pBeaconBuf, pNewBeacon->beaconBufSize);
+
+        } else if (newBcnSize <= bcnSpace) {
+            /*
+             * New beacon size will fit in the amount of space
+             *   we have previously allocated for it
+             */
+
+            /* Copy the new beacon buffer entry over the old one */
+            memcpy(pBcnStore, pNewBeacon->pBeaconBuf, newBcnSize);
+
+            /* If the old beacon size was less than the maximum
+             *  we had alloted for the entry, and the new entry
+             *  is even smaller, reset the max size to the old beacon
+             *  entry and compress the storage space (leaving a new
+             *  pad space of (oldBcnSize - newBcnSize).
+             */
+            if (oldBcnSize < bcnSpace && newBcnSize != bcnSpace) {
+                /*
+                 * Old Beacon size is smaller than the alloted storage size.
+                 *   Shrink the alloted storage space.
+                 */
+                PRINTM(INFO, "AppControl: Smaller Duplicate Beacon (%d), "
+                       "old = %d, new = %d, space = %d, left = %d\n",
+                       beaconIdx, oldBcnSize, newBcnSize, bcnSpace,
+                       (sizeof(Adapter->beaconBuffer) -
+                        (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+
+                /* memmove (since the memory overlaps) the data
+                 *  after the beacon we just stored to the end of
+                 *  the current beacon.  This cleans up any unused
+                 *  space the old larger beacon was using in the buffer
+                 */
+                memmove(pBcnStore + oldBcnSize,
+                        pBcnStore + bcnSpace,
+                        Adapter->pBeaconBufEnd - (pBcnStore + bcnSpace));
+
+                /* Decrement the end pointer by the difference between
+                 *  the old larger size and the new smaller size since
+                 *  we are using less space due to the new beacon being
+                 *  smaller
+                 */
+                Adapter->pBeaconBufEnd -= (bcnSpace - oldBcnSize);
+
+                /* Set the maximum storage size to the old beacon size */
+                pNewBeacon->beaconBufSizeMax = oldBcnSize;
+
+                /* Adjust beacon buffer pointers that are past the current */
+                for (adjIdx = 0; adjIdx < numInTable; adjIdx++) {
+                    if (Adapter->ScanTable[adjIdx].pBeaconBuf > pBcnStore) {
+                        Adapter->ScanTable[adjIdx].pBeaconBuf
+                            -= (bcnSpace - oldBcnSize);
+                        if (Adapter->ScanTable[adjIdx].pWpaIE) {
+                            Adapter->ScanTable[adjIdx].pWpaIE =
+                                (IEEEtypes_VendorSpecific_t *)
+                                (Adapter->ScanTable[adjIdx].pBeaconBuf +
+                                 Adapter->ScanTable[adjIdx].wpaOffset);
+                        }
+                        if (Adapter->ScanTable[adjIdx].pRsnIE) {
+                            Adapter->ScanTable[adjIdx].pRsnIE =
+                                (IEEEtypes_Generic_t *)
+                                (Adapter->ScanTable[adjIdx].pBeaconBuf +
+                                 Adapter->ScanTable[adjIdx].rsnOffset);
+                        }
+                        if (Adapter->ScanTable[adjIdx].pWpsIE) {
+                            Adapter->ScanTable[adjIdx].pWpsIE =
+                                (IEEEtypes_VendorSpecific_t *)
+                                (Adapter->ScanTable[adjIdx].pBeaconBuf +
+                                 Adapter->ScanTable[adjIdx].wpsOffset);
+                        }
+                    }
+                }
+            }
+        } else if (Adapter->pBeaconBufEnd + (newBcnSize - bcnSpace)
+                   < (Adapter->beaconBuffer + sizeof(Adapter->beaconBuffer))) {
+            /*
+             * Beacon is larger than space previously allocated (bcnSpace)
+             *   and there is enough space left in the beaconBuffer to store
+             *   the additional data
+             */
+            PRINTM(INFO, "AppControl: Larger Duplicate Beacon (%d), "
+                   "old = %d, new = %d, space = %d, left = %d\n",
+                   beaconIdx, oldBcnSize, newBcnSize, bcnSpace,
+                   (sizeof(Adapter->beaconBuffer) -
+                    (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+
+            /* memmove (since the memory overlaps) the data
+             *  after the beacon we just stored to the end of
+             *  the current beacon.  This moves the data for
+             *  the beacons after this further in memory to
+             *  make space for the new larger beacon we are
+             *  about to copy in.
+             */
+            memmove(pBcnStore + newBcnSize,
+                    pBcnStore + bcnSpace,
+                    Adapter->pBeaconBufEnd - (pBcnStore + bcnSpace));
+
+            /* Copy the new beacon buffer entry over the old one */
+            memcpy(pBcnStore, pNewBeacon->pBeaconBuf, newBcnSize);
+
+            /* Move the beacon end pointer by the amount of new
+             *  beacon data we are adding
+             */
+            Adapter->pBeaconBufEnd += (newBcnSize - bcnSpace);
+
+            /* This entry is bigger than the alloted max space
+             *  previously reserved.  Increase the max space to
+             *  be equal to the new beacon size
+             */
+            pNewBeacon->beaconBufSizeMax = newBcnSize;
+
+            /* Adjust beacon buffer pointers that are past the current */
+            for (adjIdx = 0; adjIdx < numInTable; adjIdx++) {
+                if (Adapter->ScanTable[adjIdx].pBeaconBuf > pBcnStore) {
+                    Adapter->ScanTable[adjIdx].pBeaconBuf
+                        += (newBcnSize - bcnSpace);
+                    if (Adapter->ScanTable[adjIdx].pWpaIE) {
+                        Adapter->ScanTable[adjIdx].pWpaIE =
+                            (IEEEtypes_VendorSpecific_t *)
+                            (Adapter->ScanTable[adjIdx].pBeaconBuf +
+                             Adapter->ScanTable[adjIdx].wpaOffset);
+                    }
+                    if (Adapter->ScanTable[adjIdx].pRsnIE) {
+                        Adapter->ScanTable[adjIdx].pRsnIE =
+                            (IEEEtypes_Generic_t *)
+                            (Adapter->ScanTable[adjIdx].pBeaconBuf +
+                             Adapter->ScanTable[adjIdx].rsnOffset);
+                    }
+                    if (Adapter->ScanTable[adjIdx].pWpsIE) {
+                        Adapter->ScanTable[adjIdx].pWpsIE =
+                            (IEEEtypes_VendorSpecific_t *)
+                            (Adapter->ScanTable[adjIdx].pBeaconBuf +
+                             Adapter->ScanTable[adjIdx].wpsOffset);
+                    }
+                }
+            }
+        } else {
+            /*
+             * Beacon is larger than the previously allocated space, but
+             *   there is not enough free space to store the additional data
+             */
+            PRINTM(INFO,
+                   "AppControl: Failed: Larger Duplicate Beacon (%d),"
+                   " old = %d, new = %d, space = %d, left = %d\n",
+                   beaconIdx, oldBcnSize, newBcnSize, bcnSpace,
+                   (sizeof(Adapter->beaconBuffer) -
+                    (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+
+            /* Storage failure, keep old beacon intact */
+            pNewBeacon->beaconBufSize = oldBcnSize;
+        }
+
+        /* Point the new entry to its permanent storage space */
+        pNewBeacon->pBeaconBuf = pBcnStore;
+        if (pNewBeacon->pWpaIE != NULL) {
+            pNewBeacon->pWpaIE = (IEEEtypes_VendorSpecific_t *)
+                (pNewBeacon->pBeaconBuf + pNewBeacon->wpaOffset);
+        }
+        if (pNewBeacon->pRsnIE != NULL) {
+            pNewBeacon->pRsnIE = (IEEEtypes_Generic_t *)
+                (pNewBeacon->pBeaconBuf + pNewBeacon->rsnOffset);
+        }
+        if (pNewBeacon->pWpsIE != NULL) {
+            pNewBeacon->pWpsIE = (IEEEtypes_VendorSpecific_t *)
+                (pNewBeacon->pBeaconBuf + pNewBeacon->wpsOffset);
+        }
+
+    } else {
+        /* No existing beacon data exists for this entry, check to see
+         *   if we can fit it in the remaining space
+         */
+        if (Adapter->pBeaconBufEnd + pNewBeacon->beaconBufSize +
+            SCAN_BEACON_ENTRY_PAD < (Adapter->beaconBuffer +
+                                     sizeof(Adapter->beaconBuffer))) {
+
+            /* Copy the beacon buffer data from the local entry to the
+             *   adapter dev struct buffer space used to store the raw
+             *   beacon data for each entry in the scan table
+             */
+            memcpy(Adapter->pBeaconBufEnd, pNewBeacon->pBeaconBuf,
+                   pNewBeacon->beaconBufSize);
+
+            /* Update the beacon ptr to point to the table save area */
+            pNewBeacon->pBeaconBuf = Adapter->pBeaconBufEnd;
+            pNewBeacon->beaconBufSizeMax = (pNewBeacon->beaconBufSize
+                                            + SCAN_BEACON_ENTRY_PAD);
+
+            if (pNewBeacon->pWpaIE != NULL) {
+                pNewBeacon->pWpaIE = (IEEEtypes_VendorSpecific_t *)
+                    (pNewBeacon->pBeaconBuf + pNewBeacon->wpaOffset);
+            }
+            if (pNewBeacon->pRsnIE != NULL) {
+                pNewBeacon->pRsnIE = (IEEEtypes_Generic_t *)
+                    (pNewBeacon->pBeaconBuf + pNewBeacon->rsnOffset);
+            }
+            if (pNewBeacon->pWpsIE != NULL) {
+                pNewBeacon->pWpsIE = (IEEEtypes_VendorSpecific_t *)
+                    (pNewBeacon->pBeaconBuf + pNewBeacon->wpsOffset);
+            }
+            /* Increment the end pointer by the size reserved */
+            Adapter->pBeaconBufEnd += pNewBeacon->beaconBufSizeMax;
+
+            PRINTM(INFO, "AppControl: Beacon[%02d] sz=%03d,"
+                   " used = %04d, left = %04d\n",
+                   beaconIdx,
+                   pNewBeacon->beaconBufSize,
+                   (Adapter->pBeaconBufEnd - Adapter->beaconBuffer),
+                   (sizeof(Adapter->beaconBuffer) -
+                    (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+        } else {
+            /*
+             * No space for new beacon
+             */
+            PRINTM(INFO, "AppControl: No space beacon (%d): "
+                   "%02x:%02x:%02x:%02x:%02x:%02x; sz=%03d, left=%03d\n",
+                   beaconIdx,
+                   pNewBeacon->MacAddress[0], pNewBeacon->MacAddress[1],
+                   pNewBeacon->MacAddress[2], pNewBeacon->MacAddress[3],
+                   pNewBeacon->MacAddress[4], pNewBeacon->MacAddress[5],
+                   pNewBeacon->beaconBufSize,
+                   (sizeof(Adapter->beaconBuffer) -
+                    (Adapter->pBeaconBufEnd - Adapter->beaconBuffer)));
+
+            /* Storage failure; clear storage records for this bcn */
+            pNewBeacon->pBeaconBuf = NULL;
+            pNewBeacon->beaconBufSize = 0;
+            pNewBeacon->beaconBufSizeMax = 0;
+            pNewBeacon->pWpaIE = NULL;
+            pNewBeacon->wpaOffset = 0;
+            pNewBeacon->pRsnIE = NULL;
+            pNewBeacon->rsnOffset = 0;
+            pNewBeacon->pWpsIE = NULL;
+            pNewBeacon->wpsOffset = 0;
+        }
+    }
+}
+
+/**
+ *  @brief This function handles the command response of scan
+ *
+ *   The response buffer for the scan command has the following
+ *      memory layout:
+ *
+ *     .-----------------------------------------------------------.
+ *     |  Header (4 * sizeof(u16)):  Standard command response hdr |
+ *     .-----------------------------------------------------------.
+ *     |  BufSize (u16) : sizeof the BSS Description data          |
+ *     .-----------------------------------------------------------.
+ *     |  NumOfSet (u8) : Number of BSS Descs returned             |
+ *     .-----------------------------------------------------------.
+ *     |  BSSDescription data (variable, size given in BufSize)    |
+ *     .-----------------------------------------------------------.
+ *     |  TLV data (variable, size calculated using Header->Size,  |
+ *     |            BufSize and sizeof the fixed fields above)     |
+ *     .-----------------------------------------------------------.
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *  @param resp    A pointer to HostCmd_DS_COMMAND
+ *
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_ret_802_11_scan(wlan_private * priv, HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_SCAN_RSP *pScan;
+    BSSDescriptor_t newBssEntry;
+    MrvlIEtypes_Data_t *pTlv;
+    MrvlIEtypes_TsfTimestamp_t *pTsfTlv;
+    u8 *pBssInfo;
+    u16 scanRespSize;
+    int bytesLeft;
+    int numInTable;
+    int bssIdx;
+    int idx;
+    int tlvBufSize;
+    u64 tsfVal;
+    ChanScanParamSet_t *pChanScan;
+    u8 band;
+    BOOLEAN bgScanResp;
+
+    ENTER();
+
+    bgScanResp = (resp->Command == HostCmd_CMD_802_11_BG_SCAN_QUERY);
+    if (bgScanResp) {
+        pScan = &resp->params.bgscanqueryresp.scanresp;
+    } else {
+        pScan = &resp->params.scanresp;
+    }
+
+    if (pScan->NumberOfSets > MRVDRV_MAX_BSSID_LIST) {
+        PRINTM(INFO, "SCAN_RESP: Invalid number of AP returned (%d)!!\n",
+               pScan->NumberOfSets);
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    bytesLeft = wlan_le16_to_cpu(pScan->BSSDescriptSize);
+    PRINTM(INFO, "SCAN_RESP: BSSDescriptSize %d\n", bytesLeft);
+
+    scanRespSize = resp->Size;
+
+    PRINTM(CMND, "SCAN_RESP: returned %d APs before parsing\n",
+           pScan->NumberOfSets);
+
+    numInTable = Adapter->NumInScanTable;
+    pBssInfo = pScan->BssDescAndTlvBuffer;
+
+    /* The size of the TLV buffer is equal to the entire command response
+     *   size (scanRespSize) minus the fixed fields (sizeof()'s), the
+     *   BSS Descriptions (BSSDescriptSize as bytesLef) and the command
+     *   response header (S_DS_GEN)
+     */
+    tlvBufSize = scanRespSize - (bytesLeft + sizeof(pScan->BSSDescriptSize)
+                                 + sizeof(pScan->NumberOfSets)
+                                 + S_DS_GEN);
+
+    pTlv = (MrvlIEtypes_Data_t *) (pScan->BssDescAndTlvBuffer + bytesLeft);
+
+    /* Search the TLV buffer space in the scan response for any valid TLVs */
+    wlan_ret_802_11_scan_get_tlv_ptrs(pTlv, tlvBufSize, &pTsfTlv);
+
+    /*
+     *  Process each scan response returned (pScan->NumberOfSets).  Save
+     *    the information in the newBssEntry and then insert into the
+     *    driver scan table either as an update to an existing entry
+     *    or as an addition at the end of the table
+     */
+    for (idx = 0; idx < pScan->NumberOfSets && bytesLeft; idx++) {
+        /* Zero out the newBssEntry we are about to store info in */
+        memset(&newBssEntry, 0x00, sizeof(newBssEntry));
+
+        /* Process the data fields and IEs returned for this BSS */
+        if ((wlan_interpret_bss_desc_with_ie(&newBssEntry,
+                                             &pBssInfo,
+                                             &bytesLeft) ==
+             WLAN_STATUS_SUCCESS)
+            && CHECK_SSID_IS_VALID(&newBssEntry.Ssid)) {
+
+            PRINTM(INFO, "SCAN_RESP: BSSID = %02x:%02x:%02x:%02x:%02x:%02x\n",
+                   newBssEntry.MacAddress[0], newBssEntry.MacAddress[1],
+                   newBssEntry.MacAddress[2], newBssEntry.MacAddress[3],
+                   newBssEntry.MacAddress[4], newBssEntry.MacAddress[5]);
+
+            /*
+             * Search the scan table for the same bssid
+             */
+            for (bssIdx = 0; bssIdx < numInTable; bssIdx++) {
+                if (memcmp(newBssEntry.MacAddress,
+                           Adapter->ScanTable[bssIdx].MacAddress,
+                           sizeof(newBssEntry.MacAddress)) == 0) {
+                    /*
+                     * If the SSID matches as well, it is a duplicate of
+                     *   this entry.  Keep the bssIdx set to this
+                     *   entry so we replace the old contents in the table
+                     */
+                    if ((newBssEntry.Ssid.SsidLength ==
+                         Adapter->ScanTable[bssIdx].Ssid.SsidLength)
+                        && (memcmp(newBssEntry.Ssid.Ssid,
+                                   Adapter->ScanTable[bssIdx].Ssid.Ssid,
+                                   newBssEntry.Ssid.SsidLength) == 0)) {
+                        PRINTM(INFO, "SCAN_RESP: Duplicate of index: %d\n",
+                               bssIdx);
+                        break;
+                    }
+                }
+            }
+            /*
+             * If the bssIdx is equal to the number of entries in the table,
+             *   the new entry was not a duplicate; append it to the scan
+             *   table
+             */
+            if (bssIdx == numInTable) {
+                /* Range check the bssIdx, keep it limited to the last entry */
+                if (bssIdx == MRVDRV_MAX_BSSID_LIST) {
+                    bssIdx--;
+                } else {
+                    numInTable++;
+                }
+            }
+
+            /*
+             * Save the beacon/probe response returned for later application
+             *   retrieval.  Duplicate beacon/probe responses are updated if
+             *   possible
+             */
+            wlan_ret_802_11_scan_store_beacon(priv,
+                                              bssIdx,
+                                              numInTable, &newBssEntry);
+            /*
+             * If the TSF TLV was appended to the scan results, save
+             *   this entry's TSF value in the networkTSF field.  The
+             *   networkTSF is the firmware's TSF value at the time the
+             *   beacon or probe response was received.
+             */
+            if (pTsfTlv) {
+                memcpy(&tsfVal, &pTsfTlv->tsfTable[idx], sizeof(tsfVal));
+                tsfVal = wlan_le64_to_cpu(tsfVal);
+
+                memcpy(&newBssEntry.networkTSF,
+                       &tsfVal, sizeof(newBssEntry.networkTSF));
+            }
+
+            band = BAND_G;
+            pChanScan = NULL;
+
+            if (bgScanResp) {
+                MrvlIEtypes_ChanListParamSet_t *chanList;
+
+                chanList = (MrvlIEtypes_ChanListParamSet_t *)
+                    ((u8 *) Adapter->bgScanConfig +
+                     sizeof(HostCmd_DS_802_11_BG_SCAN_CONFIG));
+
+                while (!pChanScan
+                       && ((u8 *) chanList < ((u8 *) Adapter->bgScanConfig
+                                              + Adapter->bgScanConfigSize))) {
+
+                    PRINTM(INFO, "SCAN_RESP: Header type=%#x  len=%d\n",
+                           chanList->Header.Type, chanList->Header.Len);
+
+                    if (chanList->Header.Type == TLV_TYPE_CHANLIST) {
+                        pChanScan = chanList->ChanScanParam;
+                        break;
+                    } else {
+                        chanList = (MrvlIEtypes_ChanListParamSet_t *)
+                            ((u8 *) chanList + chanList->Header.Len
+                             + sizeof(chanList->Header));
+                    }
+                }
+
+                if (pChanScan) {
+                    band = radio_type_to_band(pChanScan->RadioType);
+                    PRINTM(INFO, "SCAN_RESP: radio_type=%#x, "
+                           "chan=%#x, band=%#x\n", pChanScan->RadioType,
+                           pChanScan->ChanNumber, band);
+                } else {
+                    PRINTM(INFO, "SCAN_RESP: Cannot find valid "
+                           "radio_type/channel info. in channel list\n");
+                }
+            } else {
+                pChanScan = Adapter->pScanChannels;
+
+                /* Search the channel list we sent down in the command
+                 *   for the channel this new entry was found on.
+                 */
+                while (pChanScan && pChanScan->ChanNumber) {
+                    if (pChanScan->ChanNumber == newBssEntry.Channel) {
+                        /*
+                         * Convert the radio type we sent with the channel
+                         *  in the scan command to a band type that can be
+                         *  used in the join commands later
+                         */
+                        band = radio_type_to_band(pChanScan->RadioType);
+                        PRINTM(INFO, "SCAN_RESP: radio_type=%#x, "
+                               "chan=%#x, band=%#x\n", pChanScan->RadioType,
+                               pChanScan->ChanNumber, band);
+
+                        break;
+                    }
+                    pChanScan++;
+                }
+            }
+
+            /* save the band designation for this entry for use in join */
+            newBssEntry.bss_band = band;
+
+            /* Copy the locally created newBssEntry to the scan table */
+            memcpy(&Adapter->ScanTable[bssIdx],
+                   &newBssEntry, sizeof(Adapter->ScanTable[bssIdx]));
+
+        } else {
+
+            /* Error parsing/interpreting the scan response, skipped */
+            PRINTM(INFO, "SCAN_RESP: "
+                   "wlan_interpret_bss_desc_with_ie returned ERROR\n");
+        }
+    }
+
+    PRINTM(CMND, "SCAN_RESP: Scanned %2d APs, %d valid, %d total\n",
+           pScan->NumberOfSets, numInTable - Adapter->NumInScanTable,
+           numInTable);
+
+    /* Update the total number of BSSIDs in the scan table */
+    Adapter->NumInScanTable = numInTable;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief scan network with specific ssid
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param req          A pointer to ifreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_extscan_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    WLAN_802_11_SSID Ext_Scan_SSID;
+    wlan_ioctl_user_scan_cfg scanCfg;
+    union iwreq_data wrqu;
+
+    ENTER();
+
+    if (copy_from_user(&Ext_Scan_SSID, req->ifr_data, sizeof(Ext_Scan_SSID))) {
+        PRINTM(INFO, "copy of SSID for ext scan from user failed \n");
+        LEAVE();
+        return -EFAULT;
+    }
+#ifdef REASSOCIATION
+    if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->ReassocSem)) {
+        PRINTM(ERROR, "Acquire semaphore error, wlan_extscan_ioctl\n");
+        return -EBUSY;
+    }
+#endif
+
+    memset(&scanCfg, 0x00, sizeof(scanCfg));
+
+    memcpy(scanCfg.ssidList[0].ssid, Ext_Scan_SSID.Ssid,
+           Ext_Scan_SSID.SsidLength);
+
+    wlan_scan_networks(priv, &scanCfg);
+
+    memset(&wrqu, 0, sizeof(union iwreq_data));
+    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu, NULL);
+
+#ifdef REASSOCIATION
+    OS_REL_SEMAPHORE(&Adapter->ReassocSem);
+#endif
+
+    if (Adapter->SurpriseRemoved)
+        return WLAN_STATUS_FAILURE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function sends BG_SCAN query command to firmware.
+ *
+ *  @param priv    A pointer to wlan_private structure
+ *
+ *  @return        WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_bgs_query(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    /* Clear the previous scan result */
+    memset(Adapter->ScanTable, 0x00,
+           sizeof(BSSDescriptor_t) * MRVDRV_MAX_BSSID_LIST);
+    Adapter->NumInScanTable = 0;
+    Adapter->pBeaconBufEnd = Adapter->beaconBuffer;
+
+    return wlan_prepare_cmd(priv, HostCmd_CMD_802_11_BG_SCAN_QUERY,
+                            0, 0, 0, NULL);
+}
+
+/**
+ *  @brief Enable/Disable BG Scan
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param enable       TRUE-enable, FALSE-disable
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_bg_scan_enable(wlan_private * priv, BOOLEAN enable)
+{
+    int ret;
+
+    priv->adapter->bgScanConfig->Enable = enable;
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_BG_SCAN_CONFIG,
+                           0, HostCmd_OPTION_WAITFORRSP,
+                           0, priv->adapter->bgScanConfig);
+    return ret;
+}
+
+/**
+ *  @brief config BGSCAN parameter
+
+ *  @param priv         A pointer to wlan_private structure
+ *  @param req          A pointer to ifreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_do_bg_scan_config_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 action;
+    u8 *buf = NULL;
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *tmp;
+
+    ENTER();
+
+    action = *((u8 *) req->ifr_data + SKIP_CMDNUM + SKIP_SIZE);
+    PRINTM(INFO, "Action = %d\n", action);
+
+    switch (action) {
+    case HostCmd_ACT_GEN_GET:
+        buf = kmalloc(Adapter->bgScanConfigSize + SKIP_TYPE_SIZE, GFP_KERNEL);
+        if (!buf) {
+            PRINTM(MSG, "kmalloc no memory !!\n");
+            return -ENOMEM;
+        }
+        memcpy(buf, &Adapter->bgScanConfigSize, SKIP_SIZE);
+        memcpy(buf + SKIP_TYPE_SIZE, Adapter->bgScanConfig,
+               Adapter->bgScanConfigSize);
+
+        if (copy_to_user(req->ifr_data, buf,
+                         Adapter->bgScanConfigSize + SKIP_TYPE_SIZE)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            kfree(buf);
+            return -EFAULT;
+        }
+
+        kfree(buf);
+
+        break;
+
+    case HostCmd_ACT_GEN_SET:
+        Adapter->bgScanConfigSize = *(u16 *) (req->ifr_data + SKIP_CMDNUM);
+        PRINTM(INFO, "bgscanConfigSize = %d\n", Adapter->bgScanConfigSize);
+
+        if (!(tmp = kmalloc(Adapter->bgScanConfigSize, GFP_KERNEL))) {
+            PRINTM(MSG, "kmalloc no memory !!\n");
+            Adapter->bgScanConfigSize = 0;
+            return -ENOMEM;
+        }
+
+        HEXDUMP("treq", req->ifr_data + SKIP_CMDNUM + SKIP_SIZE,
+                Adapter->bgScanConfigSize);
+
+        if (copy_from_user(tmp, req->ifr_data + SKIP_CMDNUM + SKIP_SIZE,
+                           Adapter->bgScanConfigSize)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            kfree(tmp);
+            return -EFAULT;
+        }
+
+        if (Adapter->bgScanConfig) {
+            tmp->Enable = Adapter->bgScanConfig->Enable;
+            buf = (u8 *) Adapter->bgScanConfig;
+        }
+        Adapter->bgScanConfig = tmp;
+        if (buf)
+            kfree(buf);
+
+        break;
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/**
+ *  @brief config PPS/UAPSD or normal BGSCAN 
+ *  @param priv         A pointer to wlan_private structure
+ *  @param req          A pointer to ifreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_do_bgscfg_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 action;
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *pstBgScanCfg;
+
+    ENTER();
+    Adapter->bgScanConfigSize = *(u16 *) (req->ifr_data + SKIP_CMDNUM);
+    if (!(pstBgScanCfg = kmalloc(Adapter->bgScanConfigSize, GFP_KERNEL))) {
+        PRINTM(INFO, "Allocate memory failed\n");
+        return -ENOMEM;
+    }
+    memset(pstBgScanCfg, 0, Adapter->bgScanConfigSize);
+
+    if (copy_from_user(pstBgScanCfg, req->ifr_data + SKIP_CMDNUM + SKIP_SIZE,
+                       Adapter->bgScanConfigSize)) {
+        PRINTM(INFO, "Copy from user failed\n");
+        kfree(pstBgScanCfg);
+        return -EFAULT;
+    }
+
+    action = (pstBgScanCfg->Action == HostCmd_ACT_GEN_SET) ?
+        HostCmd_ACT_GEN_SET : HostCmd_ACT_GEN_GET;
+
+    HEXDUMP("bgscfg", (u8 *) pstBgScanCfg, Adapter->bgScanConfigSize);
+
+    PRINTM(INFO, "bgscfg action = 0x%0X\n", action);
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_BG_SCAN_CONFIG,
+                           action,
+                           HostCmd_OPTION_WAITFORRSP, 0, pstBgScanCfg);
+
+    if (!ret && action == HostCmd_ACT_GEN_GET) {
+        if (copy_to_user
+            (req->ifr_data + SKIP_CMDNUM + SKIP_SIZE, pstBgScanCfg,
+             MAX_SETGET_CONF_CMD_LEN)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+    }
+
+    kfree(pstBgScanCfg);
+
+    LEAVE();
+
+    return ret;
+}
+
+/**
+ *  @brief This function prepares command of bg_scan_config.
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf    A pointer to data buffer
+ *
+ *  @return             WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_bg_scan_config(wlan_private * priv,
+                               HostCmd_DS_COMMAND * cmd,
+                               int cmd_action, void *pdata_buf)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *bgcfg = &cmd->params.bgscancfg;
+    HostCmd_DS_802_11_BG_SCAN_CONFIG *pstBgScanCfg =
+        (HostCmd_DS_802_11_BG_SCAN_CONFIG *) pdata_buf;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_CONFIG);
+    cmd->Size =
+        wlan_cpu_to_le16((priv->adapter->bgScanConfigSize) + S_DS_GEN);
+
+    memcpy(bgcfg, pstBgScanCfg, Adapter->bgScanConfigSize);
+
+    bgcfg->Action = wlan_cpu_to_le16(bgcfg->Action);
+    bgcfg->ScanInterval = wlan_cpu_to_le32(bgcfg->ScanInterval);
+    bgcfg->ReportConditions = wlan_cpu_to_le32(bgcfg->ReportConditions);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of bg_scan_query.
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param cmd      A pointer to HostCmd_DS_COMMAND structure
+ *
+ *  @return         WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_802_11_bg_scan_query(wlan_private * priv, HostCmd_DS_COMMAND * cmd)
+{
+    HostCmd_DS_802_11_BG_SCAN_QUERY *bgquery = &cmd->params.bgscanquery;
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_QUERY);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_802_11_BG_SCAN_QUERY) + S_DS_GEN);
+
+    bgquery->Flush = 1;
+
+    return WLAN_STATUS_SUCCESS;
+}
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_scan.h b/drivers/net/wireless/8688_wlan/wlan/wlan_scan.h
new file mode 100755
index 0000000..23c71ee
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_scan.h
@@ -0,0 +1,427 @@
+/** @file wlan_scan.h
+ *
+ *  @brief Interface for the wlan network scan routines
+ *
+ *  Driver interface functions and type declarations for the scan module
+ *    implemented in wlan_scan.c.
+ *
+ *  (c) Copyright © 2003-2006, Marvell International Ltd.  
+ *   
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+/*************************************************************
+Change Log:
+    01/11/06: Initial revision. New scan code, relocate related functions
+
+************************************************************/
+
+#ifndef _WLAN_SCAN_H
+#define _WLAN_SCAN_H
+
+/**
+ *  @brief Maximum number of channels that can be sent in a setuserscan ioctl
+ *
+ *  @sa wlan_ioctl_user_scan_cfg
+ */
+#define WLAN_IOCTL_USER_SCAN_CHAN_MAX  50
+
+//! Infrastructure BSS scan type in wlan_scan_cmd_config
+#define WLAN_SCAN_BSS_TYPE_BSS         1
+
+//! Adhoc BSS scan type in wlan_scan_cmd_config
+#define WLAN_SCAN_BSS_TYPE_IBSS        2
+
+//! Adhoc or Infrastructure BSS scan type in wlan_scan_cmd_config, no filter
+#define WLAN_SCAN_BSS_TYPE_ANY         3
+
+/** @brief Maximum buffer space for beacons retrieved from scan responses
+ *    4000 has successfully stored up to 40 beacons
+ *    6000 has successfully stored the max scan results (max 64)
+ */
+#define MAX_SCAN_BEACON_BUFFER         6000
+
+/**
+ * @brief Buffer pad space for newly allocated beacons/probe responses
+ *
+ * Beacons are typically 6 bytes longer than an equivalent probe response.
+ *  For each scan response stored, allocate an extra byte pad at the end to
+ *  allow easy expansion to store a beacon in the same memory a probe reponse
+ *  previously contained
+ */
+#define SCAN_BEACON_ENTRY_PAD          6
+
+//! Scan time specified in the channel TLV for each channel for passive scans
+#define MRVDRV_PASSIVE_SCAN_CHAN_TIME  200
+
+//! Scan time specified in the channel TLV for each channel for active scans
+#define MRVDRV_ACTIVE_SCAN_CHAN_TIME   200
+
+//! Scan time specified in the channel TLV for each channel for specific scans
+#define MRVDRV_SPECIFIC_SCAN_CHAN_TIME 110
+
+//! Max passive scan time for each channel in milliseconds
+#define MRVDRV_MAX_PASSIVE_SCAN_CHAN_TIME   2000
+
+//! Max active scan time for each channel in milliseconds 
+#define MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME    500
+
+/**
+ * Max total scan time in milliseconds
+ * The total scan time should be less than scan command timeout value (10s)
+ */
+#define MRVDRV_MAX_TOTAL_SCAN_TIME     (MRVDRV_TIMER_10S - MRVDRV_TIMER_1S)
+
+/**
+ * @brief Structure used internally in the wlan driver to configure a scan.
+ *
+ * Sent to the command processing module to configure the firmware
+ *   scan command prepared by wlan_cmd_802_11_scan.
+ *
+ * @sa wlan_scan_networks
+ *
+ */
+typedef struct
+{
+    /**
+     *  @brief BSS Type to be sent in the firmware command
+     *
+     *  Field can be used to restrict the types of networks returned in the
+     *    scan.  Valid settings are:
+     *
+     *   - WLAN_SCAN_BSS_TYPE_BSS  (infrastructure)
+     *   - WLAN_SCAN_BSS_TYPE_IBSS (adhoc)
+     *   - WLAN_SCAN_BSS_TYPE_ANY  (unrestricted, adhoc and infrastructure)
+     */
+    u8 bssType;
+
+    /**
+     *  @brief Specific BSSID used to filter scan results in the firmware
+     */
+    u8 specificBSSID[ETH_ALEN];
+
+    /**
+     *  @brief Length of TLVs sent in command starting at tlvBuffer
+     */
+    int tlvBufferLen;
+
+    /**
+     *  @brief SSID TLV(s) and ChanList TLVs to be sent in the firmware command
+     *
+     *  @sa TLV_TYPE_CHANLIST, MrvlIEtypes_ChanListParamSet_t
+     *  @sa TLV_TYPE_SSID, MrvlIEtypes_SsIdParamSet_t
+     */
+    u8 tlvBuffer[1];            //!< SSID TLV(s) and ChanList TLVs are stored here
+} wlan_scan_cmd_config;
+
+/**
+ *  @brief IOCTL channel sub-structure sent in wlan_ioctl_user_scan_cfg
+ *
+ *  Multiple instances of this structure are included in the IOCTL command
+ *   to configure a instance of a scan on the specific channel.
+ */
+typedef struct
+{
+    u8 chanNumber;              //!< Channel Number to scan
+    u8 radioType;               //!< Radio type: 'B/G' Band = 0, 'A' Band = 1
+    u8 scanType;                //!< Scan type: Active = 0, Passive = 1
+    u8 reserved;                //!< Reserved
+    u16 scanTime;               //!< Scan duration in milliseconds; if 0 default used
+} __ATTRIB_PACK__ wlan_ioctl_user_scan_chan;
+
+/**
+ *  @brief IOCTL SSID List sub-structure sent in wlan_ioctl_user_scan_cfg
+ * 
+ *  Used to specify SSID specific filters as well as SSID pattern matching
+ *    filters for scan result processing in firmware.
+ */
+typedef struct
+{
+    char ssid[MRVDRV_MAX_SSID_LENGTH + 1];      //!< SSID
+    u8 maxLen;                  //!< Maximum length of SSID
+} __ATTRIB_PACK__ wlan_ioctl_user_scan_ssid;
+
+/**
+ *  @brief IOCTL input structure to configure an immediate scan cmd to firmware
+ *
+ *  Used in the setuserscan (WLAN_SET_USER_SCAN) private ioctl.  Specifies
+ *   a number of parameters to be used in general for the scan as well
+ *   as a channel list (wlan_ioctl_user_scan_chan) for each scan period
+ *   desired.
+ *
+ *  @sa wlan_set_user_scan_ioctl
+ */
+typedef struct
+{
+
+    /**
+     *  @brief Flag set to keep the previous scan table intact
+     *
+     *  If set, the scan results will accumulate, replacing any previous
+     *   matched entries for a BSS with the new scan data
+     */
+    u8 keepPreviousScan;        //!< Do not erase the existing scan results
+
+    /**
+     *  @brief BSS Type to be sent in the firmware command
+     *
+     *  Field can be used to restrict the types of networks returned in the
+     *    scan.  Valid settings are:
+     *
+     *   - WLAN_SCAN_BSS_TYPE_BSS  (infrastructure)
+     *   - WLAN_SCAN_BSS_TYPE_IBSS (adhoc)
+     *   - WLAN_SCAN_BSS_TYPE_ANY  (unrestricted, adhoc and infrastructure)
+     */
+    u8 bssType;
+
+    /**
+     *  @brief Configure the number of probe requests for active chan scans
+     */
+    u8 numProbes;
+
+    /**
+     *  @brief Reserved
+     */
+    u8 reserved;
+
+    /**
+     *  @brief BSSID filter sent in the firmware command to limit the results
+     */
+    u8 specificBSSID[ETH_ALEN];
+
+    /**
+     *  @brief SSID filter list used in the to limit the scan results
+     */
+    wlan_ioctl_user_scan_ssid ssidList[MRVDRV_MAX_SSID_LIST_LENGTH];
+
+    /**
+     *  @brief Variable number (fixed maximum) of channels to scan up
+     */
+    wlan_ioctl_user_scan_chan chanList[WLAN_IOCTL_USER_SCAN_CHAN_MAX];
+
+} __ATTRIB_PACK__ wlan_ioctl_user_scan_cfg;
+
+/**
+ *  @brief Sub-structure passed in wlan_ioctl_get_scan_table_entry for each BSS
+ *
+ *  Fixed field information returned for the scan response in the IOCTL
+ *    response.
+ */
+typedef struct
+{
+    u8 bssid[ETH_ALEN];         //!< BSSID of this network
+    u8 channel;                 //!< Channel this beacon/probe response was detected
+    u8 rssi;                    //!< RSSI for the received packet
+    u64 networkTSF;             //!< TSF value from the firmware at packet reception
+} __ATTRIB_PACK__ wlan_ioctl_get_scan_table_fixed;
+
+/**
+ *  @brief Structure passed in the wlan_ioctl_get_scan_table_info for each
+ *         BSS returned in the WLAN_GET_SCAN_RESP IOCTL
+ *
+ *  @sa wlan_get_scan_table_ioctl
+ */
+typedef struct
+{
+
+    /**
+     *  @brief Fixed field length included in the response.
+     *
+     *  Length value is included so future fixed fields can be added to the
+     *   response without breaking backwards compatibility.  Use the length
+     *   to find the offset for the bssInfoLength field, not a sizeof() calc.
+     */
+    u32 fixedFieldLength;
+
+    /**
+     *  @brief Always present, fixed length data fields for the BSS
+     */
+    wlan_ioctl_get_scan_table_fixed fixedFields;
+
+    /**
+     *  @brief Length of the BSS Information (probe resp or beacon) that
+     *         follows starting at bssInfoBuffer
+     */
+    u32 bssInfoLength;
+
+    /**
+     *  @brief Probe response or beacon scanned for the BSS.
+     *
+     *  Field layout:
+     *   - TSF              8 octets
+     *   - Beacon Interval  2 octets
+     *   - Capability Info  2 octets
+     *
+     *   - IEEE Infomation Elements; variable number & length per 802.11 spec
+     */
+    u8 bssInfoBuffer[1];
+} __ATTRIB_PACK__ wlan_ioctl_get_scan_table_entry;
+
+/**
+ *  @brief WLAN_GET_SCAN_RESP private IOCTL struct to retrieve the scan table
+ *
+ *  @sa wlan_get_scan_table_ioctl
+ */
+typedef struct
+{
+
+    /**
+     *  - Zero based scan entry to start retrieval in command request
+     *  - Number of scans entires returned in command response
+     */
+    u32 scanNumber;
+
+     /**
+      * Buffer marker for multiple wlan_ioctl_get_scan_table_entry structures.
+      *   Each struct is padded to the nearest 32 bit boundary.
+      */
+    u8 scan_table_entry_buffer[1];
+
+} __ATTRIB_PACK__ wlan_ioctl_get_scan_table_info;
+
+/**
+ *  @brief Structure used to store information for each beacon/probe response
+ */
+typedef struct
+{
+    /** MAC address */
+    WLAN_802_11_MAC_ADDRESS MacAddress;
+
+    /** SSID */
+    WLAN_802_11_SSID Ssid;
+
+    /** WEP encryption requirement */
+    u32 Privacy;
+
+    /** receive signal strength in dBm */
+    WLAN_802_11_RSSI Rssi;
+
+    /** Channel */
+    u32 Channel;
+
+    /** Beacon period */
+    u16 BeaconPeriod;
+
+    /** ATIM window */
+    u32 ATIMWindow;
+    /** ERP flags */
+    u8 ERPFlags;
+
+    /** Type of network in use */
+    WLAN_802_11_NETWORK_TYPE NetworkTypeInUse;
+    /** Network infrastructure mode */
+    WLAN_802_11_NETWORK_INFRASTRUCTURE InfrastructureMode;
+    /** Network supported rates */
+    WLAN_802_11_RATES SupportedRates;
+    /** WMM IE */
+    IEEEtypes_WmmParameter_t wmmIE;
+
+    /** Network band.
+     * BAND_B(0x01): 'b' band
+     * BAND_G(0x02): 'g' band
+     * BAND_A(0X04): 'a' band
+     */
+    u16 bss_band;
+
+    u8 TimeStamp[8];            //!< TSF value included in the beacon/probe response
+
+    /** PHY parameter set */
+    IEEEtypes_PhyParamSet_t PhyParamSet;
+    /** SS parameter set */
+    IEEEtypes_SsParamSet_t SsParamSet;
+    /** Capability information */
+    IEEEtypes_CapInfo_t Cap;
+
+    /** Supported data rates */
+    u8 DataRates[WLAN_SUPPORTED_RATES];
+
+    u64 networkTSF;             //!< TSF timestamp from the current firmware TSF
+
+    /** 802.11h BSS information */
+    wlan_11h_bss_info_t wlan_11h_bss_info;
+
+    /** Country information set */
+    IEEEtypes_CountryInfoFullSet_t CountryInfo;
+
+    /** WPA IE */
+    IEEEtypes_VendorSpecific_t *pWpaIE;
+    /** WPA IE offset in the beacon buffer */
+    u8 wpaOffset;
+    /** RSN IE */
+    IEEEtypes_Generic_t *pRsnIE;
+    /** RSN IE offset in the beacon buffer */
+    u8 rsnOffset;
+
+    /** WPS IE */
+    IEEEtypes_VendorSpecific_t *pWpsIE;
+    /** WPS IE offset in the beacon buffer */
+    u8 wpsOffset;
+
+    u8 *pBeaconBuf;             //!< Pointer to the returned scan response
+    uint beaconBufSize;         //!< Length of the stored scan response
+    uint beaconBufSizeMax;      //!< Max allocated size for updated scan response
+
+} BSSDescriptor_t;
+
+extern int wlan_ssid_cmp(WLAN_802_11_SSID * ssid1, WLAN_802_11_SSID * ssid2);
+extern int wlan_find_ssid_in_list(wlan_adapter * Adapter,
+                                  WLAN_802_11_SSID * ssid, u8 * bssid,
+                                  int mode);
+extern int wlan_find_best_ssid_in_list(wlan_adapter * Adapter);
+extern int wlan_find_bssid_in_list(wlan_adapter * Adapter, u8 * bssid,
+                                   int mode);
+
+extern int wlan_find_best_network_ssid(wlan_private * priv,
+                                       WLAN_802_11_SSID * pSSID);
+
+extern int wlan_cmd_specific_scan_ssid(wlan_private * priv,
+                                       WLAN_802_11_SSID * pRequestedSSID);
+extern int wlan_cmd_specific_scan_bssid(wlan_private * priv, u8 * bssid);
+
+extern int wlan_get_scan_table_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_set_user_scan_ioctl(wlan_private * priv, struct iwreq *wrq);
+
+extern int wlan_associate(wlan_private * priv, BSSDescriptor_t * pBSSDesc);
+
+extern int wlan_cmd_802_11_scan(wlan_private * priv,
+                                HostCmd_DS_COMMAND * cmd, void *pdata_buf);
+
+extern void wlan_scan_update_tsf_timestamps(wlan_private * priv,
+                                            BSSDescriptor_t * pNewBssDesc);
+
+extern int wlan_ret_802_11_scan(wlan_private * priv,
+                                HostCmd_DS_COMMAND * resp);
+
+extern int wlan_extscan_ioctl(wlan_private * priv, struct ifreq *req);
+
+extern int wlan_cmd_bgs_query(wlan_private * priv);
+extern int wlan_bg_scan_enable(wlan_private * priv, BOOLEAN enable);
+extern int wlan_do_bg_scan_config_ioctl(wlan_private * priv,
+                                        struct ifreq *req);
+extern int wlan_do_bgscfg_ioctl(wlan_private * priv, struct ifreq *req);
+
+extern int wlan_cmd_802_11_bg_scan_config(wlan_private * priv,
+                                          HostCmd_DS_COMMAND * cmd,
+                                          int cmd_action, void *pdata_buf);
+extern int wlan_cmd_802_11_bg_scan_query(wlan_private * priv,
+                                         HostCmd_DS_COMMAND * cmd);
+
+#ifdef __KERNEL__
+extern int wlan_get_scan(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_point *dwrq, char *extra);
+extern int wlan_set_scan(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_param *vwrq, char *extra);
+#endif
+
+#endif /* _WLAN_SCAN_H */
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_sdio.c b/drivers/net/wireless/8688_wlan/wlan/wlan_sdio.c
new file mode 100755
index 0000000..22bc7b7
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_sdio.c
@@ -0,0 +1,1684 @@
+/** @file wlan_sdio.c
+ *  @brief This file contains SDIO IF (interface) module
+ *  related functions.
+ * 
+ * (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/****************************************************
+Change log:
+	10/14/05: add Doxygen format comments 
+	01/05/06: add kernel 2.6.x support
+	01/23/06: add fw downlaod
+	06/06/06: add macro SD_BLOCK_SIZE_FW_DL for firmware download
+		  add macro ALLOC_BUF_SIZE for cmd resp/Rx data skb buffer allocation
+****************************************************/
+
+#include	"wlan_sdio.h"
+
+#include <linux/firmware.h>
+
+/** define SD block size for firmware download */
+#define SD_BLOCK_SIZE_FW_DL	32
+
+/** define SD block size for data Tx/Rx */
+#define SD_BLOCK_SIZE		256
+
+/** define allocated buffer size */
+#define ALLOC_BUF_SIZE		(((MAX(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE, \
+					MRVDRV_SIZE_OF_CMD_BUFFER) + SDIO_HEADER_LEN \
+					+ SD_BLOCK_SIZE - 1) / SD_BLOCK_SIZE) * SD_BLOCK_SIZE)
+
+/** Max retry number of CMD53 write */
+#define MAX_WRITE_IOMEM_RETRY	2
+
+/* The macros below are hardware platform dependent.
+   The definition should match the actual platform */
+#define GPIO_PORT_INIT()
+/** Set GPIO port to high */
+#define GPIO_PORT_TO_HIGH()
+/** Set GPIO port to low */
+#define GPIO_PORT_TO_LOW()
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+static wlan_private *pwlanpriv;
+static wlan_private *(*wlan_add_callback) (void *dev_id);
+static int (*wlan_remove_callback) (void *dev_id);
+
+/** SDIO func 1 */
+static u8 sdio_func_wlan = SDIO_FUNC1;
+
+/** SDIO Rx unit */
+static u8 sdio_rx_unit = 0;
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+#define SDIO_CLK_RATE_6MHZ	6       /**< 6 MHz */
+#define SDIO_CLK_RATE_12MHZ	12      /**< 12 MHz */
+#define SDIO_CLK_RATE_25MHZ	25      /**< 25 MHz */
+#define SDIO_CLK_RATE_DEFAULT	0   /**< Default rate */
+/** SDIO clock rate */
+int clkrate = SDIO_CLK_RATE_DEFAULT;
+module_param(clkrate, int, 0);
+
+/** ISR */
+//sd_int_handler isr_function;
+//int request_gpio_irq_callback(void (*callback) (void *), void *arg);
+//int release_gpio_irq_callback(void (*callback) (void *), void *arg);
+
+/** Chip ID for 8686 */
+#define CHIP_ID_8686 0x3042
+/** Chip ID for 8688 */
+#define CHIP_ID_8688 0x3130
+/** Chip ID for 8688R3 */
+#define CHIP_ID_8688R3 0x3131
+/** Chip ID for 8682 */
+#define CHIP_ID_8682 0x3139
+/** Null chip ID */
+#define CHIP_ID_NULL 0x0000
+
+
+/** Default helper name */
+#define DEFAULT_HELPER_NAME "mrvl/helper_sd.bin"
+/** Maximum length for firmware name */
+#define MAX_FW_NAME 32
+
+typedef struct _chipid_fwname
+{
+    /** Chip ID */
+    u16 chip_id;
+    /** Firmware filename */
+    char fw_name[MAX_FW_NAME];
+} chipid_fwname;
+
+static chipid_fwname chip_fw[] = {
+    {.chip_id = CHIP_ID_8688,.fw_name = "mrvl/sd8688.bin"},
+    {.chip_id = CHIP_ID_8686,.fw_name = "mrvl/sd8686.bin"},
+    {.chip_id = CHIP_ID_8688R3,.fw_name = "mrvl/sd8688.bin"},
+    {.chip_id = CHIP_ID_8682,.fw_name = "mrvl/sd8682.bin"},
+    {.chip_id = CHIP_ID_NULL,.fw_name = ""},    /* must be the last one */
+};
+
+extern u8 *helper_name;
+extern u8 *fw_name;
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function removes the card
+ *  
+ *  @param card    A pointer to the card
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+
+static inline u16
+get_chip_id(wlan_private * priv)
+{
+    u8 id0;
+    u8 id1;
+    u16 chip_id;
+
+    if (sbi_read_ioreg(priv, CARD_CHIP_ID_0_REG, &id0) < 0)
+        return CHIP_ID_NULL;
+
+    if (sbi_read_ioreg(priv, CARD_CHIP_ID_1_REG, &id1) < 0)
+        return CHIP_ID_NULL;
+
+    chip_id = (((u16) id0) << 8) | id1;
+    PRINTM(INFO, "Chip ID %#x\n", chip_id);
+
+    return chip_id;
+}
+
+static inline int
+get_enhance_flag(wlan_private * priv)
+{
+    u16 chip_id;
+
+    chip_id = get_chip_id(priv);
+    if ((chip_id == CHIP_ID_8688) || (chip_id == CHIP_ID_8682))
+        return TRUE;
+    else
+        return FALSE;
+}
+
+static inline char *
+find_fw_name(wlan_private * priv)
+{
+    u16 chip_id;
+    int i = 0;
+
+    chip_id = get_chip_id(priv);
+
+    while (chip_id && (chip_fw[i].chip_id != CHIP_ID_NULL)) {
+        if (chip_fw[i].chip_id == chip_id) {
+            return chip_fw[i].fw_name;
+        }
+        i++;
+    }
+    PRINTM(ERROR, "Unknown Chip ID %#x\n", chip_id);
+    return NULL;
+}
+
+/* some tool function */
+int sbi_read_iomem(wlan_private *priv, void *buf, unsigned int reg_addr, int cnt)
+{
+	struct sdio_mmc_card *card = priv->wlan_dev.card;
+	int ret = 0;
+
+	sdio_claim_host(card->func);
+	ret = sdio_readsb(card->func, buf, reg_addr, cnt);
+	sdio_release_host(card->func);
+
+	return ret;
+}
+
+int sbi_write_iomem(wlan_private *priv, void *buf, unsigned int reg_addr, int cnt)
+{
+	struct sdio_mmc_card *card = priv->wlan_dev.card;
+	int ret = 0;
+
+	sdio_claim_host(card->func);
+	ret = sdio_writesb(card->func, reg_addr, buf, cnt);
+	sdio_release_host(card->func);
+
+	return ret;
+}
+
+/** 
+ *  @brief This function get rx_unit value
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sd_get_rx_unit(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 reg;
+    ret = sbi_read_ioreg(priv, CARD_RX_UNIT_REG, &reg);
+    if (ret == WLAN_STATUS_SUCCESS)
+        sdio_rx_unit = reg;
+    return ret;
+}
+
+/** 
+ *  @brief This function reads rx length
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param dat	   A pointer to keep returned data
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+sd_read_rx_len(wlan_private * priv, u16 * dat)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 reg;
+    ret = sbi_read_ioreg(priv, CARD_RX_LEN_REG, &reg);
+    if (ret == WLAN_STATUS_SUCCESS) {
+        *dat = (u16) reg << sdio_rx_unit;
+    }
+    return ret;
+}
+
+/** 
+ *  @brief This function reads fw status registers
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param dat	   A pointer to keep returned data
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+sd_read_firmware_status(wlan_private * priv, u16 * dat)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 fws0;
+    u8 fws1;
+    ENTER();
+    ret = sbi_read_ioreg(priv, CARD_FW_STATUS0_REG, &fws0);
+    if (ret < 0)
+        return WLAN_STATUS_FAILURE;
+    ret = sbi_read_ioreg(priv, CARD_FW_STATUS1_REG, &fws1);
+    if (ret < 0)
+        return WLAN_STATUS_FAILURE;
+    *dat = (((u16) fws1) << 8) | fws0;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function reads scratch registers
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param dat	   A pointer to keep returned data
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+mv_sdio_read_scratch(wlan_private * priv, u16 * dat)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 scr0;
+    u8 scr1;
+
+    ret = sbi_read_ioreg(priv, CARD_OCR_0_REG, &scr0);
+    if (ret < 0)
+        return WLAN_STATUS_FAILURE;
+
+    ret = sbi_read_ioreg(priv, CARD_OCR_1_REG, &scr1);
+    PRINTM(INFO, "CARD_OCR_0_REG = 0x%x, CARD_OCR_1_REG = 0x%x\n", scr0,
+           scr1);
+    if (ret < 0)
+        return WLAN_STATUS_FAILURE;
+
+    *dat = (((u16) scr1) << 8) | scr0;
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function polls the card status register.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param bits    	the bit mask
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+mv_sdio_poll_card_status(wlan_private * priv, u8 bits)
+{
+    int tries;
+    u8 cs;
+
+    for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
+        if (sbi_read_ioreg(priv, CARD_STATUS_REG, &cs) < 0)
+            break;
+        else if ((cs & bits) == bits)
+            return WLAN_STATUS_SUCCESS;
+        udelay(10);
+    }
+
+    PRINTM(WARN, "mv_sdio_poll_card_status failed, tries = %d\n", tries);
+    return WLAN_STATUS_FAILURE;
+}
+
+/** 
+ *  @brief This function set the sdio bus width.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param mode    	1--1 bit mode, 4--4 bit mode
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sdio_set_bus_width(wlan_private * priv, u8 mode)
+{
+    return WLAN_STATUS_SUCCESS;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ *  @brief This function reads data from the card.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @param type	   	A pointer to keep type as data or command
+ *  @param nb		A pointer to keep the data/cmd length retured in buffer
+ *  @param payload 	A pointer to the data/cmd buffer
+ *  @param nb	   	the length of data/cmd buffer
+ *  @param npayload	the length of data/cmd buffer
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+/* external lock needed */
+static int
+mv_sdio_card_to_host(wlan_private * priv,
+                     u32 * type, int *nb, u8 * payload, int npayload)
+{
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 buf_len = 0;
+    int buf_block_len;
+    int blksz;
+    u32 event;
+
+	ENTER();
+	
+    if (!card || !card->func) {
+        PRINTM(ERROR, "card or function is NULL!\n");
+        ret = WLAN_STATUS_FAILURE;
+        return ret; 
+    }
+
+    if (!payload) {
+        PRINTM(WARN, "payload NULL pointer received!\n");
+        ret = WLAN_STATUS_FAILURE;
+	return ret;
+    }
+
+    //sdio_claim_host(card->func);
+
+    /* Read the length of data to be transferred */
+    if (priv->enhance_flag)
+        ret = sd_read_rx_len(priv, &buf_len);
+    else
+        ret = mv_sdio_read_scratch(priv, &buf_len);
+    if (ret < 0) {
+        PRINTM(ERROR, "card_to_host, read scratch reg failed\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto exit;
+    }
+
+    if (buf_len <= SDIO_HEADER_LEN || buf_len > npayload) {
+        PRINTM(ERROR, "card_to_host, invalid packet length: %d\n", buf_len);
+        ret = WLAN_STATUS_FAILURE;
+        goto exit;
+    }
+
+    /* Allocate buffer */
+    blksz = SD_BLOCK_SIZE;
+    buf_block_len = (buf_len + blksz - 1) / blksz;
+
+    ret = sdio_readsb(card->func, payload, priv->wlan_dev.ioport,
+                      buf_block_len * blksz);
+
+    if (ret < 0) {
+        PRINTM(ERROR, "card_to_host, read iomem failed: %d\n", ret);
+        ret = WLAN_STATUS_FAILURE;
+        goto exit;
+    }
+    if (priv->enhance_flag)
+        *nb = wlan_le16_to_cpu(*(u16 *) & payload[0]);
+    else
+        *nb = buf_len;
+
+    DBG_HEXDUMP(IF_D, "SDIO Blk Rd", payload, blksz * buf_block_len);
+
+    *type = wlan_le16_to_cpu(*(u16 *) & payload[2]);
+    if (*type == MV_TYPE_EVENT) {
+        event = *(u32 *) & payload[4];
+        priv->adapter->EventCause = wlan_le32_to_cpu(event);
+    }
+
+  exit:
+//	sdio_release_host(card->func);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function enables the host interrupts mask
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param mask	   the interrupt mask
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+/* external lock needed */
+static int
+enable_host_int_mask(wlan_private * priv, u8 mask)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    /* Simply write the mask to the register */
+    ret = sbi_write_ioreg(priv, HOST_INT_MASK_REG, mask);
+
+    if (ret) {
+        PRINTM(WARN, "Unable to enable the host interrupt!\n");
+        ret = WLAN_STATUS_FAILURE;
+    }
+
+    priv->adapter->HisRegCpy = 1;
+
+    LEAVE();
+    return ret;
+}
+
+/**  @brief This function disables the host interrupts mask.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param mask	   the interrupt mask
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+/* external lock needed */
+static int
+disable_host_int_mask(wlan_private * priv, u8 mask)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 host_int_mask;
+
+    ENTER();
+
+    /* Read back the host_int_mask register */
+    ret = sbi_read_ioreg(priv, HOST_INT_MASK_REG, &host_int_mask);
+    if (ret) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Update with the mask and write back to the register */
+    host_int_mask &= ~mask;
+    ret = sbi_write_ioreg(priv, HOST_INT_MASK_REG, host_int_mask);
+    if (ret < 0) {
+        PRINTM(WARN, "Unable to diable the host interrupt!\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/** 
+ *  @brief This function handles the interrupt.
+ *  
+ *  @param card	   The card handle.
+ *  @return 	   n/a
+ */
+static void
+sbi_interrupt(struct sdio_func *func)
+{
+    struct sdio_mmc_card *card;
+    wlan_private *priv;
+    u8 ireg = 0;
+
+    ENTER();
+
+    card = sdio_get_drvdata(func);
+    if (!card || !card->priv) {
+        PRINTM(INFO, "%s: sbi_interrupt(%p) card or priv is NULL, card=%p\n",
+               __FUNCTION__, func, card);
+        return;
+    }
+
+    priv = card->priv;
+    wlan_interrupt(priv);
+    if (sbi_get_int_status(priv, &ireg)) {
+        PRINTM(ERROR, "%s: reading HOST_INT_STATUS_REG failed\n",
+               __FUNCTION__);
+    } else
+        PRINTM(INFO, "%s: HOST_INT_STATUS_REG %#x\n", __FUNCTION__, ireg);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+}
+
+/** client driver probe handler 		*/
+static int
+wlan_probe(struct sdio_func *func, const struct sdio_device_id *id)
+{
+    int ret = WLAN_STATUS_FAILURE;
+    struct sdio_mmc_card *card = NULL;
+    u8 chiprev;
+
+    ENTER();
+
+    if (!wlan_add_callback) {
+        PRINTM(FATAL, "%s: add_card callback function not found!\n",
+               __FUNCTION__);
+        goto done;
+    }
+
+    if (func->class != SDIO_CLASS_WLAN) {
+        PRINTM(FATAL, "%s: class-id SD_CLASS_WLAN not found!\n",
+               __FUNCTION__);
+        goto done;
+    }
+
+    PRINTM(INFO, "%s: vendor=0x%4.04X device=0x%4.04X class=%d function=%d\n",
+           __FUNCTION__, func->vendor, func->device, func->class, func->num);
+
+    sdio_claim_host(func);
+
+    ret = sdio_enable_func(func);
+    if (ret) {
+        PRINTM(FATAL, "sdio_enable_func() failed: ret=%d\n", ret);
+        goto release_host;
+    }
+
+    ret = sdio_claim_irq(func, sbi_interrupt);
+    if (ret) {
+        PRINTM(FATAL, "sdio_claim_irq failed: ret=%d\n", ret);
+        goto disable_func;
+    }
+
+    /* read Revision Register to get the chip revision number */
+    chiprev = sdio_readb(func, CARD_REVISION_REG, &ret);
+    if (ret) {
+        PRINTM(FATAL, "cannot read CARD_REVISION_REG\n");
+        goto release_irq;
+    }
+
+    PRINTM(INFO, "revision=%#x\n", chiprev);
+
+    card = kzalloc(sizeof(struct sdio_mmc_card), GFP_KERNEL);
+    if (!card) {
+        ret = -ENOMEM;
+        goto release_irq;
+    }
+
+    card->func = func;
+
+    ret = sdio_set_block_size(card->func, SD_BLOCK_SIZE);
+    if (ret) {
+        PRINTM(ERROR, "%s: cannot set SDIO block size\n", __FUNCTION__);
+                ret = WLAN_STATUS_FAILURE;
+        goto release_irq;
+            }
+
+    sdio_release_host(func);
+
+    if (!wlan_add_callback(card)) {
+        PRINTM(ERROR, "%s: wlan_add_callback failed\n", __FUNCTION__);
+                ret = WLAN_STATUS_FAILURE;
+        goto reclaim_host;
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+    goto done;
+
+  reclaim_host:
+    sdio_claim_host(func);
+  release_irq:
+    sdio_release_irq(func);
+  disable_func:
+    sdio_disable_func(func);
+  release_host:
+    sdio_release_host(func);
+
+    if (card) {
+        kfree(card);
+        card = NULL;
+    }
+
+    if (pwlanpriv)
+        return WLAN_STATUS_SUCCESS;
+    else
+        return WLAN_STATUS_FAILURE;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** client driver remove handler 	*/
+static void
+wlan_remove(struct sdio_func *func)
+{
+    struct sdio_mmc_card *card;
+
+    ENTER();
+
+    if (!wlan_remove_callback) {
+        PRINTM(FATAL, "%s: remove_card callback function not found!\n",
+               __FUNCTION__);
+        goto done;
+        }
+    if (func) {
+        card = sdio_get_drvdata(func);
+        if (card) {
+            sdio_claim_host(func);
+            sdio_release_irq(func);
+            sdio_disable_func(func);
+            sdio_release_host(func);
+
+            wlan_remove_callback(card);
+
+            kfree(card);
+            card = NULL;
+        }
+    }
+
+  done:
+    LEAVE();
+}
+
+#ifdef CONFIG_PM
+/* client driver suspend handler 	*/
+int wlan_suspend(struct sdio_func *func)
+{
+    ENTER();
+    LEAVE();
+    return 0;
+}
+
+/* client driver resume handler 	*/
+int wlan_resume(struct sdio_func *func)
+{
+    ENTER();
+    LEAVE();
+    return 0;
+}
+#endif
+
+/** WLAN IDs */
+static const struct sdio_device_id wlan_ids[] = {
+    {SDIO_DEVICE_CLASS(SDIO_CLASS_WLAN)},
+    {},
+};
+
+MODULE_DEVICE_TABLE(sdio, wlan_ids);
+
+static struct sdio_driver wlan_sdio = {
+    .name = "wlan_sdio",
+    .id_table = wlan_ids,
+    .probe = wlan_probe,
+    .remove = wlan_remove,
+#ifdef CONFIG_PM
+//    .suspend  = wlan_suspend,
+//    .resume   = wlan_resume, 
+#endif
+
+};
+
+/** 
+ *  @brief This function registers the IF module in bus driver.
+ *  
+ *  @param add	   wlan driver's call back funtion for add card.
+ *  @param remove  wlan driver's call back funtion for remove card.
+ *  @param arg     not been used
+ *  @return	   An int pointer that keeps returned value
+ */
+int *
+sbi_register(wlan_notifier_fn_add add, wlan_notifier_fn_remove remove,
+             void *arg)
+{
+    int *sdio_ret = (int *) 1;
+
+    ENTER();
+
+    wlan_add_callback = add;
+    wlan_remove_callback = remove;
+
+    /* SDIO Driver Registration */
+    if (sdio_register_driver(&wlan_sdio) != 0) {
+        PRINTM(FATAL, "SDIO Driver Registration Failed \n");
+        sdio_ret = NULL;
+    }
+
+    LEAVE();
+    return sdio_ret;
+}
+
+/** 
+ *  @brief This function de-registers the IF module in bus driver.
+ *  
+ *  @return 	   n/a
+ */
+void
+sbi_unregister(void)
+{
+    ENTER();
+
+    /* SDIO Driver Unregistration */
+    sdio_unregister_driver(&wlan_sdio);
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function reads the IO register.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param reg	   register to be read
+ *  @param dat	   A pointer to variable that keeps returned value
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_read_ioreg(wlan_private * priv, u32 reg, u8 * dat)
+{
+    struct sdio_mmc_card *card;
+    int ret = WLAN_STATUS_FAILURE;
+
+    ENTER();
+
+    card = priv->wlan_dev.card;
+    if (!card || !card->func) {
+        PRINTM(ERROR, "sbi_read_ioreg(): card or function is NULL!\n");
+        goto done;
+    }
+
+    *dat = sdio_readb(card->func, reg, &ret);
+    if (ret) {
+        PRINTM(ERROR, "sbi_read_ioreg(): sdio_readb failed! ret=%d\n", ret);
+        goto done;
+    }
+
+    PRINTM(INFO, "sbi_read_ioreg() priv=%p func=%d reg=%#x dat=%#x\n", priv,
+           card->func->num, reg, *dat);
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function writes the IO register.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param reg	   register to be written
+ *  @param dat	   the value to be written
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_write_ioreg(wlan_private * priv, u32 reg, u8 dat)
+{
+    struct sdio_mmc_card *card;
+    int ret = WLAN_STATUS_FAILURE;
+
+    ENTER();
+
+    card = priv->wlan_dev.card;
+    if (!card || !card->func) {
+        PRINTM(ERROR, "sbi_write_ioreg(): card or function is NULL!\n");
+        goto done;
+    }
+
+    PRINTM(INFO, "sbi_write_ioreg() priv=%p func=%d reg=%#x dat=%#x\n", priv,
+           card->func->num, reg, dat);
+
+    sdio_writeb(card->func, dat, reg, &ret);
+    if (ret) {
+        PRINTM(ERROR, "sbi_write_ioreg(): sdio_readb failed! ret=%d\n", ret);
+        goto done;
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function checks the interrupt status and handle it accordingly.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param ireg    A pointer to variable that keeps returned value
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_get_int_status(wlan_private * priv, u8 * ireg)
+{
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 sdio_ireg = 0;
+    u8 *cmdBuf;
+    wlan_dev_t *wlan_dev = &priv->wlan_dev;
+    struct sk_buff *skb;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "%s: card or function is NULL!\n", __FUNCTION__);
+        ret = WLAN_STATUS_FAILURE;
+	return ret;
+    }
+
+        //PRINTM(ERROR, "%s: before claim host!\n", __FUNCTION__);
+	//sdio_claim_host(card->func);
+        ///PRINTM(ERROR, "%s: after claim host!\n", __FUNCTION__);
+
+    *ireg = 0;
+    if ((ret = sbi_read_ioreg(priv, HOST_INTSTATUS_REG, &sdio_ireg))) {
+        PRINTM(WARN, "sbi_read_ioreg: read int status register failed\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (sdio_ireg != 0) {
+        /*
+         * DN_LD_HOST_INT_STATUS and/or UP_LD_HOST_INT_STATUS
+         * Clear the interrupt status register and re-enable the interrupt
+         */
+        PRINTM(INFO, "sdio_ireg = 0x%x\n", sdio_ireg);
+        if ((ret = sbi_write_ioreg(priv, HOST_INTSTATUS_REG,
+                                    ~(sdio_ireg) & (DN_LD_HOST_INT_STATUS |
+                                                    UP_LD_HOST_INT_STATUS))) <
+            0) {
+            PRINTM(WARN,
+                   "sbi_write_ioreg: clear int status register failed\n");
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+    } else
+        PRINTM(ERROR, "cause=0 sdio_ireg = 0x%x\n", sdio_ireg);
+
+    if (sdio_ireg & DN_LD_HOST_INT_STATUS) {    /* tx_done INT */
+        *ireg |= HIS_TxDnLdRdy;
+        if (!priv->wlan_dev.dnld_sent) {        /* tx_done already received */
+            PRINTM(INFO, "warning: tx_done already received:"
+                   " dnld_sent=0x%x int status=0x%x\n",
+                   priv->wlan_dev.dnld_sent, sdio_ireg);
+        } else {
+            wmm_process_fw_iface_tx_xfer_end(priv);
+            priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+        }
+    }
+
+    if (sdio_ireg & UP_LD_HOST_INT_STATUS) {
+
+        /* 
+         * DMA read data is by block alignment,so we need alloc extra block
+         * to avoid wrong memory access.
+         */
+        if (!(skb = dev_alloc_skb(ALLOC_BUF_SIZE))) {
+            PRINTM(WARN, "No free skb\n");
+            priv->stats.rx_dropped++;
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        /* 
+         * Transfer data from card
+         * skb->tail is passed as we are calling skb_put after we
+         * are reading the data
+         */
+        if (mv_sdio_card_to_host(priv, &wlan_dev->upld_typ,
+                                 (int *) &wlan_dev->upld_len, skb->tail,
+                                 ALLOC_BUF_SIZE) < 0) {
+            u8 cr = 0;
+
+            PRINTM(ERROR, "Card to host failed: int status=0x%x\n",
+                   sdio_ireg);
+            if (sbi_read_ioreg(priv, CONFIGURATION_REG, &cr) < 0)
+                PRINTM(ERROR, "read ioreg failed (CFG)\n");
+
+            PRINTM(INFO, "Config Reg val = %d\n", cr);
+            if (sbi_write_ioreg(priv, CONFIGURATION_REG, (cr | 0x04)) < 0)
+                PRINTM(ERROR, "write ioreg failed (CFG)\n");
+
+            PRINTM(INFO, "write success\n");
+            if (sbi_read_ioreg(priv, CONFIGURATION_REG, &cr) < 0)
+                PRINTM(ERROR, "read ioreg failed (CFG)\n");
+
+            PRINTM(INFO, "Config reg val =%x\n", cr);
+            ret = WLAN_STATUS_FAILURE;
+            kfree_skb(skb);
+            goto done;
+        }
+
+        switch (wlan_dev->upld_typ) {
+        case MV_TYPE_DAT:
+            PRINTM(DATA, "Data <= FW\n");
+            skb_put(skb, priv->wlan_dev.upld_len);
+            skb_pull(skb, SDIO_HEADER_LEN);
+            wlan_process_rx_packet(priv, skb);
+            priv->adapter->IntCounter = 0;
+            /* skb will be freed by kernel later */
+            break;
+
+        case MV_TYPE_CMD:
+            *ireg |= HIS_CmdUpLdRdy;
+            priv->adapter->HisRegCpy |= *ireg;
+
+            /* take care of CurCmd = NULL case */
+            if (!priv->adapter->CurCmd) {
+                cmdBuf = priv->wlan_dev.upld_buf;
+            } else {
+                cmdBuf = priv->adapter->CurCmd->BufVirtualAddr;
+            }
+
+            priv->wlan_dev.upld_len -= SDIO_HEADER_LEN;
+            memcpy(cmdBuf, skb->data + SDIO_HEADER_LEN,
+                   MIN(MRVDRV_SIZE_OF_CMD_BUFFER, priv->wlan_dev.upld_len));
+            kfree_skb(skb);
+            break;
+
+        case MV_TYPE_EVENT:
+            *ireg |= HIS_CardEvent;
+            priv->adapter->HisRegCpy |= *ireg;
+            /* event cause has been saved to priv->adapter->EventCause */
+            kfree_skb(skb);
+            break;
+
+        default:
+            PRINTM(ERROR, "SDIO unknown upld type = 0x%x\n",
+                   wlan_dev->upld_typ);
+            kfree_skb(skb);
+            break;
+        }
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+done:
+    //sdio_release_host(card->func);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function disables the host interrupts.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_disable_host_int(wlan_private * priv)
+{
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+    int ret;
+
+    sdio_claim_host(card->func);
+    ret = disable_host_int_mask(priv, HIM_DISABLE);
+    sdio_release_host(card->func);
+    return ret;
+}
+
+/** 
+ *  @brief This function enables the host interrupts.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+int
+sbi_enable_host_int(wlan_private * priv)
+{
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+    int ret;
+
+    sdio_claim_host(card->func);
+    ret = enable_host_int_mask(priv, HIM_ENABLE);
+    sdio_release_host(card->func);
+    return ret;
+}
+
+/** 
+ *  @brief This function de-registers the device.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+int
+sbi_unregister_dev(wlan_private * priv)
+{
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "Error: card or function is NULL!\n");
+        goto done;
+    }
+
+    sdio_set_drvdata(card->func, NULL);
+
+    GPIO_PORT_TO_LOW();
+
+  done:
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function registers the device.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_register_dev(wlan_private * priv)
+{
+    int ret = WLAN_STATUS_FAILURE;
+    u8 reg;
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+    struct sdio_func *func;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "Error: card or function is NULL!\n");
+        goto free_card;
+    }
+
+    func = card->func;
+
+    GPIO_PORT_INIT();
+    GPIO_PORT_TO_HIGH();
+
+    /* Initialize the private structure */
+    strncpy(priv->wlan_dev.name, "sdio0", sizeof(priv->wlan_dev.name));
+    priv->wlan_dev.ioport = 0;
+    priv->wlan_dev.upld_rcv = 0;
+    priv->wlan_dev.upld_typ = 0;
+    priv->wlan_dev.upld_len = 0;
+
+    sdio_claim_host(func);
+
+    /* Read the IO port */
+    ret = sbi_read_ioreg(priv, IO_PORT_0_REG, &reg);
+    if (ret)
+        goto release_irq;
+    else
+        priv->wlan_dev.ioport |= reg;
+
+    ret = sbi_read_ioreg(priv, IO_PORT_1_REG, &reg);
+    if (ret)
+        goto release_irq;
+    else
+        priv->wlan_dev.ioport |= (reg << 8);
+
+    ret = sbi_read_ioreg(priv, IO_PORT_2_REG, &reg);
+    if (ret)
+        goto release_irq;
+    else
+        priv->wlan_dev.ioport |= (reg << 16);
+
+    PRINTM(INFO, "SDIO FUNC #%d IO port: 0x%x\n", func->num,
+           priv->wlan_dev.ioport);
+
+    priv->hotplug_device = &func->dev;
+    if (helper_name == NULL) {
+        helper_name = DEFAULT_HELPER_NAME;
+    }
+    if (fw_name == NULL) {
+        fw_name = find_fw_name(priv);
+        if (fw_name == NULL) {
+            goto release_irq;
+        }
+    }
+
+    sdio_release_host(func);
+
+    sdio_set_drvdata(func, card);
+
+    ret = WLAN_STATUS_SUCCESS;
+    goto done;
+
+  release_irq:
+    sdio_release_irq(func);
+    sdio_disable_func(func);
+    sdio_release_host(func);
+  free_card:
+    if (card) {
+        kfree(card);
+        card = NULL;
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function sends data to the card.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param type	   data or command
+ *  @param payload A pointer to the data/cmd buffer
+ *  @param nb	   the length of data/cmd
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_host_to_card(wlan_private * priv, u8 type, u8 * payload, u16 nb)
+{
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+    int ret = WLAN_STATUS_SUCCESS;
+    int buf_block_len;
+    int blksz;
+    int i = 0;
+    void *tmpcmdbuf = NULL;
+    int tmpcmdbufsz;
+    u8 *cmdbuf = NULL;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "card or function is NULL!\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto exit;
+    }
+
+    priv->adapter->HisRegCpy = 0;
+
+    /* Allocate buffer and copy payload */
+    blksz = SD_BLOCK_SIZE;
+    buf_block_len = (nb + SDIO_HEADER_LEN + blksz - 1) / blksz;
+
+    /* This is SDIO specific header
+     *  u16 length,
+     *  u16 type (MV_TYPE_DAT = 0, MV_TYPE_CMD = 1, MV_TYPE_EVENT = 3) 
+     */
+    if (type == MV_TYPE_DAT) {
+        *(u16 *) & payload[0] = wlan_cpu_to_le16(nb + SDIO_HEADER_LEN);
+        *(u16 *) & payload[2] = wlan_cpu_to_le16(type);
+    } else if (type == MV_TYPE_CMD) {
+        tmpcmdbufsz = WLAN_UPLD_SIZE;
+        tmpcmdbuf = kmalloc(tmpcmdbufsz, GFP_KERNEL);
+        if (!tmpcmdbuf) {
+            PRINTM(ERROR, "Unable to allocate buffer for CMD.\n");
+            ret = WLAN_STATUS_FAILURE;
+            goto exit;
+        }
+        memset(tmpcmdbuf, 0, tmpcmdbufsz);
+        cmdbuf = (u8 *) tmpcmdbuf;
+
+        *(u16 *) & cmdbuf[0] = wlan_cpu_to_le16(nb + SDIO_HEADER_LEN);
+        *(u16 *) & cmdbuf[2] = wlan_cpu_to_le16(type);
+
+        if (payload != NULL &&
+            (nb > 0 && nb <= (WLAN_UPLD_SIZE - SDIO_HEADER_LEN))) {
+
+            memcpy(&cmdbuf[SDIO_HEADER_LEN], payload, nb);
+        } else {
+            PRINTM(WARN, "sbi_host_to_card(): Error: payload=%p, nb=%d\n",
+                   payload, nb);
+        }
+    }
+
+    sdio_claim_host(card->func);
+
+    do {
+
+        /* Transfer data to card */
+        ret = sdio_writesb(card->func, priv->wlan_dev.ioport,
+                           (type == MV_TYPE_DAT) ? payload : cmdbuf,
+                           buf_block_len * blksz);
+        if (ret < 0) {
+            i++;
+            PRINTM(ERROR, "host_to_card, write iomem (%d) failed: %d\n", i,
+                   ret);
+            if (sbi_write_ioreg(priv, CONFIGURATION_REG, 0x04) < 0) {
+                PRINTM(ERROR, "write ioreg failed (CFG)\n");
+            }
+            ret = WLAN_STATUS_FAILURE;
+            if (i > MAX_WRITE_IOMEM_RETRY)
+                goto exit;
+        } else {
+            DBG_HEXDUMP(IF_D, "SDIO Blk Wr",
+                        (type == MV_TYPE_DAT) ? payload : cmdbuf,
+                        blksz * buf_block_len);
+        }
+    } while (ret == WLAN_STATUS_FAILURE);
+
+    if (type == MV_TYPE_DAT)
+        priv->wlan_dev.dnld_sent = DNLD_DATA_SENT;
+    else
+        priv->wlan_dev.dnld_sent = DNLD_CMD_SENT;
+
+  exit:
+    sdio_release_host(card->func);
+    if (tmpcmdbuf)
+        kfree(tmpcmdbuf);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function reads CIS informaion.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param cisinfo A pointer to CIS information output buffer
+ *  @param cislen  The length of CIS information output buffer
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_get_cis_info(wlan_private * priv, void *cisinfo, int *cislen)
+{
+#define CIS_PTR (0x8000)
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+    unsigned int i, cis_ptr = CIS_PTR;
+    int ret = WLAN_STATUS_FAILURE;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "sbi_get_cis_info(): card or function is NULL!\n");
+        goto exit;
+    }
+#define MAX_SDIO_CIS_INFO_LEN (256)
+    if (!cisinfo || (*cislen < MAX_SDIO_CIS_INFO_LEN)) {
+        PRINTM(WARN, "ERROR! get_cis_info: insufficient buffer passed\n");
+        goto exit;
+    }
+
+    *cislen = MAX_SDIO_CIS_INFO_LEN;
+
+    sdio_claim_host(card->func);
+
+    PRINTM(INFO, "cis_ptr=%#x\n", cis_ptr);
+
+    /* Read the Tuple Data */
+    for (i = 0; i < *cislen; i++) {
+        ((unsigned char *) cisinfo)[i] =
+            sdio_readb(card->func, cis_ptr + i, &ret);
+        if (ret) {
+            PRINTM(WARN, "get_cis_info error: ret=%d\n", ret);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+        PRINTM(INFO, "cisinfo[%d]=%#x\n", i, ((unsigned char *) cisinfo)[i]);
+    }
+
+  done:
+    sdio_release_host(card->func);
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function downloads helper image to the card.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_prog_helper(wlan_private * priv)
+{
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+    u8 *helper = NULL;
+    int helperlen;
+    int ret = WLAN_STATUS_SUCCESS;
+    void *tmphlprbuf = NULL;
+    int tmphlprbufsz;
+    u8 *hlprbuf;
+    int hlprblknow;
+    u32 tx_len;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "sbi_prog_helper(): card or function is NULL!\n");
+        goto done;
+    }
+
+    if (priv->fw_helper) {
+        helper = priv->fw_helper->data;
+        helperlen = priv->fw_helper->size;
+    } else {
+        PRINTM(MSG, "No helper image found! Terminating download.\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    PRINTM(INFO, "Downloading helper image (%d bytes), block size %d bytes\n",
+           helperlen, SD_BLOCK_SIZE);
+
+    tmphlprbufsz = WLAN_UPLD_SIZE;
+    tmphlprbuf = kmalloc(tmphlprbufsz, GFP_KERNEL);
+    if (!tmphlprbuf) {
+        PRINTM(ERROR,
+               "Unable to allocate buffer for helper. Terminating download\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    memset(tmphlprbuf, 0, tmphlprbufsz);
+    hlprbuf = (u8 *) tmphlprbuf;
+
+    sdio_claim_host(card->func);
+
+    /* Perform helper data transfer */
+    tx_len = (FIRMWARE_TRANSFER_NBLOCK * SD_BLOCK_SIZE) - SDIO_HEADER_LEN;
+    hlprblknow = 0;
+    do {
+        /* The host polls for the DN_LD_CARD_RDY and CARD_IO_READY bits */
+        ret = mv_sdio_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+        if (ret < 0) {
+            PRINTM(FATAL, "Helper download poll status timeout @ %d\n",
+                   hlprblknow);
+            goto done;
+        }
+
+        /* More data? */
+        if (hlprblknow >= helperlen)
+            break;
+
+        /* Set blocksize to transfer - checking for last block */
+        if (helperlen - hlprblknow < tx_len)
+            tx_len = helperlen - hlprblknow;
+
+        /* Set length to the 4-byte header */
+        *(u32 *) hlprbuf = wlan_cpu_to_le32(tx_len);
+
+        /* Copy payload to buffer */
+        memcpy(&hlprbuf[SDIO_HEADER_LEN], &helper[hlprblknow], tx_len);
+
+        PRINTM(INFO, ".");
+
+        /* Send data */
+        ret = sdio_writesb(card->func, priv->wlan_dev.ioport,
+                           hlprbuf, FIRMWARE_TRANSFER_NBLOCK * SD_BLOCK_SIZE);
+
+        if (ret < 0) {
+            PRINTM(FATAL, "IO error during helper download @ %d\n",
+                   hlprblknow);
+            goto done;
+        }
+
+        hlprblknow += tx_len;
+    } while (TRUE);
+
+    /* Write last EOF data */
+    PRINTM(INFO, "\nTransferring helper image EOF block\n");
+    memset(hlprbuf, 0x0, SD_BLOCK_SIZE);
+    ret = sdio_writesb(card->func, priv->wlan_dev.ioport,
+                       hlprbuf, SD_BLOCK_SIZE);
+
+    if (ret < 0) {
+        PRINTM(FATAL, "IO error in writing helper image EOF block\n");
+        goto done;
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+
+  done:
+    sdio_release_host(card->func);
+    if (tmphlprbuf)
+        kfree(tmphlprbuf);
+
+    return ret;
+}
+
+/** 
+ *  @brief This function downloads firmware image to the card.
+ *  
+ *  @param priv    	A pointer to wlan_private structure
+ *  @return 	   	WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_prog_fw_w_helper(wlan_private * priv)
+{
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+    u8 *firmware = NULL;
+    int firmwarelen;
+    u8 base0;
+    u8 base1;
+    int ret = WLAN_STATUS_SUCCESS;
+    int offset;
+    void *tmpfwbuf = NULL;
+    int tmpfwbufsz;
+    u8 *fwbuf;
+    u16 len;
+    int txlen = 0;
+    int tx_blocks = 0;
+    int i = 0;
+    int tries = 0;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "sbi_prog_fw_w_helper(): card or function is NULL!\n");
+        goto done;
+    }
+
+    if (priv->firmware) {
+        firmware = priv->firmware->data;
+        firmwarelen = priv->firmware->size;
+    } else {
+        PRINTM(MSG, "No firmware image found! Terminating download.\n");
+        return WLAN_STATUS_FAILURE;
+    }
+
+    PRINTM(INFO, "Downloading FW image (%d bytes)\n", firmwarelen);
+
+    tmpfwbufsz = WLAN_UPLD_SIZE;
+    tmpfwbuf = kmalloc(tmpfwbufsz, GFP_KERNEL);
+    if (!tmpfwbuf) {
+        PRINTM(ERROR,
+               "Unable to allocate buffer for firmware. Terminating download.\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+    memset(tmpfwbuf, 0, tmpfwbufsz);
+    fwbuf = (u8 *) tmpfwbuf;
+
+    sdio_claim_host(card->func);
+
+    /* Perform firmware data transfer */
+    offset = 0;
+    do {
+        /* The host polls for the DN_LD_CARD_RDY and CARD_IO_READY bits */
+        ret = mv_sdio_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+        if (ret < 0) {
+            PRINTM(FATAL,
+                   "FW download with helper poll status timeout @ %d\n",
+                   offset);
+            goto done;
+        }
+
+        /* More data? */
+        if (offset >= firmwarelen)
+            break;
+
+        for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
+            if ((ret = sbi_read_ioreg(priv, HOST_F1_RD_BASE_0, &base0)) < 0) {
+                PRINTM(WARN, "Dev BASE0 register read failed:"
+                       " base0=0x%04X(%d). Terminating download.\n", base0,
+                       base0);
+                ret = WLAN_STATUS_FAILURE;
+                goto done;
+            }
+            if ((ret = sbi_read_ioreg(priv, HOST_F1_RD_BASE_1, &base1)) < 0) {
+                PRINTM(WARN, "Dev BASE1 register read failed:"
+                       " base1=0x%04X(%d). Terminating download.\n", base1,
+                       base1);
+                ret = WLAN_STATUS_FAILURE;
+                goto done;
+            }
+            len = (((u16) base1) << 8) | base0;
+
+            if (len != 0)
+                break;
+            udelay(10);
+        }
+
+        if (len == 0)
+            break;
+        else if (len > WLAN_UPLD_SIZE) {
+            PRINTM(FATAL, "FW download failure @ %d, invalid length %d\n",
+                   offset, len);
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+
+        txlen = len;
+
+        if (len & BIT(0)) {
+            i++;
+            if (i > MAX_WRITE_IOMEM_RETRY) {
+                PRINTM(FATAL,
+                       "FW download failure @ %d, over max retry count\n",
+                       offset);
+                ret = WLAN_STATUS_FAILURE;
+                goto done;
+            }
+            PRINTM(ERROR, "FW CRC error indicated by the helper:"
+                   " len = 0x%04X, txlen = %d\n", len, txlen);
+            len &= ~BIT(0);
+            /* Setting this to 0 to resend from same offset */
+            txlen = 0;
+        } else
+            i = 0;
+
+        /* Set blocksize to transfer - checking for last block */
+        if (firmwarelen - offset < txlen) {
+            txlen = firmwarelen - offset;
+        }
+        PRINTM(INFO, ".");
+
+        tx_blocks = (txlen + SD_BLOCK_SIZE - 1) / SD_BLOCK_SIZE;
+
+        /* Copy payload to buffer */
+        memcpy(fwbuf, &firmware[offset], txlen);
+
+        /* Send data */
+        ret = sdio_writesb(card->func, priv->wlan_dev.ioport,
+                           fwbuf, tx_blocks * SD_BLOCK_SIZE);
+        if (ret < 0) {
+            PRINTM(ERROR, "FW download, write iomem (%d) failed @ %d\n", i,
+                   offset);
+            if (sbi_write_ioreg(priv, CONFIGURATION_REG, 0x04) < 0) {
+                PRINTM(ERROR, "write ioreg failed (CFG)\n");
+            }
+        }
+
+        offset += txlen;
+    } while (TRUE);
+
+    PRINTM(INFO, "\nFW download over, size %d bytes\n", firmwarelen);
+
+    ret = WLAN_STATUS_SUCCESS;
+  done:
+    sdio_release_host(card->func);
+    if (tmpfwbuf)
+        kfree(tmpfwbuf);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function checks if the firmware is ready to accept
+ *  command or not.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_check_fw_status(wlan_private * priv, int pollnum)
+{
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 firmwarestat;
+    int tries;
+
+    ENTER();
+
+    sdio_claim_host(card->func);
+
+    /* Wait for firmware initialization event */
+    for (tries = 0; tries < pollnum; tries++) {
+        if (!priv->enhance_flag) {
+            if ((ret = mv_sdio_read_scratch(priv, &firmwarestat)) < 0)
+                continue;
+        } else {
+            if ((ret = sd_read_firmware_status(priv, &firmwarestat)) < 0)
+                continue;
+        }
+
+        if (firmwarestat == FIRMWARE_READY) {
+            ret = WLAN_STATUS_SUCCESS;
+            break;
+        } else {
+            mdelay(10);
+            ret = WLAN_STATUS_FAILURE;
+        }
+    }
+
+    if (ret < 0) {
+        PRINTM(WARN, "Timeout waiting for FW to become active\n");
+        goto done;
+    }
+
+    ret = WLAN_STATUS_SUCCESS;
+    if (priv->enhance_flag)
+        sd_get_rx_unit(priv);
+  done:
+    sdio_release_host(card->func);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function set bus clock on/off
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param option    TRUE--on , FALSE--off
+ *  @return 	   WLAN_STATUS_SUCCESS
+ */
+int
+sbi_set_bus_clock(wlan_private * priv, u8 option)
+{
+	/*
+    if (option == TRUE)
+        sd_start_clock((psd_device) priv->wlan_dev.card);
+    else
+        sd_stop_clock((psd_device) priv->wlan_dev.card);
+    */  
+        
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function makes firmware exiting from deep sleep.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_exit_deep_sleep(wlan_private * priv)
+{
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    sdio_claim_host(card->func);
+
+    sbi_set_bus_clock(priv, TRUE);
+
+    if (priv->adapter->fwWakeupMethod == WAKEUP_FW_THRU_GPIO) {
+        GPIO_PORT_TO_LOW();
+    } else
+        ret = sbi_write_ioreg(priv, CONFIGURATION_REG, HOST_POWER_UP);
+
+    sdio_release_host(card->func);
+
+    return ret;
+}
+
+/** 
+ *  @brief This function resets the setting of deep sleep.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+sbi_reset_deepsleep_wakeup(wlan_private * priv)
+{
+    struct sdio_mmc_card *card = priv->wlan_dev.card;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+
+	if (priv->adapter->fwWakeupMethod == WAKEUP_FW_THRU_GPIO) {
+		GPIO_PORT_TO_HIGH();
+	} else {
+		sdio_claim_host(card->func);
+		ret = sbi_write_ioreg(priv, CONFIGURATION_REG, 0);
+		sdio_release_host(card->func);
+	}
+
+
+    LEAVE();
+
+    return ret;
+}
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_sdio.h b/drivers/net/wireless/8688_wlan/wlan/wlan_sdio.h
new file mode 100755
index 0000000..ed8cb35
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_sdio.h
@@ -0,0 +1,206 @@
+/** @file wlan_sdio.h
+ *  @brief This file contains SDIO IF (interface) module
+ *  related macros, enum, and structure.
+ * 
+ * (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/****************************************************
+Change log:
+	10/12/05: add Doxygen format comments 
+****************************************************/
+
+#ifndef	_WLAN_SDIO_H
+#define	_WLAN_SDIO_H
+#include	<linux/mmc/sdio.h>
+#include	<linux/mmc/sdio_ids.h>
+#include	<linux/mmc/sdio_func.h>
+#include	<linux/mmc/card.h>
+
+#include	<wlan_headers.h>
+
+/** SDIO Function */
+#define SDIO_FUNC(x)			(x)
+/** SDIO Function 0 */
+#define SDIO_FUNC0			SDIO_FUNC(0)
+/** SDIO Function 1 */
+#define SDIO_FUNC1			SDIO_FUNC(1)
+
+//#include	<sdio.h>
+
+/** SD BUS width = 1 */
+#define SD_BUS_WIDTH_1			0x00
+/** SD BUS width = 4 */
+#define SD_BUS_WIDTH_4			0x02
+/** SD BUS width mask */
+#define SD_BUS_WIDTH_MASK		0x03
+/** Asynchronous interrupt mode */
+#define ASYNC_INT_MODE			0x20
+
+/* Host Control Registers */
+/** Host Control Registers : I/O port 0 */
+#define IO_PORT_0_REG			0x00
+/** Host Control Registers : I/O port 1 */
+#define IO_PORT_1_REG			0x01
+/** Host Control Registers : I/O port 2 */
+#define IO_PORT_2_REG			0x02
+/** Host Control Registers : Configuration */
+#define CONFIGURATION_REG		0x03
+/** Host Control Registers : Host without Command 53 finish host */
+#define HOST_WO_CMD53_FINISH_HOST	(0x1U << 2)
+/** Host Control Registers : Host power up */
+#define HOST_POWER_UP			(0x1U << 1)
+/** Host Control Registers : Host power down */
+#define HOST_POWER_DOWN			(0x1U << 0)
+/** Host Control Registers : Host interrupt mask */
+#define HOST_INT_MASK_REG		0x04
+/** Host Control Registers : Upload host interrupt mask */
+#define UP_LD_HOST_INT_MASK		(0x1U)
+/** Host Control Registers : Download host interrupt mask */
+#define DN_LD_HOST_INT_MASK		(0x2U)
+/** Host Control Registers : Host interrupt status */
+#define HOST_INTSTATUS_REG		0x05
+/** Host Control Registers : Upload host interrupt status */
+#define UP_LD_HOST_INT_STATUS		(0x1U)
+/** Host Control Registers : Download host interrupt status */
+#define DN_LD_HOST_INT_STATUS		(0x2U)
+/** Host Control Registers : Host interrupt RSR */
+#define HOST_INT_RSR_REG		0x06
+/** Host Control Registers : Upload host interrupt RSR */
+#define UP_LD_HOST_INT_RSR		(0x1U)
+/** Host Control Registers : Host interrupt status */
+#define HOST_INT_STATUS_REG		0x07
+/** Host Control Registers : Upload CRC error */
+#define UP_LD_CRC_ERR			(0x1U << 2)
+/** Host Control Registers : Upload restart */
+#define UP_LD_RESTART              	(0x1U << 1)
+/** Host Control Registers : Download restart */
+#define DN_LD_RESTART              	(0x1U << 0)
+
+/* Card Control Registers */
+/** Card Control Registers : Read SQ base address A0 register */
+#define SQ_READ_BASE_ADDRESS_A0_REG  	0x10
+/** Card Control Registers : Read SQ base address A1 register */
+#define SQ_READ_BASE_ADDRESS_A1_REG  	0x11
+/** Card Control Registers : Read SQ base address A2 register */
+#define SQ_READ_BASE_ADDRESS_A2_REG  	0x12
+/** Card Control Registers : Read SQ base address A3 register */
+#define SQ_READ_BASE_ADDRESS_A3_REG  	0x13
+/** Card Control Registers : Read SQ base address B0 register */
+#define SQ_READ_BASE_ADDRESS_B0_REG  	0x14
+/** Card Control Registers : Read SQ base address B1 register */
+#define SQ_READ_BASE_ADDRESS_B1_REG  	0x15
+/** Card Control Registers : Read SQ base address B2 register */
+#define SQ_READ_BASE_ADDRESS_B2_REG  	0x16
+/** Card Control Registers : Read SQ base address B3 register */
+#define SQ_READ_BASE_ADDRESS_B3_REG  	0x17
+/** Card Control Registers : Card status register */
+#define CARD_STATUS_REG              	0x20
+/** Card Control Registers : Card I/O ready */
+#define CARD_IO_READY              	(0x1U << 3)
+/** Card Control Registers : CIS card ready */
+#define CIS_CARD_RDY                 	(0x1U << 2)
+/** Card Control Registers : Upload card ready */
+#define UP_LD_CARD_RDY               	(0x1U << 1)
+/** Card Control Registers : Download card ready */
+#define DN_LD_CARD_RDY               	(0x1U << 0)
+/** Card Control Registers : Host interrupt mask register */
+#define HOST_INTERRUPT_MASK_REG      	0x24
+/** Card Control Registers : Host power interrupt mask */
+#define HOST_POWER_INT_MASK          	(0x1U << 3)
+/** Card Control Registers : Abort card interrupt mask */
+#define ABORT_CARD_INT_MASK          	(0x1U << 2)
+/** Card Control Registers : Upload card interrupt mask */
+#define UP_LD_CARD_INT_MASK          	(0x1U << 1)
+/** Card Control Registers : Download card interrupt mask */
+#define DN_LD_CARD_INT_MASK          	(0x1U << 0)
+/** Card Control Registers : Card interrupt status register */
+#define CARD_INTERRUPT_STATUS_REG    	0x28
+/** Card Control Registers : Power up interrupt */
+#define POWER_UP_INT                 	(0x1U << 4)
+/** Card Control Registers : Power down interrupt */
+#define POWER_DOWN_INT               	(0x1U << 3)
+/** Card Control Registers : Card interrupt RSR register */
+#define CARD_INTERRUPT_RSR_REG       	0x2c
+/** Card Control Registers : Power up RSR */
+#define POWER_UP_RSR                 	(0x1U << 4)
+/** Card Control Registers : Power down RSR */
+#define POWER_DOWN_RSR               	(0x1U << 3)
+/** Card Control Registers : Debug 0 register */
+#define DEBUG_0_REG                  	0x30
+/** Card Control Registers : SD test BUS 0 */
+#define SD_TESTBUS0                  	(0x1U)
+/** Card Control Registers : Debug 1 register */
+#define DEBUG_1_REG                  	0x31
+/** Card Control Registers : SD test BUS 1 */
+#define SD_TESTBUS1                  	(0x1U)
+/** Card Control Registers : Debug 2 register */
+#define DEBUG_2_REG                  	0x32
+/** Card Control Registers : SD test BUS 2 */
+#define SD_TESTBUS2                  	(0x1U)
+/** Card Control Registers : Debug 3 register */
+#define DEBUG_3_REG                  	0x33
+/** Card Control Registers : SD test BUS 3 */
+#define SD_TESTBUS3                  	(0x1U)
+/** Card Control Registers : Card OCR 0 register */
+#define CARD_OCR_0_REG               	0x34
+/** Card Control Registers : Card OCR 1 register */
+#define CARD_OCR_1_REG               	0x35
+/** Card Control Registers : Card OCR 3 register */
+#define CARD_OCR_3_REG               	0x36
+/** Card Control Registers : Card config register */
+#define CARD_CONFIG_REG              	0x38
+/** Card Control Registers : Card revision register */
+#define CARD_REVISION_REG            	0x3c
+/** Card Control Registers : Command 53 finish G BUS */
+#define CMD53_FINISH_GBUS            	(0x1U << 1)
+/** Card Control Registers : SD negative edge */
+#define SD_NEG_EDGE                  	(0x1U << 0)
+
+/* Special registers in function 0 of the SDxx card */
+/** Special register in function 0 of the SDxxx card : Scratch 0 */
+#define	SCRATCH_0_REG			0x80fe
+/** Special register in function 0 of the SDxxx card : Scratch 1 */
+#define	SCRATCH_1_REG			0x80ff
+/** Host F1 read base 0 */
+#define HOST_F1_RD_BASE_0		0x0010
+/** Host F1 read base 1 */
+#define HOST_F1_RD_BASE_1		0x0011
+/** Host F1 card ready */
+#define HOST_F1_CARD_RDY		0x0020
+
+/** Chip Id Register 0 */
+#define CARD_CHIP_ID_0_REG		0x801c
+/** Chip Id Register 1 */
+#define CARD_CHIP_ID_1_REG		0x801d
+/** Firmware status 0 register */
+#define CARD_FW_STATUS0_REG		0x40
+/** Firmware status 1 register */
+#define CARD_FW_STATUS1_REG		0x41
+/** Rx length register */
+#define CARD_RX_LEN_REG			0x42
+/** Rx unit register */
+#define CARD_RX_UNIT_REG		0x43
+
+struct sdio_mmc_card
+{
+	struct sdio_func *func;
+        wlan_private *priv;
+};
+
+
+int sbi_read_iomem(wlan_private *priv, void *buf, unsigned int reg_addr, int cnt);
+#endif /* _WLAN_SDIO_H */
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_tx.c b/drivers/net/wireless/8688_wlan/wlan/wlan_tx.c
new file mode 100755
index 0000000..1439978
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_tx.c
@@ -0,0 +1,317 @@
+/** @file wlan_tx.c
+  * @brief This file contains the handling of TX in wlan
+  * driver.
+  *    
+  *  (c) Copyright © 2003-2006, Marvell International Ltd.  
+  *   
+  *  This software file (the "File") is distributed by Marvell International 
+  *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  *  (the "License").  You may use, redistribute and/or modify this File in 
+  *  accordance with the terms and conditions of the License, a copy of which 
+  *  is available along with the File in the gpl.txt file or by writing to 
+  *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  *  this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	09/28/05: Add Doxygen format comments
+	12/13/05: Add Proprietary periodic sleep support
+	01/05/06: Add kernel 2.6.x support	
+	04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+********************************************************/
+
+#include	"wlan_headers.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function processes a single packet and sends
+ *  to IF layer
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @param skb     A pointer to skb which includes TX packet
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+static int
+wlan_send_single_packet(wlan_private * priv, struct sk_buff *skb)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    TxPD *pLocalTxPD;
+    u8 *headptr;
+    struct sk_buff *newskb;
+    int newheadlen;
+
+    ENTER();
+
+    ASSERT(skb);
+
+    if (!skb->len || (skb->len > MRVDRV_ETH_TX_PACKET_BUFFER_SIZE)) {
+        PRINTM(ERROR, "Tx Error: Bad skb length %d : %d\n",
+               skb->len, MRVDRV_ETH_TX_PACKET_BUFFER_SIZE);
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (skb_headroom(skb) < (sizeof(TxPD) + SDIO_HEADER_LEN)) {
+        newheadlen = sizeof(TxPD) + SDIO_HEADER_LEN;
+        PRINTM(WARN, "Tx: Insufficient skb headroom %d\n", skb_headroom(skb));
+
+        /* Insufficient skb headroom - allocate a new skb */
+        newskb = skb_realloc_headroom(skb, newheadlen);
+        if (unlikely(newskb == NULL)) {
+            PRINTM(ERROR, "Tx: Cannot allocate skb\n");
+            ret = WLAN_STATUS_FAILURE;
+            goto done;
+        }
+        kfree_skb(skb);
+        skb = newskb;
+
+        Adapter->CurrentTxSkb = skb;
+        PRINTM(INFO, "new skb headroom %d\n", skb_headroom(skb));
+    }
+
+    /* The skb->head is always 16-byte aligned */
+    headptr = skb->head;
+    pLocalTxPD = (TxPD *) (headptr + SDIO_HEADER_LEN);
+
+    memset(pLocalTxPD, 0, sizeof(TxPD));
+
+    pLocalTxPD->TxPacketLength = skb->len;
+
+    /* 
+     * original skb->priority has been overwritten 
+     * by wmm_map_and_add_skb()
+     */
+    pLocalTxPD->Priority = (u8) skb->priority;
+    pLocalTxPD->PktDelay_2ms = wmm_compute_driver_packet_delay(priv, skb);
+
+    if (pLocalTxPD->Priority < NELEMENTS(Adapter->wmm.userPriPktTxCtrl)) {
+        /* 
+         * Set the priority specific TxControl field, setting of 0 will
+         *   cause the default value to be used later in this function
+         */
+        pLocalTxPD->TxControl
+            = Adapter->wmm.userPriPktTxCtrl[pLocalTxPD->Priority];
+    }
+
+    if (Adapter->PSState != PS_STATE_FULL_POWER) {
+        if (TRUE == wlan_check_last_packet_indication(priv)) {
+            Adapter->TxLockFlag = TRUE;
+            pLocalTxPD->Flags = MRVDRV_TxPD_POWER_MGMT_LAST_PACKET;
+        }
+    }
+
+    /* offset of actual data */
+    pLocalTxPD->TxPacketLocation = (long) skb->data - (long) pLocalTxPD;
+
+    if (pLocalTxPD->TxControl == 0) {
+        /* TxCtrl set by user or default */
+        pLocalTxPD->TxControl = Adapter->PktTxCtrl;
+    }
+
+    endian_convert_TxPD(pLocalTxPD);
+
+    memcpy((u8 *) pLocalTxPD->TxDestAddr, skb->data, ETH_ALEN);
+
+    ret = sbi_host_to_card(priv, MV_TYPE_DAT, headptr,
+                           skb->len + ((long) skb->data - (long) pLocalTxPD));
+    if (ret) {
+        PRINTM(ERROR,
+               "wlan_send_single_packet Error: sbi_host_to_card failed: 0x%X\n",
+               ret);
+        Adapter->dbg.num_tx_host_to_card_failure++;
+        goto done;
+    }
+
+    PRINTM(DATA, "Data => FW\n");
+    DBG_HEXDUMP(DAT_D, "Tx", headptr,
+                MIN(skb->len + sizeof(TxPD), MAX_DATA_DUMP_LEN));
+
+    wmm_process_fw_iface_tx_xfer_start(priv);
+
+  done:
+    if (!ret) {
+        priv->stats.tx_packets++;
+        priv->stats.tx_bytes += skb->len;
+    } else {
+        priv->stats.tx_dropped++;
+        priv->stats.tx_errors++;
+    }
+
+    /* need to be freed in all cases */
+    os_free_tx_packet(priv);
+
+    LEAVE();
+    return ret;
+}
+
+/********************************************************
+		Global functions
+********************************************************/
+
+/** 
+ *  @brief This function checks the conditions and sends packet to IF
+ *  layer if everything is ok.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @return 	   n/a
+ */
+void
+wlan_process_tx(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    unsigned long driver_flags;
+
+    ENTER();
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    if (priv->wlan_dev.dnld_sent) {
+        PRINTM(MSG, "TX Error: dnld_sent = %d, not sending\n",
+               priv->wlan_dev.dnld_sent);
+        goto done;
+    }
+
+    wlan_send_single_packet(priv, Adapter->CurrentTxSkb);
+    OS_INT_DISABLE(priv, driver_flags);
+    priv->adapter->HisRegCpy &= ~HIS_TxDnLdRdy;
+    OS_INT_RESTORE(priv, driver_flags);
+
+  done:
+    LEAVE();
+}
+
+/** 
+ *  @brief This function queues the packet received from
+ *  kernel/upper layer and wake up the main thread to handle it.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+  * @param skb     A pointer to skb which includes TX packet
+ *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
+ */
+int
+wlan_tx_packet(wlan_private * priv, struct sk_buff *skb)
+{
+    ulong flags;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    HEXDUMP("TX Data", skb->data, MIN(skb->len, 100));
+
+    spin_lock_irqsave(&Adapter->CurrentTxLock, flags);
+
+    wmm_map_and_add_skb(priv, skb);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief This function tells firmware to send a NULL data packet.
+ *  
+ *  @param priv     A pointer to wlan_private structure
+ *  @param flags    Trasnit Pkt Flags
+ *  @return 	    n/a
+ */
+int
+wlan_send_null_packet(wlan_private * priv, u8 flags)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    TxPD *ptxpd;
+/* sizeof(TxPD) + Interface specific header */
+#define NULL_PACKET_HDR 64
+    u8 tmpbuf[NULL_PACKET_HDR] = { 0 };
+    u8 *ptr = tmpbuf;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->SurpriseRemoved == TRUE) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    ptr += SDIO_HEADER_LEN;
+    ptxpd = (TxPD *) ptr;
+
+    ptxpd->TxControl = Adapter->PktTxCtrl;
+    ptxpd->Flags = flags;
+    ptxpd->Priority = WMM_HIGHEST_PRIORITY;
+    ptxpd->TxPacketLocation = sizeof(TxPD);
+
+    endian_convert_TxPD(ptxpd);
+
+    ret = sbi_host_to_card(priv, MV_TYPE_DAT, tmpbuf, sizeof(TxPD));
+
+    if (ret != 0) {
+        PRINTM(ERROR, "TX Error: wlan_send_null_packet failed!\n");
+        Adapter->dbg.num_tx_host_to_card_failure++;
+        goto done;
+    }
+    PRINTM(DATA, "Null data => FW\n");
+    DBG_HEXDUMP(DAT_D, "Tx", ptr, sizeof(TxPD));
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function check if we need send last packet indication.
+ *  
+ *  @param priv     A pointer to wlan_private structure
+ *
+ *  @return 	   TRUE or FALSE
+ */
+BOOLEAN
+wlan_check_last_packet_indication(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    BOOLEAN ret = FALSE;
+    BOOLEAN prop_ps = TRUE;
+
+    ENTER();
+
+    if (Adapter->sleep_period.period == 0 || Adapter->gen_null_pkg == FALSE     /* for UPSD certification tests */
+        ) {
+        LEAVE();
+        return ret;
+    }
+
+    if (wmm_lists_empty(priv)) {
+        if (((Adapter->CurBssParams.wmm_uapsd_enabled == TRUE)
+             && (Adapter->wmm.qosinfo != 0)) || prop_ps) {
+            ret = TRUE;
+        }
+    }
+
+    LEAVE();
+    return ret;
+}
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_wext.c b/drivers/net/wireless/8688_wlan/wlan/wlan_wext.c
new file mode 100755
index 0000000..083de6e
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_wext.c
@@ -0,0 +1,8964 @@
+/** @file  wlan_wext.c 
+  * @brief This file contains ioctl functions
+  * 
+  * (c) Copyright © 2003-2007, Marvell International Ltd. 
+  *
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/********************************************************
+Change log:
+	10/10/05: Add Doxygen format comments
+	12/23/05: Modify FindBSSIDInList to search entire table for
+	          duplicate BSSIDs when earlier matches are not compatible
+	12/26/05: Remove errant memcpy in wlanidle_off; overwriting stack space
+	01/05/06: Add kernel 2.6.x support	
+	01/11/06: Conditionalize new scan/join functions.
+	          Update statics/externs.  Move forward decl. from wlan_decl.h
+	04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+	04/10/06: Add hostcmd generic API
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	05/04/06: Add IBSS coalescing related new iwpriv command
+	08/29/06: Add ledgpio private command
+	10/23/06: Validate setbcnavg/setdataavg command parameters and
+	          return error if out of range
+********************************************************/
+
+#include	"wlan_headers.h"
+
+/** Get log buffer size */
+#define GETLOG_BUFSIZE  512
+
+/** Maximum scan cell size */
+#define MAX_SCAN_CELL_SIZE      (IW_EV_ADDR_LEN + \
+				MRVDRV_MAX_SSID_LENGTH + \
+				IW_EV_UINT_LEN + IW_EV_FREQ_LEN + \
+				IW_EV_QUAL_LEN + MRVDRV_MAX_SSID_LENGTH + \
+				IW_EV_PARAM_LEN + 40)   /* 40 for WPAIE */
+
+typedef struct _ioctl_cmd
+{
+    /** IOCTL command number */
+    int cmd;
+    /** IOCTL subcommand number */
+    int subcmd;
+    /** Size fix flag */
+    BOOLEAN fixsize;
+} ioctl_cmd;
+
+static ioctl_cmd Commands_Allowed_In_DeepSleep[] = {
+    {.cmd = WLANDEEPSLEEP,.subcmd = 0,.fixsize = FALSE},
+    {.cmd = WLAN_SETONEINT_GETWORDCHAR,.subcmd = WLANVERSION,.fixsize =
+     FALSE},
+    {.cmd = WLAN_SETINT_GETINT,.subcmd = WLANSDIOCLOCK,.fixsize = TRUE},
+    {.cmd = WLAN_SET_GET_2K,.subcmd = WLAN_GET_CFP_TABLE,.fixsize = FALSE},
+#ifdef DEBUG_LEVEL1
+    {.cmd = WLAN_SET_GET_SIXTEEN_INT,.subcmd = WLAN_DRV_DBG,.fixsize = FALSE},
+#endif
+};
+
+static ioctl_cmd Commands_Allowed_In_HostSleep[] = {
+    {.cmd = WLAN_SETONEINT_GETWORDCHAR,.subcmd = WLANVERSION,.fixsize =
+     FALSE},
+    {.cmd = WLANDEEPSLEEP,.subcmd = 1,.fixsize = FALSE},
+    {.cmd = WLANDEEPSLEEP,.subcmd = 0,.fixsize = FALSE},
+    {.cmd = WLAN_SETINT_GETINT,.subcmd = WLANSDIOCLOCK,.fixsize = TRUE},
+    {.cmd = WLAN_SET_GET_2K,.subcmd = WLAN_GET_CFP_TABLE,.fixsize = FALSE},
+#ifdef DEBUG_LEVEL1
+    {.cmd = WLAN_SET_GET_SIXTEEN_INT,.subcmd = WLAN_DRV_DBG,.fixsize = FALSE},
+#endif
+};
+
+static ioctl_cmd Commands_DisAllowed_In_AutoDeepSleep[] = {
+    {.cmd = WLANDEEPSLEEP,.subcmd = 0,.fixsize = FALSE},
+    {.cmd = WLANCMD52RDWR,.subcmd = 0,.fixsize = FALSE},
+    {.cmd = WLANCMD53RDWR,.subcmd = 0,.fixsize = FALSE},
+    {.cmd = WLANCISDUMP,.subcmd = 0,.fixsize = FALSE},
+};
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/********************************************************
+		Global Variables
+********************************************************/
+#ifdef DEBUG_LEVEL1
+#ifdef DEBUG_LEVEL2
+#define	DEFAULT_DEBUG_MASK	(0xffffffff & ~DBG_EVENT)
+#else
+#define DEFAULT_DEBUG_MASK	(DBG_MSG | DBG_FATAL | DBG_ERROR)
+#endif
+u32 drvdbg = DEFAULT_DEBUG_MASK;
+u32 ifdbg = 0;
+#endif
+
+/********************************************************
+		Local Functions
+********************************************************/
+static int wlan_set_rate(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_param *vwrq, char *extra);
+static int wlan_get_rate(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_param *vwrq, char *extra);
+
+static int wlan_get_essid(struct net_device *dev,
+                          struct iw_request_info *info, struct iw_point *dwrq,
+                          char *extra);
+
+static int wlan_set_freq(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_freq *fwrq, char *extra);
+static int wlan_get_freq(struct net_device *dev, struct iw_request_info *info,
+                         struct iw_freq *fwrq, char *extra);
+
+static int wlan_set_mode(struct net_device *dev, struct iw_request_info *info,
+                         u32 * uwrq, char *extra);
+static int wlan_get_mode(struct net_device *dev, struct iw_request_info *info,
+                         u32 * uwrq, char *extra);
+
+static int wlan_set_encode(struct net_device *dev,
+                           struct iw_request_info *info,
+                           struct iw_point *dwrq, char *extra);
+static int wlan_get_encode(struct net_device *dev,
+                           struct iw_request_info *info,
+                           struct iw_point *dwrq, u8 * extra);
+
+static int wlan_set_txpow(struct net_device *dev,
+                          struct iw_request_info *info, struct iw_param *vwrq,
+                          char *extra);
+static int wlan_get_txpow(struct net_device *dev,
+                          struct iw_request_info *info, struct iw_param *vwrq,
+                          char *extra);
+
+static int wlan_set_coalescing_ioctl(wlan_private * priv, struct iwreq *wrq);
+
+/** 
+ *  @brief This function checks if the commans is allowed
+ *  in deepsleep/hostsleep mode or not.
+ * 
+ *  @param req	       A pointer to ifreq structure 
+ *  @param cmd         the command ID
+ *  @return 	   TRUE or FALSE
+ */
+static BOOLEAN
+wlan_is_cmd_allowed_in_ds_hs(struct ifreq *req, int cmd,
+                             ioctl_cmd * allowed_cmds, int count)
+{
+    int subcmd = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+    int i;
+
+    ENTER();
+
+    for (i = 0; i < count; i++) {
+        if (cmd == allowed_cmds[i].cmd) {
+            if (allowed_cmds[i].subcmd == 0) {
+                LEAVE();
+                return TRUE;
+            }
+            if (allowed_cmds[i].fixsize == TRUE)
+                subcmd = (int) req->ifr_data;
+            else
+                subcmd = wrq->u.data.flags;
+            if (allowed_cmds[i].subcmd == subcmd) {
+                LEAVE();
+                return TRUE;
+            }
+        }
+    }
+
+    LEAVE();
+
+    return FALSE;
+}
+
+/** 
+ *  @brief This function checks if the commans is disallowed
+ *  in auto deepsleep mode.
+ * 
+ *  @param req		A pointer to ifreq structure 
+ *  @param cmd		Command ID
+ *  @return   		TRUE or FALSE
+ */
+static BOOLEAN
+wlan_is_cmd_disallowed_in_ads(struct ifreq *req, int cmd,
+                              ioctl_cmd * disallowed_cmds, int count)
+{
+    int subcmd = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+    int i;
+
+    ENTER();
+
+    for (i = 0; i < count; i++) {
+        if (cmd == disallowed_cmds[i].cmd) {
+            if (disallowed_cmds[i].subcmd == 0) {
+                LEAVE();
+                return TRUE;
+            }
+            if (disallowed_cmds[i].fixsize == TRUE)
+                subcmd = (int) req->ifr_data;
+            else
+                subcmd = wrq->u.data.flags;
+            if (disallowed_cmds[i].subcmd == subcmd) {
+                LEAVE();
+                return TRUE;
+            }
+        }
+    }
+
+    LEAVE();
+    return FALSE;
+}
+
+/** 
+ *  @brief This function checks if the command is allowed.
+ * 
+ *  @param priv		A pointer to wlan_private structure
+ *  @return		TRUE or FALSE
+ */
+BOOLEAN
+wlan_is_cmd_allowed(wlan_private * priv)
+{
+    BOOLEAN ret = TRUE;
+
+    ENTER();
+
+    if (priv->adapter->bHostSleepConfigured) {
+        PRINTM(INFO, "IOCTLS called when WLAN access is blocked\n");
+        ret = FALSE;
+    }
+    if (!priv->adapter->IsAutoDeepSleepEnabled) {
+        if ((priv->adapter->IsDeepSleep == TRUE)) {
+            PRINTM(INFO, "IOCTLS called when station is in DeepSleep\n");
+            ret = FALSE;
+        }
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief Find a character in a string.
+ *   
+ *  @param s	   A pointer to string
+ *  @param c	   Character to be located 
+ *  @param n       the length of string
+ *  @return 	   A pointer to the first occurrence of c in string, or NULL if c is not found.
+ */
+static void *
+wlan_memchr(void *s, int c, int n)
+{
+    const u8 *p = s;
+
+    ENTER();
+
+    while (n-- != 0) {
+        if ((u8) c == *p++) {
+            LEAVE();
+            return (void *) (p - 1);
+        }
+    }
+
+    LEAVE();
+
+    return NULL;
+}
+
+#if WIRELESS_EXT > 14
+/** 
+ *  @brief This function sends customized event to application.
+ *  
+ *  @param priv    A pointer to wlan_private structure
+ *  @para str	   A pointer to event string
+ *  @return 	   n/a
+ */
+void
+send_iwevcustom_event(wlan_private * priv, s8 * str)
+{
+    union iwreq_data iwrq;
+    u8 buf[50];
+
+    ENTER();
+
+    memset(&iwrq, 0, sizeof(union iwreq_data));
+    memset(buf, 0, sizeof(buf));
+
+    snprintf(buf, sizeof(buf) - 1, "%s", str);
+
+    iwrq.data.pointer = buf;
+    iwrq.data.length = strlen(buf) + 1 + IW_EV_LCP_LEN;
+
+    /* Send Event to upper layer */
+    wireless_send_event(priv->wlan_dev.netdev, IWEVCUSTOM, &iwrq, buf);
+    PRINTM(INFO, "Wireless event %s is sent to app\n", str);
+
+    LEAVE();
+    return;
+}
+#endif
+
+/** 
+ *  @brief get the channel frequency power info with specific channel
+ *   
+ *  @param band	 		it can be BAND_A, BAND_G or BAND_B
+ *  @param channel       	the channel for looking	
+ *  @param region_channel 	A pointer to REGION_CHANNEL structure
+ *  @return 	   			A pointer to CHANNEL_FREQ_POWER structure or NULL if not find.
+ */
+
+CHANNEL_FREQ_POWER *
+get_cfp_by_band_and_channel(u8 band, u16 channel,
+                            REGION_CHANNEL * region_channnel)
+{
+    REGION_CHANNEL *rc;
+    CHANNEL_FREQ_POWER *cfp = NULL;
+    int i, j;
+
+    for (j = 0; !cfp && (j < MAX_REGION_CHANNEL_NUM); j++) {
+        rc = &region_channnel[j];
+
+        if (!rc->Valid || !rc->CFP)
+            continue;
+        switch (rc->Band) {
+        case BAND_A:
+            switch (band) {
+            case BAND_A:       // matching BAND_A
+                break;
+            default:
+                continue;
+            }
+            break;
+        case BAND_B:
+        case BAND_G:
+            switch (band) {
+            case BAND_B:       //matching BAND_B/G
+            case BAND_G:
+                break;
+            default:
+                continue;
+            }
+            break;
+        default:
+            continue;
+        }
+        if (channel == FIRST_VALID_CHANNEL)
+            cfp = &rc->CFP[0];
+        else {
+            for (i = 0; i < rc->NrCFP; i++) {
+                if (rc->CFP[i].Channel == channel) {
+                    cfp = &rc->CFP[i];
+                    break;
+                }
+            }
+        }
+    }
+
+    if (!cfp && channel)
+        PRINTM(INFO, "get_cfp_by_band_and_channel(): cannot find "
+               "cfp by band %d & channel %d\n", band, channel);
+
+    LEAVE();
+    return cfp;
+}
+
+/** 
+ *  @brief Find the channel frequency power info with specific channel
+ *   
+ *  @param adapter 	A pointer to wlan_adapter structure
+ *  @param band		it can be BAND_A, BAND_G or BAND_B
+ *  @param channel      the channel for looking	
+ *  @return 	   	A pointer to CHANNEL_FREQ_POWER structure or NULL if not find.
+ */
+CHANNEL_FREQ_POWER *
+find_cfp_by_band_and_channel(wlan_adapter * adapter, u8 band, u16 channel)
+{
+    CHANNEL_FREQ_POWER *cfp = NULL;
+
+    ENTER();
+
+    if (adapter->State11D.Enable11D == ENABLE_11D)
+        cfp =
+            get_cfp_by_band_and_channel(band, channel,
+                                        adapter->universal_channel);
+    else
+        cfp =
+            get_cfp_by_band_and_channel(band, channel,
+                                        adapter->region_channel);
+
+    return cfp;
+}
+
+/** 
+ *  @brief Find the channel frequency power info with specific frequency
+ *   
+ *  @param adapter  A pointer to wlan_adapter structure
+ *  @param band     it can be BAND_A, BAND_G or BAND_B
+ *  @param freq     the frequency for looking   
+ *  @return         Pointer to CHANNEL_FREQ_POWER structure; NULL if not found
+ */
+static CHANNEL_FREQ_POWER *
+find_cfp_by_band_and_freq(wlan_adapter * adapter, u8 band, u32 freq)
+{
+    CHANNEL_FREQ_POWER *cfp = NULL;
+    REGION_CHANNEL *rc;
+    int count = sizeof(adapter->region_channel) /
+        sizeof(adapter->region_channel[0]);
+    int i, j;
+
+    ENTER();
+
+    for (j = 0; !cfp && (j < count); j++) {
+        rc = &adapter->region_channel[j];
+
+        if (adapter->State11D.Enable11D == ENABLE_11D) {
+            rc = &adapter->universal_channel[j];
+        }
+
+        if (!rc->Valid || !rc->CFP)
+            continue;
+        switch (rc->Band) {
+        case BAND_A:
+            switch (band) {
+            case BAND_A:       // matching BAND_A
+                break;
+            default:
+                continue;
+            }
+            break;
+        case BAND_B:
+        case BAND_G:
+            switch (band) {
+            case BAND_B:
+            case BAND_G:
+                break;
+            default:
+                continue;
+            }
+            break;
+        default:
+            continue;
+        }
+        for (i = 0; i < rc->NrCFP; i++) {
+            if (rc->CFP[i].Freq == freq) {
+                cfp = &rc->CFP[i];
+                break;
+            }
+        }
+    }
+
+    if (!cfp && freq)
+        PRINTM(INFO, "find_cfp_by_band_and_freql(): cannot find cfp by "
+               "band %d & freq %d\n", band, freq);
+
+    LEAVE();
+
+    return cfp;
+}
+
+#ifdef MFG_CMD_SUPPORT
+/** 
+ *  @brief Manufacturing command ioctl function
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq 		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+wlan_mfg_command(wlan_private * priv, struct iwreq *wrq)
+{
+    HostCmd_DS_GEN *pCmdPtr;
+    u8 *mfg_cmd;
+    u16 mfg_cmd_len;
+    int ret;
+
+    ENTER();
+
+    /* allocate MFG command buffer */
+    if (!(mfg_cmd = kmalloc(MRVDRV_SIZE_OF_CMD_BUFFER, GFP_KERNEL))) {
+        PRINTM(INFO, "allocate MFG command buffer failed!\n");
+        LEAVE();
+        return -ENOMEM;
+    }
+
+    /* get MFG command header */
+    if (copy_from_user(mfg_cmd, wrq->u.data.pointer, sizeof(HostCmd_DS_GEN))) {
+        PRINTM(INFO, "copy from user failed: MFG command header\n");
+        ret = -EFAULT;
+        goto mfg_exit;
+    }
+
+    /* get the command size */
+    pCmdPtr = (HostCmd_DS_GEN *) mfg_cmd;
+    mfg_cmd_len = pCmdPtr->Size;
+    PRINTM(INFO, "MFG command len = %d\n", mfg_cmd_len);
+
+    if (mfg_cmd_len > MRVDRV_SIZE_OF_CMD_BUFFER) {
+        ret = -EINVAL;
+        goto mfg_exit;
+    }
+
+    /* get the whole command from user */
+    if (copy_from_user(mfg_cmd, wrq->u.data.pointer, mfg_cmd_len)) {
+        PRINTM(INFO, "copy from user failed: MFG command\n");
+        ret = -EFAULT;
+        goto mfg_exit;
+    }
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_MFG_COMMAND,
+                           0, HostCmd_OPTION_WAITFORRSP, 0, mfg_cmd);
+
+    /* copy the response back to user */
+    if (!ret && pCmdPtr->Size) {
+        mfg_cmd_len = MIN(pCmdPtr->Size, mfg_cmd_len);
+        if (copy_to_user(wrq->u.data.pointer, mfg_cmd, mfg_cmd_len)) {
+            PRINTM(INFO, "copy to user failed: MFG command\n");
+            ret = -EFAULT;
+        }
+        wrq->u.data.length = mfg_cmd_len;
+    }
+
+  mfg_exit:
+    kfree(mfg_cmd);
+    LEAVE();
+    return ret;
+}
+#endif
+
+/** 
+ *  @brief Check if Rate Auto
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @return 	   		TRUE/FALSE
+ */
+BOOLEAN
+wlan_is_rate_auto(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i;
+    int ratenum = 0;
+    int bitsize = 0;
+
+    ENTER();
+
+    bitsize = sizeof(Adapter->RateBitmap) * 8;
+    for (i = 0; i < bitsize; i++) {
+        if (Adapter->RateBitmap & (1 << i))
+            ratenum++;
+        if (ratenum > 1)
+            break;
+    }
+
+    LEAVE();
+
+    if (ratenum > 1)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+/** 
+ *  @brief Covert Rate Bitmap to Rate index
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @return 	   		TRUE/FALSE
+ */
+int
+wlan_get_rate_index(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int bitsize = sizeof(Adapter->RateBitmap) * 8;
+    int i;
+
+    ENTER();
+
+    for (i = 0; i < bitsize; i++) {
+        if (Adapter->RateBitmap & (1 << i)) {
+            LEAVE();
+            return i;
+        }
+    }
+
+    LEAVE();
+
+    return 0;
+}
+
+/** 
+ *  @brief Update Current Channel 
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+static int
+wlan_update_current_chan(wlan_private * priv)
+{
+    int ret;
+
+    /*
+     ** the channel in f/w could be out of sync, get the current channel
+     */
+    ENTER();
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_RF_CHANNEL,
+                           HostCmd_OPT_802_11_RF_CHANNEL_GET,
+                           HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    PRINTM(INFO, "Current Channel = %d\n",
+           priv->adapter->CurBssParams.BSSDescriptor.Channel);
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief Set Current Channel 
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @param channel		The channel to be set. 
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+static int
+wlan_set_current_chan(wlan_private * priv, int channel)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+    PRINTM(INFO, "Set Channel = %d\n", channel);
+
+    /* 
+     **  Current channel is not set to AdhocChannel requested, set channel
+     */
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_RF_CHANNEL,
+                           HostCmd_OPT_802_11_RF_CHANNEL_SET,
+                           HostCmd_OPTION_WAITFORRSP, 0, &channel);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Change Adhoc Channel
+ *   
+ *  @param priv 		A pointer to wlan_private structure
+ *  @param channel		The channel to be set. 
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, WLAN_STATUS_FAILURE--fail
+ */
+static int
+wlan_change_adhoc_chan(wlan_private * priv, int channel)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+    Adapter->AdhocChannel = channel;
+
+    wlan_update_current_chan(priv);
+
+    if (Adapter->CurBssParams.BSSDescriptor.Channel == Adapter->AdhocChannel) {
+        /* AdhocChannel is set to the current Channel already */
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    PRINTM(INFO, "Updating Channel from %d to %d\n",
+           Adapter->CurBssParams.BSSDescriptor.Channel,
+           Adapter->AdhocChannel);
+
+    wlan_set_current_chan(priv, Adapter->AdhocChannel);
+
+    wlan_update_current_chan(priv);
+
+    if (Adapter->CurBssParams.BSSDescriptor.Channel != Adapter->AdhocChannel) {
+        PRINTM(INFO, "Failed to updated Channel to %d, channel = %d\n",
+               Adapter->AdhocChannel,
+               Adapter->CurBssParams.BSSDescriptor.Channel);
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        int i;
+        WLAN_802_11_SSID curAdhocSsid;
+
+        PRINTM(INFO, "Channel Changed while in an IBSS\n");
+
+        /* Copy the current ssid */
+        memcpy(&curAdhocSsid,
+               &Adapter->CurBssParams.BSSDescriptor.Ssid,
+               sizeof(WLAN_802_11_SSID));
+
+        /* Exit Adhoc mode */
+        PRINTM(INFO, "In wlan_change_adhoc_chan(): Sending Adhoc Stop\n");
+        ret = wlan_disconnect(priv);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+
+        /* Scan for the network */
+        wlan_cmd_specific_scan_ssid(priv, &curAdhocSsid);
+
+        // find out the BSSID that matches the current SSID 
+        i = wlan_find_ssid_in_list(Adapter, &curAdhocSsid, NULL,
+                                   Wlan802_11IBSS);
+
+        if (i >= 0) {
+            PRINTM(INFO, "SSID found at %d in List," "so join\n", i);
+            wlan_join_adhoc(priv, &Adapter->ScanTable[i]);
+        } else {
+            // else send START command
+            PRINTM(INFO, "SSID not found in list, "
+                   "so creating adhoc with ssid = %s\n", curAdhocSsid.Ssid);
+            wlan_start_adhoc(priv, &curAdhocSsid);
+        }                       // end of else (START command)
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set/Get WPA IE   
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param ie_data_ptr  A pointer to IE
+ *  @param ie_len       Length of the IE
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_wpa_ie_helper(wlan_private * priv, u8 * ie_data_ptr, u16 ie_len)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (ie_len) {
+        if (ie_len > sizeof(Adapter->Wpa_ie)) {
+            PRINTM(INFO, "failed to copy WPA IE, too big \n");
+            LEAVE();
+            return -EFAULT;
+        }
+        if (copy_from_user(Adapter->Wpa_ie, ie_data_ptr, ie_len)) {
+            PRINTM(INFO, "failed to copy WPA IE \n");
+            LEAVE();
+            return -EFAULT;
+        }
+        Adapter->Wpa_ie_len = ie_len;
+        PRINTM(INFO, "Set Wpa_ie_len=%d IE=%#x\n",
+               Adapter->Wpa_ie_len, Adapter->Wpa_ie[0]);
+        HEXDUMP("Wpa_ie", Adapter->Wpa_ie, Adapter->Wpa_ie_len);
+
+        if (Adapter->Wpa_ie[0] == WPA_IE) {
+            Adapter->SecInfo.WPAEnabled = TRUE;
+        } else if (Adapter->Wpa_ie[0] == RSN_IE) {
+            Adapter->SecInfo.WPA2Enabled = TRUE;
+        } else {
+            Adapter->SecInfo.WPAEnabled = FALSE;
+            Adapter->SecInfo.WPA2Enabled = FALSE;
+        }
+    } else {
+        memset(Adapter->Wpa_ie, 0, sizeof(Adapter->Wpa_ie));
+        Adapter->Wpa_ie_len = ie_len;
+        PRINTM(INFO, "Reset Wpa_ie_len=%d IE=%#x\n",
+               Adapter->Wpa_ie_len, Adapter->Wpa_ie[0]);
+        Adapter->SecInfo.WPAEnabled = FALSE;
+        Adapter->SecInfo.WPA2Enabled = FALSE;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set/Get WPA IE
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param req          A pointer to ifreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_wpa_ie_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    struct iwreq *wrq = (struct iwreq *) req;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+    ret = wlan_set_wpa_ie_helper(priv,
+                                 wrq->u.data.pointer, wrq->u.data.length);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set WPA key
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_encode_wpa(struct net_device *dev,
+                    struct iw_request_info *info,
+                    struct iw_point *dwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    WLAN_802_11_KEY *pKey;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    pKey = (WLAN_802_11_KEY *) extra;
+
+    HEXDUMP("Key buffer: ", extra, dwrq->length);
+
+    // current driver only supports key length of up to 32 bytes
+    if (pKey->KeyLength > MRVL_MAX_WPA_KEY_LENGTH) {
+        PRINTM(INFO, " Error in key length \n");
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
+        /* IBSS/WPA-None uses only one key (Group) for both receiving and
+           sending unicast and multicast packets. */
+        /*Send the key as PTK to firmware */
+        pKey->KeyIndex = 0x40000000;
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_KEY_MATERIAL,
+                               HostCmd_ACT_GEN_SET,
+                               HostCmd_OPTION_WAITFORRSP,
+                               KEY_INFO_ENABLED, pKey);
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+        /*Send the key as GTK to firmware */
+        pKey->KeyIndex = ~0x40000000;
+    }
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_KEY_MATERIAL,
+                           HostCmd_ACT_GEN_SET,
+                           HostCmd_OPTION_WAITFORRSP, KEY_INFO_ENABLED, pKey);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/*
+ *  iwconfig ethX key on:	WEPEnabled;
+ *  iwconfig ethX key off:	WEPDisabled;
+ *  iwconfig ethX key [x]:	CurrentWepKeyIndex = x; WEPEnabled;
+ *  iwconfig ethX key [x] kstr:	WepKey[x] = kstr;
+ *  iwconfig ethX key kstr:	WepKey[CurrentWepKeyIndex] = kstr;
+ *
+ *  all:			Send command SET_WEP;
+ 				SetMacPacketFilter;
+ */
+
+/** 
+ *  @brief Set WEP key
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param dwrq 		A pointer to iw_point structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_encode_nonwpa(struct net_device *dev,
+                       struct iw_request_info *info,
+                       struct iw_point *dwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    MRVL_WEP_KEY *pWep;
+    int index, PrevAuthMode;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    if (Adapter->CurrentWepKeyIndex >= MRVL_NUM_WEP_KEY)
+        Adapter->CurrentWepKeyIndex = 0;
+    pWep = &Adapter->WepKey[Adapter->CurrentWepKeyIndex];
+    PrevAuthMode = Adapter->SecInfo.AuthenticationMode;
+
+    index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
+
+    if (index >= 4) {
+        PRINTM(INFO, "Key index #%d out of range.\n", index + 1);
+        LEAVE();
+        return -EINVAL;
+    }
+
+    PRINTM(INFO, "Flags=0x%x, Length=%d Index=%d CurrentWepKeyIndex=%d\n",
+           dwrq->flags, dwrq->length, index, Adapter->CurrentWepKeyIndex);
+
+    if (dwrq->length > 0) {
+        /* iwconfig ethX key [n] xxxxxxxxxxx 
+         * Key has been provided by the user 
+         */
+
+        /*
+         * Check the size of the key 
+         */
+
+        if (dwrq->length > MAX_WEP_KEY_SIZE) {
+            LEAVE();
+            return -EINVAL;
+        }
+
+        /*
+         * Check the index (none -> use current) 
+         */
+
+        if (index < 0 || index > 3)     //invalid index or no index
+            index = Adapter->CurrentWepKeyIndex;
+        else                    //index is given & valid
+            pWep = &Adapter->WepKey[index];
+
+        /*
+         * Check if the key is not marked as invalid 
+         */
+        if (!(dwrq->flags & IW_ENCODE_NOKEY)) {
+            /* Cleanup */
+            memset(pWep, 0, sizeof(MRVL_WEP_KEY));
+
+            /* Copy the key in the driver */
+            memcpy(pWep->KeyMaterial, extra, dwrq->length);
+
+            /* Set the length */
+            if (dwrq->length > MIN_WEP_KEY_SIZE) {
+                pWep->KeyLength = MAX_WEP_KEY_SIZE;
+            } else {
+                if (dwrq->length > 0) {
+                    pWep->KeyLength = MIN_WEP_KEY_SIZE;
+                } else {
+                    /* Disable the key */
+                    pWep->KeyLength = 0;
+                }
+            }
+            pWep->KeyIndex = index;
+
+            if (Adapter->SecInfo.WEPStatus != Wlan802_11WEPEnabled) {
+                /*
+                 * The status is set as Key Absent 
+                 * so as to make sure we display the 
+                 * keys when iwlist ethX key is used
+                 */
+                Adapter->SecInfo.WEPStatus = Wlan802_11WEPKeyAbsent;
+            }
+
+            PRINTM(INFO, "KeyIndex=%u KeyLength=%u\n",
+                   pWep->KeyIndex, pWep->KeyLength);
+            HEXDUMP("WepKey", (u8 *) pWep->KeyMaterial, pWep->KeyLength);
+        }
+    } else {
+        /*
+         * No key provided so it is either enable key, 
+         * on or off */
+        if (dwrq->flags & IW_ENCODE_DISABLED) {
+            PRINTM(INFO, "*** iwconfig ethX key off ***\n");
+
+            Adapter->SecInfo.WEPStatus = Wlan802_11WEPDisabled;
+            if (Adapter->SecInfo.AuthenticationMode ==
+                Wlan802_11AuthModeShared)
+                Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+        } else {
+            /* iwconfig ethX key [n]
+             * iwconfig ethX key on 
+             * Do we want to just set the transmit key index ? 
+             */
+
+            if (index < 0 || index > 3) {
+                PRINTM(INFO, "*** iwconfig ethX key on ***\n");
+                index = Adapter->CurrentWepKeyIndex;
+            } else {
+                PRINTM(INFO, "*** iwconfig ethX key [x=%d] ***\n", index);
+                Adapter->CurrentWepKeyIndex = index;
+            }
+
+            /* Copy the required key as the current key */
+            pWep = &Adapter->WepKey[index];
+
+            if (!pWep->KeyLength) {
+                PRINTM(INFO, "Key not set,so cannot enable it\n");
+                LEAVE();
+                return -EPERM;
+            }
+
+            Adapter->SecInfo.WEPStatus = Wlan802_11WEPEnabled;
+
+            HEXDUMP("KeyMaterial", (u8 *) pWep->KeyMaterial, pWep->KeyLength);
+        }
+    }
+
+    if (pWep->KeyLength) {
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_SET_WEP,
+                               HostCmd_ACT_ADD, HostCmd_OPTION_WAITFORRSP,
+                               0, NULL);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    }
+
+    if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled) {
+        Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_WEP_ENABLE;
+    } else {
+        Adapter->CurrentPacketFilter &= ~HostCmd_ACT_MAC_WEP_ENABLE;
+    }
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_MAC_CONTROL,
+                           0, HostCmd_OPTION_WAITFORRSP,
+                           0, &Adapter->CurrentPacketFilter);
+
+    if (dwrq->flags & IW_ENCODE_RESTRICTED) {
+        /* iwconfig ethX restricted key [1] */
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeShared;
+        PRINTM(INFO, "Auth mode restricted!\n");
+    } else if (dwrq->flags & IW_ENCODE_OPEN) {
+        /* iwconfig ethX key [2] open */
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+        PRINTM(INFO, "Auth mode open!\n");
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set RX Antenna
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param Mode			RF antenna mode
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_rx_antenna(wlan_private * priv, int Mode)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Mode != RF_ANTENNA_1 && Mode != RF_ANTENNA_2
+        && Mode != RF_ANTENNA_AUTO) {
+        LEAVE();
+        return -EINVAL;
+    }
+
+    Adapter->RxAntennaMode = Mode;
+
+    PRINTM(INFO, "SET RX Antenna Mode to 0x%04x\n", Adapter->RxAntennaMode);
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_RF_ANTENNA,
+                           HostCmd_ACT_SET_RX, HostCmd_OPTION_WAITFORRSP,
+                           0, &Adapter->RxAntennaMode);
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief Set TX Antenna
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param Mode			RF antenna mode
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_tx_antenna(wlan_private * priv, int Mode)
+{
+    int ret = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if ((Mode != RF_ANTENNA_1) && (Mode != RF_ANTENNA_2)
+        && (Mode != RF_ANTENNA_AUTO)) {
+        LEAVE();
+        return -EINVAL;
+    }
+
+    Adapter->TxAntennaMode = Mode;
+
+    PRINTM(INFO, "SET TX Antenna Mode to 0x%04x\n", Adapter->TxAntennaMode);
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_RF_ANTENNA,
+                           HostCmd_ACT_SET_TX, HostCmd_OPTION_WAITFORRSP,
+                           0, &Adapter->TxAntennaMode);
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief Get RX Antenna
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param buf			A pointer to recieve antenna mode
+ *  @return 	   		length of buf 
+ */
+static int
+wlan_get_rx_antenna(wlan_private * priv, char *buf)
+{
+    int ret = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    // clear it, so we will know if the value 
+    // returned below is correct or not.
+    Adapter->RxAntennaMode = 0;
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_RF_ANTENNA,
+                           HostCmd_ACT_GET_RX, HostCmd_OPTION_WAITFORRSP,
+                           0, NULL);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    PRINTM(INFO, "Get Rx Antenna Mode:0x%04x\n", Adapter->RxAntennaMode);
+
+    LEAVE();
+
+    return sprintf(buf, "0x%04x", Adapter->RxAntennaMode) + 1;
+}
+
+/** 
+ *  @brief Get TX Antenna
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param buf			A pointer to recieve antenna mode
+ *  @return 	   		length of buf 
+ */
+static int
+wlan_get_tx_antenna(wlan_private * priv, char *buf)
+{
+    int ret = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    // clear it, so we will know if the value 
+    // returned below is correct or not.
+    Adapter->TxAntennaMode = 0;
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_RF_ANTENNA,
+                           HostCmd_ACT_GET_TX, HostCmd_OPTION_WAITFORRSP,
+                           0, NULL);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    PRINTM(INFO, "Get Tx Antenna Mode:0x%04x\n", Adapter->TxAntennaMode);
+
+    LEAVE();
+
+    return sprintf(buf, "0x%04x", Adapter->TxAntennaMode) + 1;
+}
+
+/** 
+ *  @brief Set Radio On/OFF
+ *   
+ *  @param priv  		A pointer to wlan_private structure
+ *  @param option 		Radio Option
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+static int
+wlan_radio_ioctl(wlan_private * priv, u8 option)
+{
+    int ret = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->RadioOn != option) {
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            PRINTM(MSG, "Cannot turn radio off in connected state.\n");
+            LEAVE();
+            return -EINVAL;
+        }
+
+        PRINTM(INFO, "Switching %s the Radio\n", option ? "On" : "Off");
+        Adapter->RadioOn = option;
+
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_RADIO_CONTROL,
+                               HostCmd_ACT_GEN_SET,
+                               HostCmd_OPTION_WAITFORRSP, 0, NULL);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+#ifdef REASSOCIATION
+/** 
+ *  @brief Set Auto Reassociation On
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+static int
+reassociation_on(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    Adapter->Reassoc_on = TRUE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Auto Reassociation Off
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+static int
+reassociation_off(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->ReassocTimerIsSet == TRUE) {
+        wlan_cancel_timer(&Adapter->MrvDrvTimer);
+        Adapter->ReassocTimerIsSet = FALSE;
+    }
+
+    Adapter->Reassoc_on = FALSE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+#endif /* REASSOCIATION */
+
+/** 
+ *  @brief Set Region
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param region_code		region code
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail 
+ */
+static int
+wlan_set_region(wlan_private * priv, u16 region_code)
+{
+    int i;
+
+    ENTER();
+
+    for (i = 0; i < MRVDRV_MAX_REGION_CODE; i++) {
+        // use the region code to search for the index
+        if (region_code == RegionCodeToIndex[i]) {
+            priv->adapter->RegionCode = region_code;
+            break;
+        }
+    }
+
+    // if it's unidentified region code
+    if (i >= MRVDRV_MAX_REGION_CODE) {
+        PRINTM(INFO, "Region Code not identified\n");
+        LEAVE();
+        return WLAN_STATUS_FAILURE;
+    }
+
+    if (wlan_set_regiontable(priv, priv->adapter->RegionCode,
+                             priv->adapter->config_bands)) {
+        LEAVE();
+        return -EINVAL;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Copy Rates
+ *   
+ *  @param dest                 A pointer to Dest Buf
+ *  @param pos		        The position for copy
+ *  @param src		        A pointer to Src Buf
+ *  @param len                  The len of Src Buf
+ *  @return 	   	        Number of Rates copyed 
+ */
+static inline int
+wlan_copy_rates(u8 * dest, int pos, u8 * src, int len)
+{
+    int i;
+
+    ENTER();
+
+    for (i = 0; i < len && src[i]; i++, pos++) {
+        if (pos >= sizeof(WLAN_802_11_RATES))
+            break;
+        dest[pos] = src[i];
+    }
+
+    LEAVE();
+
+    return pos;
+}
+
+/** 
+ *  @brief Get active data rates
+ *   
+ *  @param Adapter          A pointer to wlan_adapter structure
+ *  @param rates            The buf to return the active rates
+ *  @return                 The number of Rates
+ */
+static int
+get_active_data_rates(wlan_adapter * Adapter, WLAN_802_11_RATES rates)
+{
+    int k = 0;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus != WlanMediaStateConnected) {
+        if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+            //Infra. mode
+            if (Adapter->config_bands & BAND_G) {
+                PRINTM(INFO, "Infra mBAND_G=%#x\n", BAND_G);
+                k = wlan_copy_rates(rates, k, SupportedRates_G,
+                                    sizeof(SupportedRates_G));
+            } else {
+                if (Adapter->config_bands & BAND_B) {
+                    PRINTM(INFO, "Infra mBAND_B=%#x\n", BAND_B);
+                    k = wlan_copy_rates(rates, k,
+                                        SupportedRates_B,
+                                        sizeof(SupportedRates_B));
+                }
+                if (Adapter->config_bands & BAND_A) {
+                    PRINTM(INFO, "Infra mBAND_A=%#x\n", BAND_A);
+                    k = wlan_copy_rates(rates, k,
+                                        SupportedRates_A,
+                                        sizeof(SupportedRates_A));
+                }
+            }
+        } else {
+            //ad-hoc mode
+            if (Adapter->config_bands & BAND_G) {
+                PRINTM(INFO, "Adhoc mBAND_G=%#x\n", BAND_G);
+                k = wlan_copy_rates(rates, k, AdhocRates_G,
+                                    sizeof(AdhocRates_G));
+            } else if (Adapter->config_bands & BAND_B) {
+                PRINTM(INFO, "Adhoc mBAND_B=%#x\n", BAND_B);
+                k = wlan_copy_rates(rates, k, AdhocRates_B,
+                                    sizeof(AdhocRates_B));
+            }
+            if (Adapter->config_bands & BAND_A) {
+                PRINTM(INFO, "Adhoc mBAND_A=%#x\n", BAND_A);
+                k = wlan_copy_rates(rates, k, AdhocRates_A,
+                                    sizeof(AdhocRates_A));
+            }
+        }
+    } else {
+        k = wlan_copy_rates(rates, 0, Adapter->CurBssParams.DataRates,
+                            Adapter->CurBssParams.NumOfRates);
+    }
+
+    LEAVE();
+
+    return k;
+}
+
+/** 
+ *  @brief Get/Set Per packet TX Control flags
+ *  
+ *  @param priv     A pointer to wlan_private structure
+ *  @param wrq      A pointer to user data
+ *  @return         WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_txcontrol(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data[3];
+    int ret;
+
+    ENTER();
+
+    ret = WLAN_STATUS_SUCCESS;
+
+    switch (wrq->u.data.length) {
+    case 0:
+        /*
+         *  Get the Global setting for TxCtrl 
+         */
+        if (copy_to_user(wrq->u.data.pointer,
+                         &Adapter->PktTxCtrl, sizeof(u32))) {
+            PRINTM(INFO, "copy_to_user failed!\n");
+            ret = -EFAULT;
+        } else {
+            wrq->u.data.length = 1;
+        }
+        break;
+
+    case 1:
+        /*
+         *  Set the Global setting for TxCtrl
+         */
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+        } else {
+            Adapter->PktTxCtrl = data[0];
+            PRINTM(INFO, "PktTxCtrl set: 0x%08x\n", Adapter->PktTxCtrl);
+        }
+        break;
+
+    case 2:
+        /*
+         *  Get the per User Priority setting for TxCtrl for the given UP
+         */
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(int) * 2)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+
+        } else if (data[1] >= NELEMENTS(Adapter->wmm.userPriPktTxCtrl)) {
+            /* Range check the UP input from user space */
+            PRINTM(INFO, "User priority out of range\n");
+            ret = -EINVAL;
+
+        } else if (Adapter->wmm.userPriPktTxCtrl[data[1]]) {
+            data[2] = Adapter->wmm.userPriPktTxCtrl[data[1]];
+
+            /* User priority setting is valid, return it */
+            if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 3)) {
+                PRINTM(INFO, "copy_to_user failed!\n");
+                ret = -EFAULT;
+            } else {
+                wrq->u.data.length = 3;
+            }
+
+        } else {
+            /* Return the global setting since the UP set is zero */
+            data[2] = Adapter->PktTxCtrl;
+
+            if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 3)) {
+                PRINTM(INFO, "copy_to_user failed!\n");
+                ret = -EFAULT;
+            } else {
+                wrq->u.data.length = 3;
+            }
+        }
+        break;
+
+    case 3:
+        /*
+         *  Set the per User Priority setting for TxCtrl for the given UP
+         */
+
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(int) * 3)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+        } else if (data[1] >= NELEMENTS(Adapter->wmm.userPriPktTxCtrl)) {
+            PRINTM(INFO, "User priority out of range\n");
+            ret = -EINVAL;
+        } else {
+            Adapter->wmm.userPriPktTxCtrl[data[1]] = data[2];
+
+            if (Adapter->wmm.userPriPktTxCtrl[data[1]] == 0) {
+                /* Return the global setting since the UP set is zero */
+                data[2] = Adapter->PktTxCtrl;
+            }
+
+            if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 3)) {
+                PRINTM(INFO, "copy_to_user failed!\n");
+                ret = -EFAULT;
+            } else {
+                wrq->u.data.length = 3;
+            }
+        }
+        break;
+
+    default:
+        ret = -EINVAL;
+        break;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Enable/Disable atim uapsd null package generation
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_null_pkg_gen(wlan_private * priv, struct iwreq *wrq)
+{
+    int data;
+    wlan_adapter *Adapter = priv->adapter;
+    int *val;
+
+    ENTER();
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    PRINTM(INFO, "Enable UAPSD NULL PKG: %s\n",
+           (data == CMD_ENABLED) ? "Enable" : "Disable");
+    switch (data) {
+    case CMD_ENABLED:
+        Adapter->gen_null_pkg = TRUE;
+        break;
+    case CMD_DISABLED:
+        Adapter->gen_null_pkg = FALSE;
+        break;
+    default:
+        break;
+    }
+
+    data = (Adapter->gen_null_pkg == TRUE) ? CMD_ENABLED : CMD_DISABLED;
+    val = (int *) wrq->u.name;
+    *val = data;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set NULL Package generation interval
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_null_pkt_interval(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data;
+    ENTER();
+
+    if ((int) wrq->u.data.length == 0) {
+        data = Adapter->NullPktInterval;
+
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(MSG, "copy_to_user failed!\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    } else {
+        if ((int) wrq->u.data.length > 1) {
+            PRINTM(MSG, "ioctl too many args!\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+        Adapter->NullPktInterval = data;
+    }
+
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Adhoc awake period 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_adhoc_awake_period(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data;
+    ENTER();
+
+    if ((int) wrq->u.data.length == 0) {
+        data = Adapter->AdhocAwakePeriod;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(MSG, "copy_to_user failed!\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    } else {
+        if ((int) wrq->u.data.length > 1) {
+            PRINTM(MSG, "ioctl too many args!\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+#define AWAKE_PERIOD_NOCHANGE 0
+#define AWAKE_PERIOD_MIN 1
+#define AWAKE_PERIOD_MAX 31
+#define DISABLE_AWAKE_PERIOD 0xff
+        if ((((data & 0xff) >= AWAKE_PERIOD_MIN) &&
+             ((data & 0xff) <= AWAKE_PERIOD_MAX)) ||
+            ((data & 0xff) == DISABLE_AWAKE_PERIOD))
+            Adapter->AdhocAwakePeriod = (u16) data;
+        else {
+            if (data != AWAKE_PERIOD_NOCHANGE) {
+                PRINTM(INFO,
+                       "Invalid parameter, AdhocAwakePeriod not changed.\n");
+                LEAVE();
+                return -EINVAL;
+            }
+            data = Adapter->AdhocAwakePeriod;
+            if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+                PRINTM(MSG, "copy_to_user failed!\n");
+                LEAVE();
+                return -EFAULT;
+            }
+        }
+    }
+    wrq->u.data.length = 1;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set bcn missing timeout 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_bcn_miss_timeout(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data;
+    ENTER();
+
+    if ((int) wrq->u.data.length == 0) {
+        data = Adapter->BCNMissTimeOut;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(MSG, "copy_to_user failed!\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    } else {
+        if ((int) wrq->u.data.length > 1) {
+            PRINTM(MSG, "ioctl too many args!\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        if (((data >= 0) && (data <= 50)) || (data == 0xffff))
+            Adapter->BCNMissTimeOut = (u16) data;
+        else {
+            PRINTM(INFO,
+                   "Invalid parameter, BCN Missing timeout not changed.\n");
+            LEAVE();
+            return -EINVAL;
+
+        }
+    }
+
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set adhoc g proctection
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_adhoc_g_protection(wlan_private * priv, struct iwreq *wrq)
+{
+    int data;
+    int *val;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+#define ADHOC_G_PROTECTION_ON		1
+#define ADHOC_G_PROTECTION_OFF		0
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+
+    switch (data) {
+    case CMD_DISABLED:
+        Adapter->CurrentPacketFilter &=
+            ~HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON;
+        break;
+    case CMD_ENABLED:
+        Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON;
+        break;
+
+    case CMD_GET:
+        if (Adapter->
+            CurrentPacketFilter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)
+            data = ADHOC_G_PROTECTION_ON;
+        else
+            data = ADHOC_G_PROTECTION_OFF;
+        break;
+
+    default:
+        LEAVE();
+        return -EINVAL;
+    }
+
+    val = (int *) wrq->u.name;
+    *val = data;
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+#ifdef DEBUG_LEVEL1
+/** 
+ *  @brief Get/Set the bit mask of driver debug message control
+ *  @param priv			A pointer to wlan_private structure
+ *  @param wrq			A pointer to wrq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_drv_dbg(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[4];
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0) {
+        data[0] = drvdbg;
+        data[1] = ifdbg;
+        /* Return the current driver debug bit masks */
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 2)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+            goto drvdbgexit;
+        }
+        wrq->u.data.length = 2;
+    } else if (wrq->u.data.length < 3) {
+        /* Get the driver debug bit masks */
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+            goto drvdbgexit;
+        }
+        drvdbg = data[0];
+        if (wrq->u.data.length == 2)
+            ifdbg = data[1];
+    } else {
+        PRINTM(INFO, "Invalid parameter number\n");
+        goto drvdbgexit;
+    }
+
+    printk(KERN_ALERT "drvdbg = 0x%x\n", drvdbg);
+#ifdef DEBUG_LEVEL2
+    printk(KERN_ALERT "INFO  (%08x) %s\n", DBG_INFO,
+           (drvdbg & DBG_INFO) ? "X" : "");
+    printk(KERN_ALERT "WARN  (%08x) %s\n", DBG_WARN,
+           (drvdbg & DBG_WARN) ? "X" : "");
+    printk(KERN_ALERT "ENTRY (%08x) %s\n", DBG_ENTRY,
+           (drvdbg & DBG_ENTRY) ? "X" : "");
+#endif
+    printk(KERN_ALERT "FW_D  (%08x) %s\n", DBG_FW_D,
+           (drvdbg & DBG_FW_D) ? "X" : "");
+    printk(KERN_ALERT "CMD_D (%08x) %s\n", DBG_CMD_D,
+           (drvdbg & DBG_CMD_D) ? "X" : "");
+    printk(KERN_ALERT "DAT_D (%08x) %s\n", DBG_DAT_D,
+           (drvdbg & DBG_DAT_D) ? "X" : "");
+    printk(KERN_ALERT "INTR  (%08x) %s\n", DBG_INTR,
+           (drvdbg & DBG_INTR) ? "X" : "");
+    printk(KERN_ALERT "EVENT (%08x) %s\n", DBG_EVENT,
+           (drvdbg & DBG_EVENT) ? "X" : "");
+    printk(KERN_ALERT "CMND  (%08x) %s\n", DBG_CMND,
+           (drvdbg & DBG_CMND) ? "X" : "");
+    printk(KERN_ALERT "DATA  (%08x) %s\n", DBG_DATA,
+           (drvdbg & DBG_DATA) ? "X" : "");
+    printk(KERN_ALERT "ERROR (%08x) %s\n", DBG_ERROR,
+           (drvdbg & DBG_ERROR) ? "X" : "");
+    printk(KERN_ALERT "FATAL (%08x) %s\n", DBG_FATAL,
+           (drvdbg & DBG_FATAL) ? "X" : "");
+    printk(KERN_ALERT "MSG   (%08x) %s\n", DBG_MSG,
+           (drvdbg & DBG_MSG) ? "X" : "");
+    printk(KERN_ALERT "ifdbg = 0x%x\n", ifdbg);
+    printk(KERN_ALERT "IF_D  (%08x) %s\n", DBG_IF_D,
+           (ifdbg & DBG_IF_D) ? "X" : "");
+
+  drvdbgexit:
+    LEAVE();
+    return ret;
+}
+#endif
+
+/** 
+ *  @brief Get/Set module type config
+ *  @param priv			A pointer to wlan_private structure
+ *  @param wrq			A pointer to wrq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_module_type_config(wlan_private * priv, struct iwreq *wrq)
+{
+    HostCmd_DS_MODULE_TYPE_CONFIG moduletypecfg;
+    int data = 0;
+    u16 action;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0) {
+        action = HostCmd_ACT_GEN_GET;
+    } else if (wrq->u.data.length > 1) {
+        PRINTM(MSG, "ioctl too many args!\n");
+        ret = -EFAULT;
+        goto mtexit;
+    } else {
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+            goto mtexit;
+        }
+        action = HostCmd_ACT_GEN_SET;
+    }
+    moduletypecfg.Action = action;
+    moduletypecfg.Module = (u16) data;
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_MODULE_TYPE_CONFIG,
+                           action, HostCmd_OPTION_WAITFORRSP,
+                           0, (void *) &moduletypecfg);
+
+    if (!ret && action == HostCmd_ACT_GEN_GET) {
+        data = (int) moduletypecfg.Module;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+            goto mtexit;
+        }
+        wrq->u.data.length = 1;
+    }
+
+  mtexit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Commit handler: called after a bunch of SET operations
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_config_commit(struct net_device *dev,
+                   struct iw_request_info *info, char *cwrq, char *extra)
+{
+    ENTER();
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get protocol name 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_name(struct net_device *dev, struct iw_request_info *info,
+              char *cwrq, char *extra)
+{
+    const char *cp;
+    char comm[6] = { "COMM-" };
+    char mrvl[6] = { "MRVL-" };
+    int cnt;
+
+    ENTER();
+
+    strcpy(cwrq, mrvl);
+
+    cp = strstr(driver_version, comm);
+    if (cp == driver_version)   //skip leading "COMM-"
+        cp = driver_version + strlen(comm);
+    else
+        cp = driver_version;
+
+    cnt = strlen(mrvl);
+    cwrq += cnt;
+    while (cnt < 16 && (*cp != '-')) {
+        *cwrq++ = toupper(*cp++);
+        cnt++;
+    }
+    *cwrq = '\0';
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get frequency
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param fwrq 		A pointer to iw_freq structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_freq(struct net_device *dev, struct iw_request_info *info,
+              struct iw_freq *fwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    CHANNEL_FREQ_POWER *cfp;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    cfp = find_cfp_by_band_and_channel(Adapter, Adapter->CurBssParams.band,
+                                       (u16) Adapter->CurBssParams.
+                                       BSSDescriptor.Channel);
+
+    if (!cfp) {
+        if (Adapter->CurBssParams.BSSDescriptor.Channel) {
+            PRINTM(INFO, "Invalid channel=%d\n",
+                   Adapter->CurBssParams.BSSDescriptor.Channel);
+        }
+        LEAVE();
+        return -EINVAL;
+    }
+
+    fwrq->m = (long) cfp->Freq * 100000;
+    fwrq->e = 1;
+
+    PRINTM(INFO, "freq=%u\n", fwrq->m);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get current BSSID
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param awrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
+             struct sockaddr *awrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        memcpy(awrq->sa_data,
+               Adapter->CurBssParams.BSSDescriptor.MacAddress, ETH_ALEN);
+    } else {
+        memset(awrq->sa_data, 0, ETH_ALEN);
+    }
+    awrq->sa_family = ARPHRD_ETHER;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Adapter Node Name
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_nick(struct net_device *dev, struct iw_request_info *info,
+              struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /*
+     * Check the size of the string 
+     */
+
+    if (dwrq->length > 16) {
+        LEAVE();
+        return -E2BIG;
+    }
+
+    memset(Adapter->nodeName, 0, sizeof(Adapter->nodeName));
+    memcpy(Adapter->nodeName, extra, dwrq->length);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Adapter Node Name
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_nick(struct net_device *dev, struct iw_request_info *info,
+              struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    /*
+     * Get the Nick Name saved 
+     */
+
+    strncpy(extra, Adapter->nodeName, 16);
+
+    extra[16] = '\0';
+
+    /*
+     * If none, we may want to get the one that was set 
+     */
+
+    /*
+     * Push it out ! 
+     */
+    dwrq->length = strlen(extra) + 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set RTS threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
+             struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int rthr = vwrq->value;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    if (vwrq->disabled) {
+        Adapter->RTSThsd = rthr = MRVDRV_RTS_MAX_VALUE;
+    } else {
+        if (rthr < MRVDRV_RTS_MIN_VALUE || rthr > MRVDRV_RTS_MAX_VALUE) {
+            LEAVE();
+            return -EINVAL;
+        }
+        Adapter->RTSThsd = rthr;
+    }
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                           HostCmd_ACT_GEN_SET, HostCmd_OPTION_WAITFORRSP,
+                           RtsThresh_i, &rthr);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get RTS threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
+             struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    Adapter->RTSThsd = 0;
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                           HostCmd_ACT_GEN_GET, HostCmd_OPTION_WAITFORRSP,
+                           RtsThresh_i, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    vwrq->value = Adapter->RTSThsd;
+    vwrq->disabled = ((vwrq->value < MRVDRV_RTS_MIN_VALUE)
+                      || (vwrq->value > MRVDRV_RTS_MAX_VALUE));
+    vwrq->fixed = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Fragment threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_frag(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    int fthr = vwrq->value;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    if (vwrq->disabled) {
+        Adapter->FragThsd = fthr = MRVDRV_FRAG_MAX_VALUE;
+    } else {
+        if (fthr < MRVDRV_FRAG_MIN_VALUE || fthr > MRVDRV_FRAG_MAX_VALUE) {
+            LEAVE();
+            return -EINVAL;
+        }
+        Adapter->FragThsd = fthr;
+    }
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                           HostCmd_ACT_GEN_SET, HostCmd_OPTION_WAITFORRSP,
+                           FragThresh_i, &fthr);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get Fragment threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_frag(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    Adapter->FragThsd = 0;
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_SNMP_MIB, HostCmd_ACT_GEN_GET,
+                           HostCmd_OPTION_WAITFORRSP, FragThresh_i, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    vwrq->value = Adapter->FragThsd;
+    vwrq->disabled = ((vwrq->value < MRVDRV_FRAG_MIN_VALUE)
+                      || (vwrq->value > MRVDRV_FRAG_MAX_VALUE));
+    vwrq->fixed = 1;
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get Wlan Mode
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_mode(struct net_device *dev,
+              struct iw_request_info *info, u32 * uwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *adapter = priv->adapter;
+
+    ENTER();
+
+    switch (adapter->InfrastructureMode) {
+    case Wlan802_11IBSS:
+        *uwrq = IW_MODE_ADHOC;
+        break;
+
+    case Wlan802_11Infrastructure:
+        *uwrq = IW_MODE_INFRA;
+        break;
+
+    default:
+    case Wlan802_11AutoUnknown:
+        *uwrq = IW_MODE_AUTO;
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Encryption key
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_encode(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_point *dwrq, u8 * extra)
+{
+
+    wlan_private *priv = dev->priv;
+    wlan_adapter *adapter = priv->adapter;
+    int index = (dwrq->flags & IW_ENCODE_INDEX);
+
+    ENTER();
+
+    PRINTM(INFO, "flags=0x%x index=%d length=%d CurrentWepKeyIndex=%d\n",
+           dwrq->flags, index, dwrq->length, adapter->CurrentWepKeyIndex);
+    if (index < 0 || index > 4) {
+        PRINTM(INFO, "Key index #%d out of range.\n", index);
+        LEAVE();
+        return -EINVAL;
+    }
+    if (adapter->CurrentWepKeyIndex >= MRVL_NUM_WEP_KEY)
+        adapter->CurrentWepKeyIndex = 0;
+    dwrq->flags = 0;
+
+    /*
+     * Check encryption mode 
+     */
+
+    switch (adapter->SecInfo.AuthenticationMode) {
+    case Wlan802_11AuthModeOpen:
+        dwrq->flags = IW_ENCODE_OPEN;
+        break;
+
+    case Wlan802_11AuthModeShared:
+    case Wlan802_11AuthModeNetworkEAP:
+        dwrq->flags = IW_ENCODE_RESTRICTED;
+        break;
+    default:
+        dwrq->flags = IW_ENCODE_DISABLED | IW_ENCODE_OPEN;
+        break;
+    }
+
+    if ((adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled)
+        || (adapter->SecInfo.WEPStatus == Wlan802_11WEPKeyAbsent)
+        || adapter->SecInfo.WPAEnabled || adapter->SecInfo.WPA2Enabled) {
+        dwrq->flags &= ~IW_ENCODE_DISABLED;
+    } else {
+        dwrq->flags |= IW_ENCODE_DISABLED;
+    }
+
+    memset(extra, 0, 16);
+
+    if (!index) {
+        /* Handle current key request   */
+        if ((adapter->WepKey[adapter->CurrentWepKeyIndex].KeyLength) &&
+            (adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled)) {
+            index = adapter->WepKey[adapter->CurrentWepKeyIndex].KeyIndex;
+            memcpy(extra, adapter->WepKey[index].KeyMaterial,
+                   adapter->WepKey[index].KeyLength);
+            dwrq->length = adapter->WepKey[index].KeyLength;
+            /* return current key */
+            dwrq->flags |= (index + 1);
+            /* return WEP enabled */
+            dwrq->flags &= ~IW_ENCODE_DISABLED;
+        } else if ((adapter->SecInfo.WPAEnabled)
+                   || (adapter->SecInfo.WPA2Enabled)
+            ) {
+            /* return WPA enabled */
+            dwrq->flags &= ~IW_ENCODE_DISABLED;
+        } else {
+            dwrq->flags |= IW_ENCODE_DISABLED;
+        }
+    } else {
+        /* Handle specific key requests */
+        index--;
+        if (adapter->WepKey[index].KeyLength) {
+            memcpy(extra, adapter->WepKey[index].KeyMaterial,
+                   adapter->WepKey[index].KeyLength);
+            dwrq->length = adapter->WepKey[index].KeyLength;
+            /* return current key */
+            dwrq->flags |= (index + 1);
+            /* return WEP enabled */
+            dwrq->flags &= ~IW_ENCODE_DISABLED;
+        } else if ((adapter->SecInfo.WPAEnabled)
+                   || (adapter->SecInfo.WPA2Enabled)
+            ) {
+            /* return WPA enabled */
+            dwrq->flags &= ~IW_ENCODE_DISABLED;
+        } else {
+            dwrq->flags |= IW_ENCODE_DISABLED;
+        }
+    }
+
+    dwrq->flags |= IW_ENCODE_NOKEY;
+
+    PRINTM(INFO, "Key:%02x:%02x:%02x:%02x:%02x:%02x KeyLen=%d\n",
+           extra[0], extra[1], extra[2],
+           extra[3], extra[4], extra[5], dwrq->length);
+
+    PRINTM(INFO, "Return flags=0x%x\n", dwrq->flags);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get TX Power
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_txpow(struct net_device *dev,
+               struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_RF_TX_POWER,
+                           HostCmd_ACT_GEN_GET,
+                           HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    PRINTM(INFO, "TXPOWER GET %d dbm.\n", Adapter->TxPowerLevel);
+    vwrq->value = Adapter->TxPowerLevel;
+    vwrq->fixed = 1;
+    if (Adapter->RadioOn) {
+        vwrq->disabled = 0;
+        vwrq->flags = IW_TXPOW_DBM;
+    } else {
+        vwrq->disabled = 1;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set TX Retry Count
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_retry(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *adapter = priv->adapter;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    if (vwrq->flags == IW_RETRY_LIMIT) {
+        /* The MAC has a 4-bit Total_Tx_Count register
+           Total_Tx_Count = 1 + Tx_Retry_Count */
+#define TX_RETRY_MIN 0
+#define TX_RETRY_MAX 14
+        if (vwrq->value < TX_RETRY_MIN || vwrq->value > TX_RETRY_MAX) {
+            LEAVE();
+            return -EINVAL;
+        }
+        /* Set Tx retry count */
+        adapter->TxRetryCount = vwrq->value;
+
+        ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+                               HostCmd_ACT_GEN_SET, HostCmd_OPTION_WAITFORRSP,
+                               ShortRetryLim_i, NULL);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    } else {
+        LEAVE();
+        return -EOPNOTSUPP;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get TX Retry Count
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_retry(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    Adapter->TxRetryCount = 0;
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_SNMP_MIB, HostCmd_ACT_GEN_GET,
+                           HostCmd_OPTION_WAITFORRSP, ShortRetryLim_i, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+    vwrq->disabled = 0;
+    if (!vwrq->flags) {
+        vwrq->flags = IW_RETRY_LIMIT;
+        /* Get Tx retry count */
+        vwrq->value = Adapter->TxRetryCount;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Sort Channels
+ *   
+ *  @param freq 		A pointer to iw_freq structure
+ *  @param num		        number of Channels
+ *  @return 	   		NA
+ */
+static inline void
+sort_channels(struct iw_freq *freq, int num)
+{
+    int i, j;
+    struct iw_freq temp;
+
+    ENTER();
+
+    for (i = 0; i < num; i++)
+        for (j = i + 1; j < num; j++)
+            if (freq[i].i > freq[j].i) {
+                temp.i = freq[i].i;
+                temp.m = freq[i].m;
+
+                freq[i].i = freq[j].i;
+                freq[i].m = freq[j].m;
+
+                freq[j].i = temp.i;
+                freq[j].m = temp.m;
+            }
+
+    LEAVE();
+}
+
+/* data rate listing
+	MULTI_BANDS:
+		abg		a	b	b/g
+   Infra 	G(12)		A(8)	B(4)	G(12)
+   Adhoc 	A+B(12)		A(8)	B(4)	B(4)
+
+	non-MULTI_BANDS:
+		   		 	b	b/g
+   Infra 	     		    	B(4)	G(12)
+   Adhoc 	      		    	B(4)	B(4)
+ */
+/** 
+ *  @brief Get Range Info
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_range(struct net_device *dev, struct iw_request_info *info,
+               struct iw_point *dwrq, char *extra)
+{
+    int i, j;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    struct iw_range *range = (struct iw_range *) extra;
+    CHANNEL_FREQ_POWER *cfp;
+    WLAN_802_11_RATES rates;
+
+    ENTER();
+
+    dwrq->length = sizeof(struct iw_range);
+    memset(range, 0, sizeof(struct iw_range));
+
+    range->min_nwid = 0;
+    range->max_nwid = 0;
+
+    memset(rates, 0, sizeof(rates));
+    range->num_bitrates = get_active_data_rates(Adapter, rates);
+    if (range->num_bitrates > sizeof(rates))
+        range->num_bitrates = sizeof(rates);
+
+    for (i = 0; i < MIN(range->num_bitrates, IW_MAX_BITRATES) && rates[i];
+         i++) {
+        range->bitrate[i] = (rates[i] & 0x7f) * 500000;
+    }
+    range->num_bitrates = i;
+    PRINTM(INFO, "IW_MAX_BITRATES=%d num_bitrates=%d\n", IW_MAX_BITRATES,
+           range->num_bitrates);
+
+    range->num_frequency = 0;
+    if (wlan_get_state_11d(priv) == ENABLE_11D &&
+        Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        u8 chan_no;
+        u8 band;
+
+        parsed_region_chan_11d_t *parsed_region_chan =
+            &Adapter->parsed_region_chan;
+
+        band = parsed_region_chan->band;
+        PRINTM(INFO, "band=%d NoOfChan=%d\n", band,
+               parsed_region_chan->NoOfChan);
+
+        for (i = 0; (range->num_frequency < IW_MAX_FREQUENCIES)
+             && (i < parsed_region_chan->NoOfChan); i++) {
+            chan_no = parsed_region_chan->chanPwr[i].chan;
+            PRINTM(INFO, "chan_no=%d\n", chan_no);
+            range->freq[range->num_frequency].i = (long) chan_no;
+            range->freq[range->num_frequency].m =
+                (long) chan_2_freq(chan_no, band) * 100000;
+            range->freq[range->num_frequency].e = 1;
+            range->num_frequency++;
+        }
+    } else {
+        for (j = 0; (range->num_frequency < IW_MAX_FREQUENCIES)
+             && (j < sizeof(Adapter->region_channel)
+                 / sizeof(Adapter->region_channel[0])); j++) {
+            cfp = Adapter->region_channel[j].CFP;
+            for (i = 0; (range->num_frequency < IW_MAX_FREQUENCIES)
+                 && Adapter->region_channel[j].Valid
+                 && cfp && (i < Adapter->region_channel[j].NrCFP); i++) {
+                range->freq[range->num_frequency].i = (long) cfp->Channel;
+                range->freq[range->num_frequency].m =
+                    (long) cfp->Freq * 100000;
+                range->freq[range->num_frequency].e = 1;
+                cfp++;
+                range->num_frequency++;
+            }
+        }
+    }
+
+    PRINTM(INFO, "IW_MAX_FREQUENCIES=%d num_frequency=%d\n",
+           IW_MAX_FREQUENCIES, range->num_frequency);
+
+    range->num_channels = range->num_frequency;
+
+    sort_channels(&range->freq[0], range->num_frequency);
+
+    /*
+     * Set an indication of the max TCP throughput in bit/s that we can
+     * expect using this interface 
+     */
+    if (i > 2)
+        range->throughput = 5000 * 1000;
+    else
+        range->throughput = 1500 * 1000;
+
+    range->min_rts = MRVDRV_RTS_MIN_VALUE;
+    range->max_rts = MRVDRV_RTS_MAX_VALUE;
+    range->min_frag = MRVDRV_FRAG_MIN_VALUE;
+    range->max_frag = MRVDRV_FRAG_MAX_VALUE;
+
+    range->encoding_size[0] = 5;
+    range->encoding_size[1] = 13;
+    range->num_encoding_sizes = 2;
+    range->max_encoding_tokens = 4;
+
+#define IW_POWER_PERIOD_MIN 1000000     /* 1 sec */
+#define IW_POWER_PERIOD_MAX 120000000   /* 2 min */
+#define IW_POWER_TIMEOUT_MIN 1000       /* 1 ms  */
+#define IW_POWER_TIMEOUT_MAX 1000000    /* 1 sec */
+
+    /* Power Management duration & timeout */
+    range->min_pmp = IW_POWER_PERIOD_MIN;
+    range->max_pmp = IW_POWER_PERIOD_MAX;
+    range->min_pmt = IW_POWER_TIMEOUT_MIN;
+    range->max_pmt = IW_POWER_TIMEOUT_MAX;
+    range->pmp_flags = IW_POWER_PERIOD;
+    range->pmt_flags = IW_POWER_TIMEOUT;
+    range->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_ALL_R;
+
+    /*
+     * Minimum version we recommend 
+     */
+    range->we_version_source = 15;
+
+    /*
+     * Version we are compiled with 
+     */
+    range->we_version_compiled = WIRELESS_EXT;
+
+    range->retry_capa = IW_RETRY_LIMIT;
+    range->retry_flags = IW_RETRY_LIMIT | IW_RETRY_MAX;
+
+    range->min_retry = TX_RETRY_MIN;
+    range->max_retry = TX_RETRY_MAX;
+
+    /*
+     * Set the qual, level and noise range values 
+     */
+    /*
+     * need to put the right values here 
+     */
+#define IW_MAX_QUAL_PERCENT 100
+#define IW_AVG_QUAL_PERCENT 70
+    range->max_qual.qual = IW_MAX_QUAL_PERCENT;
+    range->max_qual.level = 0;
+    range->max_qual.noise = 0;
+
+    range->avg_qual.qual = IW_AVG_QUAL_PERCENT;
+    range->avg_qual.level = 0;
+    range->avg_qual.noise = 0;
+
+    range->sensitivity = 0;
+    /*
+     * Setup the supported power level ranges 
+     */
+    memset(range->txpower, 0, sizeof(range->txpower));
+    range->txpower[0] = Adapter->MinTxPowerLevel;
+    range->txpower[1] = Adapter->MaxTxPowerLevel;
+    range->num_txpower = 2;
+    range->txpower_capa = IW_TXPOW_DBM | IW_TXPOW_RANGE;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Set power management 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_power(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    /* PS is currently supported only in Infrastructure Mode 
+     * Remove this check if it is to be supported in IBSS mode also 
+     */
+
+    if (vwrq->disabled) {
+        Adapter->PSMode = Wlan802_11PowerModeCAM;
+        if (Adapter->PSState != PS_STATE_FULL_POWER) {
+            wlan_exit_ps(priv, HostCmd_OPTION_WAITFORRSP);
+        }
+
+        LEAVE();
+        return 0;
+    }
+
+    if ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {
+        PRINTM(INFO, "Setting power timeout command is not supported\n");
+        LEAVE();
+        return -EINVAL;
+    } else if ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_PERIOD) {
+        PRINTM(INFO, "Setting power period command is not supported\n");
+        LEAVE();
+        return -EINVAL;
+    }
+
+    if (Adapter->PSMode != Wlan802_11PowerModeCAM) {
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    Adapter->PSMode = Wlan802_11PowerModeMAX_PSP;
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        wlan_enter_ps(priv, HostCmd_OPTION_WAITFORRSP);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Get power management 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_power(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int mode;
+
+    ENTER();
+
+    mode = Adapter->PSMode;
+
+    if ((vwrq->disabled = (mode == Wlan802_11PowerModeCAM))
+        || Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    vwrq->value = 0;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Set sensitivity threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_sens(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    ENTER();
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Get sensitivity threshold
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_FAILURE
+ */
+static int
+wlan_get_sens(struct net_device *dev,
+              struct iw_request_info *info, struct iw_param *vwrq,
+              char *extra)
+{
+    ENTER();
+    LEAVE();
+    return WLAN_STATUS_FAILURE;
+}
+
+/** 
+ *  @brief  Append/Reset IE buffer. 
+ *   
+ *  Pass an opaque block of data, expected to be IEEE IEs, to the driver 
+ *    for eventual passthrough to the firmware in an associate/join 
+ *    (and potentially start) command.  This function is the main body
+ *    for both wlan_set_gen_ie_ioctl and wlan_set_gen_ie
+ *
+ *  Data is appended to an existing buffer and then wrapped in a passthrough
+ *    TLV in the command API to the firmware.  The firmware treats the data
+ *    as a transparent passthrough to the transmitted management frame.
+ *
+ *  @param Adapter      A pointer to wlan_private structure
+ *  @param ie_data_ptr  A pointer to iwreq structure
+ *  @param ie_len       Length of the IE or IE block passed in ie_data_ptr
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_gen_ie_helper(wlan_private * priv, u8 * ie_data_ptr, u16 ie_len)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    IEEEtypes_VendorHeader_t *pVendorIe;
+    const u8 wpa_oui[] = { 0x00, 0x50, 0xf2, 0x01 };
+
+    ENTER();
+    /* If the passed length is zero, reset the buffer */
+    if (ie_len == 0) {
+        Adapter->genIeBufferLen = 0;
+
+    } else if (ie_data_ptr == NULL) {
+        /* NULL check */
+        ret = -EINVAL;
+    } else {
+
+        pVendorIe = (IEEEtypes_VendorHeader_t *) ie_data_ptr;
+
+        /* Test to see if it is a WPA IE, if not, then it is a gen IE */
+        if ((pVendorIe->ElementId == RSN_IE)
+            || ((pVendorIe->ElementId == WPA_IE)
+                && (memcmp(pVendorIe->Oui, wpa_oui, sizeof(wpa_oui)) == 0))) {
+
+            /* IE is a WPA/WPA2 IE so call set_wpa function */
+            ret = wlan_set_wpa_ie_helper(priv, ie_data_ptr, ie_len);
+        } else {
+            /* 
+             * Verify that the passed length is not larger than the available 
+             *   space remaining in the buffer
+             */
+            if (ie_len < (sizeof(Adapter->genIeBuffer)
+                          - Adapter->genIeBufferLen)) {
+
+                /* Append the passed data to the end of the genIeBuffer */
+                if (copy_from_user((Adapter->genIeBuffer
+                                    + Adapter->genIeBufferLen),
+                                   ie_data_ptr, ie_len)) {
+                    PRINTM(INFO, "Copy from user failed\n");
+                    ret = -EFAULT;
+
+                } else {
+                    /* Increment the stored buffer length by the size passed */
+                    Adapter->genIeBufferLen += ie_len;
+                }
+
+            } else {
+                /* Passed data does not fit in the remaining buffer space */
+                ret = WLAN_STATUS_FAILURE;
+            }
+        }
+    }
+
+    /* Return WLAN_STATUS_SUCCESS, or < 0 for error case */
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief  Get IE buffer from driver 
+ *   
+ *  Used to pass an opaque block of data, expected to be IEEE IEs,
+ *    back to the application.  Currently the data block passed
+ *    back to the application is the saved association response retrieved 
+ *    from the firmware.
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param ie_data_ptr  A pointer to the IE or IE block
+ *  @param ie_len_ptr   In/Out parameter pointer for the buffer length passed 
+ *                      in ie_data_ptr and the resulting data length copied
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_gen_ie_helper(wlan_private * priv,
+                       u8 * ie_data_ptr, u16 * ie_len_ptr)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    IEEEtypes_AssocRsp_t *pAssocRsp;
+    int copySize;
+
+    ENTER();
+
+    pAssocRsp = (IEEEtypes_AssocRsp_t *) Adapter->assocRspBuffer;
+
+    /*
+     * Set the amount to copy back to the application as the minimum of the 
+     *   available IE data or the buffer provided by the application
+     */
+    copySize = (Adapter->assocRspSize - sizeof(pAssocRsp->Capability) -
+                -sizeof(pAssocRsp->StatusCode) - sizeof(pAssocRsp->AId));
+    copySize = MIN(copySize, *ie_len_ptr);
+
+    /* Copy the IEEE TLVs in the assoc response back to the application */
+    if (copy_to_user(ie_data_ptr, (u8 *) pAssocRsp->IEBuffer, copySize)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    /* Returned copy length */
+    *ie_len_ptr = copySize;
+
+    /* No error on return */
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+#if (WIRELESS_EXT >= 18)
+/** 
+ *  @brief  Set IE 
+ *
+ *  Calls main function set_gen_ie_fuct that adds the inputted IE
+ *    to the genie buffer
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_gen_ie(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_point *dwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+    ret = wlan_set_gen_ie_helper(dev->priv, dwrq->pointer, dwrq->length);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief  Get IE 
+ *
+ *  Calls main function get_gen_ie_fuct that retrieves expected IEEE IEs
+ *    and places then in the iw_point structure
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_gen_ie(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_point *dwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+    ret = wlan_get_gen_ie_helper(dev->priv, dwrq->pointer, &dwrq->length);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set authentication mode
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_setauthalg(wlan_private * priv, int alg)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, "auth alg is %#x\n", alg);
+
+    switch (alg) {
+    case IW_AUTH_ALG_SHARED_KEY:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeShared;
+        break;
+    case IW_AUTH_ALG_LEAP:
+        //clear WPA IE
+        wlan_set_wpa_ie_helper(priv, NULL, 0);
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeNetworkEAP;
+        break;
+    case IW_AUTH_ALG_OPEN_SYSTEM:
+    default:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief set authentication mode params
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_auth(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+    switch (vwrq->flags & IW_AUTH_INDEX) {
+    case IW_AUTH_CIPHER_PAIRWISE:
+    case IW_AUTH_CIPHER_GROUP:
+        if (vwrq->value & IW_AUTH_CIPHER_NONE)
+            priv->adapter->SecInfo.EncryptionMode = CIPHER_NONE;
+        else if (vwrq->value & IW_AUTH_CIPHER_WEP40)
+            priv->adapter->SecInfo.EncryptionMode = CIPHER_WEP40;
+        else if (vwrq->value & IW_AUTH_CIPHER_TKIP)
+            priv->adapter->SecInfo.EncryptionMode = CIPHER_TKIP;
+        else if (vwrq->value & IW_AUTH_CIPHER_CCMP)
+            priv->adapter->SecInfo.EncryptionMode = CIPHER_CCMP;
+        else if (vwrq->value & IW_AUTH_CIPHER_WEP104)
+            priv->adapter->SecInfo.EncryptionMode = CIPHER_WEP104;
+        break;
+    case IW_AUTH_80211_AUTH_ALG:
+        wlan_setauthalg(priv, vwrq->value);
+        break;
+    case IW_AUTH_WPA_ENABLED:
+        if (vwrq->value == FALSE)
+            wlan_set_wpa_ie_helper(priv, NULL, 0);
+        break;
+    case IW_AUTH_WPA_VERSION:
+    case IW_AUTH_KEY_MGMT:
+    case IW_AUTH_TKIP_COUNTERMEASURES:
+    case IW_AUTH_DROP_UNENCRYPTED:
+    case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+    case IW_AUTH_ROAMING_CONTROL:
+    case IW_AUTH_PRIVACY_INVOKED:
+    default:
+        break;
+    }
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  get authentication mode params 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_auth(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+    ENTER();
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+    switch (vwrq->flags & IW_AUTH_INDEX) {
+    case IW_AUTH_CIPHER_PAIRWISE:
+    case IW_AUTH_CIPHER_GROUP:
+        if (priv->adapter->SecInfo.EncryptionMode == CIPHER_NONE)
+            vwrq->value = IW_AUTH_CIPHER_NONE;
+        else if (priv->adapter->SecInfo.EncryptionMode == CIPHER_WEP40)
+            vwrq->value = IW_AUTH_CIPHER_WEP40;
+        else if (priv->adapter->SecInfo.EncryptionMode == CIPHER_TKIP)
+            vwrq->value = IW_AUTH_CIPHER_TKIP;
+        else if (priv->adapter->SecInfo.EncryptionMode == CIPHER_CCMP)
+            vwrq->value = IW_AUTH_CIPHER_CCMP;
+        else if (priv->adapter->SecInfo.EncryptionMode == CIPHER_WEP104)
+            vwrq->value = IW_AUTH_CIPHER_WEP104;
+        break;
+    case IW_AUTH_80211_AUTH_ALG:
+        if (Adapter->SecInfo.AuthenticationMode == Wlan802_11AuthModeShared)
+            vwrq->value = IW_AUTH_ALG_SHARED_KEY;
+        else if (Adapter->SecInfo.AuthenticationMode ==
+                 Wlan802_11AuthModeNetworkEAP)
+            vwrq->value = IW_AUTH_ALG_LEAP;
+        else
+            vwrq->value = IW_AUTH_ALG_OPEN_SYSTEM;
+        break;
+    case IW_AUTH_WPA_ENABLED:
+        if (Adapter->Wpa_ie_len > 0)
+            vwrq->value = TRUE;
+        else
+            vwrq->value = FALSE;
+        break;
+    case IW_AUTH_WPA_VERSION:
+    case IW_AUTH_KEY_MGMT:
+    case IW_AUTH_TKIP_COUNTERMEASURES:
+    case IW_AUTH_DROP_UNENCRYPTED:
+    case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+    case IW_AUTH_ROAMING_CONTROL:
+    case IW_AUTH_PRIVACY_INVOKED:
+    default:
+        ret = -EOPNOTSUPP;
+        break;
+    }
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief  Request MLME operation 
+ *
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_mlme(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_point *dwrq, char *extra)
+{
+    struct iw_mlme *mlme = (struct iw_mlme *) extra;
+    wlan_private *priv = dev->priv;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+    if ((mlme->cmd == IW_MLME_DEAUTH) || (mlme->cmd == IW_MLME_DISASSOC)) {
+        wlan_disconnect(priv);
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Extended version of encoding configuration 
+ *
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_encode_ext(struct net_device *dev,
+                    struct iw_request_info *info,
+                    struct iw_point *dwrq, char *extra)
+{
+    struct iw_encode_ext *ext = (struct iw_encode_ext *) extra;
+    wlan_private *priv = dev->priv;
+    WLAN_802_11_KEY *pkey;
+    int keyindex;
+    u8 *pKeyMaterial = NULL;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+    keyindex = dwrq->flags & IW_ENCODE_INDEX;
+    if (keyindex > 4) {
+        LEAVE();
+        return -EINVAL;
+    }
+    if (ext->key_len > (dwrq->length - sizeof(struct iw_encode_ext))) {
+        LEAVE();
+        return -EINVAL;
+    }
+    pKeyMaterial = (u8 *) (ext + 1);
+    //Disable Key
+    if ((dwrq->flags & IW_ENCODE_DISABLED) && (ext->key_len == 0)) {
+        dwrq->length = 0;
+        wlan_set_encode_nonwpa(dev, info, dwrq, extra);
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+    //Set WEP key
+    if (ext->key_len <= MAX_WEP_KEY_SIZE) {
+        dwrq->length = ext->key_len;
+        wlan_set_encode_nonwpa(dev, info, dwrq, pKeyMaterial);
+        if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+            dwrq->length = 0;
+            wlan_set_encode_nonwpa(dev, info, dwrq, extra);
+        }
+    } else {
+        pkey = kmalloc(sizeof(WLAN_802_11_KEY) + ext->key_len, GFP_KERNEL);
+        if (!pkey) {
+            PRINTM(INFO, "allocate key buffer failed!\n");
+            LEAVE();
+            return -ENOMEM;
+        }
+        memset(pkey, 0, sizeof(WLAN_802_11_KEY) + ext->key_len);
+        memcpy((u8 *) pkey->BSSID, (u8 *) ext->addr.sa_data, ETH_ALEN);
+        pkey->KeyLength = ext->key_len;
+        memcpy(pkey->KeyMaterial, pKeyMaterial, ext->key_len);
+        pkey->KeyIndex = keyindex - 1;
+        if (pkey->KeyIndex == 0)
+            pkey->KeyIndex = 0x40000000;
+        if (ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)
+            memcpy((u8 *) & pkey->KeyRSC, ext->rx_seq,
+                   IW_ENCODE_SEQ_MAX_SIZE);
+        pkey->Length = sizeof(WLAN_802_11_KEY) + ext->key_len;
+        wlan_set_encode_wpa(dev, info, dwrq, (u8 *) pkey);
+        kfree(pkey);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief  Extended version of encoding configuration 
+ *
+ *   
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_encode_ext(struct net_device *dev,
+                    struct iw_request_info *info,
+                    struct iw_point *dwrq, char *extra)
+{
+    ENTER();
+    LEAVE();
+    return -EOPNOTSUPP;
+}
+#endif /* #if (WIRELESS_EXT >= 18) */
+
+/** 
+ *  @brief  Append/Reset IE buffer. 
+ *   
+ *  Pass an opaque block of data, expected to be IEEE IEs, to the driver 
+ *    for eventual passthrough to the firmware in an associate/join 
+ *    (and potentially start) command.
+ *
+ *  Data is appended to an existing buffer and then wrapped in a passthrough
+ *    TLV in the command API to the firmware.  The firmware treats the data
+ *    as a transparent passthrough to the transmitted management frame.
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure    
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_gen_ie_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+    ret = wlan_set_gen_ie_helper(priv,
+                                 wrq->u.data.pointer, wrq->u.data.length);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief  Get IE buffer from driver 
+ *   
+ *  Used to pass an opaque block of data, expected to be IEEE IEs,
+ *    back to the application.  Currently the data block passed
+ *    back to the application is the saved association response retrieved 
+ *    from the firmware.
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure
+ *
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_gen_ie_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+    ret = wlan_get_gen_ie_helper(priv,
+                                 wrq->u.data.pointer, &wrq->u.data.length);
+    LEAVE();
+    return ret;
+}
+
+/*
+ * iwconfig settable callbacks 
+ */
+static const iw_handler wlan_handler[] = {
+    (iw_handler) wlan_config_commit,    /* SIOCSIWCOMMIT */
+    (iw_handler) wlan_get_name, /* SIOCGIWNAME */
+    (iw_handler) NULL,          /* SIOCSIWNWID */
+    (iw_handler) NULL,          /* SIOCGIWNWID */
+    (iw_handler) wlan_set_freq, /* SIOCSIWFREQ */
+    (iw_handler) wlan_get_freq, /* SIOCGIWFREQ */
+    (iw_handler) wlan_set_mode, /* SIOCSIWMODE */
+    (iw_handler) wlan_get_mode, /* SIOCGIWMODE */
+    (iw_handler) wlan_set_sens, /* SIOCSIWSENS */
+    (iw_handler) wlan_get_sens, /* SIOCGIWSENS */
+    (iw_handler) NULL,          /* SIOCSIWRANGE */
+    (iw_handler) wlan_get_range,        /* SIOCGIWRANGE */
+    (iw_handler) NULL,          /* SIOCSIWPRIV */
+    (iw_handler) NULL,          /* SIOCGIWPRIV */
+    (iw_handler) NULL,          /* SIOCSIWSTATS */
+    (iw_handler) NULL,          /* SIOCGIWSTATS */
+#if WIRELESS_EXT > 15
+    iw_handler_set_spy,         /* SIOCSIWSPY */
+    iw_handler_get_spy,         /* SIOCGIWSPY */
+    iw_handler_set_thrspy,      /* SIOCSIWTHRSPY */
+    iw_handler_get_thrspy,      /* SIOCGIWTHRSPY */
+#else /* WIRELESS_EXT > 15 */
+#ifdef WIRELESS_SPY
+    (iw_handler) wlan_set_spy,  /* SIOCSIWSPY */
+    (iw_handler) wlan_get_spy,  /* SIOCGIWSPY */
+#else /* WIRELESS_SPY */
+    (iw_handler) NULL,          /* SIOCSIWSPY */
+    (iw_handler) NULL,          /* SIOCGIWSPY */
+#endif /* WIRELESS_SPY */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) NULL,          /* -- hole -- */
+#endif /* WIRELESS_EXT > 15 */
+    (iw_handler) wlan_set_wap,  /* SIOCSIWAP */
+    (iw_handler) wlan_get_wap,  /* SIOCGIWAP */
+#if WIRELESS_EXT >= 18
+    (iw_handler) wlan_set_mlme, /* SIOCSIWMLME  */
+#else
+    (iw_handler) NULL,          /* -- hole -- */
+#endif
+    //(iw_handler) wlan_get_aplist,         /* SIOCGIWAPLIST */
+    NULL,                       /* SIOCGIWAPLIST */
+#if WIRELESS_EXT > 13
+    (iw_handler) wlan_set_scan, /* SIOCSIWSCAN */
+    (iw_handler) wlan_get_scan, /* SIOCGIWSCAN */
+#else /* WIRELESS_EXT > 13 */
+    (iw_handler) NULL,          /* SIOCSIWSCAN */
+    (iw_handler) NULL,          /* SIOCGIWSCAN */
+#endif /* WIRELESS_EXT > 13 */
+    (iw_handler) wlan_set_essid,        /* SIOCSIWESSID */
+    (iw_handler) wlan_get_essid,        /* SIOCGIWESSID */
+    (iw_handler) wlan_set_nick, /* SIOCSIWNICKN */
+    (iw_handler) wlan_get_nick, /* SIOCGIWNICKN */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) wlan_set_rate, /* SIOCSIWRATE */
+    (iw_handler) wlan_get_rate, /* SIOCGIWRATE */
+    (iw_handler) wlan_set_rts,  /* SIOCSIWRTS */
+    (iw_handler) wlan_get_rts,  /* SIOCGIWRTS */
+    (iw_handler) wlan_set_frag, /* SIOCSIWFRAG */
+    (iw_handler) wlan_get_frag, /* SIOCGIWFRAG */
+    (iw_handler) wlan_set_txpow,        /* SIOCSIWTXPOW */
+    (iw_handler) wlan_get_txpow,        /* SIOCGIWTXPOW */
+    (iw_handler) wlan_set_retry,        /* SIOCSIWRETRY */
+    (iw_handler) wlan_get_retry,        /* SIOCGIWRETRY */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) wlan_get_encode,       /* SIOCGIWENCODE */
+    (iw_handler) wlan_set_power,        /* SIOCSIWPOWER */
+    (iw_handler) wlan_get_power,        /* SIOCGIWPOWER */
+#if (WIRELESS_EXT >= 18)
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) NULL,          /* -- hole -- */
+    (iw_handler) wlan_set_gen_ie,       /* SIOCSIWGENIE */
+    (iw_handler) wlan_get_gen_ie,       /* SIOCGIWGENIE */
+    (iw_handler) wlan_set_auth, /* SIOCSIWAUTH  */
+    (iw_handler) wlan_get_auth, /* SIOCGIWAUTH  */
+    (iw_handler) wlan_set_encode_ext,   /* SIOCSIWENCODEEXT */
+    (iw_handler) wlan_get_encode_ext,   /* SIOCGIWENCODEEXT */
+#endif /* WIRELESSS_EXT >= 18 */
+};
+
+/*
+ * iwpriv settable callbacks 
+ */
+
+static const iw_handler wlan_private_handler[] = {
+    NULL,                       /* SIOCIWFIRSTPRIV */
+};
+
+static const struct iw_priv_args wlan_private_args[] = {
+    /*
+     * { cmd, set_args, get_args, name } 
+     */
+    {
+     WLANEXTSCAN,
+     IW_PRIV_TYPE_INT,
+     IW_PRIV_TYPE_CHAR | 2,
+     "extscan"},
+    {
+     WLANHOSTCMD,
+     IW_PRIV_TYPE_BYTE | 2047,
+     IW_PRIV_TYPE_BYTE | 2047,
+     "hostcmd"},
+    {
+     WLANARPFILTER,
+     IW_PRIV_TYPE_BYTE | 2047,
+     IW_PRIV_TYPE_BYTE | 2047,
+     "arpfilter"},
+    {
+     WLANREGRDWR,
+     IW_PRIV_TYPE_CHAR | 256,
+     IW_PRIV_TYPE_CHAR | 256,
+     "regrdwr"},
+    {
+     WLANCMD52RDWR,
+     IW_PRIV_TYPE_BYTE | 7,
+     IW_PRIV_TYPE_BYTE | 7,
+     "sdcmd52rw"},
+    {
+     WLANCMD53RDWR,
+     IW_PRIV_TYPE_CHAR | CMD53BUFLEN,
+     IW_PRIV_TYPE_CHAR | CMD53BUFLEN,
+     "sdcmd53rw"},
+    {
+     WLAN_SETCONF_GETCONF,
+     IW_PRIV_TYPE_BYTE | MAX_SETGET_CONF_SIZE,
+     IW_PRIV_TYPE_BYTE | MAX_SETGET_CONF_SIZE,
+     "setgetconf"},
+    {
+     WLANCISDUMP,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_BYTE | 512,
+     "getcis"},
+    {
+     WLANSCAN_TYPE,
+     IW_PRIV_TYPE_CHAR | 8,
+     IW_PRIV_TYPE_CHAR | 8,
+     "scantype"},
+    {
+     WLAN_SETADDR_GETNONE,
+     IW_PRIV_TYPE_ADDR | 1,
+     IW_PRIV_TYPE_NONE,
+     ""},
+    {
+     WLANDEAUTH,
+     IW_PRIV_TYPE_ADDR | 1,
+     IW_PRIV_TYPE_NONE,
+     "deauth"},
+    {
+     WLAN_SETINT_GETINT,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     ""},
+    {
+     WLANNF,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getNF"},
+    {
+     WLANRSSI,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getRSSI"},
+    {
+     WLANBGSCAN,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "bgscan"},
+    {
+     WLANENABLE11D,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "enable11d"},
+    {
+     WLANADHOCGRATE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "adhocgrate"},
+    {
+     WLANSDIOCLOCK,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "sdioclock"},
+    {
+     WLANWMM_ENABLE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "wmm"},
+    {
+     WLANNULLGEN,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "uapsdnullgen"},
+    {
+     WLANADHOCCSET,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "setcoalescing"},
+    {
+     WLAN_ADHOC_G_PROT,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "adhocgprot"},
+    {
+     WLAN_SETONEINT_GETONEINT,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     ""},
+    {
+     WLAN_11H_SETLOCALPOWER,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "setpowercons"},
+    {
+     WLAN_WMM_QOSINFO,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "wmm_qosinfo"},
+    {
+     WLAN_LISTENINTRVL,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "lolisteninter"},
+    {
+     WLAN_FW_WAKEUP_METHOD,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "fwwakeupmethod"},
+    {
+     WLAN_NULLPKTINTERVAL,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "psnullinterval"},
+    {
+     WLAN_BCN_MISS_TIMEOUT,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "bcnmisto"},
+    {
+     WLAN_ADHOC_AWAKE_PERIOD,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "adhocawakepd"},
+    {
+     WLAN_MODULE_TYPE,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "moduletype"},
+    {
+     WLAN_AUTODEEPSLEEP,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "autodeepsleep"},
+    {
+     WLAN_ENHANCEDPS,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "enhanceps"},
+    {
+     WLAN_WAKEUP_MT,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_INT | 1,
+     "wakeupmt"},
+
+    /* Using iwpriv sub-command feature */
+    {
+     WLAN_SETONEINT_GETNONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     ""},
+    {
+     WLAN_SUBCMD_SETRXANTENNA,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setrxant"},
+    {
+     WLAN_SUBCMD_SETTXANTENNA,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "settxant"},
+    {
+     WLANSETAUTHALG,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "authalgs",
+     },
+    {
+     WLANSETENCRYPTIONMODE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "encryptionmode",
+     },
+    {
+     WLANSETREGION,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setregioncode"},
+    {
+     WLAN_SET_LISTEN_INTERVAL,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setlisteninter"},
+    {
+     WLAN_SET_MULTIPLE_DTIM,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setmultipledtim"},
+    {
+     WLANSETBCNAVG,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setbcnavg"},
+    {
+     WLANSETDATAAVG,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "setdataavg"},
+    {
+     WLANASSOCIATE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     IW_PRIV_TYPE_NONE,
+     "associate"},
+    {
+     WLAN_SETNONE_GETONEINT,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     ""},
+    {
+     WLANGETREGION,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getregioncode"},
+    {
+     WLAN_GET_LISTEN_INTERVAL,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getlisteninter"},
+    {
+     WLAN_GET_MULTIPLE_DTIM,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getmultipledtim"},
+    {
+     WLAN_GET_TX_RATE,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "gettxrate"},
+    {
+     WLANGETBCNAVG,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getbcnavg"},
+    {
+     WLANGETDATAAVG,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+     "getdataavg"},
+    {
+     WLAN_SETNONE_GETTWELVE_CHAR,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     ""},
+    {
+     WLAN_SUBCMD_GETRXANTENNA,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     "getrxant"},
+    {
+     WLAN_SUBCMD_GETTXANTENNA,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     "gettxant"},
+    {
+     WLAN_GET_TSF,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     "gettsf"},
+    {
+     WLAN_WPS_SESSION,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 12,
+     "wpssession"},
+    {
+     WLANDEEPSLEEP,
+     IW_PRIV_TYPE_CHAR | 1,
+     IW_PRIV_TYPE_CHAR | 6,
+     "deepsleep"},
+    {
+     WLAN_SETNONE_GETNONE,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     ""},
+    {
+     WLANADHOCSTOP,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "adhocstop"},
+    {
+     WLANRADIOON,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "radioon"},
+    {
+     WLANRADIOOFF,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "radiooff"},
+    {
+     WLANREMOVEADHOCAES,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "rmaeskey"},
+    {
+     WLANCRYPTOTEST,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "crypto_test"},
+#ifdef REASSOCIATION
+    {
+     WLANREASSOCIATIONAUTO,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "reasso-on"},
+    {
+     WLANREASSOCIATIONUSER,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "reasso-off"},
+#endif /* REASSOCIATION */
+    {
+     WLANWLANIDLEON,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "wlanidle-on"},
+    {
+     WLANWLANIDLEOFF,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_NONE,
+     "wlanidle-off"},
+    {
+     WLAN_SET64CHAR_GET64CHAR,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     ""},
+    {
+     WLANSLEEPPARAMS,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "sleepparams"},
+
+    {
+     WLAN_11H_REQUESTTPC,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "requesttpc"},
+    {
+     WLAN_11H_SETPOWERCAP,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "powercap"},
+    {
+     WLAN_MEASREQ,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "measreq"},
+    {
+     WLAN_BCA_TIMESHARE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "bca-ts"},
+    {
+     WLANSCAN_MODE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "scanmode"},
+    {
+     WLAN_GET_ADHOC_STATUS,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "getadhocstatus"},
+    {
+     WLAN_SET_GEN_IE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "setgenie"},
+    {
+     WLAN_GET_GEN_IE,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "getgenie"},
+    {
+     WLAN_WMM_QUEUE_STATUS,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "qstatus"},
+    {
+     WLAN_WMM_TS_STATUS,
+     IW_PRIV_TYPE_CHAR | 64,
+     IW_PRIV_TYPE_CHAR | 64,
+     "ts_status"},
+    {
+     WLAN_SETWORDCHAR_GETNONE,
+     IW_PRIV_TYPE_CHAR | 32,
+     IW_PRIV_TYPE_NONE,
+     ""},
+    {
+     WLANSETADHOCAES,
+     IW_PRIV_TYPE_CHAR | 32,
+     IW_PRIV_TYPE_NONE,
+     "setaeskey"},
+    {
+     WLAN_SETONEINT_GETWORDCHAR,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_CHAR | 128,
+     ""},
+    {
+     WLANGETADHOCAES,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_CHAR | 128,
+     "getaeskey"},
+    {
+     WLANVERSION,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_CHAR | 128,
+     "version"},
+    {
+     WLANVEREXT,
+     IW_PRIV_TYPE_INT | 1,
+     IW_PRIV_TYPE_CHAR | 128,
+     "verext"},
+    {
+     WLANSETWPAIE,
+     IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | 24,
+     IW_PRIV_TYPE_NONE,
+     "setwpaie"},
+    {
+     WLAN_SETTENCHAR_GETNONE,
+     IW_PRIV_TYPE_CHAR | 10,
+     IW_PRIV_TYPE_NONE,
+     ""},
+    {
+     WLAN_SET_BAND,
+     IW_PRIV_TYPE_CHAR | 10,
+     IW_PRIV_TYPE_NONE,
+     "setband"},
+    {
+     WLAN_SET_ADHOC_CH,
+     IW_PRIV_TYPE_CHAR | 10,
+     IW_PRIV_TYPE_NONE,
+     "setadhocch"},
+    {
+     WLAN_11H_CHANSWANN,
+     IW_PRIV_TYPE_CHAR | 10,
+     IW_PRIV_TYPE_NONE,
+     "chanswann"},
+    {
+     WLAN_SETNONE_GETTENCHAR,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 10,
+     ""},
+    {
+     WLAN_GET_BAND,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 10,
+     "getband"},
+    {
+     WLAN_GET_ADHOC_CH,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | 10,
+     "getadhocch"},
+    {
+     WLANGETLOG,
+     IW_PRIV_TYPE_NONE,
+     IW_PRIV_TYPE_CHAR | GETLOG_BUFSIZE,
+     "getlog"},
+    {
+     WLAN_SET_GET_SIXTEEN_INT,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     ""},
+    {
+     WLAN_TPCCFG,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "tpccfg"},
+    {
+     WLAN_SCANPROBES,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "scanprobes"},
+    {
+     WLAN_LED_GPIO_CTRL,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "ledgpio"},
+    {
+     WLAN_SLEEP_PERIOD,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "sleeppd"},
+    {
+     WLAN_ADAPT_RATESET,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "rateadapt"},
+
+    {
+     WLAN_INACTIVITY_TIMEOUT,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "inactivityto"},
+    {
+     WLANSNR,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "getSNR"},
+    {
+     WLAN_GET_RATE,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "getrate"},
+    {
+     WLAN_GET_RXINFO,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "getrxinfo"},
+    {
+     WLAN_SET_ATIM_WINDOW,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "atimwindow"},
+    {
+     WLAN_BEACON_INTERVAL,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "bcninterval"},
+    {
+     WLAN_SDIO_PULL_CTRL,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "sdiopullctrl"},
+    {
+     WLAN_SCAN_TIME,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "scantime"},
+    {
+     WLAN_ECL_SYS_CLOCK,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "sysclock"},
+    {
+     WLAN_TXCONTROL,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "txcontrol"},
+    {
+     WLANHSCFG,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "hscfg"},
+    {
+     WLANHSSETPARA,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "hssetpara"},
+    {
+     WLANDBGSCFG,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "dbgscfg"},
+#ifdef DEBUG_LEVEL1
+    {
+     WLAN_DRV_DBG,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "drvdbg"},
+#endif
+    {
+     WLAN_DRV_DELAY_MAX,
+     IW_PRIV_TYPE_INT | 16,
+     IW_PRIV_TYPE_INT | 16,
+     "drvdelaymax"},
+    {
+     WLAN_SET_GET_2K,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     ""},
+    {
+     WLAN_SET_USER_SCAN,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "setuserscan"},
+    {
+     WLAN_GET_SCAN_TABLE,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "getscantable"},
+    {
+     WLAN_SET_MRVL_TLV,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "setmrvltlv"},
+    {
+     WLAN_GET_ASSOC_RSP,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "getassocrsp"},
+    {
+     WLAN_ADDTS_REQ,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "addts"},
+    {
+     WLAN_DELTS_REQ,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "delts"},
+    {
+     WLAN_QUEUE_CONFIG,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "qconfig"},
+    {
+     WLAN_QUEUE_STATS,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "qstats"},
+    {
+     WLAN_TX_PKT_STATS,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "txpktstats"},
+    {
+     WLAN_GET_CFP_TABLE,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "getcfptable"},
+    {
+     WLAN_MEF_CFG,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "mefcfg"},
+    {
+     WLAN_GET_MEM,
+     IW_PRIV_TYPE_BYTE | 2000,
+     IW_PRIV_TYPE_BYTE | 2000,
+     "getmem"},
+};
+
+/** wlan_handler_def */
+struct iw_handler_def wlan_handler_def = {
+  num_standard:sizeof(wlan_handler) / sizeof(iw_handler),
+  num_private:sizeof(wlan_private_handler) / sizeof(iw_handler),
+  num_private_args:sizeof(wlan_private_args) /
+        sizeof(struct iw_priv_args),
+  standard:(iw_handler *) wlan_handler,
+  private:(iw_handler *) wlan_private_handler,
+  private_args:(struct iw_priv_args *) wlan_private_args,
+#if WIRELESS_EXT > 20
+  get_wireless_stats:wlan_get_wireless_stats,
+#endif
+};
+
+/** 
+ *  @brief wlan hostcmd ioctl handler
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param req		        A pointer to ifreq structure
+ *  @param cmd			command 
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_hostcmd_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+    u8 *tempResponseBuffer;
+    CmdCtrlNode *pCmdNode;
+    HostCmd_DS_GEN *pCmdPtr;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    u16 wait_option = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    if ((wrq->u.data.pointer == NULL) || (wrq->u.data.length < S_DS_GEN)) {
+        PRINTM(INFO,
+               "wlan_hostcmd_ioctl() corrupt data: pointer=%p, length=%d\n",
+               wrq->u.data.pointer, wrq->u.data.length);
+        LEAVE();
+        return -EFAULT;
+    }
+
+    /*
+     * Get a free command control node 
+     */
+    if (!(pCmdNode = wlan_get_cmd_node(priv))) {
+        PRINTM(INFO, "Failed wlan_get_cmd_node\n");
+        LEAVE();
+        return -ENOMEM;
+    }
+
+    if (!
+        (tempResponseBuffer =
+         kmalloc(MRVDRV_SIZE_OF_CMD_BUFFER, GFP_KERNEL))) {
+        PRINTM(INFO, "ERROR: Failed to allocate response buffer!\n");
+        wlan_insert_cmd_to_free_q(priv, pCmdNode);
+        LEAVE();
+        return -ENOMEM;
+    }
+
+    wait_option |= HostCmd_OPTION_WAITFORRSP;
+
+    wlan_init_cmd_node(priv, pCmdNode, 0, wait_option, NULL);
+    init_waitqueue_head(&pCmdNode->cmdwait_q);
+
+    pCmdPtr = (HostCmd_DS_GEN *) pCmdNode->BufVirtualAddr;
+
+    /*
+     * Copy the whole command into the command buffer 
+     */
+    if (copy_from_user(pCmdPtr, wrq->u.data.pointer, wrq->u.data.length)) {
+        PRINTM(INFO, "Copy from user failed\n");
+        kfree(tempResponseBuffer);
+        wlan_insert_cmd_to_free_q(priv, pCmdNode);
+        LEAVE();
+        return -EFAULT;
+    }
+
+    if (pCmdPtr->Size < S_DS_GEN) {
+        PRINTM(INFO, "wlan_hostcmd_ioctl() invalid cmd size: Size=%d\n",
+               pCmdPtr->Size);
+        kfree(tempResponseBuffer);
+        wlan_insert_cmd_to_free_q(priv, pCmdNode);
+        LEAVE();
+        return -EFAULT;
+    }
+
+    pCmdNode->pdata_buf = tempResponseBuffer;
+    pCmdNode->CmdFlags |= CMD_F_HOSTCMD;
+
+    pCmdPtr->Result = 0;
+
+    PRINTM(INFO, "HOSTCMD Command: 0x%04x Size: %d\n",
+           pCmdPtr->Command, pCmdPtr->Size);
+    HEXDUMP("Command Data", (u8 *) (pCmdPtr), MIN(32, pCmdPtr->Size));
+    PRINTM(INFO, "Copying data from : (user)0x%p -> 0x%p(driver)\n",
+           req->ifr_data, pCmdPtr);
+
+    pCmdNode->CmdWaitQWoken = FALSE;
+    pCmdPtr->Command = wlan_cpu_to_le16(pCmdPtr->Command);
+    pCmdPtr->Size = wlan_cpu_to_le16(pCmdPtr->Size);
+    wlan_insert_cmd_to_pending_q(Adapter, pCmdNode, TRUE);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+    if (wait_option & HostCmd_OPTION_WAITFORRSP) {
+        /* Sleep until response is generated by FW */
+        wait_event_interruptible(pCmdNode->cmdwait_q,
+                                 pCmdNode->CmdWaitQWoken);
+    }
+
+    /* Copy the response back to user space */
+    pCmdPtr = (HostCmd_DS_GEN *) tempResponseBuffer;
+
+    if (copy_to_user(wrq->u.data.pointer, tempResponseBuffer, pCmdPtr->Size))
+        PRINTM(INFO, "ERROR: copy_to_user failed!\n");
+    wrq->u.data.length = pCmdPtr->Size;
+    kfree(tempResponseBuffer);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief wlan arpfilter ioctl handler
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param req		        A pointer to ifreq structure
+ *  @param cmd			command 
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_arpfilter_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+    wlan_private *priv = dev->priv;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+    MrvlIEtypesHeader_t hdr;
+
+    ENTER();
+
+    if ((wrq->u.data.pointer == NULL)
+        || (wrq->u.data.length < sizeof(MrvlIEtypesHeader_t))
+        || (wrq->u.data.length > sizeof(Adapter->ArpFilter))) {
+        PRINTM(INFO,
+               "wlan_arpfilter_ioctl() corrupt data: pointer=%p, length=%d\n",
+               wrq->u.data.pointer, wrq->u.data.length);
+        LEAVE();
+        return -EFAULT;
+    }
+
+    if (copy_from_user(&hdr, wrq->u.data.pointer, sizeof(hdr))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    if (hdr.Len == 0) {
+        Adapter->ArpFilterSize = 0;
+        memset(Adapter->ArpFilter, 0, sizeof(Adapter->ArpFilter));
+    } else {
+        Adapter->ArpFilterSize = wrq->u.data.length;
+
+        PRINTM(INFO, "Copying data from : (user)0x%p -> 0x%p(driver)\n",
+               wrq->u.data.pointer, Adapter->ArpFilter);
+        if (copy_from_user(Adapter->ArpFilter, wrq->u.data.pointer,
+                           Adapter->ArpFilterSize)) {
+            Adapter->ArpFilterSize = 0;
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+        HEXDUMP("ArpFilter", Adapter->ArpFilter, Adapter->ArpFilterSize);
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Rx Info 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success
+ */
+static int
+wlan_get_rxinfo(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data[2];
+    ENTER();
+    data[0] = Adapter->SNR[TYPE_RXPD][TYPE_NOAVG];
+    data[1] = Adapter->RxPDRate;
+    if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 2)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    wrq->u.data.length = 2;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get SNR 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_snr(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    int data[4];
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+        PRINTM(INFO, "Can not get SNR in disconnected state\n");
+        LEAVE();
+        return -ENOTSUPP;
+    }
+
+    memset(data, 0, sizeof(data));
+    if (wrq->u.data.length) {
+        if (copy_from_user
+            (data, wrq->u.data.pointer,
+             MIN(wrq->u.data.length, 4) * sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    }
+    if ((wrq->u.data.length == 0) || (data[0] == 0) || (data[0] == 1)) {
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_RSSI,
+                               0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    }
+
+    if (wrq->u.data.length == 0) {
+        data[0] = Adapter->SNR[TYPE_BEACON][TYPE_NOAVG];
+        data[1] = Adapter->SNR[TYPE_BEACON][TYPE_AVG];
+        if ((jiffies - Adapter->RxPDAge) > HZ)  //data expired after 1 second
+            data[2] = 0;
+        else
+            data[2] = Adapter->SNR[TYPE_RXPD][TYPE_NOAVG];
+        data[3] = Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE;
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 4)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        wrq->u.data.length = 4;
+    } else if (data[0] == 0) {
+        data[0] = Adapter->SNR[TYPE_BEACON][TYPE_NOAVG];
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    } else if (data[0] == 1) {
+        data[0] = Adapter->SNR[TYPE_BEACON][TYPE_AVG];
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    } else if (data[0] == 2) {
+        if ((jiffies - Adapter->RxPDAge) > HZ)  //data expired after 1 second
+            data[0] = 0;
+        else
+            data[0] = Adapter->SNR[TYPE_RXPD][TYPE_NOAVG];
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    } else if (data[0] == 3) {
+        data[0] = Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE;
+        if (copy_to_user(wrq->u.data.pointer, data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    } else {
+        LEAVE();
+        return -ENOTSUPP;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set SDIO PULL CTRL 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_sdio_pull_ctrl(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[2];
+    HostCmd_DS_SDIO_PULL_CTRL sdio_pull_ctrl;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+    memset(&sdio_pull_ctrl, 0, sizeof(sdio_pull_ctrl));
+    if (wrq->u.data.length > 0) {
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(data))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        PRINTM(INFO, "WLAN SET SDIO PULL CTRL: %d %d\n", data[0], data[1]);
+        sdio_pull_ctrl.Action = HostCmd_ACT_GEN_SET;
+        sdio_pull_ctrl.PullUp = data[0];
+        sdio_pull_ctrl.PullDown = data[1];
+    } else {
+        sdio_pull_ctrl.Action = HostCmd_ACT_GEN_GET;
+    }
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_SDIO_PULL_CTRL,
+                           0, HostCmd_OPTION_WAITFORRSP,
+                           0, (void *) &sdio_pull_ctrl);
+    data[0] = sdio_pull_ctrl.PullUp;
+    data[1] = sdio_pull_ctrl.PullDown;
+    wrq->u.data.length = 2;
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set scan time
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wreq		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_scan_time(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[3] = { 0, 0, 0 };
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.length > 0 && wrq->u.data.length <= 3) {
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+        PRINTM(INFO,
+               "WLAN SET Scan Time: Specific %d, Active %d, Passive %d\n",
+               data[0], data[1], data[2]);
+        if (data[0]) {
+            if (data[0] > MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME) {
+                PRINTM(MSG,
+                       "Invalid parameter, max specific scan time is %d ms\n",
+                       MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME);
+                LEAVE();
+                return -EINVAL;
+            }
+            Adapter->SpecificScanTime = data[0];
+        }
+        if (data[1]) {
+            if (data[1] > MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME) {
+                PRINTM(MSG,
+                       "Invalid parameter, max active scan time is %d ms\n",
+                       MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME);
+                LEAVE();
+                return -EINVAL;
+            }
+            Adapter->ActiveScanTime = data[1];
+        }
+        if (data[2]) {
+            if (data[2] > MRVDRV_MAX_PASSIVE_SCAN_CHAN_TIME) {
+                PRINTM(MSG,
+                       "Invalid parameter, max passive scan time is %d ms\n",
+                       MRVDRV_MAX_PASSIVE_SCAN_CHAN_TIME);
+                LEAVE();
+                return -EINVAL;
+            }
+            Adapter->PassiveScanTime = data[2];
+        }
+    }
+
+    data[0] = Adapter->SpecificScanTime;
+    data[1] = Adapter->ActiveScanTime;
+    data[2] = Adapter->PassiveScanTime;
+    wrq->u.data.length = 3;
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Adhoc beacon Interval 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_beacon_interval(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[2];
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.length > 0) {
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+        PRINTM(INFO, "WLAN SET BEACON INTERVAL: %d\n", data[0]);
+        if ((data[0] > MRVDRV_MAX_BEACON_INTERVAL) ||
+            (data[0] < MRVDRV_MIN_BEACON_INTERVAL)) {
+            LEAVE();
+            return -ENOTSUPP;
+        }
+        Adapter->BeaconPeriod = data[0];
+    }
+    data[0] = Adapter->BeaconPeriod;
+    wrq->u.data.length = 1;
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        data[1] = Adapter->CurBssParams.BSSDescriptor.BeaconPeriod;
+        wrq->u.data.length = 2;
+    }
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Adhoc ATIM Window 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_atim_window(wlan_private * priv, struct iwreq *wrq)
+{
+    int data[2];
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.length > 0) {
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+        PRINTM(INFO, "WLAN SET ATIM WINDOW: %d\n", data[0]);
+        Adapter->AtimWindow = data[0];
+        Adapter->AtimWindow = MIN(Adapter->AtimWindow, 50);
+    }
+    data[0] = Adapter->AtimWindow;
+    wrq->u.data.length = 1;
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        data[1] = Adapter->CurBssParams.BSSDescriptor.ATIMWindow;
+        wrq->u.data.length = 2;
+    }
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set system clock
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wreq		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_ecl_sys_clock(wlan_private * priv, struct iwreq *wrq)
+{
+    HostCmd_DS_ECL_SYSTEM_CLOCK_CONFIG cmd;
+    u16 action;
+    int data[16], len, i;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    memset(&cmd, 0, sizeof(HostCmd_DS_ECL_SYSTEM_CLOCK_CONFIG));
+    if (wrq->u.data.length > 0) {
+        if (copy_from_user(data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        PRINTM(INFO, "WLAN set system clock: %d\n", data[0]);
+        action = HostCmd_ACT_GEN_SET;
+        cmd.Action = action;
+        cmd.SystemClock = (u16) data[0];
+    } else {
+        action = HostCmd_ACT_GEN_GET;
+        cmd.Action = action;
+    }
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_ECL_SYSTEM_CLOCK_CONFIG,
+                           action, HostCmd_OPTION_WAITFORRSP,
+                           0, (void *) &cmd);
+
+    if (!ret && action == HostCmd_ACT_GEN_GET) {
+        data[0] = cmd.SystemClock;
+        PRINTM(INFO, "WLAN get system clock: %d\n", data[0]);
+        len = MIN(cmd.SupportedSysClockLen / sizeof(u16),
+                  sizeof(data) / sizeof(data[0]) - 1);
+        for (i = 0; i < len; i++) {
+            data[i + 1] = cmd.SupportedSysClock[i];
+        }
+        wrq->u.data.length = 1 + len;
+
+        if (copy_to_user
+            (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get RSSI 
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_rssi(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    int temp;
+    int data = 0;
+    int *val;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+        PRINTM(INFO, "Can not get RSSI in disconnected state\n");
+        LEAVE();
+        return -ENOTSUPP;
+    }
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    if ((data == 0) || (data == 1)) {
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_RSSI,
+                               0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    }
+
+    switch (data) {
+    case 0:
+
+        temp = CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_NOAVG],
+                        Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+        break;
+    case 1:
+        temp = CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_AVG],
+                        Adapter->NF[TYPE_BEACON][TYPE_AVG]);
+        break;
+    case 2:
+        if ((jiffies - Adapter->RxPDAge) > HZ)  //data expired after 1 second
+            temp = 0;
+        else
+            temp = CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_NOAVG],
+                            Adapter->NF[TYPE_RXPD][TYPE_NOAVG]);
+        break;
+    case 3:
+        temp = CAL_RSSI(Adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
+                        Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
+        break;
+    default:
+        LEAVE();
+        return -ENOTSUPP;
+    }
+    val = (int *) wrq->u.name;
+    *val = temp;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get NF
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wreq		        A pointer to iwreq structure 
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_nf(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+    int temp;
+    int data = 0;
+    int *val;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateDisconnected) {
+        PRINTM(INFO, "Can not get NF in disconnected state\n");
+        LEAVE();
+        return -ENOTSUPP;
+    }
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    if ((data == 0) || (data == 1)) {
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_RSSI,
+                               0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+    }
+
+    switch (data) {
+    case 0:
+        temp = Adapter->NF[TYPE_BEACON][TYPE_NOAVG];
+        break;
+    case 1:
+        temp = Adapter->NF[TYPE_BEACON][TYPE_AVG];
+        break;
+    case 2:
+        if ((jiffies - Adapter->RxPDAge) > HZ)  //data expired after 1 second
+            temp = 0;
+        else
+            temp = Adapter->NF[TYPE_RXPD][TYPE_NOAVG];
+        break;
+    case 3:
+        temp = Adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE;
+        break;
+    default:
+        LEAVE();
+        return -ENOTSUPP;
+    }
+
+    temp = CAL_NF(temp);
+
+    PRINTM(INFO, "***temp = %d\n", temp);
+    val = (int *) wrq->u.name;
+    *val = temp;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Remove AES key
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_remove_aes(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    WLAN_802_11_KEY key;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (Adapter->InfrastructureMode != Wlan802_11IBSS ||
+        Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        LEAVE();
+        return -EOPNOTSUPP;
+    }
+    Adapter->AdhocAESEnabled = FALSE;
+
+    memset(&key, 0, sizeof(WLAN_802_11_KEY));
+    PRINTM(INFO, "WPA2: DISABLE AES_KEY\n");
+    key.KeyLength = WPA_AES_KEY_LEN;
+    key.KeyIndex = 0x40000000;
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_KEY_MATERIAL,
+                           HostCmd_ACT_GEN_SET,
+                           HostCmd_OPTION_WAITFORRSP,
+                           !(KEY_INFO_ENABLED), &key);
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief Get Support Rates
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_getrate_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    WLAN_802_11_RATES rates;
+    int rate[sizeof(rates)];
+    int i;
+
+    ENTER();
+
+    memset(rates, 0, sizeof(rates));
+    memset(rate, 0, sizeof(rate));
+    wrq->u.data.length = get_active_data_rates(Adapter, rates);
+    if (wrq->u.data.length > sizeof(rates))
+        wrq->u.data.length = sizeof(rates);
+
+    for (i = 0; i < wrq->u.data.length; i++) {
+        rates[i] &= ~0x80;
+        rate[i] = rates[i];
+    }
+
+    if (copy_to_user
+        (wrq->u.data.pointer, rate, wrq->u.data.length * sizeof(int))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get TxRate
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_txrate_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int *pdata;
+    struct iwreq *wrq = (struct iwreq *) req;
+    int ret = WLAN_STATUS_SUCCESS;
+    ENTER();
+    Adapter->TxRate = 0;
+    PRINTM(INFO, "wlan_get_txrate_ioctl\n");
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,
+                           HostCmd_ACT_GEN_GET, HostCmd_OPTION_WAITFORRSP,
+                           0, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+    pdata = (int *) wrq->u.name;
+    *pdata = (int) Adapter->TxRate;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Adhoc Status
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_get_adhoc_status_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    char status[64];
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    memset(status, 0, sizeof(status));
+
+    switch (Adapter->InfrastructureMode) {
+    case Wlan802_11IBSS:
+        if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+            switch (Adapter->AdhocState) {
+            case ADHOC_STARTED:
+                strcpy(status, "AdhocStarted");
+                break;
+            case ADHOC_JOINED:
+                strcpy(status, "AdhocJoined");
+                break;
+            case ADHOC_COALESCED:
+                strcpy(status, "AdhocCoalesced");
+                break;
+            default:
+                strcpy(status, "InvalidAdhocState");
+                break;
+            }
+        } else {
+            strcpy(status, "AdhocIdle");
+        }
+        break;
+    case Wlan802_11Infrastructure:
+        strcpy(status, "InfraMode");
+        break;
+    default:
+        strcpy(status, "AutoUnknownMode");
+        break;
+    }
+
+    PRINTM(INFO, "Status = %s\n", status);
+    wrq->u.data.length = strlen(status) + 1;
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &status, wrq->u.data.length)) {
+            LEAVE();
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Driver Version
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_version_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int len;
+    char buf[128];
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    get_version(priv->adapter, buf, sizeof(buf) - 1);
+
+    len = strlen(buf);
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, buf, len)) {
+            PRINTM(INFO, "CopyToUser failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        wrq->u.data.length = len;
+    }
+
+    PRINTM(INFO, "wlan version: %s\n", buf);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Driver and FW version
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_verext_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    HostCmd_DS_VERSION_EXT versionExtCmd;
+    int len;
+
+    ENTER();
+
+    memset(&versionExtCmd, 0x00, sizeof(versionExtCmd));
+
+    if (wrq->u.data.flags == 0) {
+        //from iwpriv subcmd
+        versionExtCmd.versionStrSel =
+            *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    } else {
+        if (copy_from_user(&versionExtCmd.versionStrSel,
+                           wrq->u.data.pointer,
+                           sizeof(versionExtCmd.versionStrSel))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    }
+
+    wlan_prepare_cmd(priv,
+                     HostCmd_CMD_VERSION_EXT, 0,
+                     HostCmd_OPTION_WAITFORRSP, 0, &versionExtCmd);
+
+    len = strlen(versionExtCmd.versionStr) + 1;
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, versionExtCmd.versionStr, len)) {
+            PRINTM(INFO, "CopyToUser failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        wrq->u.data.length = len;
+    }
+
+    PRINTM(INFO, "Version: %s\n", versionExtCmd.versionStr);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Read/Write adapter registers
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_regrdwr_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    wlan_ioctl_regrdwr regrdwr;
+    wlan_offset_value offval;
+    u8 *pRdeeprom;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (copy_from_user(&regrdwr, req->ifr_data, sizeof(regrdwr))) {
+        PRINTM(INFO,
+               "copy of regrdwr for wlan_regrdwr_ioctl from user failed \n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    if (regrdwr.WhichReg == REG_EEPROM) {
+        PRINTM(INFO, "Inside RDEEPROM\n");
+        pRdeeprom =
+            (char *) kmalloc((regrdwr.NOB + sizeof(regrdwr)), GFP_KERNEL);
+        if (!pRdeeprom) {
+            PRINTM(INFO, "allocate memory for EEPROM read failed\n");
+            LEAVE();
+            return -ENOMEM;
+        }
+        memcpy(pRdeeprom, &regrdwr, sizeof(regrdwr));
+        PRINTM(INFO, "Action: %d, Offset: %x, NOB: %02x\n",
+               regrdwr.Action, regrdwr.Offset, regrdwr.NOB);
+
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_EEPROM_ACCESS,
+                               regrdwr.Action, HostCmd_OPTION_WAITFORRSP,
+                               0, pRdeeprom);
+
+        /*
+         * Return the result back to the user 
+         */
+        if (!ret && regrdwr.Action == HostCmd_ACT_GEN_READ) {
+            if (copy_to_user
+                (req->ifr_data, pRdeeprom, sizeof(regrdwr) + regrdwr.NOB)) {
+                PRINTM(INFO,
+                       "copy of regrdwr for wlan_regrdwr_ioctl to user failed \n");
+                ret = -EFAULT;
+            }
+        }
+
+        kfree(pRdeeprom);
+
+        LEAVE();
+        return ret;
+    }
+
+    offval.offset = regrdwr.Offset;
+    offval.value = (regrdwr.Action) ? regrdwr.Value : 0x00;
+
+    PRINTM(INFO, "RegAccess: %02x Action:%d "
+           "Offset: %04x Value: %04x\n",
+           regrdwr.WhichReg, regrdwr.Action, offval.offset, offval.value);
+
+    /*
+     * regrdwr.WhichReg should contain the command that
+     * corresponds to which register access is to be 
+     * performed HostCmd_CMD_MAC_REG_ACCESS 0x0019
+     * HostCmd_CMD_BBP_REG_ACCESS 0x001a 
+     * HostCmd_CMD_RF_REG_ACCESS 0x001b 
+     */
+    ret = wlan_prepare_cmd(priv, regrdwr.WhichReg,
+                           regrdwr.Action, HostCmd_OPTION_WAITFORRSP,
+                           0, &offval);
+
+    /*
+     * Return the result back to the user 
+     */
+    if (!ret && regrdwr.Action == HostCmd_ACT_GEN_READ) {
+        regrdwr.Value = offval.value;
+        if (copy_to_user(req->ifr_data, &regrdwr, sizeof(regrdwr))) {
+            PRINTM(INFO,
+                   "copy of regrdwr for wlan_regrdwr_ioctl to user failed \n");
+            ret = -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Cmd52 read/write register
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_cmd52rdwr_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    u8 buf[7];
+    u8 rw, func, dat = 0xff;
+    u32 reg;
+
+    ENTER();
+
+    if (copy_from_user(buf, req->ifr_data, sizeof(buf))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    rw = buf[0];
+    func = buf[1];
+    reg = buf[5];
+    reg = (reg << 8) + buf[4];
+    reg = (reg << 8) + buf[3];
+    reg = (reg << 8) + buf[2];
+
+    if (rw != 0)
+        dat = buf[6];
+
+    PRINTM(INFO, "rw=%d func=%d reg=0x%08X dat=0x%02X\n", rw, func, reg, dat);
+
+    if (rw == 0) {
+        if (sbi_read_ioreg(priv, reg, &dat) < 0) {
+            PRINTM(INFO, "sdio_read_ioreg: reading register 0x%X failed\n",
+                   reg);
+            dat = 0xff;
+        }
+    } else {
+        if (sbi_write_ioreg(priv, reg, dat) < 0) {
+            PRINTM(INFO, "sdio_read_ioreg: writing register 0x%X failed\n",
+                   reg);
+            dat = 0xff;
+        }
+    }
+    if (copy_to_user(req->ifr_data, &dat, sizeof(dat))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Cmd53 read/write register
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_cmd53rdwr_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    u8 buf[11];
+    u8 rw, func, mode;
+    u16 blklen = 0, blknum = 0;
+    u32 reg = 0;
+    u8 data[CMD53BUFLEN];
+
+    ENTER();
+
+    if (copy_from_user(buf, req->ifr_data, sizeof(buf))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        return -EFAULT;
+    }
+
+    rw = buf[0];                // read/write (0/1)
+    func = buf[1];              // func (0/1/2)
+    reg = buf[5];               // address
+    reg = (reg << 8) + buf[4];
+    reg = (reg << 8) + buf[3];
+    reg = (reg << 8) + buf[2];
+    mode = buf[6];              // byte mode/block mode (0/1)
+    blklen = buf[8];            // block size
+    blklen = (blklen << 8) + buf[7];
+    blknum = buf[10];           // block number or byte number
+    blknum = (blknum << 8) + buf[9];
+
+    PRINTM(INFO, "CMD53 read, func = %d, addr = %#x, mode = %d, "
+           "block size = %d, block(byte) number = %d\n",
+           func, reg, mode, blklen, blknum);
+
+    if (rw == 0) {
+	/* modified by feng */
+        //if (sdio_read_iomem(priv->wlan_dev.card, func, reg, mode,
+        //                   FIXED_ADDRESS, blknum, blklen, data) < 0) {
+        if (sbi_read_iomem(priv, data, reg, blknum * blklen) < 0) { 
+		PRINTM(ERROR, "sbi_read_iomem: reading memory 0x%x failed\n",
+			reg);
+        }
+    }
+
+    if (copy_to_user(req->ifr_data, data, sizeof(data))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief crypto test
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_crypto_test(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    u8 *buf = NULL;
+    HostCmd_DS_802_11_CRYPTO *cmd = NULL;
+    MrvlIEtypes_Data_t *data;
+    u16 len = 0;
+
+    ENTER();
+
+#define CRYPTO_TEST_BUF_LEN	1024
+    if (!(buf = kmalloc(CRYPTO_TEST_BUF_LEN, GFP_KERNEL))) {
+        PRINTM(INFO, "kmalloc failed!\n");
+        LEAVE();
+        return -ENOMEM;
+    }
+    memset(buf, 0, CRYPTO_TEST_BUF_LEN);
+    cmd = (HostCmd_DS_802_11_CRYPTO *) buf;
+
+    if (wrq->u.data.length < CRYPTO_TEST_BUF_LEN) {
+        if (copy_from_user(buf, wrq->u.data.pointer, wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+            goto crypto_exit;
+        }
+    }
+
+    data = (MrvlIEtypes_Data_t *) (buf + sizeof(HostCmd_DS_802_11_CRYPTO));
+    HEXDUMP("crypton", (u8 *) cmd, wrq->u.data.length);
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_CRYPTO,
+                           HostCmd_ACT_GEN_SET,
+                           HostCmd_OPTION_WAITFORRSP, 0, cmd);
+    len = data->Header.Len;
+    wrq->u.data.length =
+        sizeof(HostCmd_DS_802_11_CRYPTO) + sizeof(MrvlIEtypesHeader_t) + len;
+    if (copy_to_user
+        (wrq->u.data.pointer, cmd,
+         sizeof(HostCmd_DS_802_11_CRYPTO) + sizeof(MrvlIEtypesHeader_t) +
+         len)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        ret = -EFAULT;
+    }
+
+  crypto_exit:
+    kfree(buf);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Convert ascii string to Hex integer
+ *     
+ *  @param d                    A pointer to integer buf
+ *  @param s			A pointer to ascii string 
+ *  @param dlen			the length o fascii string
+ *  @return 	   	        number of integer  
+ */
+static int
+ascii2hex(u8 * d, char *s, u32 dlen)
+{
+    int i;
+    u8 n;
+
+    ENTER();
+
+    memset(d, 0x00, dlen);
+
+    for (i = 0; i < dlen * 2; i++) {
+        if ((s[i] >= 48) && (s[i] <= 57))
+            n = s[i] - 48;
+        else if ((s[i] >= 65) && (s[i] <= 70))
+            n = s[i] - 55;
+        else if ((s[i] >= 97) && (s[i] <= 102))
+            n = s[i] - 87;
+        else
+            break;
+        if ((i % 2) == 0)
+            n = n * 16;
+        d[i / 2] += n;
+    }
+
+    LEAVE();
+
+    return i;
+}
+
+/** 
+ *  @brief Set adhoc aes key
+ *   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_setadhocaes_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    u8 key_ascii[32];
+    u8 key_hex[16];
+    int ret = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+
+    WLAN_802_11_KEY key;
+
+    ENTER();
+
+    if (Adapter->InfrastructureMode != Wlan802_11IBSS) {
+        LEAVE();
+        return -EOPNOTSUPP;
+    }
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        LEAVE();
+        return -EOPNOTSUPP;
+    }
+    if (copy_from_user(key_ascii, wrq->u.data.pointer, sizeof(key_ascii))) {
+        PRINTM(INFO, "wlan_setadhocaes_ioctl copy from user failed \n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    Adapter->AdhocAESEnabled = TRUE;
+    ascii2hex(key_hex, key_ascii, sizeof(key_hex));
+
+    HEXDUMP("wlan_setadhocaes_ioctl", key_hex, sizeof(key_hex));
+
+    PRINTM(INFO, "WPA2: ENABLE AES_KEY\n");
+    key.KeyLength = WPA_AES_KEY_LEN;
+    key.KeyIndex = 0x40000000;
+    memcpy(key.KeyMaterial, key_hex, key.KeyLength);
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_KEY_MATERIAL,
+                           HostCmd_ACT_GEN_SET,
+                           HostCmd_OPTION_WAITFORRSP, KEY_INFO_ENABLED, &key);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get adhoc aes key   
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_getadhocaes_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    u8 *tmp;
+    u8 key_ascii[33];
+    u8 key_hex[16];
+    int i, ret = 0;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+    WLAN_802_11_KEY key;
+
+    ENTER();
+
+    memset(key_hex, 0x00, sizeof(key_hex));
+
+    PRINTM(INFO, "WPA2: ENABLE AES_KEY\n");
+    key.KeyLength = WPA_AES_KEY_LEN;
+    key.KeyIndex = 0x40000000;
+    memcpy(key.KeyMaterial, key_hex, key.KeyLength);
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_KEY_MATERIAL,
+                           HostCmd_ACT_GEN_GET,
+                           HostCmd_OPTION_WAITFORRSP, KEY_INFO_ENABLED, &key);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    memcpy(key_hex, Adapter->aeskey.KeyParamSet.Key, sizeof(key_hex));
+
+    HEXDUMP("wlan_getadhocaes_ioctl", key_hex, sizeof(key_hex));
+
+    wrq->u.data.length = sizeof(key_ascii) + 1;
+
+    memset(key_ascii, 0x00, sizeof(key_ascii));
+    tmp = key_ascii;
+
+    for (i = 0; i < sizeof(key_hex); i++)
+        tmp += sprintf(tmp, "%02x", key_hex[i]);
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &key_ascii, sizeof(key_ascii))) {
+            PRINTM(INFO, "copy_to_user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set multiple dtim
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_multiple_dtim_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    struct iwreq *wrq = (struct iwreq *) req;
+    u32 mdtim;
+    int idata;
+    int ret = -EINVAL;
+
+    ENTER();
+
+    idata = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    mdtim = (u32) idata;
+    if (((mdtim >= MRVDRV_MIN_MULTIPLE_DTIM) &&
+         (mdtim <= MRVDRV_MAX_MULTIPLE_DTIM))
+        || (mdtim == MRVDRV_IGNORE_MULTIPLE_DTIM)) {
+        priv->adapter->MultipleDtim = mdtim;
+        ret = WLAN_STATUS_SUCCESS;
+    }
+    if (ret)
+        PRINTM(INFO, "Invalid parameter, MultipleDtim not changed.\n");
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set authentication mode
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_setauthalg_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int alg;
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wrq->u.data.flags == 0) {
+        //from iwpriv subcmd
+        alg = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    } else {
+        //from wpa_supplicant subcmd
+        if (copy_from_user(&alg, wrq->u.data.pointer, sizeof(alg))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    }
+
+    PRINTM(INFO, "auth alg is %#x\n", alg);
+
+    switch (alg) {
+    case AUTH_ALG_SHARED_KEY:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeShared;
+        break;
+    case AUTH_ALG_NETWORK_EAP:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeNetworkEAP;
+        break;
+    case AUTH_ALG_OPEN_SYSTEM:
+    default:
+        Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+        break;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Encryption mode
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_setencryptionmode_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int mode;
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    if (wrq->u.data.flags == 0) {
+        //from iwpriv subcmd
+        mode = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    } else {
+        //from wpa_supplicant subcmd
+        if (copy_from_user(&mode, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    }
+    PRINTM(INFO, "encryption mode is %#x\n", mode);
+    priv->adapter->SecInfo.EncryptionMode = mode;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Rx antenna
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_subcmd_getrxantenna_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int len;
+    char buf[8];
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    PRINTM(INFO, "WLAN_SUBCMD_GETRXANTENNA\n");
+    len = wlan_get_rx_antenna(priv, buf);
+
+    wrq->u.data.length = len;
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &buf, len)) {
+            PRINTM(INFO, "CopyToUser failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get Tx antenna
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_subcmd_gettxantenna_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int len;
+    char buf[8];
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    PRINTM(INFO, "WLAN_SUBCMD_GETTXANTENNA\n");
+    len = wlan_get_tx_antenna(priv, buf);
+
+    wrq->u.data.length = len;
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &buf, len)) {
+            PRINTM(INFO, "CopyToUser failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get the MAC TSF value from the firmware
+ *
+ *  @param priv         A pointer to wlan_private structure
+ *  @param wrq          A pointer to iwreq structure containing buffer
+ *                      space to store a TSF value retrieved from the firmware
+ *
+ *  @return             0 if successful; IOCTL error code otherwise
+ */
+static int
+wlan_get_tsf_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    u64 tsfVal = 0;
+    int ret;
+
+    ENTER();
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_GET_TSF,
+                           0, HostCmd_OPTION_WAITFORRSP, 0, &tsfVal);
+
+    PRINTM(INFO, "IOCTL: Get TSF = 0x%016llx\n", tsfVal);
+
+    if (ret != WLAN_STATUS_SUCCESS) {
+        PRINTM(INFO, "IOCTL: Get TSF; Command exec failed\n");
+        ret = -EFAULT;
+    } else {
+        if (copy_to_user(wrq->u.data.pointer,
+                         &tsfVal,
+                         MIN(wrq->u.data.length, sizeof(tsfVal))) != 0) {
+
+            PRINTM(INFO, "IOCTL: Get TSF; Copy to user failed\n");
+            ret = -EFAULT;
+        } else {
+            ret = 0;
+        }
+    }
+
+    LEAVE();
+
+    return ret;
+}
+
+/** 
+ *  @brief  Control WPS Session Enable/Disable
+ *  @param priv         A pointer to wlan_private structure
+ *  @param req          A pointer to ifreq structure
+ *  @return             WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_wps_session_ioctl(wlan_private * priv, struct iwreq *req)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    char buf[8];
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    PRINTM(INFO, "WLAN_WPS_SESSION\n");
+
+    memset(buf, 0, sizeof(buf));
+    if (copy_from_user(buf, wrq->u.data.pointer,
+                       MIN(sizeof(buf) - 1, wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    if (buf[0] == 1)
+        Adapter->wps.SessionEnable = TRUE;
+    else
+        Adapter->wps.SessionEnable = FALSE;
+
+    PRINTM(INFO, "Adapter->wps.SessionEnable = %d\n",
+           Adapter->wps.SessionEnable);
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set DeepSleep mode
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_deepsleep_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    char status[128];
+    struct iwreq *wrq = (struct iwreq *) req;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        PRINTM(MSG, "Cannot enter Deep Sleep mode in connected state.\n");
+        LEAVE();
+        return -EINVAL;
+    }
+
+    if (*(char *) req->ifr_data == '0') {
+        PRINTM(INFO, "Exit Deep Sleep Mode.\n");
+        sprintf(status, "setting to off ");
+        wlan_set_deep_sleep(priv, FALSE);
+    } else if (*(char *) req->ifr_data == '1') {
+        PRINTM(INFO, "Enter Deep Sleep Mode.\n");
+        sprintf(status, "setting to on ");
+        wlan_set_deep_sleep(priv, TRUE);
+    } else if (*(char *) req->ifr_data == '2') {
+        PRINTM(INFO, "Get Deep Sleep Mode.\n");
+        if (Adapter->IsDeepSleep == TRUE) {
+            sprintf(status, "on ");
+        } else {
+            sprintf(status, "off ");
+        }
+    } else {
+        PRINTM(INFO, "unknown option = %d\n", *(u8 *) req->ifr_data);
+        LEAVE();
+        return -EINVAL;
+    }
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &status, strlen(status))) {
+            LEAVE();
+            return -EFAULT;
+        }
+        wrq->u.data.length = strlen(status);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Config Host Sleep parameters
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wreq		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_hscfg_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data[3] = { -1, 0xff, 0xff };
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length >= 1 && wrq->u.data.length <= 3) {
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        PRINTM(INFO,
+               "wlan_hscfg_ioctl: data[0]=%#08x, data[1]=%#02x, data[2]=%#02x\n",
+               data[0], data[1], data[2]);
+    } else {
+        PRINTM(MSG, "Invalid Argument\n");
+        LEAVE();
+        return -EINVAL;
+    }
+
+    Adapter->HSCfg.conditions = data[0];
+    if (Adapter->HSCfg.conditions != HOST_SLEEP_CFG_CANCEL) {
+        if (wrq->u.data.length == 2) {
+            Adapter->HSCfg.gpio = (u8) data[1];
+        } else if (wrq->u.data.length == 3) {
+            Adapter->HSCfg.gpio = (u8) data[1];
+            Adapter->HSCfg.gap = (u8) data[2];
+        }
+    }
+
+    PRINTM(INFO,
+           "hscfg: cond=%#x gpio=%#x gap=%#x PSState=%d HS_Activated=%d\n",
+           Adapter->HSCfg.conditions, Adapter->HSCfg.gpio, Adapter->HSCfg.gap,
+           Adapter->PSState, Adapter->HS_Activated);
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_HOST_SLEEP_CFG,
+                           0, HostCmd_OPTION_WAITFORRSP, 0, &Adapter->HSCfg);
+
+    data[0] = Adapter->HSCfg.conditions;
+    data[1] = Adapter->HSCfg.gpio;
+    data[2] = Adapter->HSCfg.gap;
+    wrq->u.data.length = 3;
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set Host Sleep parameters
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wreq		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_hssetpara_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data[3] = { -1, 0xff, 0xff };
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length >= 1 && wrq->u.data.length <= 3) {
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        PRINTM(INFO,
+               "wlan_hssetpara_ioctl: data[0]=%#08x, data[1]=%#02x, data[2]=%#02x\n",
+               data[0], data[1], data[2]);
+    }
+
+    Adapter->HSCfg.conditions = data[0];
+    if (Adapter->HSCfg.conditions != HOST_SLEEP_CFG_CANCEL) {
+        if (wrq->u.data.length == 2) {
+            Adapter->HSCfg.gpio = (u8) data[1];
+        } else if (wrq->u.data.length == 3) {
+            Adapter->HSCfg.gpio = (u8) data[1];
+            Adapter->HSCfg.gap = (u8) data[2];
+        }
+    }
+
+    PRINTM(INFO,
+           "hssetpara: cond=%#x gpio=%#x gap=%#x PSState=%d HS_Activated=%d\n",
+           Adapter->HSCfg.conditions, Adapter->HSCfg.gpio, Adapter->HSCfg.gap,
+           Adapter->PSState, Adapter->HS_Activated);
+
+    data[0] = Adapter->HSCfg.conditions;
+    data[1] = Adapter->HSCfg.gpio;
+    data[2] = Adapter->HSCfg.gap;
+    wrq->u.data.length = 3;
+    if (copy_to_user
+        (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** Destination host */
+#define DESTINATION_HOST	0x01
+/** 
+ *  @brief Config Small Debug parameters
+ *   
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wreq		A pointer to iwreq structure
+ *  @return    		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_dbgs_cfg(wlan_private * priv, struct iwreq *wrq)
+{
+    int *data = NULL;
+    u8 buf[512];
+    DBGS_CFG_DATA *pDbgCfg = (DBGS_CFG_DATA *) buf;
+    DBGS_ENTRY_DATA *pEntry;
+    int ret = WLAN_STATUS_SUCCESS;
+    int i;
+
+    ENTER();
+
+#define MAX_DBGS_CFG_ENTRIES	0x7F
+    if (wrq->u.data.length < 3 ||
+        wrq->u.data.length > 3 + MAX_DBGS_CFG_ENTRIES * 2) {
+        PRINTM(MSG, "Invalid parameter number\n");
+        ret = -EFAULT;
+        goto dbgs_exit;
+    }
+
+    if (!(data = kmalloc(sizeof(int) * wrq->u.data.length, GFP_KERNEL))) {
+        PRINTM(INFO, "Allocate memory failed\n");
+        ret = -ENOMEM;
+        goto dbgs_exit;
+    }
+    memset(data, 0, sizeof(int) * wrq->u.data.length);
+    memset(buf, 0, sizeof(buf));
+
+    if (copy_from_user
+        (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+        PRINTM(INFO, "Copy from user failed\n");
+        ret = -EFAULT;
+        goto dbgs_exit;
+    }
+    if (wrq->u.data.length < (3 + (data[2] & 0x7f) * 2)) {
+        PRINTM(MSG, "Invalid parameter number\n");
+        ret = -EFAULT;
+        goto dbgs_exit;
+    }
+
+    pDbgCfg->data.Destination = (u8) data[0];
+#ifdef	DEBUG_LEVEL1
+    if (pDbgCfg->data.Destination & DESTINATION_HOST)
+        drvdbg |= DBG_FW_D;
+    else
+        drvdbg &= ~DBG_FW_D;
+#endif
+    pDbgCfg->data.ToAirChan = (u8) data[1];
+    pDbgCfg->data.En_NumEntries = (u8) data[2];
+    pDbgCfg->size =
+        sizeof(HostCmd_DS_DBGS_CFG) +
+        (pDbgCfg->data.En_NumEntries & 0x7f) * sizeof(DBGS_ENTRY_DATA);
+    pEntry = (DBGS_ENTRY_DATA *) (buf + sizeof(DBGS_CFG_DATA));
+    for (i = 0; i < (pDbgCfg->data.En_NumEntries & 0x7f); i++) {
+        pEntry->ModeAndMaskorID = (u16) data[3 + i * 2];
+        pEntry->BaseOrID = (u16) data[3 + i * 2 + 1];
+        pEntry->ModeAndMaskorID = wlan_cpu_to_le16(pEntry->ModeAndMaskorID);
+        pEntry->BaseOrID = wlan_cpu_to_le16(pEntry->BaseOrID);
+        pEntry++;
+    }
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_DBGS_CFG,
+                           0, HostCmd_OPTION_WAITFORRSP, 0, pDbgCfg);
+
+  dbgs_exit:
+    if (data)
+        kfree(data);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set Cal data ext
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_caldata_ext_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    HostCmd_DS_802_11_CAL_DATA_EXT *pCalData = NULL;
+    int ret = WLAN_STATUS_SUCCESS;
+    u16 action;
+
+    ENTER();
+
+    if (!(pCalData = kmalloc(MAX_SETGET_CONF_CMD_LEN, GFP_KERNEL))) {
+        PRINTM(INFO, "Allocate memory failed\n");
+        ret = -ENOMEM;
+        goto calexit;
+    }
+    memset(pCalData, 0, MAX_SETGET_CONF_CMD_LEN);
+
+    if (copy_from_user(pCalData, req->ifr_data + SKIP_CMDNUM,
+                       MAX_SETGET_CONF_CMD_LEN)) {
+        PRINTM(INFO, "Copy from user failed\n");
+        kfree(pCalData);
+        ret = -EFAULT;
+        goto calexit;
+    }
+
+    action = (pCalData->Action == HostCmd_ACT_GEN_SET) ?
+        HostCmd_ACT_GEN_SET : HostCmd_ACT_GEN_GET;
+
+    HEXDUMP("Cal data ext", (u8 *) pCalData, MAX_SETGET_CONF_CMD_LEN);
+
+    PRINTM(INFO, "CalData Action = 0x%0X\n", action);
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_CAL_DATA_EXT,
+                           action, HostCmd_OPTION_WAITFORRSP, 0, pCalData);
+
+    if (!ret && action == HostCmd_ACT_GEN_GET) {
+        if (copy_to_user(req->ifr_data + SKIP_CMDNUM, pCalData,
+                         MAX_SETGET_CONF_CMD_LEN)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+    }
+
+    kfree(pCalData);
+  calexit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set band 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_do_setband_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int cnt, i;
+    char buf[16];
+    u16 tmp = 0;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        LEAVE();
+        return -EOPNOTSUPP;
+    }
+    memset(buf, '\0', sizeof(buf));
+    if (copy_from_user(buf, wrq->u.data.pointer,
+                       MIN(wrq->u.data.length, sizeof(buf) - 1))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    cnt = strlen(buf);
+
+    if (!cnt || cnt > 3) {
+        LEAVE();
+        return -EINVAL;
+    }
+    for (i = 0; i < cnt; i++) {
+        switch (buf[i]) {
+        case 'B':
+        case 'b':
+            PRINTM(INFO, "setband: BAND B\n");
+            tmp |= BAND_B;
+            break;
+        case 'G':
+        case 'g':
+            PRINTM(INFO, "setband: BAND G\n");
+            tmp |= BAND_G;
+            break;
+        case 'A':
+        case 'a':
+            PRINTM(INFO, "setband: BAND A\n");
+            tmp |= BAND_A;
+            break;
+        default:
+            PRINTM(INFO, "setband: Invalid %02x(%c)\n", buf[i], buf[i]);
+            LEAVE();
+            return -EINVAL;
+        }
+    }
+
+    PRINTM(INFO, "setband: sel=%02x, fw=%02x\n", tmp, Adapter->fw_bands);
+
+    /* Validate against FW support */
+    if ((tmp | Adapter->fw_bands) & ~Adapter->fw_bands) {
+        LEAVE();
+        return -EINVAL;
+    }
+    /* To support only <a/b/bg/abg> */
+    if (!tmp || (tmp == BAND_G) || (tmp == (BAND_A | BAND_B)) ||
+        (tmp == (BAND_A | BAND_G))) {
+        LEAVE();
+        return -EINVAL;
+    }
+    if (wlan_set_regiontable(priv, Adapter->RegionCode, tmp)) {
+        LEAVE();
+        return -EINVAL;
+    }
+
+    Adapter->config_bands = tmp;
+
+    if (Adapter->config_bands & BAND_A) {
+        Adapter->adhoc_start_band = BAND_A;
+        Adapter->AdhocChannel = DEFAULT_AD_HOC_CHANNEL_A;
+    } else if (Adapter->config_bands & BAND_G) {
+        Adapter->adhoc_start_band = BAND_G;
+        Adapter->AdhocChannel = DEFAULT_AD_HOC_CHANNEL;
+    } else {
+        Adapter->adhoc_start_band = BAND_B;
+        Adapter->AdhocChannel = DEFAULT_AD_HOC_CHANNEL;
+    }
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set adhoc channel 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_setadhocch_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    /* iwpriv ethX setaddocchannel "a nnn" */
+    u32 vals[2];
+    u16 band;
+    u8 chan;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter->InfrastructureMode != Wlan802_11IBSS) {
+        LEAVE();
+        return -EOPNOTSUPP;
+    }
+    if (copy_from_user(vals, wrq->u.data.pointer,
+                       MIN(wrq->u.data.length, sizeof(vals)))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+
+    }
+    switch (vals[0]) {          /* 1st byte is band */
+    case 'B':
+    case 'b':
+        band = BAND_B;
+        break;
+    case 'G':
+    case 'g':
+        band = BAND_G;
+        break;
+    case 'A':
+    case 'a':
+        band = BAND_A;
+        break;
+    default:
+        LEAVE();
+        return -EINVAL;
+    }
+
+    /* Validate against FW support */
+    if ((band | Adapter->fw_bands) & ~Adapter->fw_bands) {
+        LEAVE();
+        return -EINVAL;
+    }
+    chan = vals[1];
+
+    if (!find_cfp_by_band_and_channel(Adapter, band, (u16) chan)) {
+        PRINTM(INFO, "Invalid channel number %d\n", chan);
+        LEAVE();
+        return -EINVAL;
+    }
+
+    if (wlan_change_adhoc_chan(priv, chan) != WLAN_STATUS_SUCCESS) {
+        PRINTM(INFO, "Fail to change adhoc channel number %d\n", chan);
+        LEAVE();
+        return -EINVAL;
+    }
+    Adapter->adhoc_start_band = band;
+    Adapter->AdhocChannel = chan;
+    Adapter->AdhocAutoSel = FALSE;
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get band 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_get_band_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    char status[10], *ptr;
+    u16 val = priv->adapter->config_bands;
+
+    ENTER();
+
+    memset(status, 0, sizeof(status));
+    ptr = status;
+
+    if (val & BAND_A)
+        *ptr++ = 'a';
+
+    if (val & BAND_B)
+        *ptr++ = 'b';
+
+    if (val & BAND_G)
+        *ptr++ = 'g';
+
+    *ptr = '\0';
+
+    PRINTM(INFO, "Status = %s\n", status);
+    wrq->u.data.length = strlen(status) + 1;
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, &status, wrq->u.data.length)) {
+            LEAVE();
+            return -EFAULT;
+        }
+    }
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get adhoc channel 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_get_adhocch_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    u32 status[2];
+    wlan_adapter *Adapter = priv->adapter;
+    u16 band = Adapter->adhoc_start_band;
+
+    ENTER();
+
+    if (band & BAND_A) {
+        status[0] = 'a';
+    } else if (band & BAND_B) {
+        status[0] = 'b';
+    } else if (band & BAND_G) {
+        status[0] = 'g';
+    }
+
+    status[1] = Adapter->AdhocChannel;
+
+    if (wrq->u.data.pointer) {
+        wrq->u.data.length = sizeof(status);
+
+        if (copy_to_user(wrq->u.data.pointer, status, wrq->u.data.length))
+            return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set sleep period 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_sleep_period(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    int data;
+    wlan_adapter *Adapter = priv->adapter;
+    HostCmd_DS_802_11_SLEEP_PERIOD sleeppd;
+
+    ENTER();
+
+    if (wrq->u.data.length > 1) {
+        LEAVE();
+        return -ENOTSUPP;
+    }
+    memset(&sleeppd, 0, sizeof(sleeppd));
+    memset(&Adapter->sleep_period, 0, sizeof(SleepPeriod));
+
+    if (wrq->u.data.length == 0) {
+        sleeppd.Action = HostCmd_ACT_GEN_GET;
+    } else {
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+        /* sleep period is 0 or 10~60 in milliseconds */
+#define MIN_SLEEP_PERIOD		10
+#define MAX_SLEEP_PERIOD		60
+#define SLEEP_PERIOD_RESERVED_FF	0xFF
+        if ((data <= MAX_SLEEP_PERIOD && data >= MIN_SLEEP_PERIOD) ||
+            (data == 0)
+            || (data == SLEEP_PERIOD_RESERVED_FF)       /* for UPSD certification tests */
+            ) {
+            sleeppd.Action = HostCmd_ACT_GEN_SET;
+            sleeppd.Period = data;
+        } else {
+            LEAVE();
+            return -EINVAL;
+        }
+    }
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_SLEEP_PERIOD,
+                           0, HostCmd_OPTION_WAITFORRSP,
+                           0, (void *) &sleeppd);
+
+    data = (int) Adapter->sleep_period.period;
+    if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set adapt rate 
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_adapt_rateset(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+    int data[4];
+    int rateindex;
+
+    ENTER();
+    memset(data, 0, sizeof(data));
+    if (!wrq->u.data.length) {
+        PRINTM(INFO, "Get ADAPT RATE SET\n");
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_RATE_ADAPT_RATESET,
+                               HostCmd_ACT_GEN_GET, HostCmd_OPTION_WAITFORRSP,
+                               0, NULL);
+        data[0] = Adapter->HWRateDropMode;
+        data[2] = Adapter->Threshold;
+        data[3] = Adapter->FinalRate;
+        wrq->u.data.length = 4;
+        data[1] = Adapter->RateBitmap;
+        if (copy_to_user
+            (wrq->u.data.pointer, data, sizeof(int) * wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+    } else {
+        PRINTM(INFO, "Set ADAPT RATE SET\n");
+        if (wrq->u.data.length > 4) {
+            LEAVE();
+            return -EINVAL;
+        }
+        if (copy_from_user
+            (data, wrq->u.data.pointer, sizeof(int) * wrq->u.data.length)) {
+            LEAVE();
+            PRINTM(INFO, "Copy from user failed\n");
+            return -EFAULT;
+        }
+
+        if (data[0] > HW_SINGLE_RATE_DROP) {
+            LEAVE();
+            return -EINVAL;
+        }
+        Adapter->HWRateDropMode = data[0];
+        Adapter->Threshold = data[2];
+        Adapter->FinalRate = data[3];
+        Adapter->RateBitmap = data[1];
+        Adapter->Is_DataRate_Auto = wlan_is_rate_auto(priv);
+        if (Adapter->Is_DataRate_Auto)
+            Adapter->DataRate = 0;
+        else {
+            rateindex = wlan_get_rate_index(priv);
+            Adapter->DataRate = index_to_data_rate(rateindex);
+        }
+        PRINTM(INFO, "RateBitmap=%x,IsRateAuto=%d,DataRate=%d\n",
+               Adapter->RateBitmap, Adapter->Is_DataRate_Auto,
+               Adapter->DataRate);
+        ret =
+            wlan_prepare_cmd(priv, HostCmd_CMD_802_11_RATE_ADAPT_RATESET,
+                             HostCmd_ACT_GEN_SET, HostCmd_OPTION_WAITFORRSP,
+                             0, NULL);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set inactivity timeout
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_inactivity_timeout(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    int data = 0;
+    u16 timeout = 0;
+
+    ENTER();
+    if (wrq->u.data.length > 1) {
+        LEAVE();
+        return -ENOTSUPP;
+    }
+    if (wrq->u.data.length == 0) {
+        /* Get */
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_INACTIVITY_TIMEOUT,
+                               HostCmd_ACT_GEN_GET, HostCmd_OPTION_WAITFORRSP,
+                               0, &timeout);
+        data = timeout;
+        if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    } else {
+        /* Set */
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+        timeout = data;
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_INACTIVITY_TIMEOUT,
+                               HostCmd_ACT_GEN_SET, HostCmd_OPTION_WAITFORRSP,
+                               0, &timeout);
+    }
+
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get LOG
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param wrq			A pointer to iwreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_getlog_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    char *buf = NULL;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    PRINTM(INFO, " GET STATS\n");
+
+    if (!(buf = kmalloc(GETLOG_BUFSIZE, GFP_KERNEL))) {
+        PRINTM(INFO, "kmalloc failed!\n");
+        LEAVE();
+        return -ENOMEM;
+    }
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_GET_LOG,
+                           0, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    if (!ret && wrq->u.data.pointer) {
+        sprintf(buf, "\n"
+                "mcasttxframe     %u\n"
+                "failed           %u\n"
+                "retry            %u\n"
+                "multiretry       %u\n"
+                "framedup         %u\n"
+                "rtssuccess       %u\n"
+                "rtsfailure       %u\n"
+                "ackfailure       %u\n"
+                "rxfrag           %u\n"
+                "mcastrxframe     %u\n"
+                "fcserror         %u\n"
+                "txframe          %u\n",
+                Adapter->LogMsg.mcasttxframe,
+                Adapter->LogMsg.failed,
+                Adapter->LogMsg.retry,
+                Adapter->LogMsg.multiretry,
+                Adapter->LogMsg.framedup,
+                Adapter->LogMsg.rtssuccess,
+                Adapter->LogMsg.rtsfailure,
+                Adapter->LogMsg.ackfailure,
+                Adapter->LogMsg.rxfrag,
+                Adapter->LogMsg.mcastrxframe,
+                Adapter->LogMsg.fcserror, Adapter->LogMsg.txframe);
+        wrq->u.data.length = strlen(buf) + 1;
+        if (copy_to_user(wrq->u.data.pointer, buf, wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+    }
+
+    kfree(buf);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief config sleep parameters
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_sleep_params_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_sleep_params_config sp;
+
+    ENTER();
+
+    memset(&sp, 0, sizeof(sp));
+
+    if (!wrq->u.data.pointer) {
+        LEAVE();
+        return -EFAULT;
+    }
+    if (copy_from_user(&sp, wrq->u.data.pointer,
+                       MIN(sizeof(sp), wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    memcpy(&Adapter->sp, &sp.Error, sizeof(SleepParams));
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_SLEEP_PARAMS,
+                           sp.Action, HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+    if (!ret && !sp.Action) {
+        memcpy(&sp.Error, &Adapter->sp, sizeof(SleepParams));
+        if (copy_to_user(wrq->u.data.pointer, &sp, sizeof(sp))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        wrq->u.data.length = sizeof(sp);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Read the CIS Table
+ *  @param priv                 A pointer to wlan_private structure
+ *  @param req			A pointer to ifreq structure
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_do_getcis_ioctl(wlan_private * priv, struct ifreq *req)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    struct iwreq *wrq = (struct iwreq *) req;
+    char *cisinfo;
+#define MAX_CIS_INFO_LEN (512)
+    int cislen = MAX_CIS_INFO_LEN;
+
+    ENTER();
+
+    cisinfo = (char *) kmalloc(cislen, GFP_KERNEL);
+    if (!cisinfo) {
+        PRINTM(ERROR, "Memory allocation for cisinfo failed!\n");
+        ret = WLAN_STATUS_FAILURE;
+        goto done;
+    }
+
+    memset(cisinfo, 0, cislen);
+    ret = sbi_get_cis_info(priv, (void *) cisinfo, &cislen);
+    if (ret != WLAN_STATUS_SUCCESS) {
+        PRINTM(INFO, "Failed to get CIS information from card\n");
+        ret = -EFAULT;
+        goto done;
+    }
+
+    if (wrq->u.data.pointer) {
+        if (copy_to_user(wrq->u.data.pointer, cisinfo, cislen)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+            goto done;
+        }
+        wrq->u.data.length = cislen;
+    }
+
+  done:
+    if (cisinfo)
+        kfree(cisinfo);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set BCA timeshare
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_bca_timeshare_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int ret;
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_bca_timeshare_config bca_ts;
+
+    ENTER();
+
+    memset(&bca_ts, 0, sizeof(HostCmd_DS_802_11_BCA_TIMESHARE));
+
+    if (!wrq->u.data.pointer) {
+        LEAVE();
+        return -EFAULT;
+    }
+    if (copy_from_user(&bca_ts, wrq->u.data.pointer,
+                       MIN(sizeof(bca_ts), wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    PRINTM(INFO, "TrafficType=%x TimeShareInterva=%x BTTime=%x\n",
+           bca_ts.TrafficType, bca_ts.TimeShareInterval, bca_ts.BTTime);
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_BCA_CONFIG_TIMESHARE,
+                           bca_ts.Action, HostCmd_OPTION_WAITFORRSP,
+                           0, &bca_ts);
+
+    if (!ret && !bca_ts.Action) {
+        if (copy_to_user(wrq->u.data.pointer, &Adapter->bca_ts,
+                         sizeof(bca_ts))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        wrq->u.data.length = sizeof(HostCmd_DS_802_11_BCA_TIMESHARE);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set scan type
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_scan_type_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    u8 buf[12];
+    u8 *option[] = { "active", "passive", "get", };
+    int i, max_options = (sizeof(option) / sizeof(option[0]));
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (wlan_get_state_11d(priv) == ENABLE_11D) {
+        PRINTM(INFO, "11D: Cannot set scantype when 11D enabled\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    memset(buf, 0, sizeof(buf));
+
+    if (copy_from_user(buf, wrq->u.data.pointer, MIN(sizeof(buf),
+                                                     wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    PRINTM(INFO, "Scan Type Option = %s\n", buf);
+
+    buf[sizeof(buf) - 1] = '\0';
+
+    for (i = 0; i < max_options; i++) {
+        if (!strcmp(buf, option[i]))
+            break;
+    }
+
+    switch (i) {
+    case 0:
+        Adapter->ScanType = HostCmd_SCAN_TYPE_ACTIVE;
+        break;
+    case 1:
+        Adapter->ScanType = HostCmd_SCAN_TYPE_PASSIVE;
+        break;
+    case 2:
+        wrq->u.data.length = strlen(option[Adapter->ScanType]) + 1;
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         option[Adapter->ScanType], wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+
+        break;
+    default:
+        PRINTM(INFO, "Invalid Scan Type Ioctl Option\n");
+        ret = -EINVAL;
+        break;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Set scan mode
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_scan_mode_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u8 buf[12];
+    u8 *option[] = { "bss", "ibss", "any", "get" };
+    int i, max_options = (sizeof(option) / sizeof(option[0]));
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    memset(buf, 0, sizeof(buf));
+
+    if (copy_from_user(buf, wrq->u.data.pointer, MIN(sizeof(buf),
+                                                     wrq->u.data.length))) {
+        PRINTM(INFO, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    PRINTM(INFO, "Scan Mode Option = %s\n", buf);
+
+    buf[sizeof(buf) - 1] = '\0';
+
+    for (i = 0; i < max_options; i++) {
+        if (!strcmp(buf, option[i]))
+            break;
+    }
+
+    switch (i) {
+
+    case 0:
+        Adapter->ScanMode = HostCmd_BSS_TYPE_BSS;
+        break;
+    case 1:
+        Adapter->ScanMode = HostCmd_BSS_TYPE_IBSS;
+        break;
+    case 2:
+        Adapter->ScanMode = HostCmd_BSS_TYPE_ANY;
+        break;
+    case 3:
+
+        wrq->u.data.length = strlen(option[Adapter->ScanMode - 1]) + 1;
+
+        PRINTM(INFO, "Get Scan Mode Option = %s\n",
+               option[Adapter->ScanMode - 1]);
+
+        PRINTM(INFO, "Scan Mode Length %d\n", wrq->u.data.length);
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         option[Adapter->ScanMode - 1], wrq->u.data.length)) {
+            PRINTM(INFO, "Copy to user failed\n");
+            ret = -EFAULT;
+        }
+        PRINTM(INFO, "GET Scan Type Option after copy = %s\n",
+               (char *) wrq->u.data.pointer);
+
+        break;
+
+    default:
+        PRINTM(INFO, "Invalid Scan Mode Ioctl Option\n");
+        ret = -EINVAL;
+        break;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set Adhoc G Rate
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_do_set_grate_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data, data1;
+    int *val;
+
+    ENTER();
+
+    data1 = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+    switch (data1) {
+    case 0:
+        Adapter->adhoc_grate_enabled = FALSE;
+        break;
+    case 1:
+        Adapter->adhoc_grate_enabled = TRUE;
+        break;
+    case 2:
+        break;
+    default:
+        LEAVE();
+        return -EINVAL;
+    }
+    data = Adapter->adhoc_grate_enabled;
+    val = (int *) wrq->u.name;
+    *val = data;
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Firmware wakeup method
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_cmd_fw_wakeup_method(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u16 action;
+    u16 method;
+    int ret;
+    int data;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0 || !wrq->u.data.pointer) {
+        action = HostCmd_ACT_GEN_GET;
+        method = Adapter->fwWakeupMethod;
+    } else {
+        action = HostCmd_ACT_GEN_SET;
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+        switch (data) {
+        case 0:
+            method = WAKEUP_FW_UNCHANGED;
+            break;
+        case 1:
+            method = WAKEUP_FW_THRU_INTERFACE;
+            break;
+        case 2:
+            method = WAKEUP_FW_THRU_GPIO;
+            break;
+        default:
+            LEAVE();
+            return -EINVAL;
+        }
+    }
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_FW_WAKE_METHOD, action,
+                           HostCmd_OPTION_WAITFORRSP, 0, &method);
+
+    if (action == HostCmd_ACT_GEN_GET) {
+        method = Adapter->fwWakeupMethod;
+        if (copy_to_user(wrq->u.data.pointer, &method, sizeof(method))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+        wrq->u.data.length = 1;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get/Set Auto Deep Sleep mode
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_auto_deep_sleep(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data;
+
+    ENTER();
+
+    if (wrq->u.data.length > 0 && wrq->u.data.pointer) {
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+        switch (data) {
+        case 0:
+            if (Adapter->IsAutoDeepSleepEnabled) {
+                Adapter->IsAutoDeepSleepEnabled = FALSE;
+                /* Try to exit DS if auto DS disabled */
+                wlan_set_deep_sleep(priv, FALSE);
+            }
+            break;
+        case 1:
+            if (!Adapter->IsAutoDeepSleepEnabled) {
+                Adapter->IsAutoDeepSleepEnabled = TRUE;
+                /* Wakeup main thread to enter DS if auto DS enabled */
+                wake_up_interruptible(&priv->MainThread.waitQ);
+            }
+            break;
+        default:
+            LEAVE();
+            return -EINVAL;
+        }
+    }
+
+    data = Adapter->IsAutoDeepSleepEnabled;
+    if (copy_to_user(wrq->u.data.pointer, &data, sizeof(data))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get/Set Enhanced PS mode
+ *  
+ *  @param priv		A pointer to wlan_private structure
+ *  @param wrq	   	A pointer to user data
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+wlan_enhanced_ps(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int data;
+
+    ENTER();
+
+    if (wrq->u.data.length > 0 && wrq->u.data.pointer) {
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            LEAVE();
+            return -EFAULT;
+        }
+
+        switch (data) {
+        case 0:
+            Adapter->IsEnhancedPSEnabled = FALSE;
+            break;
+        case 1:
+            Adapter->IsEnhancedPSEnabled = TRUE;
+            break;
+        default:
+            LEAVE();
+            return -EINVAL;
+        }
+    }
+
+    data = Adapter->IsEnhancedPSEnabled;
+    if (copy_to_user(wrq->u.data.pointer, &data, sizeof(data))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Set MEF cfg 
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param wrq      A pointer to iwreq structure
+ *
+ *  @return         WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_mef_cfg(wlan_private * priv, struct iwreq *wrq)
+{
+    u8 *tempResponseBuffer = NULL;
+    MEF_CFG_DATA *pMefData = NULL;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if ((wrq->u.data.pointer == NULL) ||
+        (wrq->u.data.length < sizeof(HostCmd_DS_MEF_CFG))) {
+        PRINTM(INFO, "wlan_set_mef_cfg corrupt data: pointer=%p, length=%d\n",
+               wrq->u.data.pointer, wrq->u.data.length);
+        LEAVE();
+        return -EFAULT;
+    }
+    if (!
+        (tempResponseBuffer =
+         kmalloc(MRVDRV_SIZE_OF_CMD_BUFFER, GFP_KERNEL))) {
+        PRINTM(INFO, "ERROR: Failed to allocate response buffer!\n");
+        LEAVE();
+        return -ENOMEM;
+    }
+    pMefData = (MEF_CFG_DATA *) tempResponseBuffer;
+
+    /*
+     * Copy the whole command into the command buffer 
+     */
+    if (copy_from_user
+        ((u8 *) & pMefData->data, wrq->u.data.pointer, wrq->u.data.length)) {
+        PRINTM(INFO, "Copy from user failed\n");
+        kfree(tempResponseBuffer);
+        LEAVE();
+        return -EFAULT;
+    }
+    pMefData->size = wrq->u.data.length;
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_MEF_CFG, 0,
+                           HostCmd_OPTION_WAITFORRSP, 0, tempResponseBuffer);
+    kfree(tempResponseBuffer);
+    LEAVE();
+    return ret;
+
+}
+
+/**
+ *  @brief Get the CFP table based on the region code
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param wrq      A pointer to iwreq structure
+ *
+ *  @return         WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_cfp_table_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    pwlan_ioctl_cfp_table ioctl_cfp;
+    CHANNEL_FREQ_POWER *cfp;
+    int cfp_no;
+    int regioncode;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0 || !wrq->u.data.pointer) {
+        ret = -EINVAL;
+        goto cfpexit;
+    }
+
+    ioctl_cfp = (pwlan_ioctl_cfp_table) wrq->u.data.pointer;
+
+    if (copy_from_user(&regioncode, &ioctl_cfp->region, sizeof(int))) {
+        PRINTM(INFO, "Get CFP table: copy from user failed\n");
+        ret = -EFAULT;
+        goto cfpexit;
+    }
+
+    if (!regioncode)
+        regioncode = Adapter->RegionCode;
+
+    cfp =
+        wlan_get_region_cfp_table((u8) regioncode, (u8) Adapter->config_bands,
+                                  &cfp_no);
+
+    if (cfp == NULL) {
+        PRINTM(MSG, "No related CFP table found, region code = 0x%x\n",
+               regioncode);
+        ret = -EFAULT;
+        goto cfpexit;
+    }
+
+    if (copy_to_user(&ioctl_cfp->cfp_no, &cfp_no, sizeof(int))) {
+        PRINTM(INFO, "Get CFP table: copy to user failed\n");
+        ret = -EFAULT;
+        goto cfpexit;
+    }
+
+    if (copy_to_user
+        (ioctl_cfp->cfp, cfp, sizeof(CHANNEL_FREQ_POWER) * cfp_no)) {
+        PRINTM(INFO, "Get CFP table: copy to user failed\n");
+        ret = -EFAULT;
+        goto cfpexit;
+    }
+
+    wrq->u.data.length =
+        sizeof(int) * 2 + sizeof(CHANNEL_FREQ_POWER) * cfp_no;
+
+  cfpexit:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Get firmware memory
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param wrq      A pointer to iwreq structure
+ *
+ *  @return         WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_firmware_mem(wlan_private * priv, struct iwreq *wrq)
+{
+    HostCmd_DS_GET_MEM *pGetMem;
+    u8 *buf = NULL;
+    FW_MEM_DATA *pFwData;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if ((wrq->u.data.length < sizeof(HostCmd_DS_GET_MEM)) ||
+        !wrq->u.data.pointer) {
+        ret = -EINVAL;
+        LEAVE();
+        return ret;
+    }
+    if (!(buf = kmalloc(MRVDRV_SIZE_OF_CMD_BUFFER, GFP_KERNEL))) {
+        PRINTM(INFO, "allocate  buffer failed!\n");
+        LEAVE();
+        return -ENOMEM;
+    }
+    memset(buf, 0, MRVDRV_SIZE_OF_CMD_BUFFER);
+    pFwData = (FW_MEM_DATA *) buf;
+    pGetMem = &pFwData->data;
+
+    if (copy_from_user
+        (pGetMem, wrq->u.data.pointer, sizeof(HostCmd_DS_GET_MEM))) {
+        PRINTM(INFO, "Get Mem: copy from user failed\n");
+        ret = -EFAULT;
+        goto memexit;
+    }
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_GET_MEM, 0,
+                           HostCmd_OPTION_WAITFORRSP, 0, buf);
+    if (!ret) {
+        wrq->u.data.length = pFwData->size;
+        if (copy_to_user
+            (wrq->u.data.pointer, (u8 *) pGetMem, wrq->u.data.length)) {
+            PRINTM(INFO, "Get Mem: copy to user failed\n");
+            ret = -EFAULT;
+            goto memexit;
+        }
+    }
+  memexit:
+    kfree(buf);
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief  Retrieve transmit packet statistics from the firmware
+ *
+ *  @param priv     A pointer to wlan_private structure
+ *  @param wrq      A pointer to iwreq structure
+ *
+ *  @return         WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_tx_pkt_stats_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    HostCmd_DS_TX_PKT_STATS txPktStats;
+    int ret;
+
+    ENTER();
+
+    if (wrq->u.data.length == 0 || !wrq->u.data.pointer) {
+        LEAVE();
+        return -EINVAL;
+    }
+
+    if (wrq->u.data.length < sizeof(txPktStats)) {
+        LEAVE();
+        return -E2BIG;
+    }
+
+    memset(&txPktStats, 0x00, sizeof(txPktStats));
+
+    if ((ret = wlan_prepare_cmd(priv,
+                                HostCmd_CMD_TX_PKT_STATS, 0,
+                                HostCmd_OPTION_WAITFORRSP, 0, &txPktStats))) {
+        LEAVE();
+        return ret;
+    }
+
+    if (copy_to_user(wrq->u.data.pointer,
+                     (u8 *) & txPktStats, sizeof(txPktStats))) {
+        PRINTM(INFO, "TxPktStats: copy to user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+/** 
+ *  @brief ioctl function - entry point
+ *  
+ *  @param dev		A pointer to net_device structure
+ *  @param req	   	A pointer to ifreq structure
+ *  @param cmd 		command
+ *  @return 	   	WLAN_STATUS_SUCCESS--success, otherwise fail
+ */
+int
+wlan_do_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+    int subcmd = 0;
+    int idata = 0;
+    int *pdata;
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    struct iwreq *wrq = (struct iwreq *) req;
+
+    ENTER();
+
+    if (Adapter->bHostSleepConfigured) {
+        BOOLEAN cmd_allowed = FALSE;
+        int count = sizeof(Commands_Allowed_In_HostSleep)
+            / sizeof(Commands_Allowed_In_HostSleep[0]);
+
+        if (cmd == WLAN_SET_GET_SIXTEEN_INT &&
+            ((int) wrq->u.data.flags == WLANHSCFG)) {
+            u32 cond;
+            if (copy_from_user(&cond, wrq->u.data.pointer, sizeof(cond))) {
+                PRINTM(INFO, "Copy from user failed\n");
+                LEAVE();
+                return -EFAULT;
+            }
+
+            if (cond == HOST_SLEEP_CFG_CANCEL) {
+                cmd_allowed = TRUE;
+                if (Adapter->IsDeepSleep) {
+                    wlan_set_deep_sleep(priv, FALSE);
+                }
+            }
+        } else
+            if (wlan_is_cmd_allowed_in_ds_hs
+                (req, cmd, Commands_Allowed_In_HostSleep, count)) {
+            cmd_allowed = TRUE;
+        }
+        if (!cmd_allowed) {
+            PRINTM(MSG, "%s IOCTLS called when WLAN access is blocked\n",
+                   __FUNCTION__);
+            LEAVE();
+            return -EBUSY;
+        }
+    }
+
+    if (!Adapter->IsAutoDeepSleepEnabled) {
+        if (Adapter->IsDeepSleep) {
+            int count = sizeof(Commands_Allowed_In_DeepSleep)
+                / sizeof(Commands_Allowed_In_DeepSleep[0]);
+
+            if (!wlan_is_cmd_allowed_in_ds_hs
+                (req, cmd, Commands_Allowed_In_DeepSleep, count)) {
+                PRINTM(MSG,
+                       "():%s IOCTLS called when station is"
+                       " in DeepSleep\n", __FUNCTION__);
+                LEAVE();
+                return -EBUSY;
+            }
+        }
+    } else {
+        int count = sizeof(Commands_DisAllowed_In_AutoDeepSleep) /
+            sizeof(Commands_DisAllowed_In_AutoDeepSleep[0]);
+        if (wlan_is_cmd_disallowed_in_ads(req, cmd,
+                                          Commands_DisAllowed_In_AutoDeepSleep,
+                                          count)) {
+            PRINTM(MSG, "Command is not allowed in AutoDeepSleep mode\n");
+            LEAVE();
+            return -EBUSY;
+        }
+    }
+
+    PRINTM(INFO, "wlan_do_ioctl: ioctl cmd = 0x%x\n", cmd);
+    switch (cmd) {
+    case WLANEXTSCAN:
+        ret = wlan_extscan_ioctl(priv, req);
+        break;
+    case WLANHOSTCMD:
+        ret = wlan_hostcmd_ioctl(dev, req, cmd);
+        break;
+    case WLANARPFILTER:
+        ret = wlan_arpfilter_ioctl(dev, req, cmd);
+        break;
+
+    case WLANCISDUMP:          /* Read CIS Table  */
+        ret = wlan_do_getcis_ioctl(priv, req);
+        break;
+
+    case WLANSCAN_TYPE:
+        PRINTM(INFO, "Scan Type Ioctl\n");
+        ret = wlan_scan_type_ioctl(priv, wrq);
+        break;
+
+    case WLAN_SETADDR_GETNONE:
+        switch (wrq->u.data.flags) {
+        case WLANDEAUTH:
+            {
+                struct sockaddr saddr;
+
+                PRINTM(INFO, "Deauth\n");
+
+                if (wrq->u.data.length) {
+                    if (copy_from_user(&saddr,
+                                       wrq->u.data.pointer, sizeof(saddr))) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        LEAVE();
+                        return -EFAULT;
+                    }
+                    wmm_stop_queue(priv);
+                    ret =
+                        wlan_prepare_cmd(priv,
+                                         HostCmd_CMD_802_11_DEAUTHENTICATE, 0,
+                                         HostCmd_OPTION_WAITFORRSP, 0,
+                                         &saddr);
+
+                    if (Adapter->MediaConnectStatus ==
+                        WlanMediaStateConnected) {
+                        wmm_start_queue(priv);
+                        os_carrier_on(priv);
+                        os_start_queue(priv);
+                    }
+                } else {
+                    ret = wlan_disconnect(priv);
+                }
+                break;
+            }
+
+        default:
+            ret = -EOPNOTSUPP;
+            break;
+        }
+        break;
+
+#ifdef MFG_CMD_SUPPORT
+    case WLANMANFCMD:
+        PRINTM(INFO, "Entering the Manufacturing ioctl SIOCCFMFG\n");
+        ret = wlan_mfg_command(priv, wrq);
+
+        PRINTM(INFO, "Manufacturing Ioctl %s\n",
+               (ret) ? "failed" : "success");
+        break;
+#endif
+
+    case WLANREGRDWR:          /* Register read write command */
+        ret = wlan_regrdwr_ioctl(priv, req);
+        break;
+
+    case WLANCMD52RDWR:        /* CMD52 read/write command */
+        ret = wlan_cmd52rdwr_ioctl(priv, req);
+        break;
+
+    case WLANCMD53RDWR:        /* CMD53 read/write command */
+        ret = wlan_cmd53rdwr_ioctl(priv, req);
+        break;
+
+    case SIOCSIWENCODE:        /* set encoding token & mode for WPA */
+        ret = wlan_set_encode(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);
+        break;
+    case WLAN_SETNONE_GETNONE: /* set WPA mode on/off ioctl #20 */
+        switch (wrq->u.data.flags) {
+        case WLANADHOCSTOP:
+            PRINTM(INFO, "Adhoc stop\n");
+            ret = wlan_do_adhocstop_ioctl(priv);
+            break;
+
+        case WLANRADIOON:
+            wlan_radio_ioctl(priv, RADIO_ON);
+            break;
+
+        case WLANRADIOOFF:
+            ret = wlan_radio_ioctl(priv, RADIO_OFF);
+            break;
+        case WLANREMOVEADHOCAES:
+            ret = wlan_remove_aes(priv);
+            break;
+        case WLANCRYPTOTEST:
+            ret = wlan_crypto_test(priv, wrq);
+            break;
+#ifdef REASSOCIATION
+        case WLANREASSOCIATIONAUTO:
+            reassociation_on(priv);
+            break;
+        case WLANREASSOCIATIONUSER:
+            reassociation_off(priv);
+            break;
+#endif /* REASSOCIATION */
+        case WLANWLANIDLEON:
+            wlanidle_on(priv);
+            break;
+        case WLANWLANIDLEOFF:
+            wlanidle_off(priv);
+            break;
+        }                       /* End of switch */
+        break;
+
+    case WLAN_SETWORDCHAR_GETNONE:
+        switch (wrq->u.data.flags) {
+        case WLANSETADHOCAES:
+            ret = wlan_setadhocaes_ioctl(priv, req);
+            break;
+        }
+        break;
+
+    case WLAN_SETONEINT_GETWORDCHAR:
+        switch (wrq->u.data.flags) {
+        case WLANGETADHOCAES:
+            ret = wlan_getadhocaes_ioctl(priv, req);
+            break;
+        case WLANVERSION:      /* Get driver version */
+            ret = wlan_version_ioctl(priv, req);
+            break;
+        case WLANVEREXT:
+            ret = wlan_verext_ioctl(priv, wrq);
+            break;
+        }
+        break;
+
+    case WLANSETWPAIE:
+        ret = wlan_set_wpa_ie_ioctl(priv, req);
+        break;
+    case WLAN_SETINT_GETINT:
+        /* The first 4 bytes of req->ifr_data is sub-ioctl number
+         * after 4 bytes sits the payload.
+         */
+        subcmd = (int) req->ifr_data;   //from iwpriv subcmd
+        switch (subcmd) {
+        case WLANNF:
+            ret = wlan_get_nf(priv, wrq);
+            break;
+        case WLANRSSI:
+            ret = wlan_get_rssi(priv, wrq);
+            break;
+        case WLANBGSCAN:
+            {
+                int data, data1;
+                int *val;
+                data1 = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+                switch (data1) {
+                case CMD_DISABLED:
+                    PRINTM(INFO, "Background scan is set to disable\n");
+                    ret = wlan_bg_scan_enable(priv, FALSE);
+                    val = (int *) wrq->u.name;
+                    *val = data1;
+                    break;
+                case CMD_ENABLED:
+                    PRINTM(INFO, "Background scan is set to enable\n");
+                    ret = wlan_bg_scan_enable(priv, TRUE);
+                    val = (int *) wrq->u.name;
+                    *val = data1;
+                    break;
+                case CMD_GET:
+                    data = (Adapter->bgScanConfig->Enable == TRUE) ?
+                        CMD_ENABLED : CMD_DISABLED;
+                    val = (int *) wrq->u.name;
+                    *val = data;
+                    break;
+                default:
+                    ret = -EINVAL;
+                    PRINTM(INFO, "Background scan: wrong parameter\n");
+                    break;
+                }
+            }
+            break;
+        case WLANENABLE11D:
+            ret = wlan_cmd_enable_11d(priv, wrq);
+            break;
+        case WLANADHOCGRATE:
+            ret = wlan_do_set_grate_ioctl(priv, wrq);
+            break;
+        case WLANSDIOCLOCK:
+            {
+                int data;
+                int *val;
+                data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+                switch (data) {
+                case CMD_DISABLED:
+                    PRINTM(INFO, "SDIO clock is turned off\n");
+                    ret = sbi_set_bus_clock(priv, FALSE);
+                    break;
+                case CMD_ENABLED:
+                    PRINTM(INFO, "SDIO clock is turned on\n");
+                    ret = sbi_set_bus_clock(priv, TRUE);
+                    break;
+                case CMD_GET:  /* need an API in sdio.c to get STRPCL */
+                default:
+                    ret = -EINVAL;
+                    PRINTM(INFO, "sdioclock: wrong parameter\n");
+                    break;
+                }
+                val = (int *) wrq->u.name;
+                *val = data;
+            }
+            break;
+        case WLANWMM_ENABLE:
+            ret = wlan_wmm_enable_ioctl(priv, wrq);
+            break;
+        case WLANNULLGEN:
+            ret = wlan_null_pkg_gen(priv, wrq);
+            /* enable/disable null pkg generation */
+            break;
+        case WLANADHOCCSET:
+            ret = wlan_set_coalescing_ioctl(priv, wrq);
+            break;
+        case WLAN_ADHOC_G_PROT:
+            ret = wlan_adhoc_g_protection(priv, wrq);
+            break;
+        }
+        break;
+
+    case WLAN_SETONEINT_GETONEINT:
+        switch (wrq->u.data.flags) {
+        case WLAN_11H_SETLOCALPOWER:
+            ret = wlan_11h_ioctl_get_local_power(priv, wrq);
+            break;
+
+        case WLAN_WMM_QOSINFO:
+            {
+                int data;
+                if (wrq->u.data.length == 1) {
+                    if (copy_from_user
+                        (&data, wrq->u.data.pointer, sizeof(int))) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        LEAVE();
+                        return -EFAULT;
+                    }
+                    Adapter->wmm.qosinfo = (u8) data;
+                } else {
+                    data = (int) Adapter->wmm.qosinfo;
+                    if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+                        PRINTM(INFO, "Copy to user failed\n");
+                        LEAVE();
+                        return -EFAULT;
+                    }
+                    wrq->u.data.length = 1;
+                }
+            }
+            break;
+        case WLAN_LISTENINTRVL:
+            if (!wrq->u.data.length) {
+                int data;
+                PRINTM(INFO, "Get LocalListenInterval Value\n");
+#define GET_ONE_INT	1
+                data = Adapter->LocalListenInterval;
+                if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+                    PRINTM(INFO, "Copy to user failed\n");
+                    LEAVE();
+                    return -EFAULT;
+                }
+
+                wrq->u.data.length = GET_ONE_INT;
+            } else {
+                int data;
+                if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+                    PRINTM(INFO, "Copy from user failed\n");
+                    LEAVE();
+                    return -EFAULT;
+                }
+
+                PRINTM(INFO, "Set LocalListenInterval = %d\n", data);
+#define MAX_U16_VAL	65535
+                if (data > MAX_U16_VAL) {
+                    PRINTM(INFO, "Exceeds U16 value\n");
+                    LEAVE();
+                    return -EINVAL;
+                }
+                Adapter->LocalListenInterval = data;
+            }
+            break;
+        case WLAN_FW_WAKEUP_METHOD:
+            ret = wlan_cmd_fw_wakeup_method(priv, wrq);
+            break;
+        case WLAN_NULLPKTINTERVAL:
+            ret = wlan_null_pkt_interval(priv, wrq);
+            break;
+        case WLAN_BCN_MISS_TIMEOUT:
+            ret = wlan_bcn_miss_timeout(priv, wrq);
+            break;
+        case WLAN_ADHOC_AWAKE_PERIOD:
+            ret = wlan_adhoc_awake_period(priv, wrq);
+            break;
+        case WLAN_MODULE_TYPE:
+            ret = wlan_module_type_config(priv, wrq);
+            break;
+        case WLAN_AUTODEEPSLEEP:
+            ret = wlan_auto_deep_sleep(priv, wrq);
+            break;
+        case WLAN_ENHANCEDPS:
+            ret = wlan_enhanced_ps(priv, wrq);
+            break;
+        case WLAN_WAKEUP_MT:
+            if (wrq->u.data.length > 0)
+                Adapter->IntCounter++;
+            wake_up_interruptible(&priv->MainThread.waitQ);
+            break;
+        default:
+            ret = -EOPNOTSUPP;
+            break;
+        }
+        break;
+
+    case WLAN_SETONEINT_GETNONE:
+        /* The first 4 bytes of req->ifr_data is sub-ioctl number
+         * after 4 bytes sits the payload.
+         */
+        subcmd = wrq->u.data.flags;     //from wpa_supplicant subcmd
+
+        if (!subcmd)
+            subcmd = (int) req->ifr_data;       //from iwpriv subcmd
+
+        idata = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+
+        switch (subcmd) {
+        case WLAN_SUBCMD_SETRXANTENNA: /* SETRXANTENNA */
+            ret = wlan_set_rx_antenna(priv, idata);
+            break;
+        case WLAN_SUBCMD_SETTXANTENNA: /* SETTXANTENNA */
+            ret = wlan_set_tx_antenna(priv, idata);
+            break;
+
+        case WLANSETBCNAVG:
+            if (idata == 0)
+                Adapter->bcn_avg_factor = DEFAULT_BCN_AVG_FACTOR;
+            else if (idata > MAX_BCN_AVG_FACTOR || idata < MIN_BCN_AVG_FACTOR) {
+                PRINTM(MSG, "The value '%u' is out of the range (0-%u).\n",
+                       idata, MAX_BCN_AVG_FACTOR);
+                LEAVE();
+                return -EINVAL;
+            } else
+                Adapter->bcn_avg_factor = idata;
+            break;
+        case WLANSETDATAAVG:
+            if (idata == 0)
+                Adapter->data_avg_factor = DEFAULT_DATA_AVG_FACTOR;
+            else if (idata > MAX_DATA_AVG_FACTOR
+                     || idata < MIN_DATA_AVG_FACTOR) {
+                PRINTM(MSG, "The value '%u' is out of the range (0-%u).\n",
+                       idata, MAX_DATA_AVG_FACTOR);
+                LEAVE();
+                return -EINVAL;
+            } else
+                Adapter->data_avg_factor = idata;
+            memset(Adapter->rawSNR, 0x00, sizeof(Adapter->rawSNR));
+            memset(Adapter->rawNF, 0x00, sizeof(Adapter->rawNF));
+            Adapter->nextSNRNF = 0;
+            Adapter->numSNRNF = 0;
+            break;
+        case WLANASSOCIATE:
+            ret = wlan_associate_to_table_idx(priv, idata);
+            break;
+
+        case WLANSETREGION:
+            ret = wlan_set_region(priv, (u16) idata);
+            break;
+
+        case WLAN_SET_LISTEN_INTERVAL:
+            Adapter->ListenInterval = (u16) idata;
+            break;
+
+        case WLAN_SET_MULTIPLE_DTIM:
+            ret = wlan_set_multiple_dtim_ioctl(priv, req);
+            break;
+
+        case WLANSETAUTHALG:
+            ret = wlan_setauthalg_ioctl(priv, req);
+            break;
+
+        case WLANSETENCRYPTIONMODE:
+            ret = wlan_setencryptionmode_ioctl(priv, req);
+            break;
+
+        default:
+            ret = -EOPNOTSUPP;
+            break;
+        }
+
+        break;
+
+    case WLAN_SETNONE_GETTWELVE_CHAR:  /* Get Antenna settings */
+        /* 
+         * We've not used IW_PRIV_TYPE_FIXED so sub-ioctl number is
+         * in flags of iwreq structure, otherwise it will be in
+         * mode member of iwreq structure.
+         */
+        switch ((int) wrq->u.data.flags) {
+        case WLAN_SUBCMD_GETRXANTENNA: /* Get Rx Antenna */
+            ret = wlan_subcmd_getrxantenna_ioctl(priv, req);
+            break;
+
+        case WLAN_SUBCMD_GETTXANTENNA: /* Get Tx Antenna */
+            ret = wlan_subcmd_gettxantenna_ioctl(priv, req);
+            break;
+
+        case WLAN_GET_TSF:
+            ret = wlan_get_tsf_ioctl(priv, wrq);
+            break;
+
+        case WLAN_WPS_SESSION:
+            ret = wlan_do_wps_session_ioctl(priv, wrq);
+            break;
+        }
+        break;
+
+    case WLANDEEPSLEEP:
+        ret = wlan_deepsleep_ioctl(priv, req);
+        break;
+
+    case WLAN_SET64CHAR_GET64CHAR:
+        switch ((int) wrq->u.data.flags) {
+        case WLAN_11H_REQUESTTPC:
+            ret = wlan_11h_ioctl_request_tpc(priv, wrq);
+            break;
+        case WLAN_11H_SETPOWERCAP:
+            ret = wlan_11h_ioctl_set_power_cap(priv, wrq);
+            break;
+        case WLAN_MEASREQ:
+            ret = wlan_meas_ioctl_send_req(priv, wrq);
+            break;
+
+        case WLANSLEEPPARAMS:
+            ret = wlan_sleep_params_ioctl(priv, wrq);
+            break;
+
+        case WLAN_BCA_TIMESHARE:
+            ret = wlan_bca_timeshare_ioctl(priv, wrq);
+            break;
+        case WLANSCAN_MODE:
+            PRINTM(INFO, "Scan Mode Ioctl\n");
+            ret = wlan_scan_mode_ioctl(priv, wrq);
+            break;
+
+        case WLAN_GET_ADHOC_STATUS:
+            ret = wlan_get_adhoc_status_ioctl(priv, wrq);
+            break;
+        case WLAN_SET_GEN_IE:
+            ret = wlan_set_gen_ie_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_GEN_IE:
+            ret = wlan_get_gen_ie_ioctl(priv, wrq);
+            break;
+        case WLAN_WMM_QUEUE_STATUS:
+            ret = wlan_wmm_queue_status_ioctl(priv, wrq);
+            break;
+        case WLAN_WMM_TS_STATUS:
+            ret = wlan_wmm_ts_status_ioctl(priv, wrq);
+            break;
+        }
+        break;
+
+    case WLAN_SETCONF_GETCONF:
+        PRINTM(INFO, "The WLAN_SETCONF_GETCONF=0x%x is %d\n",
+               WLAN_SETCONF_GETCONF, *(u8 *) req->ifr_data);
+        switch (*(u8 *) req->ifr_data) {
+        case CAL_DATA_EXT_CONFIG:
+            ret = wlan_do_caldata_ext_ioctl(priv, req);
+            break;
+        case BG_SCAN_CONFIG:
+            ret = wlan_do_bg_scan_config_ioctl(priv, req);
+            break;
+        case BG_SCAN_CFG:
+            ret = wlan_do_bgscfg_ioctl(priv, req);
+            break;
+        }
+        break;
+
+    case WLAN_SETNONE_GETONEINT:
+        switch ((int) req->ifr_data) {
+        case WLANGETBCNAVG:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->bcn_avg_factor;
+            break;
+
+        case WLANGETDATAAVG:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->data_avg_factor;
+            break;
+
+        case WLANGETREGION:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->RegionCode;
+            break;
+
+        case WLAN_GET_LISTEN_INTERVAL:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->ListenInterval;
+            break;
+
+        case WLAN_GET_MULTIPLE_DTIM:
+            pdata = (int *) wrq->u.name;
+            *pdata = (int) Adapter->MultipleDtim;
+            break;
+        case WLAN_GET_TX_RATE:
+            ret = wlan_get_txrate_ioctl(priv, req);
+            break;
+        default:
+            ret = -EOPNOTSUPP;
+
+        }
+
+        break;
+
+    case WLAN_SETTENCHAR_GETNONE:
+        switch ((int) wrq->u.data.flags) {
+        case WLAN_SET_BAND:
+            ret = wlan_do_setband_ioctl(priv, wrq);
+            break;
+
+        case WLAN_SET_ADHOC_CH:
+            ret = wlan_do_setadhocch_ioctl(priv, wrq);
+            break;
+
+        case WLAN_11H_CHANSWANN:
+            ret = wlan_11h_ioctl_chan_sw_ann(priv, wrq);
+            break;
+        }
+        break;
+
+    case WLAN_SETNONE_GETTENCHAR:
+        switch ((int) wrq->u.data.flags) {
+        case WLAN_GET_BAND:
+            ret = wlan_do_get_band_ioctl(priv, wrq);
+            break;
+
+        case WLAN_GET_ADHOC_CH:
+            ret = wlan_do_get_adhocch_ioctl(priv, wrq);
+            break;
+        }
+        break;
+
+    case WLANGETLOG:
+        ret = wlan_do_getlog_ioctl(priv, wrq);
+        break;
+
+    case WLAN_SET_GET_SIXTEEN_INT:
+        switch ((int) wrq->u.data.flags) {
+        case WLAN_TPCCFG:
+            {
+                int data[5];
+                HostCmd_DS_802_11_TPC_CFG cfg;
+                memset(&cfg, 0, sizeof(cfg));
+                if ((wrq->u.data.length > 1) && (wrq->u.data.length != 5)) {
+                    LEAVE();
+                    return WLAN_STATUS_FAILURE;
+                }
+                if (wrq->u.data.length == 0) {
+                    cfg.Action = HostCmd_ACT_GEN_GET;
+                } else {
+                    if (copy_from_user(data,
+                                       wrq->u.data.pointer,
+                                       sizeof(int) * 5)) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        LEAVE();
+                        return -EFAULT;
+                    }
+
+                    cfg.Action = HostCmd_ACT_GEN_SET;
+                    cfg.Enable = data[0];
+                    cfg.UseSNR = data[1];
+#define TPC_DATA_NO_CHANG	0x7f
+                    if (wrq->u.data.length == 1) {
+                        cfg.P0 = TPC_DATA_NO_CHANG;
+                        cfg.P1 = TPC_DATA_NO_CHANG;
+                        cfg.P2 = TPC_DATA_NO_CHANG;
+                    } else {
+                        cfg.P0 = data[2];
+                        cfg.P1 = data[3];
+                        cfg.P2 = data[4];
+                    }
+                }
+
+                ret = wlan_prepare_cmd(priv,
+                                       HostCmd_CMD_802_11_TPC_CFG, 0,
+                                       HostCmd_OPTION_WAITFORRSP, 0,
+                                       (void *) &cfg);
+
+                data[0] = cfg.Enable;
+                data[1] = cfg.UseSNR;
+                data[2] = cfg.P0;
+                data[3] = cfg.P1;
+                data[4] = cfg.P2;
+                if (copy_to_user(wrq->u.data.pointer, data, sizeof(int) * 5)) {
+                    PRINTM(INFO, "Copy to user failed\n");
+                    LEAVE();
+                    return -EFAULT;
+                }
+
+                wrq->u.data.length = 5;
+            }
+            break;
+
+        case WLAN_SCANPROBES:
+            {
+                int data;
+                if (wrq->u.data.length > 0) {
+                    if (copy_from_user
+                        (&data, wrq->u.data.pointer, sizeof(int))) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        LEAVE();
+                        return -EFAULT;
+                    }
+
+                    Adapter->ScanProbes = data;
+                } else {
+                    data = Adapter->ScanProbes;
+                    if (copy_to_user(wrq->u.data.pointer, &data, sizeof(int))) {
+                        PRINTM(INFO, "Copy to user failed\n");
+                        LEAVE();
+                        return -EFAULT;
+                    }
+                }
+                wrq->u.data.length = 1;
+            }
+            break;
+        case WLAN_LED_GPIO_CTRL:
+            {
+                int i;
+                int data[MAX_LEDS * 2];
+                HostCmd_DS_802_11_LED_CTRL ctrl;
+                MrvlIEtypes_LedGpio_t *gpio;
+
+                gpio = (MrvlIEtypes_LedGpio_t *) & ctrl.LedGpio;
+
+                if ((wrq->u.data.length > MAX_LEDS * 2) ||
+                    (wrq->u.data.length % 2) != 0) {
+                    PRINTM(MSG, "invalid ledgpio parameters\n");
+                    LEAVE();
+                    return -EINVAL;
+                }
+
+                memset(&ctrl, 0, sizeof(ctrl));
+                if (wrq->u.data.length == 0) {
+                    ctrl.Action = HostCmd_ACT_GEN_GET;
+                } else {
+                    if (copy_from_user(data, wrq->u.data.pointer,
+                                       sizeof(int) * wrq->u.data.length)) {
+                        PRINTM(INFO, "Copy from user failed\n");
+                        LEAVE();
+                        return -EFAULT;
+                    }
+
+                    ctrl.Action = HostCmd_ACT_GEN_SET;
+                    ctrl.LedNums = 0;
+                    gpio->Header.Type = TLV_TYPE_LED_GPIO;
+                    gpio->Header.Len = wrq->u.data.length;
+                    for (i = 0; i < wrq->u.data.length; i += 2) {
+                        gpio->LedGpio[i / 2].LedNum = data[i];
+                        gpio->LedGpio[i / 2].GpioNum = data[i + 1];
+                    }
+                }
+                ret = wlan_prepare_cmd(priv,
+                                       HostCmd_CMD_802_11_LED_CONTROL, 0,
+                                       HostCmd_OPTION_WAITFORRSP,
+                                       0, (void *) &ctrl);
+
+                for (i = 0; i < gpio->Header.Len; i += 2) {
+                    data[i] = gpio->LedGpio[i / 2].LedNum;
+                    data[i + 1] = gpio->LedGpio[i / 2].GpioNum;
+                }
+                if (copy_to_user(wrq->u.data.pointer, data,
+                                 sizeof(int) * gpio->Header.Len)) {
+                    PRINTM(INFO, "Copy to user failed\n");
+                    LEAVE();
+                    return -EFAULT;
+                }
+
+                wrq->u.data.length = gpio->Header.Len;
+            }
+            break;
+        case WLAN_SLEEP_PERIOD:
+            ret = wlan_sleep_period(priv, wrq);
+            break;
+        case WLAN_ADAPT_RATESET:
+            ret = wlan_adapt_rateset(priv, wrq);
+            break;
+        case WLAN_INACTIVITY_TIMEOUT:
+            ret = wlan_inactivity_timeout(priv, wrq);
+            break;
+        case WLANSNR:
+            ret = wlan_get_snr(priv, wrq);
+            break;
+        case WLAN_GET_RATE:
+            ret = wlan_getrate_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_RXINFO:
+            ret = wlan_get_rxinfo(priv, wrq);
+            break;
+        case WLAN_SET_ATIM_WINDOW:
+            ret = wlan_atim_window(priv, wrq);
+            break;
+        case WLAN_BEACON_INTERVAL:
+            ret = wlan_beacon_interval(priv, wrq);
+            break;
+        case WLAN_SDIO_PULL_CTRL:
+            ret = wlan_sdio_pull_ctrl(priv, wrq);
+            break;
+        case WLAN_SCAN_TIME:
+            ret = wlan_scan_time(priv, wrq);
+            break;
+        case WLAN_ECL_SYS_CLOCK:
+            ret = wlan_ecl_sys_clock(priv, wrq);
+            break;
+        case WLAN_TXCONTROL:
+            ret = wlan_txcontrol(priv, wrq);
+            break;
+        case WLANHSCFG:
+            ret = wlan_hscfg_ioctl(priv, wrq);
+            break;
+        case WLANHSSETPARA:
+            ret = wlan_hssetpara_ioctl(priv, wrq);
+            break;
+        case WLANDBGSCFG:
+            ret = wlan_dbgs_cfg(priv, wrq);
+            break;
+#ifdef DEBUG_LEVEL1
+        case WLAN_DRV_DBG:
+            ret = wlan_drv_dbg(priv, wrq);
+            break;
+#endif
+        case WLAN_DRV_DELAY_MAX:
+            ret = wlan_wmm_drv_delay_max_ioctl(priv, wrq);
+            break;
+        }
+        break;
+
+    case WLAN_SET_GET_2K:
+        switch ((int) wrq->u.data.flags) {
+        case WLAN_SET_USER_SCAN:
+            ret = wlan_set_user_scan_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_SCAN_TABLE:
+            ret = wlan_get_scan_table_ioctl(priv, wrq);
+            break;
+        case WLAN_SET_MRVL_TLV:
+            ret = wlan_set_mrvl_tlv_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_ASSOC_RSP:
+            ret = wlan_get_assoc_rsp_ioctl(priv, wrq);
+            break;
+        case WLAN_ADDTS_REQ:
+            ret = wlan_wmm_addts_req_ioctl(priv, wrq);
+            break;
+        case WLAN_DELTS_REQ:
+            ret = wlan_wmm_delts_req_ioctl(priv, wrq);
+            break;
+        case WLAN_QUEUE_CONFIG:
+            ret = wlan_wmm_queue_config_ioctl(priv, wrq);
+            break;
+        case WLAN_QUEUE_STATS:
+            ret = wlan_wmm_queue_stats_ioctl(priv, wrq);
+            break;
+        case WLAN_TX_PKT_STATS:
+            ret = wlan_tx_pkt_stats_ioctl(priv, wrq);
+            break;
+        case WLAN_GET_CFP_TABLE:
+            ret = wlan_get_cfp_table_ioctl(priv, wrq);
+            break;
+        case WLAN_MEF_CFG:
+            ret = wlan_set_mef_cfg(priv, wrq);
+            break;
+        case WLAN_GET_MEM:
+            ret = wlan_get_firmware_mem(priv, wrq);
+            break;
+        default:
+            ret = -EOPNOTSUPP;
+        }
+        break;
+
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get wireless statistics
+ *
+ *  NOTE: If wlan_prepare_cmd() with wait option is issued 
+ *    in this function, a kernel dump (scheduling while atomic) 
+ *    issue may happen on some versions of kernels.
+ *
+ *  @param dev		A pointer to net_device structure
+ *  @return 	   	A pointer to iw_statistics buf
+ */
+struct iw_statistics *
+wlan_get_wireless_stats(struct net_device *dev)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return NULL;
+    }
+
+    priv->wstats.status = Adapter->InfrastructureMode;
+    priv->wstats.discard.retries = priv->stats.tx_errors;
+
+    /* send RSSI command to get beacon RSSI/NF, valid only if associated */
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+        ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_RSSI, 0, 0, 0, NULL);
+    }
+
+    priv->wstats.qual.level =
+        CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_AVG],
+                 Adapter->NF[TYPE_BEACON][TYPE_AVG]);
+    if (Adapter->NF[TYPE_BEACON][TYPE_AVG] == 0
+        && Adapter->MediaConnectStatus == WlanMediaStateConnected)
+        priv->wstats.qual.noise = MRVDRV_NF_DEFAULT_SCAN_VALUE;
+    else
+        priv->wstats.qual.noise = CAL_NF(Adapter->NF[TYPE_BEACON][TYPE_AVG]);
+    priv->wstats.qual.qual = 0;
+
+    PRINTM(INFO, "Signal Level = %#x\n", priv->wstats.qual.level);
+    PRINTM(INFO, "Noise = %#x\n", priv->wstats.qual.noise);
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_GET_LOG, 0, 0, 0, NULL);
+
+    if (!ret) {
+        priv->wstats.discard.code = 0;
+        priv->wstats.discard.fragment = Adapter->LogMsg.fcserror;
+        priv->wstats.discard.retries = Adapter->LogMsg.retry;
+        priv->wstats.discard.misc = Adapter->LogMsg.ackfailure;
+    }
+
+    LEAVE();
+
+    return &priv->wstats;
+}
+
+static int
+wlan_set_coalescing_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    int data;
+    int *val;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    data = *((int *) (wrq->u.name + SUBCMD_OFFSET));
+
+    switch (data) {
+    case CMD_DISABLED:
+    case CMD_ENABLED:
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_IBSS_COALESCING_STATUS,
+                               HostCmd_ACT_GEN_SET,
+                               HostCmd_OPTION_WAITFORRSP, 0, &data);
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+        break;
+
+    case CMD_GET:
+        ret = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_802_11_IBSS_COALESCING_STATUS,
+                               HostCmd_ACT_GEN_GET,
+                               HostCmd_OPTION_WAITFORRSP, 0, &data);
+        if (ret) {
+            LEAVE();
+            return ret;
+        }
+        break;
+
+    default:
+        LEAVE();
+        return -EINVAL;
+    }
+
+    val = (int *) wrq->u.name;
+    *val = data;
+
+    LEAVE();
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set frequency
+ *   
+ *  @param dev 			A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure 
+ *  @param fwrq			A pointer to iw_freq structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int
+wlan_set_freq(struct net_device *dev, struct iw_request_info *info,
+              struct iw_freq *fwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int rc = -EINPROGRESS;      /* Call commit handler */
+    CHANNEL_FREQ_POWER *cfp;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+    if (Adapter->InfrastructureMode != Wlan802_11IBSS) {
+        LEAVE();
+        return -EOPNOTSUPP;
+    }
+    if (Adapter->is_multiband) {
+        PRINTM(MSG, "SIOCSIWFREQ: IOCTLS call not supported in "
+               "MultiBands mode, use private command "
+               "'setadhocch' instead.\n");
+        LEAVE();
+        return -ENOTSUPP;
+    }
+
+    /*
+     * If setting by frequency, convert to a channel 
+     */
+    if (fwrq->e == 1) {
+
+        long f = fwrq->m / 100000;
+        int c = 0;
+
+        cfp = find_cfp_by_band_and_freq(Adapter, 0, f);
+        if (!cfp) {
+            PRINTM(INFO, "Invalid freq=%ld\n", f);
+            LEAVE();
+            return -EINVAL;
+        }
+
+        c = (int) cfp->Channel;
+
+        if (c < 0) {
+            LEAVE();
+            return -EINVAL;
+        }
+        fwrq->e = 0;
+        fwrq->m = c;
+    }
+
+    /*
+     * Setting by channel number 
+     */
+    if (fwrq->m > 1000 || fwrq->e > 0) {
+        rc = -EOPNOTSUPP;
+    } else {
+        int channel = fwrq->m;
+
+        cfp = find_cfp_by_band_and_channel(Adapter, 0, (u16) channel);
+        if (!cfp) {
+            rc = -EINVAL;
+        } else {
+            rc = wlan_change_adhoc_chan(priv, channel);
+            /*  If station is WEP enabled, send the 
+             *  command to set WEP in firmware
+             */
+            if (Adapter->SecInfo.WEPStatus == Wlan802_11WEPEnabled) {
+                PRINTM(INFO, "set_freq: WEP Enabled\n");
+                ret = wlan_prepare_cmd(priv,
+                                       HostCmd_CMD_802_11_SET_WEP,
+                                       HostCmd_ACT_ADD,
+                                       HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+                if (ret) {
+                    LEAVE();
+                    return ret;
+                }
+                Adapter->CurrentPacketFilter |= HostCmd_ACT_MAC_WEP_ENABLE;
+
+                wlan_prepare_cmd(priv,
+                                 HostCmd_CMD_MAC_CONTROL,
+                                 0, HostCmd_OPTION_WAITFORRSP,
+                                 0, &Adapter->CurrentPacketFilter);
+            }
+        }
+    }
+
+    LEAVE();
+    return rc;
+}
+
+/** 
+ *  @brief Set Deep Sleep 
+ *   
+ *  @param priv 	A pointer to wlan_private structure
+ *  @param bDeepSleep	TRUE--enalbe deepsleep, FALSE--disable deepsleep
+ *  @return 	   	WLAN_STATUS_SUCCESS-success, otherwise fail
+ */
+
+int
+wlan_set_deep_sleep(wlan_private * priv, BOOLEAN bDeepSleep)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (bDeepSleep == TRUE) {
+        if (Adapter->IsDeepSleep != TRUE) {
+            PRINTM(INFO, "Deep Sleep: sleep\n");
+
+            // note: the command could be queued and executed later
+            //       if there is command in prigressing.
+            ret = wlan_prepare_cmd(priv,
+                                   HostCmd_CMD_802_11_DEEP_SLEEP, 0,
+                                   HostCmd_OPTION_WAITFORRSP, 0, NULL);
+
+            if (ret) {
+                LEAVE();
+                return ret;
+            }
+            wmm_stop_queue(priv);
+            os_stop_queue(priv);
+            os_carrier_off(priv);
+        }
+    } else {
+        if (Adapter->IsDeepSleep == TRUE) {
+            PRINTM(CMND, "Deep Sleep: wakeup\n");
+
+            if (Adapter->IntCounterSaved) {
+                Adapter->IntCounter = Adapter->IntCounterSaved;
+                Adapter->IntCounterSaved = 0;
+            }
+
+            if (sbi_exit_deep_sleep(priv))
+                PRINTM(ERROR, "Deep Sleep : wakeup failed\n");
+
+            if (Adapter->IsDeepSleep == TRUE) {
+
+                if (os_wait_interruptible_timeout(Adapter->ds_awake_q,
+                                                  !Adapter->IsDeepSleep,
+                                                  MRVDRV_DEEP_SLEEP_EXIT_TIMEOUT)
+                    == 0) {
+                    PRINTM(MSG, "ds_awake_q: timer expired\n");
+                }
+            }
+
+            if (Adapter->IntCounter)
+                wake_up_interruptible(&priv->MainThread.waitQ);
+        }
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief use index to get the data rate
+ *   
+ *  @param index                The index of data rate
+ *  @return 	   		data rate or 0 
+ */
+u32
+index_to_data_rate(u8 index)
+{
+    ENTER();
+    if (index >= sizeof(WlanDataRates))
+        index = 0;
+
+    LEAVE();
+    return WlanDataRates[index];
+}
+
+/** 
+ *  @brief use rate to get the index
+ *   
+ *  @param rate                 data rate
+ *  @return 	   		index or 0 
+ */
+u8
+data_rate_to_index(u32 rate)
+{
+    u8 *ptr;
+
+    ENTER();
+    if (rate)
+        if ((ptr = wlan_memchr(WlanDataRates, (u8) rate,
+                               sizeof(WlanDataRates)))) {
+            LEAVE();
+            return (ptr - WlanDataRates);
+        }
+    LEAVE();
+    return 0;
+}
+
+/** 
+ *  @brief set data rate
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+
+int
+wlan_set_rate(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    u32 data_rate;
+    int ret = WLAN_STATUS_SUCCESS;
+    WLAN_802_11_RATES rates;
+    u8 *rate;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    PRINTM(INFO, "Vwrq->value = %d\n", vwrq->value);
+
+    if (vwrq->value == -1) {
+        Adapter->DataRate = 0;
+        Adapter->RateBitmap = 0;
+        memset(rates, 0, sizeof(rates));
+        get_active_data_rates(Adapter, rates);
+        rate = rates;
+        while (*rate) {
+            Adapter->RateBitmap |= 1 << (data_rate_to_index(*rate & 0x7f));
+            rate++;
+        }
+        Adapter->Is_DataRate_Auto = TRUE;
+    } else {
+        if ((vwrq->value % 500000)) {
+            LEAVE();
+            return -EINVAL;
+        }
+
+        data_rate = vwrq->value / 500000;
+
+        memset(rates, 0, sizeof(rates));
+        get_active_data_rates(Adapter, rates);
+        rate = rates;
+        while (*rate) {
+            PRINTM(INFO, "Rate=0x%X  Wanted=0x%X\n", *rate, data_rate);
+            if ((*rate & 0x7f) == (data_rate & 0x7f))
+                break;
+            rate++;
+        }
+        if (!*rate) {
+            PRINTM(MSG, "The fixed data rate 0x%X is out "
+                   "of range.\n", data_rate);
+            LEAVE();
+            return -EINVAL;
+        }
+
+        Adapter->DataRate = data_rate;
+        Adapter->RateBitmap = 1 << (data_rate_to_index(Adapter->DataRate));
+        Adapter->Is_DataRate_Auto = FALSE;
+    }
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_RATE_ADAPT_RATESET,
+                           HostCmd_ACT_GEN_SET, HostCmd_OPTION_WAITFORRSP,
+                           0, NULL);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief get data rate
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_rate(struct net_device *dev, struct iw_request_info *info,
+              struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    if (Adapter->Is_DataRate_Auto)
+        vwrq->fixed = 0;
+    else
+        vwrq->fixed = 1;
+
+    Adapter->TxRate = 0;
+
+    ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,
+                           HostCmd_ACT_GEN_GET, HostCmd_OPTION_WAITFORRSP,
+                           0, NULL);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+    vwrq->value = index_to_data_rate(Adapter->TxRate) * 500000;
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief set wireless mode 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param uwrq 		Wireless mode to set
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_mode(struct net_device *dev,
+              struct iw_request_info *info, u32 * uwrq, char *extra)
+{
+    int ret = WLAN_STATUS_SUCCESS;
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+
+    WLAN_802_11_NETWORK_INFRASTRUCTURE WantedMode;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    switch (*uwrq) {
+    case IW_MODE_ADHOC:
+        PRINTM(INFO, "Wanted Mode is ad-hoc: current DataRate=%#x\n",
+               Adapter->DataRate);
+        WantedMode = Wlan802_11IBSS;
+        break;
+
+    case IW_MODE_INFRA:
+        PRINTM(INFO, "Wanted Mode is Infrastructure\n");
+        WantedMode = Wlan802_11Infrastructure;
+        break;
+
+    case IW_MODE_AUTO:
+        PRINTM(INFO, "Wanted Mode is Auto\n");
+        WantedMode = Wlan802_11AutoUnknown;
+        break;
+
+    default:
+        PRINTM(INFO, "Wanted Mode is Unknown: 0x%x\n", *uwrq);
+        LEAVE();
+        return -EINVAL;
+    }
+
+    if (Adapter->InfrastructureMode == WantedMode ||
+        WantedMode == Wlan802_11AutoUnknown) {
+        PRINTM(INFO, "Already set to required mode! No change!\n");
+
+        Adapter->InfrastructureMode = WantedMode;
+
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    if (Adapter->InfrastructureMode == Wlan802_11Infrastructure) {
+        if (Adapter->PSState != PS_STATE_FULL_POWER) {
+            wlan_exit_ps(priv, HostCmd_OPTION_WAITFORRSP);
+        }
+        Adapter->PSMode = Wlan802_11PowerModeCAM;
+    }
+
+    ret = wlan_disconnect(priv);
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    Adapter->SecInfo.AuthenticationMode = Wlan802_11AuthModeOpen;
+
+    Adapter->InfrastructureMode = WantedMode;
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_SNMP_MIB,
+                           0, HostCmd_OPTION_WAITFORRSP,
+                           DesiredBssType_i, NULL);
+
+    if (ret) {
+        LEAVE();
+        return ret;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Set Encryption key
+ *   
+ *  @param dev      A pointer to net_device structure
+ *  @param info     A pointer to iw_request_info structure
+ *  @param dwrq     A pointer to iw_point structure
+ *  @param extra    A pointer to extra data buf
+ *  @return         WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+wlan_set_encode(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_point *dwrq, char *extra)
+{
+
+    WLAN_802_11_KEY *pKey = NULL;
+    int retval = -EINVAL;
+
+    ENTER();
+
+    if (dwrq->length > MAX_WEP_KEY_SIZE) {
+        pKey = (WLAN_802_11_KEY *) extra;
+        if (pKey->KeyLength <= MAX_WEP_KEY_SIZE) {
+            //dynamic WEP
+            dwrq->length = pKey->KeyLength;
+            dwrq->flags = pKey->KeyIndex + 1;
+            retval = wlan_set_encode_nonwpa(dev, info, dwrq,
+                                            pKey->KeyMaterial);
+        } else {
+            //WPA
+            retval = wlan_set_encode_wpa(dev, info, dwrq, extra);
+        }
+    } else {
+        //static WEP
+        PRINTM(INFO, "Setting WEP\n");
+        retval = wlan_set_encode_nonwpa(dev, info, dwrq, extra);
+    }
+
+    LEAVE();
+
+    return retval;
+}
+
+/** 
+ *  @brief set tx power 
+ *   
+ *  @param dev                  A pointer to net_device structure
+ *  @param info			A pointer to iw_request_info structure
+ *  @param vwrq 		A pointer to iw_param structure
+ *  @param extra		A pointer to extra data buf
+ *  @return 	   		WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_set_txpow(struct net_device *dev, struct iw_request_info *info,
+               struct iw_param *vwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int ret = WLAN_STATUS_SUCCESS;
+
+    u16 dbm;
+
+    ENTER();
+
+    if (!wlan_is_cmd_allowed(priv)) {
+        PRINTM(MSG, "%s: not allowed\n", __FUNCTION__);
+        LEAVE();
+        return -EBUSY;
+    }
+
+    if (vwrq->disabled) {
+        wlan_radio_ioctl(priv, RADIO_OFF);
+        LEAVE();
+        return WLAN_STATUS_SUCCESS;
+    }
+
+    wlan_radio_ioctl(priv, RADIO_ON);
+
+    dbm = (u16) vwrq->value;
+
+    if ((dbm < Adapter->MinTxPowerLevel) || (dbm > Adapter->MaxTxPowerLevel)) {
+        PRINTM(MSG,
+               "The set txpower value %d dBm is out of range (%d dBm-%d dBm)!\n",
+               dbm, Adapter->MinTxPowerLevel, Adapter->MaxTxPowerLevel);
+        LEAVE();
+        return -EINVAL;
+    }
+
+    /* auto tx power control */
+
+    if (vwrq->fixed == 0)
+        dbm = 0xffff;
+
+    PRINTM(INFO, "<1>TXPOWER SET %d dbm.\n", dbm);
+
+    ret = wlan_prepare_cmd(priv,
+                           HostCmd_CMD_802_11_RF_TX_POWER,
+                           HostCmd_ACT_GEN_SET,
+                           HostCmd_OPTION_WAITFORRSP, 0, (void *) &dbm);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Get current essid 
+ *   
+ *  @param dev      A pointer to net_device structure
+ *  @param info     A pointer to iw_request_info structure
+ *  @param dwrq     A pointer to iw_point structure
+ *  @param extra    A pointer to extra data buf
+ *  @return         WLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+int
+wlan_get_essid(struct net_device *dev, struct iw_request_info *info,
+               struct iw_point *dwrq, char *extra)
+{
+    wlan_private *priv = dev->priv;
+    wlan_adapter *Adapter = priv->adapter;
+    int tblIdx = -1;
+    BSSDescriptor_t *pBSSDesc;
+
+    ENTER();
+
+    pBSSDesc = &Adapter->CurBssParams.BSSDescriptor;
+
+    /*
+     * Get the current SSID 
+     */
+    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
+
+        tblIdx = wlan_find_ssid_in_list(Adapter,
+                                        &pBSSDesc->Ssid,
+                                        pBSSDesc->MacAddress,
+                                        Adapter->InfrastructureMode);
+
+        dwrq->length = MIN(dwrq->length, pBSSDesc->Ssid.SsidLength);
+        memcpy(extra, &pBSSDesc->Ssid.Ssid, dwrq->length);
+
+    } else {
+        dwrq->length = 0;
+    }
+
+    /* If the current network is in the table, return the table index */
+    if (tblIdx >= 0) {
+        dwrq->flags = (tblIdx + 1) & IW_ENCODE_INDEX;
+    } else {
+        dwrq->flags = 1;
+    }
+
+    LEAVE();
+    return WLAN_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief Get version 
+ *   
+ *  @param adapter              A pointer to wlan_adapter structure
+ *  @param version		A pointer to version buffer
+ *  @param maxlen		max length of version buffer
+ *  @return 	   		NA
+ */
+void
+get_version(wlan_adapter * adapter, char *version, int maxlen)
+{
+    union
+    {
+        u32 l;
+        u8 c[4];
+    } ver;
+    char fwver[32];
+
+    ENTER();
+
+    ver.l = adapter->FWReleaseNumber;
+    if (ver.c[3] == 0)
+        sprintf(fwver, "%u.%u.%u", ver.c[2], ver.c[1], ver.c[0]);
+    else
+        sprintf(fwver, "%u.%u.%u.p%u",
+                ver.c[2], ver.c[1], ver.c[0], ver.c[3]);
+
+    snprintf(version, maxlen, driver_version, fwver);
+
+    LEAVE();
+}
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_wext.h b/drivers/net/wireless/8688_wlan/wlan/wlan_wext.h
new file mode 100755
index 0000000..e8580d3
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_wext.h
@@ -0,0 +1,541 @@
+/** @file wlan_wext.h
+ * @brief This file contains definition for IOCTL call.
+ *  
+ * (c) Copyright © 2003-2007, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change log:
+	10/11/05: Add Doxygen format comments
+	12/19/05: Correct a typo in structure _wlan_ioctl_wmm_tspec
+	01/11/06: Conditionalize new scan/join ioctls
+	04/10/06: Add hostcmd generic API
+	04/18/06: Remove old Subscrive Event and add new Subscribe Event
+	          implementation through generic hostcmd API
+	06/08/06: Add definitions of custom events
+	08/29/06: Add ledgpio private command
+********************************************************/
+
+#ifndef	_WLAN_WEXT_H_
+#define	_WLAN_WEXT_H_
+
+/** Offset for subcommand */
+#define SUBCMD_OFFSET			4
+/** PRIVATE CMD ID */
+#define	WLANIOCTL			0x8BE0
+
+/** Private command ID to set WPA IE */
+#define WLANSETWPAIE			(WLANIOCTL + 0)
+/** Private command ID to set CIS dump */
+#define WLANCISDUMP 			(WLANIOCTL + 1)
+#ifdef MFG_CMD_SUPPORT
+#define	WLANMANFCMD			(WLANIOCTL + 2)
+#endif
+/** Private command ID to read/write register */
+#define	WLANREGRDWR			(WLANIOCTL + 3)
+/** Maximum EEPROM data */
+#define MAX_EEPROM_DATA     			256
+/** Private command ID to Host command */
+#define	WLANHOSTCMD			(WLANIOCTL + 4)
+
+/** Private command ID for ARP filter */
+#define WLANARPFILTER			(WLANIOCTL + 6)
+
+/** Private command ID to set/get int */
+#define WLAN_SETINT_GETINT		(WLANIOCTL + 7)
+/** Private command ID to get Noise Floor value */
+#define WLANNF					1
+/** Private command ID to get RSSI */
+#define WLANRSSI				2
+/** Private command ID to set/get BG scan */
+#define WLANBGSCAN				4
+/** Private command ID to enabled 11d support */
+#define WLANENABLE11D				5
+/** Private command ID to set/get AdHoc G rate */
+#define WLANADHOCGRATE				6
+/** Private command ID to set/get SDIO clock */
+#define WLANSDIOCLOCK				7
+/** Private command ID to enable WMM */
+#define WLANWMM_ENABLE				8
+/** Private command ID to set Null packet generation */
+#define WLANNULLGEN				10
+/** Private command ID to set AdHoc */
+#define WLANADHOCCSET				11
+/** Private command ID to set AdHoc G protection */
+#define WLAN_ADHOC_G_PROT			12
+
+/** Private command ID to set/get none */
+#define WLAN_SETNONE_GETNONE	        (WLANIOCTL + 8)
+/** Private command ID to turn on radio */
+#define WLANRADIOON                 		1
+/** Private command ID to turn off radio */
+#define WLANRADIOOFF                		2
+/** Private command ID to Remove AdHoc AES key */
+#define WLANREMOVEADHOCAES          		3
+/** Private command ID to stop AdHoc mode */
+#define WLANADHOCSTOP               		4
+/** Private command ID to set WLAN crypto test */
+#define WLANCRYPTOTEST				6
+#ifdef REASSOCIATION
+/** Private command ID to set reassociation to auto mode */
+#define WLANREASSOCIATIONAUTO			7
+/** Private command ID to set reassociation to user mode */
+#define WLANREASSOCIATIONUSER			8
+#endif /* REASSOCIATION */
+/** Private command ID to turn on wlan idle */
+#define WLANWLANIDLEON				9
+/** Private command ID to turn off wlan idle */
+#define WLANWLANIDLEOFF				10
+
+/** Private command ID to get log */
+#define WLANGETLOG                  	(WLANIOCTL + 9)
+
+/** Private command ID to set/get configurations */
+#define WLAN_SETCONF_GETCONF		(WLANIOCTL + 10)
+
+/** BG scan configuration */
+#define BG_SCAN_CONFIG				1
+/** BG scan configuration */
+#define BG_SCAN_CFG   				3
+/** Calibration data ext configuration */
+#define CAL_DATA_EXT_CONFIG         2
+
+/** Private command ID to set scan type */
+#define WLANSCAN_TYPE			(WLANIOCTL + 11)
+
+/** Private command ID to set a wext address variable */
+#define WLAN_SETADDR_GETNONE  (WLANIOCTL + 12)
+/** Private command ID to send deauthentication */
+#define WLANDEAUTH                  		1
+
+/** Private command ID to set/get 2k */
+#define WLAN_SET_GET_2K         (WLANIOCTL + 13)
+/** Private command ID to start scan */
+#define WLAN_SET_USER_SCAN              1
+/** Private command ID to get the scan table */
+#define WLAN_GET_SCAN_TABLE             2
+/** Private command ID to set Marvell TLV */
+#define WLAN_SET_MRVL_TLV               3
+/** Private command ID to get association response */
+#define WLAN_GET_ASSOC_RSP              4
+/** Private command ID to request ADDTS */
+#define WLAN_ADDTS_REQ                  5
+/** Private command ID to request DELTS */
+#define WLAN_DELTS_REQ                  6
+/** Private command ID to queue configuration */
+#define WLAN_QUEUE_CONFIG               7
+/** Private command ID to queue stats */
+#define WLAN_QUEUE_STATS                8
+/** Private command ID to get CFP table */
+#define WLAN_GET_CFP_TABLE              9
+/** Private command ID to set/get MEF configuration */
+#define WLAN_MEF_CFG                   10
+/** Private command ID to get memory */
+#define WLAN_GET_MEM                   11
+/** Private command ID to get Tx packet stats */
+#define WLAN_TX_PKT_STATS              12
+
+/** Private command ID to set none/get one int */
+#define WLAN_SETNONE_GETONEINT		(WLANIOCTL + 15)
+/** Private command ID to get region */
+#define WLANGETREGION				1
+/** Private command ID to get listen interval */
+#define WLAN_GET_LISTEN_INTERVAL		2
+/** Private command ID to get multiple DTIM */
+#define WLAN_GET_MULTIPLE_DTIM			3
+/** Private command ID to get Tx rate */
+#define WLAN_GET_TX_RATE			4
+/** Private command ID to get beacon average */
+#define	WLANGETBCNAVG				5
+/** Private command ID to get data average */
+#define WLANGETDATAAVG				6
+
+/** Private command ID to set ten characters and get none */
+#define WLAN_SETTENCHAR_GETNONE		(WLANIOCTL + 16)
+/** Private command ID to set band */
+#define WLAN_SET_BAND               		1
+/** Private command ID to set AdHoc channel */
+#define WLAN_SET_ADHOC_CH           		2
+/** Private command ID to set/get SW ann for 11h */
+#define WLAN_11H_CHANSWANN          		3
+
+/** Private command ID to set none and get ten characters */
+#define WLAN_SETNONE_GETTENCHAR		(WLANIOCTL + 17)
+/** Private command ID to get band */
+#define WLAN_GET_BAND				1
+/** Private command ID to get AdHoc channel */
+#define WLAN_GET_ADHOC_CH			2
+
+/** Private command ID to set none/get tewlve chars*/
+#define WLAN_SETNONE_GETTWELVE_CHAR (WLANIOCTL + 19)
+/** Private command ID to get Rx antenna */
+#define WLAN_SUBCMD_GETRXANTENNA    1
+/** Private command ID to get Tx antenna */
+#define WLAN_SUBCMD_GETTXANTENNA    2
+/** Private command ID to get TSF value */
+#define WLAN_GET_TSF                3
+/** Private command ID for WPS session */
+#define WLAN_WPS_SESSION            4
+
+/** Private command ID to set word character and get none */
+#define WLAN_SETWORDCHAR_GETNONE	(WLANIOCTL + 20)
+/** Private command ID to set AdHoc AES */
+#define WLANSETADHOCAES				1
+
+/** Private command ID to set one int/get word char */
+#define WLAN_SETONEINT_GETWORDCHAR	(WLANIOCTL + 21)
+/** Private command ID to get AdHoc AES key */
+#define WLANGETADHOCAES				1
+/** Private command ID to get version */
+#define WLANVERSION				2
+/** Private command ID to get extended version */
+#define WLANVEREXT				3
+
+/** Private command ID to set one int/get one int */
+#define WLAN_SETONEINT_GETONEINT	(WLANIOCTL + 23)
+/** Private command ID to set local power for 11h */
+#define WLAN_11H_SETLOCALPOWER      		1
+/** Private command ID to get WMM QoS information */
+#define WLAN_WMM_QOSINFO			2
+/** Private command ID to set/get listen interval */
+#define	WLAN_LISTENINTRVL			3
+/** Private command ID to set/get firmware wakeup method */
+#define WLAN_FW_WAKEUP_METHOD			4
+/** Firmware wakeup method : Unchanged */
+#define WAKEUP_FW_UNCHANGED			0
+/** Firmware wakeup method : Through interface */
+#define WAKEUP_FW_THRU_INTERFACE		1
+/** Firmware wakeup method : Through GPIO*/
+#define WAKEUP_FW_THRU_GPIO			2
+
+/** Private command ID to set/get NULL packet interval */
+#define WLAN_NULLPKTINTERVAL			5
+/** Private command ID to set/get beacon miss timeout */
+#define WLAN_BCN_MISS_TIMEOUT			6
+/** Private command ID to set/get AdHoc awake period */
+#define WLAN_ADHOC_AWAKE_PERIOD			7
+/** Private command ID to set/get module type */
+#define WLAN_MODULE_TYPE			11
+/** Private command ID to enable/disable auto Deep Sleep */
+#define WLAN_AUTODEEPSLEEP			12
+/** Private command ID to set/get enhance DPS */
+#define WLAN_ENHANCEDPS				13
+/** Private command ID to wake up MT */
+#define WLAN_WAKEUP_MT				14
+
+/** Private command ID to set one int/get none */
+#define WLAN_SETONEINT_GETNONE		(WLANIOCTL + 24)
+/** Private command ID to set Rx antenna */
+#define WLAN_SUBCMD_SETRXANTENNA		1
+/** Private command ID to set Tx antenna */
+#define WLAN_SUBCMD_SETTXANTENNA		2
+/** Private command ID to set authentication algorithm */
+#define WLANSETAUTHALG				4
+/** Private command ID to set encryption mode */
+#define WLANSETENCRYPTIONMODE			5
+/** Private command ID to set region */
+#define WLANSETREGION				6
+/** Private command ID to set listen interval */
+#define WLAN_SET_LISTEN_INTERVAL		7
+
+/** Private command ID to set multiple DTIM */
+#define WLAN_SET_MULTIPLE_DTIM			8
+
+/** Private command ID to set beacon average */
+#define WLANSETBCNAVG				9
+/** Private command ID to set data average */
+#define WLANSETDATAAVG				10
+/** Private command ID to associate */
+#define WLANASSOCIATE				11
+
+/** Private command ID to set 64-bit char/get 64-bit char */
+#define WLAN_SET64CHAR_GET64CHAR	(WLANIOCTL + 25)
+/** Private command ID to set/get sleep parameters */
+#define WLANSLEEPPARAMS 			2
+/** Private command ID to set/get BCA timeshare */
+#define	WLAN_BCA_TIMESHARE			3
+/** Private command ID to request TPC for 11h */
+#define WLAN_11H_REQUESTTPC         		4
+/** Private command ID to set power capabilities */
+#define WLAN_11H_SETPOWERCAP        		5
+/** Private command ID to set/get scan mode */
+#define WLANSCAN_MODE				6
+
+/** Private command ID to get AdHoc status */
+#define WLAN_GET_ADHOC_STATUS			9
+
+/** Private command ID to set generic IE */
+#define WLAN_SET_GEN_IE                 	10
+/** Private command ID to get generic IE */
+#define WLAN_GET_GEN_IE                 	11
+
+/** Private command ID to request MEAS */
+#define WLAN_MEASREQ                    	12
+/** Private command ID to get WMM queue status */
+#define WLAN_WMM_QUEUE_STATUS               13
+/** Private command ID to get Traffic stream status */
+#define WLAN_WMM_TS_STATUS                  14
+
+/** Private command to scan for a specific ESSID */
+#define WLANEXTSCAN			(WLANIOCTL + 26)
+/** Private command ID to set/get Deep Sleep mode */
+#define WLANDEEPSLEEP			(WLANIOCTL + 27)
+/** Deep Sleep enable flag */
+#define DEEP_SLEEP_ENABLE			1
+/** Deep Sleep disable flag */
+#define DEEP_SLEEP_DISABLE  			0
+
+/** Private command ID to set/get sixteen int */
+#define WLAN_SET_GET_SIXTEEN_INT       (WLANIOCTL + 29)
+/** Private command ID to set/get TPC configurations */
+#define WLAN_TPCCFG                             1
+/** Private command ID to set/get LED GPIO control */
+#define WLAN_LED_GPIO_CTRL			5
+/** Private command ID to set the number of probe requests per channel */
+#define WLAN_SCANPROBES 			6
+/** Private command ID to set/get the sleep period */
+#define WLAN_SLEEP_PERIOD			7
+/** Private command ID to set/get the rate set */
+#define	WLAN_ADAPT_RATESET			8
+/** Private command ID to set/get the inactivity timeout */
+#define	WLAN_INACTIVITY_TIMEOUT			9
+/** Private command ID to get the SNR */
+#define WLANSNR					10
+/** Private command ID to get the rate */
+#define WLAN_GET_RATE				11
+/** Private command ID to get Rx information */
+#define	WLAN_GET_RXINFO				12
+/** Private command ID to set the ATIM window */
+#define	WLAN_SET_ATIM_WINDOW			13
+/** Private command ID to set/get the beacon interval */
+#define WLAN_BEACON_INTERVAL			14
+/** Private command ID to set/get SDIO pull */
+#define WLAN_SDIO_PULL_CTRL			15
+/** Private command ID to set/get the scan time */
+#define WLAN_SCAN_TIME				16
+/** Private command ID to set/get ECL system clock */
+#define WLAN_ECL_SYS_CLOCK			17
+/** Private command ID to set/get the Tx control */
+#define WLAN_TXCONTROL				19
+/** Private command ID to set/get Host Sleep configuration */
+#define WLANHSCFG				21
+/** Private command ID to set Host Sleep parameters */
+#define WLANHSSETPARA				22
+/** Private command ID for debug configuration */
+#define WLANDBGSCFG				24
+#ifdef DEBUG_LEVEL1
+/** Private command ID to set/get driver debug */
+#define WLAN_DRV_DBG				25
+#endif
+/** Private command ID to set/get the max packet delay passed from drv to fw */
+#define WLAN_DRV_DELAY_MAX       27
+
+/** Private command ID to read/write Command 52 */
+#define WLANCMD52RDWR			(WLANIOCTL + 30)
+/** Private command ID to read/write Command 53 */
+#define WLANCMD53RDWR			(WLANIOCTL + 31)
+/** Command 53 buffer length */
+#define CMD53BUFLEN				512
+
+/** MAC register */
+#define	REG_MAC					0x19
+/** BBP register */
+#define	REG_BBP					0x1a
+/** RF register */
+#define	REG_RF					0x1b
+/** EEPROM register */
+#define	REG_EEPROM				0x59
+
+/** Command disabled */
+#define	CMD_DISABLED				0
+/** Command enabled */
+#define	CMD_ENABLED				1
+/** Command get */
+#define	CMD_GET					2
+/** Skip command number */
+#define SKIP_CMDNUM				4
+/** Skip type */
+#define SKIP_TYPE				1
+/** Skip size */
+#define SKIP_SIZE				2
+/** Skip action */
+#define SKIP_ACTION				2
+/** Skip type and size */
+#define SKIP_TYPE_SIZE			(SKIP_TYPE + SKIP_SIZE)
+/** Skip type and action */
+#define SKIP_TYPE_ACTION		(SKIP_TYPE + SKIP_ACTION)
+
+/** Maximum size of set/get configurations */
+#define MAX_SETGET_CONF_SIZE		2000    /* less than MRVDRV_SIZE_OF_CMD_BUFFER */
+/** Maximum length of set/get configuration commands */
+#define MAX_SETGET_CONF_CMD_LEN		(MAX_SETGET_CONF_SIZE - SKIP_CMDNUM)
+
+/* define custom events */
+/** Custom event : Host Sleep activated */
+#define CUS_EVT_HS_ACTIVATED		"HS_ACTIVATED "
+/** Custom event : Host Sleep deactivated */
+#define CUS_EVT_HS_DEACTIVATED		"HS_DEACTIVATED "
+/** Custom event : Host Sleep wakeup */
+#define CUS_EVT_HS_WAKEUP		"HS_WAKEUP"
+/** Custom event : Beacon RSSI low */
+#define CUS_EVT_BEACON_RSSI_LOW		"EVENT=BEACON_RSSI_LOW"
+/** Custom event : Beacon SNR low */
+#define CUS_EVT_BEACON_SNR_LOW		"EVENT=BEACON_SNR_LOW"
+/** Custom event : Beacon RSSI high */
+#define CUS_EVT_BEACON_RSSI_HIGH	"EVENT=BEACON_RSSI_HIGH"
+/** Custom event : Beacon SNR high */
+#define CUS_EVT_BEACON_SNR_HIGH		"EVENT=BEACON_SNR_HIGH"
+/** Custom event : Max fail */
+#define CUS_EVT_MAX_FAIL		"EVENT=MAX_FAIL"
+/** Custom event : MIC failure, unicast */
+#define CUS_EVT_MLME_MIC_ERR_UNI	"MLME-MICHAELMICFAILURE.indication unicast "
+/** Custom event : MIC failure, multicast */
+#define CUS_EVT_MLME_MIC_ERR_MUL	"MLME-MICHAELMICFAILURE.indication multicast "
+
+/** Custom event : Data RSSI low */
+#define CUS_EVT_DATA_RSSI_LOW		"EVENT=DATA_RSSI_LOW"
+/** Custom event : Data SNR low */
+#define CUS_EVT_DATA_SNR_LOW		"EVENT=DATA_SNR_LOW"
+/** Custom event : Data RSSI high */
+#define CUS_EVT_DATA_RSSI_HIGH		"EVENT=DATA_RSSI_HIGH"
+/** Custom event : Data SNR high */
+#define CUS_EVT_DATA_SNR_HIGH		"EVENT=DATA_SNR_HIGH"
+
+/** Custom event : Deep Sleep awake */
+#define CUS_EVT_DEEP_SLEEP_AWAKE	"EVENT=DS_AWAKE"
+
+/** Custom event : AdHoc link sensed */
+#define CUS_EVT_ADHOC_LINK_SENSED	"EVENT=ADHOC_LINK_SENSED"
+/** Custom event : AdHoc beacon lost */
+#define CUS_EVT_ADHOC_BCN_LOST		"EVENT=ADHOC_BCN_LOST"
+
+/** wlan_ioctl */
+typedef struct _wlan_ioctl
+{
+        /** Command ID */
+    u16 command;
+        /** data length */
+    u16 len;
+        /** data pointer */
+    u8 *data;
+} wlan_ioctl;
+
+/** wlan_ioctl_rfantenna */
+typedef struct _wlan_ioctl_rfantenna
+{
+    /** Action */
+    u16 Action;
+    /** RF Antenna mode */
+    u16 AntennaMode;
+} wlan_ioctl_rfantenna;
+
+/** wlan_ioctl_regrdwr */
+typedef struct _wlan_ioctl_regrdwr
+{
+        /** Which register to access */
+    u16 WhichReg;
+        /** Read or Write */
+    u16 Action;
+    /** Register offset */
+    u32 Offset;
+    /** NOB */
+    u16 NOB;
+    /** Value */
+    u32 Value;
+} wlan_ioctl_regrdwr;
+
+/** wlan_ioctl_cfregrdwr */
+typedef struct _wlan_ioctl_cfregrdwr
+{
+        /** Read or Write */
+    u8 Action;
+        /** register address */
+    u16 Offset;
+        /** register value */
+    u16 Value;
+} wlan_ioctl_cfregrdwr;
+
+/** wlan_ioctl_adhoc_key_info */
+typedef struct _wlan_ioctl_adhoc_key_info
+{
+    /** Action */
+    u16 action;
+    /** AdHoc key */
+    u8 key[16];
+    /** TKIP Tx MIC */
+    u8 tkiptxmickey[16];
+    /** TKIP Rx MIC */
+    u8 tkiprxmickey[16];
+} wlan_ioctl_adhoc_key_info;
+
+/** sleep_params */
+typedef struct _wlan_ioctl_sleep_params_config
+{
+    /** Action */
+    u16 Action;
+    /** Error */
+    u16 Error;
+    /** Offset */
+    u16 Offset;
+    /** Stable time */
+    u16 StableTime;
+    /** Calibration control */
+    u8 CalControl;
+    /** External sleep clock */
+    u8 ExtSleepClk;
+    /** Reserved */
+    u16 Reserved;
+} __ATTRIB_PACK__ wlan_ioctl_sleep_params_config,
+    *pwlan_ioctl_sleep_params_config;
+
+/** BCA TIME SHARE */
+typedef struct _wlan_ioctl_bca_timeshare_config
+{
+        /** ACT_GET/ACT_SET */
+    u16 Action;
+        /** Type: WLAN, BT */
+    u16 TrafficType;
+        /** Interval: 20msec - 60000msec */
+    u32 TimeShareInterval;
+        /** PTA arbiter time in msec */
+    u32 BTTime;
+} __ATTRIB_PACK__ wlan_ioctl_bca_timeshare_config,
+    *pwlan_ioctl_bca_timeshare_config;
+
+/** Maximum number of CFPs in the list */
+#define MAX_CFP_LIST_NUM	64
+
+/** wlan_ioctl_cfp_table */
+typedef struct _wlan_ioctl_cfp_table
+{
+    /** Region */
+    u32 region;
+    /** CFP number */
+    u32 cfp_no;
+    struct
+    {
+        /** CFP channel */
+        u16 Channel;
+        /** CFP frequency */
+        u32 Freq;
+        /** Maximum Tx power */
+        u16 MaxTxPower;
+        /** Unsupported flag */
+        u8 Unsupported;
+    } cfp[MAX_CFP_LIST_NUM];
+} __ATTRIB_PACK__ wlan_ioctl_cfp_table, *pwlan_ioctl_cfp_table;
+
+#endif /* _WLAN_WEXT_H_ */
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_wmm.c b/drivers/net/wireless/8688_wlan/wlan/wlan_wmm.c
new file mode 100755
index 0000000..7211b15
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_wmm.c
@@ -0,0 +1,1801 @@
+/** @file wlan_wmm.c
+ * @brief This file contains functions for WMM.
+ *
+ * (c) Copyright © 2003-2006, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available along with the File in the gpl.txt file or by writing to
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change log:
+    10/04/05: Add Doxygen format comments
+    11/11/05: Add support for WMM Status change event
+    01/05/06: Add kernel 2.6.x support
+    01/11/06: Conditionalize new scan/join code modifications.
+    04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+    08/14/07: Support Linux 2.6.22 kernel
+********************************************************/
+#include    "wlan_headers.h"
+
+/********************************************************
+    Local Variables
+********************************************************/
+
+/** Maximum value FW can accept for driver delay in packet transmission */
+#define DRV_PKT_DELAY_TO_FW_MAX   512
+
+/** Upper and Lower threshold for packet queuing in the driver
+ *
+ *    - When the number of packets queued reaches the upper limit,
+ *      the driver will stop the net queue in the app/kernel space.
+ *
+ *    - When the number of packets drops beneath the lower limit after
+ *      having reached the upper limit, the driver will restart the net
+ *      queue.
+ */
+
+/** Lower threshold for packet queuing in the driver.
+ * When the number of packets drops beneath the lower limit after having
+ * reached the upper limit, the driver will restart the net queue.
+ */
+#define WMM_QUEUED_PACKET_LOWER_LIMIT   180
+
+/** Upper threshold for packet queuing in the driver.
+ * When the number of packets queued reaches the upper limit, the driver
+ * will stop the net queue in the app/kernel space.
+ */
+#define WMM_QUEUED_PACKET_UPPER_LIMIT   200
+
+/** Offset for TOS field in the IP header */
+#define IPTOS_OFFSET 5
+
+static const u8 wmm_info_ie[] = { WMM_IE, 0x07,
+    0x00, 0x50, 0xf2, 0x02,
+    0x00, 0x01, 0x00
+};
+
+/**
+ * AC Priorities go from AC_BK to AC_VO.  The ACI enumeration for AC_BK (1)
+ *   is higher than the enumeration for AC_BE (0); hence the needed
+ *   mapping conversion for wmm AC to priority Queue Index
+ */
+static const u8 wmm_aci_to_qidx_map[] = { WMM_AC_BE,
+    WMM_AC_BK,
+    WMM_AC_VI,
+    WMM_AC_VO
+};
+
+/********************************************************
+    Local Functions
+********************************************************/
+#ifdef DEBUG_LEVEL2
+/**
+ *  @brief Debug print function to display the priority parameters for a WMM AC
+ *
+ *  @param pACParam Pointer to the AC paramters to display
+ *
+ *  @return         void
+ */
+static void
+wlan_wmm_ac_debug_print(const IEEEtypes_WmmAcParameters_t * pACParam)
+{
+    const char *acStr[] = { "BK", "BE", "VI", "VO" };
+
+    PRINTM(INFO, "WMM AC_%s: ACI=%d, ACM=%d, Aifsn=%d, "
+           "EcwMin=%d, EcwMax=%d, TxopLimit=%d\n",
+           acStr[wmm_aci_to_qidx_map[pACParam->AciAifsn.Aci]],
+           pACParam->AciAifsn.Aci, pACParam->AciAifsn.Acm,
+           pACParam->AciAifsn.Aifsn, pACParam->Ecw.EcwMin,
+           pACParam->Ecw.EcwMax, wlan_le16_to_cpu(pACParam->TxopLimit));
+}
+
+/** Print the WMM AC for debug purpose */
+#define PRINTM_AC(pACParam) wlan_wmm_ac_debug_print(pACParam)
+#else
+/** Print the WMM AC for debug purpose */
+#define PRINTM_AC(pACParam)
+#endif
+
+/**
+ *  @brief Compute the difference between two timestamps.
+ *
+ *  @param pTv1 Pointer to timestamp1
+ *  @param pTv2 Pointer to timestamp2
+ *
+ *  @return Time difference in ms between pTv1 and pTv2 (pTv1 - pTv2)
+ */
+static int
+timeval_diff_in_ms(const struct timeval *pTv1, const struct timeval *pTv2)
+{
+    int diff_ms;
+
+    diff_ms = (pTv1->tv_sec - pTv2->tv_sec) * 1000;
+    diff_ms += (pTv1->tv_usec - pTv2->tv_usec) / 1000;
+
+    return diff_ms;
+}
+
+/**
+ *  @brief Set the WMM queue priorities to their default values
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+static void
+wmm_default_queue_priorities(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    /* default queue priorities: VO->VI->BE->BK */
+    Adapter->wmm.queuePriority[0] = WMM_AC_VO;
+    Adapter->wmm.queuePriority[1] = WMM_AC_VI;
+    Adapter->wmm.queuePriority[2] = WMM_AC_BE;
+    Adapter->wmm.queuePriority[3] = WMM_AC_BK;
+}
+
+/**
+ *  @brief Initialize WMM priority queues
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+static void
+wmm_setup_queue_priorities(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    IEEEtypes_WmmParameter_t *pWmmIe;
+
+    u16 cwmax, cwmin, avg_back_off, tmp[4];
+    int i, j, numAc, acIdx;
+
+    if (Adapter->wmm.enabled == FALSE) {
+        /* WMM is not enabled, just set the defaults and return */
+        wmm_default_queue_priorities(priv);
+        return;
+    }
+
+    pWmmIe = &Adapter->CurBssParams.BSSDescriptor.wmmIE;
+
+    HEXDUMP("WMM: setup_queue_priorities: param IE",
+            (u8 *) pWmmIe, sizeof(IEEEtypes_WmmParameter_t));
+
+    PRINTM(INFO, "WMM Parameter IE: version=%d, "
+           "QoSInfo Parameter Set Count=%d, Reserved=%#x\n",
+           pWmmIe->VendHdr.Version, pWmmIe->QoSInfo.ParaSetCount,
+           pWmmIe->Reserved);
+
+    for (numAc = 0; numAc < NELEMENTS(pWmmIe->AcParams); numAc++) {
+        cwmax = (1 << pWmmIe->AcParams[numAc].Ecw.EcwMax) - 1;
+        cwmin = (1 << pWmmIe->AcParams[numAc].Ecw.EcwMin) - 1;
+        avg_back_off = (cwmin >> 1) + pWmmIe->AcParams[numAc].AciAifsn.Aifsn;
+
+        acIdx = wmm_aci_to_qidx_map[pWmmIe->AcParams[numAc].AciAifsn.Aci];
+        Adapter->wmm.queuePriority[acIdx] = acIdx;
+        tmp[acIdx] = avg_back_off;
+
+        PRINTM(INFO, "WMM: CWmax=%d CWmin=%d Avg Back-off=%d\n",
+               cwmax, cwmin, avg_back_off);
+        PRINTM_AC(&pWmmIe->AcParams[numAc]);
+    }
+
+    HEXDUMP("WMM: avg_back_off", (u8 *) tmp, sizeof(tmp));
+    HEXDUMP("WMM: queuePriority", Adapter->wmm.queuePriority,
+            sizeof(Adapter->wmm.queuePriority));
+
+    /* bubble sort */
+    for (i = 0; i < numAc; i++) {
+        for (j = 1; j < numAc - i; j++) {
+            if (tmp[j - 1] > tmp[j]) {
+                SWAP_U16(tmp[j - 1], tmp[j]);
+                SWAP_U8(Adapter->wmm.queuePriority[j - 1],
+                        Adapter->wmm.queuePriority[j]);
+            } else if (tmp[j - 1] == tmp[j]) {
+                if (Adapter->wmm.queuePriority[j - 1]
+                    < Adapter->wmm.queuePriority[j]) {
+                    SWAP_U8(Adapter->wmm.queuePriority[j - 1],
+                            Adapter->wmm.queuePriority[j]);
+                }
+            }
+        }
+    }
+
+    HEXDUMP("WMM: avg_back_off, sort", (u8 *) tmp, sizeof(tmp));
+    HEXDUMP("WMM: queuePriority, sort", Adapter->wmm.queuePriority,
+            sizeof(Adapter->wmm.queuePriority));
+}
+
+/**
+ *  @brief pop up the highest skb from wmm queue
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+static void
+wmm_pop_highest_prio_skb(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i;
+    u8 ac;
+
+    ENTER();
+
+    for (i = 0; i < MAX_AC_QUEUES; i++) {
+        ac = Adapter->wmm.queuePriority[i];
+        if (!list_empty((struct list_head *) &Adapter->wmm.txSkbQ[ac])) {
+            PRINTM(DATA, "WMM: Highest prio pkt in AC Queue %d\n", i);
+            Adapter->CurrentTxSkb = Adapter->wmm.txSkbQ[ac].next;
+            Adapter->wmm.packetsOut[ac]++;
+            list_del((struct list_head *) Adapter->wmm.txSkbQ[ac].next);
+            break;
+        }
+    }
+
+    LEAVE();
+}
+
+/**
+ *  @brief Evaluate whether or not an AC is to be downgraded
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param evalAC   AC to evaluate for downgrading
+ *
+ *  @return WMM AC the evalAC traffic is to be sent on.
+ */
+static wlan_wmm_ac_e
+wmm_eval_downgrade_ac(wlan_private * priv, wlan_wmm_ac_e evalAC)
+{
+    wlan_wmm_ac_e downAC;
+    wlan_wmm_ac_e retAC;
+    WmmAcStatus_t *pACStatus;
+
+    pACStatus = &priv->adapter->wmm.acStatus[evalAC];
+
+    if (pACStatus->Disabled == FALSE) {
+        /* Okay to use this AC, its enabled */
+        return evalAC;
+    }
+
+    /* Setup a default return value of the lowest priority */
+    retAC = WMM_AC_BK;
+
+    /*
+     *  Find the highest AC that is enabled and does not require admission
+     *    control.  The spec disallows downgarding to an AC which is enabled
+     *    due to a completed admission control.  Unadmitted traffic is not
+     *    to be sent on an AC with admitted traffic.
+     */
+    for (downAC = WMM_AC_BK; downAC < evalAC; downAC++) {
+        pACStatus = &priv->adapter->wmm.acStatus[downAC];
+
+        if ((pACStatus->Disabled == FALSE)
+            && (pACStatus->FlowRequired == FALSE)) {
+            /* AC is enabled and does not require admission control */
+            retAC = downAC;
+        }
+    }
+
+    return retAC;
+}
+
+/**
+ *  @brief Downgrade WMM priority queue
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+static void
+wmm_setup_ac_downgrade(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_wmm_ac_e acVal;
+
+    PRINTM(INFO, "WMM: AC Priorities: BK(0), BE(1), VI(2), VO(3)\n");
+
+    if (Adapter->wmm.enabled == FALSE) {
+        /* WMM is not enabled, default priorities */
+        for (acVal = WMM_AC_BK; acVal <= WMM_AC_VO; acVal++) {
+            for (acVal = WMM_AC_BK; acVal <= WMM_AC_VO; acVal++) {
+                Adapter->wmm.acDowngradedVals[acVal] = acVal;
+            }
+        }
+    } else {
+        for (acVal = WMM_AC_BK; acVal <= WMM_AC_VO; acVal++) {
+            Adapter->wmm.acDowngradedVals[acVal]
+                = wmm_eval_downgrade_ac(priv, acVal);
+            PRINTM(INFO, "WMM: AC PRIO %d maps to %d\n",
+                   acVal, Adapter->wmm.acDowngradedVals[acVal]);
+        }
+    }
+}
+
+/**
+ *  @brief Convert the IP TOS field to an WMM AC Queue assignment
+ *
+ *  @param tos  IP TOS field
+ *
+ *  @return     WMM AC Queue mapping of the IP TOS field
+ */
+wlan_wmm_ac_e
+wmm_convert_tos_to_ac(int tos)
+{
+    u8 tosIdx;
+
+    /* Map of TOS UP values to WMM AC */
+    const wlan_wmm_ac_e tos_to_ac[] = { WMM_AC_BE,
+        WMM_AC_BK,
+        WMM_AC_BK,
+        WMM_AC_BE,
+        WMM_AC_VI,
+        WMM_AC_VI,
+        WMM_AC_VO,
+        WMM_AC_VO
+    };
+
+    tosIdx = tos >> IPTOS_OFFSET;
+
+    if (tosIdx >= NELEMENTS(tos_to_ac)) {
+        return WMM_AC_BE;
+    }
+
+    return tos_to_ac[tosIdx];
+}
+
+/**
+ *  @brief  Evaluate a given AC and downgrade it to a lower AC if the
+ *          WMM Parameter IE received from the AP indicates that the AP
+ *          is disabled (due to call admission control (ACM bit)
+ *
+ *  @param priv   Pointer to the wlan_private driver data struct
+ *  @param acVal  AC to evaulate for downgrading
+ *
+ *  @return       Same AC as input if downgrading not required or
+ *                the AC the traffic for the given AC should be downgraded to
+ */
+wlan_wmm_ac_e
+wmm_downgrade_ac(wlan_private * priv, wlan_wmm_ac_e acVal)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    return (Adapter->wmm.acDowngradedVals[acVal]);
+}
+
+/**
+ *  @brief  Map the IP TOS field to a user priority value
+ *
+ *  @param tos  IP TOS field
+ *
+ *  @return     User priority tos input parameter maps to
+ */
+static u8
+wmm_tos_to_priority(u8 tos)
+{
+    u8 tosIdx;
+    const u8 tos_to_priority[] = {
+        /* Priority   DSCP_P2   DSCP_P1  DSCP_P0   WMM_AC   */
+        0x00,                   /*    0         0        0       AC_BE   */
+        0x01,                   /*    0         0        1       AC_BK   */
+        0x02,                   /*    0         1        0       AC_BK   */
+        0x03,                   /*    0         1        1       AC_BE   */
+        0x04,                   /*    1         0        0       AC_VI   */
+        0x05,                   /*    1         0        1       AC_VI   */
+        0x06,                   /*    1         1        0       AC_VO   */
+        0x07                    /*    1         1        1       AC_VO   */
+    };
+
+    tosIdx = tos >> IPTOS_OFFSET;
+
+    if (tosIdx >= NELEMENTS(tos_to_priority)) {
+        return WMM_AC_BE;
+    }
+
+    return tos_to_priority[tosIdx];
+}
+
+/**
+ *  @brief  Process a transfer of a data packet to the firmware from the
+ *          driver queue in order to manipulate flow control in the driver.
+ *
+ *  @param priv  Pointer to the wlan_private driver data struct
+ *
+ *  @return      void
+ */
+void
+wmm_process_fw_iface_tx_xfer_start(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    if (--Adapter->wmm.packetsQueued < WMM_QUEUED_PACKET_LOWER_LIMIT) {
+        PRINTM(DATA, "WMM: FW OS+: %d\n", Adapter->wmm.packetsQueued);
+        os_start_queue(priv);
+    }
+}
+
+/**
+ *  @brief  Process the completion of a data packet transfer to the firmware
+ *          from the driver queue in order to manipulate flow control in the
+ *          driver.
+ *
+ *  @param priv  Pointer to the wlan_private driver data struct
+ *
+ *  @return      void
+ *
+ */
+void
+wmm_process_fw_iface_tx_xfer_end(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    if (Adapter->wmm.packetsQueued) {
+        PRINTM(DATA, "WMM: FW OS-: %d\n", Adapter->wmm.packetsQueued);
+        os_stop_queue(priv);
+    }
+}
+
+/**
+ *  @brief  Process a transfer of a data packet from the OS to the driver
+ *          queue in order to manipulate flow control in the driver.
+ *
+ *  @param priv  Pointer to the wlan_private driver data struct
+ *
+ *  @return      void
+ */
+void
+wmm_process_app_iface_tx(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    Adapter->wmm.packetsQueued++;
+
+    if ((!priv->wlan_dev.dnld_sent && (Adapter->PSState != PS_STATE_SLEEP))
+        || (Adapter->wmm.packetsQueued >= WMM_QUEUED_PACKET_UPPER_LIMIT)) {
+        PRINTM(DATA, "WMM: APP OS-: %d\n", Adapter->wmm.packetsQueued);
+        os_stop_queue(priv);
+    }
+}
+
+/**
+ *  @brief  Stop the WMM data queues.  Traffic is still accepted from the
+ *          OS until the buffer limits are reached.
+ *
+ *  @param priv  Pointer to the wlan_private driver data struct
+ *
+ *  @return      void
+ */
+void
+wmm_stop_queue(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    PRINTM(DATA, "WMM: Q-: %d\n", Adapter->wmm.packetsQueued);
+    Adapter->wmm.queueStopped = TRUE;
+}
+
+/**
+ *  @brief  Start/re-start the WMM data queues and indicate to the OS layer
+ *          that data is being accepted again.
+ *
+ *  @param priv  Pointer to the wlan_private driver data struct
+ *
+ *  @return      void
+ */
+void
+wmm_start_queue(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    PRINTM(DATA, "WMM: Q+: %d\n", Adapter->wmm.packetsQueued);
+    Adapter->wmm.queueStopped = FALSE;
+    if (Adapter->wmm.packetsQueued) {
+        wake_up_interruptible(&priv->MainThread.waitQ);
+    }
+}
+
+/**
+ *  @brief  Query the status of the WMM queues.  Determine if the driver data
+ *          path is active or not.
+ *
+ *  @param priv  Pointer to the wlan_private driver data struct
+ *
+ *  @return      TRUE if WMM queues have been stopped, FALSE if still active
+ */
+int
+wmm_is_queue_stopped(wlan_private * priv)
+{
+    return (priv->adapter->wmm.queueStopped == TRUE);
+}
+
+/**
+ *  @brief Initialize the WMM state information and the WMM data path queues.
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+void
+wmm_init(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int i;
+
+    memset(&Adapter->wmm, 0x00, sizeof(Adapter->wmm));
+
+    for (i = 0; i < MAX_AC_QUEUES; i++) {
+        INIT_LIST_HEAD((struct list_head *) &Adapter->wmm.txSkbQ[i]);
+    }
+
+    Adapter->wmm.required = FALSE;
+
+    Adapter->gen_null_pkg = TRUE;       /* Enable NULL Pkg generation */
+}
+
+/**
+ *  @brief Setup the queue priorities and downgrade any queues as required
+ *         by the WMM info.  Setups default values if WMM is not active
+ *         for this association.
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+void
+wmm_setup_queues(wlan_private * priv)
+{
+    wmm_setup_queue_priorities(priv);
+    wmm_setup_ac_downgrade(priv);
+}
+
+/**
+ *  @brief implement WMM enable command
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param wrq      Pointer to user data
+ *
+ *  @return         WLAN_STATUS_SUCCESS if success; otherwise <0
+ */
+int
+wlan_wmm_enable_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    switch (*((int *) (wrq->u.name + SUBCMD_OFFSET))) {
+
+    case CMD_DISABLED:         /* disable */
+        Adapter->wmm.required = FALSE;
+        break;
+
+    case CMD_ENABLED:          /* enable */
+        Adapter->wmm.required = TRUE;
+        break;
+
+    case CMD_GET:
+        break;
+
+    default:
+        PRINTM(INFO, "Invalid option\n");
+        return -EINVAL;
+    }
+
+    *(int *) wrq->u.name = Adapter->wmm.required;
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Application API to set/get the maximum driver queue delay 
+ *         used in the firmware for computing packet lifetime expiry.
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param wrq      Pointer to user data
+ *
+ *  @return         WLAN_STATUS_SUCCESS if success; otherwise <0
+ */
+int
+wlan_wmm_drv_delay_max_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    int ret;
+    int data;
+
+    ENTER();
+
+    ret = WLAN_STATUS_SUCCESS;
+
+    if (wrq->u.data.length > 1) {
+        ret = -ENOTSUPP;
+    }
+
+    if (wrq->u.data.length == 1) {
+        /* Set */
+        if (copy_from_user(&data, wrq->u.data.pointer, sizeof(int))) {
+            PRINTM(INFO, "Copy from user failed\n");
+            ret = -EFAULT;
+        } else if (data > DRV_PKT_DELAY_TO_FW_MAX) {
+            ret = -EINVAL;
+        } else {
+            Adapter->wmm.drvPktDelayMax = data;
+        }
+    }
+
+    if (copy_to_user(wrq->u.data.pointer,
+                     &Adapter->wmm.drvPktDelayMax, sizeof(int))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        ret = -EFAULT;
+    }
+
+    wrq->u.data.length = 1;
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Implement cmd HostCmd_CMD_WMM_GET_STATUS
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      Pointer to CMD buffer
+ *  @param InfoBuf  Pointer to cmd data
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmd_wmm_get_status(wlan_private * priv,
+                        HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    PRINTM(INFO, "WMM: WMM_GET_STATUS cmd sent\n");
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);
+    cmd->Size =
+        wlan_cpu_to_le16(sizeof(HostCmd_DS_WMM_GET_STATUS) + S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief  Send a command to firmware to retrieve the current WMM status
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS; WLAN_STATUS_FAILURE
+ */
+int
+wlan_cmd_wmm_status_change(wlan_private * priv)
+{
+    return wlan_prepare_cmd(priv, HostCmd_CMD_WMM_GET_STATUS, 0, 0, 0, NULL);
+}
+
+/**
+ *  @brief Check if wmm TX queue is empty
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         FALSE if not empty; TRUE if empty
+ */
+int
+wmm_lists_empty(wlan_private * priv)
+{
+    int i;
+
+    for (i = 0; i < MAX_AC_QUEUES; i++) {
+        if (!list_empty((struct list_head *) &priv->adapter->wmm.txSkbQ[i])) {
+            return FALSE;
+        }
+    }
+    return TRUE;
+}
+
+/**
+ *  @brief Cleanup wmm TX queue
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *
+ *  @return         void
+ */
+void
+wmm_cleanup_queues(wlan_private * priv)
+{
+    int i;
+    struct sk_buff *delNode, *Q;
+
+    ENTER();
+
+    for (i = 0; i < MAX_AC_QUEUES; i++) {
+        Q = &priv->adapter->wmm.txSkbQ[i];
+
+        while (!list_empty((struct list_head *) Q)) {
+            delNode = Q->next;
+            list_del((struct list_head *) delNode);
+            kfree_skb(delNode);
+        }
+    }
+
+    priv->adapter->wmm.packetsQueued = 0;
+
+    LEAVE();
+}
+
+/**
+ *  @brief Add skb to WMM queue
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param skb      Pointer to sk_buff
+ *
+ *  @return         void
+ */
+void
+wmm_map_and_add_skb(wlan_private * priv, struct sk_buff *skb)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    struct ethhdr *eth;
+    struct timeval tstamp;
+    u8 tos;
+    wlan_wmm_ac_e ac;
+    wlan_wmm_ac_e ac_down;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+    struct iphdr *iph;
+#endif
+    eth = (struct ethhdr *) skb->data;
+
+    switch (eth->h_proto) {
+    case __constant_htons(ETH_P_IP):
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+        iph = ip_hdr(skb);
+        tos = IPTOS_PREC(iph->tos);
+#else
+        tos = IPTOS_PREC(skb->nh.iph->tos);
+#endif
+        PRINTM(DATA, "packet type ETH_P_IP: %04x, tos=%#x prio=%#x\n",
+               eth->h_proto, tos, skb->priority);
+        break;
+    case __constant_htons(ETH_P_ARP):
+        PRINTM(DATA, "ARP packet %04x\n", eth->h_proto);
+    default:
+        tos = 0;
+        break;
+    }
+
+    ac = wmm_convert_tos_to_ac(tos);
+    ac_down = wmm_downgrade_ac(priv, ac);
+
+    skb->priority = wmm_tos_to_priority(tos);
+    PRINTM(DATA, "wmm_map: tos=%#x, ac=%#x ac_down=%#x, priority=%#x\n",
+           tos, ac, ac_down, skb->priority);
+
+    list_add_tail((struct list_head *) skb,
+                  (struct list_head *) &Adapter->wmm.txSkbQ[ac_down]);
+
+    wmm_process_app_iface_tx(priv);
+
+    /* Record the current time the packet was queued; used to determine
+     *   the amount of time the packet was queued in the driver before it
+     *   was sent to the firmware.  The delay is then sent along with the
+     *   packet to the firmware for aggregate delay calculation for stats
+     *   and MSDU lifetime expiry.
+     */
+    do_gettimeofday(&tstamp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+    skb->tstamp = timeval_to_ktime(tstamp);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
+    skb_set_timestamp(skb, &tstamp);
+#else
+    memcpy(&skb->stamp, &tstamp, sizeof(skb->stamp));
+#endif
+}
+
+/**
+ *  @brief Process the GET_WMM_STATUS command response from firmware
+ *
+ *  The GET_WMM_STATUS command returns multiple TLVs for:
+ *      - Each AC Queue status
+ *      - Current WMM Parameter IE
+ *
+ *  This function parses the TLVs and then calls further functions
+ *   to process any changes in the queue prioritization or state.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer including TLVs
+ *                 TLVs for each queue and the WMM Parameter IE.
+ *
+ *  @return WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmdresp_wmm_get_status(wlan_private * priv,
+                            const HostCmd_DS_COMMAND * resp)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    u8 *pCurrent = (u8 *) & resp->params.getWmmStatus;
+    u32 respLen = resp->Size;
+    int valid = TRUE;
+    int enableData = TRUE;
+
+    MrvlIEtypes_Data_t *pTlvHdr;
+    MrvlIEtypes_WmmQueueStatus_t *pTlvWmmQStatus;
+    IEEEtypes_WmmParameter_t *pWmmParamIe;
+    WmmAcStatus_t *pACStatus;
+
+    PRINTM(INFO, "WMM: WMM_GET_STATUS cmdresp received: %d\n", respLen);
+    HEXDUMP("CMD_RESP: WMM_GET_STATUS", pCurrent, respLen);
+
+    while ((respLen >= sizeof(pTlvHdr->Header)) && valid) {
+        pTlvHdr = (MrvlIEtypes_Data_t *) pCurrent;
+        pTlvHdr->Header.Len = wlan_le16_to_cpu(pTlvHdr->Header.Len);
+
+        switch (wlan_le16_to_cpu(pTlvHdr->Header.Type)) {
+        case TLV_TYPE_WMMQSTATUS:
+            pTlvWmmQStatus = (MrvlIEtypes_WmmQueueStatus_t *) pTlvHdr;
+            PRINTM(INFO,
+                   "CMD_RESP: WMM_GET_STATUS: QSTATUS TLV: %d, %d, %d\n",
+                   pTlvWmmQStatus->QueueIndex, pTlvWmmQStatus->FlowRequired,
+                   pTlvWmmQStatus->Disabled);
+
+            pACStatus = &Adapter->wmm.acStatus[pTlvWmmQStatus->QueueIndex];
+            pACStatus->Disabled = pTlvWmmQStatus->Disabled;
+            pACStatus->FlowRequired = pTlvWmmQStatus->FlowRequired;
+            pACStatus->FlowCreated = pTlvWmmQStatus->FlowCreated;
+            break;
+
+        case WMM_IE:
+            /*
+             * Point the regular IEEE IE 2 bytes into the Marvell IE
+             *   and setup the IEEE IE type and length byte fields
+             */
+
+            HEXDUMP("WMM: WMM TLV:", (u8 *) pTlvHdr, pTlvHdr->Header.Len + 4);
+
+            pWmmParamIe = (IEEEtypes_WmmParameter_t *) (pCurrent + 2);
+            pWmmParamIe->VendHdr.Len = pTlvHdr->Header.Len;
+            pWmmParamIe->VendHdr.ElementId = WMM_IE;
+
+            PRINTM(INFO, "CMD_RESP: WMM_GET_STATUS: WMM Parameter Set: %d\n",
+                   pWmmParamIe->QoSInfo.ParaSetCount);
+
+            memcpy((u8 *) & Adapter->CurBssParams.BSSDescriptor.wmmIE,
+                   pWmmParamIe, pWmmParamIe->VendHdr.Len + 2);
+
+            break;
+
+        default:
+            valid = FALSE;
+            break;
+        }
+
+        pCurrent += (pTlvHdr->Header.Len + sizeof(pTlvHdr->Header));
+        respLen -= (pTlvHdr->Header.Len + sizeof(pTlvHdr->Header));
+    }
+
+    wmm_setup_queue_priorities(priv);
+    wmm_setup_ac_downgrade(priv);
+
+    if (enableData) {
+        wmm_start_queue(priv);
+        os_carrier_on(priv);
+        os_start_queue(priv);
+    }
+
+    send_iwevcustom_event(priv, WMM_CONFIG_CHANGE_INDICATION);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Call back from the command module to allow insertion of a WMM TLV
+ *
+ *  If the BSS we are associating to supports WMM, add the required WMM
+ *    Information IE to the association request command buffer in the form
+ *    of a Marvell extended IEEE IE.
+ *
+ *  @param priv        Pointer to the wlan_private driver data struct
+ *  @param ppAssocBuf  Output parameter: Pointer to the TLV output buffer,
+ *                     modified on return to point after the appended WMM TLV
+ *  @param pWmmIE      Pointer to the WMM IE for the BSS we are joining
+ *
+ *  @return Length of data appended to the association tlv buffer
+ */
+u32
+wlan_wmm_process_association_req(wlan_private * priv,
+                                 u8 ** ppAssocBuf,
+                                 IEEEtypes_WmmParameter_t * pWmmIE)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    MrvlIEtypes_WmmParamSet_t *pWmmTlv;
+    u32 retLen = 0;
+
+    /* Null checks */
+    if (ppAssocBuf == 0)
+        return 0;
+    if (*ppAssocBuf == 0)
+        return 0;
+    if (pWmmIE == 0)
+        return 0;
+
+    PRINTM(INFO, "WMM: process assoc req: bss->wmmIe=%x\n",
+           pWmmIE->VendHdr.ElementId);
+
+    if (Adapter->wmm.required && pWmmIE->VendHdr.ElementId == WMM_IE) {
+        pWmmTlv = (MrvlIEtypes_WmmParamSet_t *) * ppAssocBuf;
+        pWmmTlv->Header.Type = (u16) wmm_info_ie[0];
+        pWmmTlv->Header.Type = wlan_cpu_to_le16(pWmmTlv->Header.Type);
+        pWmmTlv->Header.Len = (u16) wmm_info_ie[1];
+        pWmmTlv->Header.Len = wlan_cpu_to_le16(pWmmTlv->Header.Len);
+
+        memcpy(pWmmTlv->WmmIE, &wmm_info_ie[2], pWmmTlv->Header.Len);
+#define QOS_INFO_PARA_MASK 0x0f
+        if (pWmmIE->QoSInfo.QosUAPSD
+            && ((Adapter->wmm.qosinfo & QOS_INFO_PARA_MASK) != 0)) {
+            memcpy((u8 *) (pWmmTlv->WmmIE + pWmmTlv->Header.Len
+                           - sizeof(Adapter->wmm.qosinfo)),
+                   &Adapter->wmm.qosinfo, sizeof(Adapter->wmm.qosinfo));
+        }
+        retLen = sizeof(pWmmTlv->Header) + pWmmTlv->Header.Len;
+
+        HEXDUMP("ASSOC_CMD: WMM IE", (u8 *) pWmmTlv, retLen);
+        *ppAssocBuf += retLen;
+    }
+
+    return retLen;
+}
+
+/**
+ *   @brief Compute the time delay in the driver queues for a given skb.
+ *
+ *   When the skb is received at the OS/Driver interface, the current
+ *     time is set in the skb structure.  The difference between the present
+ *     time and that received time is computed in this function and limited
+ *     based on pre-compiled limits in the driver.
+ *
+ *   @param skb  Pointer to a sk_buff which has been previously timestamped
+ *
+ *   @return Time delay of the packet in 2ms units after having limit applied
+ */
+u8
+wmm_compute_driver_packet_delay(wlan_private * priv,
+                                const struct sk_buff * skb)
+{
+    u8 retVal;
+    struct timeval in_tv;
+    struct timeval out_tv;
+    int queue_delay;
+
+    retVal = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
+    skb_get_timestamp(skb, &in_tv);
+#else
+    memcpy(&in_tv, &skb->stamp, sizeof(in_tv));
+#endif
+    do_gettimeofday(&out_tv);
+
+    queue_delay = timeval_diff_in_ms(&out_tv, &in_tv);
+
+    /* Queue delay is passed as a uint8 in units of 2ms (ms shifted
+     *  by 1). Min value (other than 0) is therefore 2ms, max is 510ms.
+     *
+     * Pass max value if queue_delay is beyond the uint8 range
+     */
+    retVal = MIN(queue_delay, priv->adapter->wmm.drvPktDelayMax) >> 1;
+
+    PRINTM(DATA, "WMM: Pkt Delay: %d ms, %d ms sent to FW\n",
+           queue_delay, retVal);
+
+    return retVal;
+}
+
+/**
+ *  @brief Transmit the highest priority packet awaiting in the WMM Queues
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *
+ *  @return        void
+ */
+void
+wmm_process_tx(wlan_private * priv)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    ulong flags;
+
+    OS_INTERRUPT_SAVE_AREA;
+
+    ENTER();
+
+    if ((Adapter->PSState == PS_STATE_SLEEP)
+        || (Adapter->PSState == PS_STATE_PRE_SLEEP)) {
+        PRINTM(INFO, "In PS State %d"
+               " - Not sending the packet\n", Adapter->PSState);
+        LEAVE();
+
+        return;
+    }
+
+    spin_lock_irqsave(&Adapter->CurrentTxLock, flags);
+
+    if (priv->wlan_dev.dnld_sent) {
+        spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+
+        LEAVE();
+
+        return;
+    }
+
+    UpdateTransStart(priv->wlan_dev.netdev);
+    wmm_pop_highest_prio_skb(priv);
+
+    spin_unlock_irqrestore(&Adapter->CurrentTxLock, flags);
+
+    if (Adapter->CurrentTxSkb) {
+        wlan_process_tx(priv);
+    }
+
+    LEAVE();
+}
+
+/**
+ *  @brief Private IOCTL entry to get the status of the WMM queues
+ *
+ *  Return the following information for each WMM AC:
+ *        - WMM IE Acm Required
+ *        - Firmware Flow Required
+ *        - Firmware Flow Established
+ *        - Firmware Queue Enabled
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_queue_status_t struct for request
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_queue_status_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_adapter *Adapter = priv->adapter;
+    wlan_ioctl_wmm_queue_status_t qstatus;
+    wlan_wmm_ac_e acVal;
+    WmmAcStatus_t *pACStatus;
+    IEEEtypes_WmmAcParameters_t *pWmmIeAC;
+
+    for (acVal = WMM_AC_BK; acVal <= WMM_AC_VO; acVal++) {
+        pACStatus = &Adapter->wmm.acStatus[acVal];
+        pWmmIeAC = &Adapter->CurBssParams.BSSDescriptor.wmmIE.AcParams[acVal];
+
+        /* Acm bit */
+        qstatus.acStatus[acVal].wmmAcm = pWmmIeAC->AciAifsn.Acm;
+
+        /* Firmware status */
+        qstatus.acStatus[acVal].flowRequired = pACStatus->FlowRequired;
+        qstatus.acStatus[acVal].flowCreated = pACStatus->FlowCreated;
+        qstatus.acStatus[acVal].disabled = pACStatus->Disabled;
+    }
+
+    if (copy_to_user(wrq->u.data.pointer, &qstatus, sizeof(qstatus))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Private IOCTL entry to get the status of the WMM Traffic Streams
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_queue_status_t struct for request
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_ts_status_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_wmm_ts_status_t ts_status_ioctl;
+    wlan_cmd_wmm_ts_status_t ts_status_cmd;
+    int retcode;
+
+    if (copy_from_user(&ts_status_ioctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length,
+                           sizeof(ts_status_ioctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "WMM: TS Status: copy from user failed\n");
+        retcode = -EFAULT;
+    }
+
+    memset(&ts_status_cmd, 0x00, sizeof(ts_status_cmd));
+    ts_status_cmd.tid = ts_status_ioctl.tid;
+
+    retcode = wlan_prepare_cmd(priv,
+                               HostCmd_CMD_WMM_TS_STATUS, 0,
+                               HostCmd_OPTION_WAITFORRSP, 0, &ts_status_cmd);
+
+    if (retcode) {
+        return -EFAULT;
+    }
+
+    memcpy(&ts_status_ioctl, &ts_status_cmd, sizeof(ts_status_ioctl));
+
+    if (copy_to_user(wrq->u.data.pointer,
+                     &ts_status_ioctl, sizeof(ts_status_ioctl))) {
+        PRINTM(INFO, "Copy to user failed\n");
+        return -EFAULT;
+    }
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Private IOCTL entry to send an ADDTS TSPEC
+ *
+ *  Receive a ADDTS command from the application.  The command structure
+ *    contains a TSPEC and timeout in milliseconds.  The timeout is performed
+ *    in the firmware after the ADDTS command frame is sent.
+ *
+ *  The TSPEC is received in the API as an opaque block whose length is
+ *    calculated from the IOCTL data length.  The firmware will send the
+ *    entire data block, including the bytes after the TSPEC.  This is done
+ *    to allow extra IEs to be packaged with the TSPEC in the ADDTS action
+ *    frame.
+ *
+ *  The IOCTL structure contains two return fields:
+ *    - The firmware command result which indicates failure and timeouts
+ *    - The IEEE Status code which contains the corresponding value from
+ *      any ADDTS response frame received.
+ *
+ *  In addition, the opaque TSPEC data block passed in is replaced with the
+ *    TSPEC recieved in the ADDTS response frame.  In case of failure, the
+ *    AP may modify the TSPEC on return and in the case of success, the
+ *    medium time is returned as calculated by the AP.  Along with the TSPEC,
+ *    any IEs that are sent in the ADDTS response are also returned and can be
+ *    parsed using the IOCTL length as an indicator of extra elements.
+ *
+ *  The return value to the application layer indicates a driver execution
+ *    success or failure.  A successful return could still indicate a firmware
+ *    failure or AP negotiation failure via the commandResult field copied
+ *    back to the application.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_addts_req_t struct for this ADDTS request
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_addts_req_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    static int dialogTok = 0;
+    wlan_ioctl_wmm_addts_req_t addtsIoctl;
+    wlan_cmd_wmm_addts_req_t addtsCmd;
+    int retcode;
+
+    if (copy_from_user(&addtsIoctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length, sizeof(addtsIoctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "TSPEC: ADDTS copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        memset(&addtsCmd, 0x00, sizeof(addtsCmd));
+        addtsCmd.dialogToken = ++dialogTok;
+        addtsCmd.timeout_ms = addtsIoctl.timeout_ms;
+        addtsCmd.tspecDataLen = (wrq->u.data.length
+                                 - sizeof(addtsCmd.timeout_ms)
+                                 - sizeof(addtsCmd.commandResult)
+                                 - sizeof(addtsCmd.ieeeStatusCode));
+        memcpy(addtsCmd.tspecData,
+               addtsIoctl.tspecData, addtsCmd.tspecDataLen);
+
+        retcode = wlan_prepare_cmd(priv,
+                                   HostCmd_CMD_WMM_ADDTS_REQ, 0,
+                                   HostCmd_OPTION_WAITFORRSP, 0, &addtsCmd);
+
+        wrq->u.data.length = (sizeof(addtsIoctl.timeout_ms)
+                              + sizeof(addtsIoctl.commandResult)
+                              + sizeof(addtsIoctl.ieeeStatusCode)
+                              + addtsCmd.tspecDataLen);
+
+        addtsIoctl.commandResult = addtsCmd.commandResult;
+        addtsIoctl.ieeeStatusCode = addtsCmd.ieeeStatusCode;
+        memcpy(addtsIoctl.tspecData,
+               addtsCmd.tspecData, addtsCmd.tspecDataLen);
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         &addtsIoctl, sizeof(addtsIoctl))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+
+        if (retcode) {
+            return -EFAULT;
+        }
+    }
+
+    return retcode;
+}
+
+/**
+ *  @brief Private IOCTL entry to send a DELTS TSPEC
+ *
+ *  Receive a DELTS command from the application.  The command structure
+ *    contains a TSPEC and reason code along with space for a command result
+ *    to be returned.  The information is packaged is sent to the wlan_cmd.c
+ *    firmware command prep and send routines for execution in the firmware.
+ *
+ *  The reason code is not used for WMM implementations but is indicated in
+ *    the 802.11e specification.
+ *
+ *  The return value to the application layer indicates a driver execution
+ *    success or failure.  A successful return could still indicate a firmware
+ *    failure via the commandResult field copied back to the application.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_delts_req_t struct for this DELTS request
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_delts_req_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_wmm_delts_req_t deltsIoctl;
+    wlan_cmd_wmm_delts_req_t deltsCmd;
+    int retcode;
+
+    if (copy_from_user(&deltsIoctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length, sizeof(deltsIoctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "TSPEC: DELTS copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        memset(&deltsCmd, 0x00, sizeof(deltsCmd));
+
+        /* Dialog token unused for WMM implementations */
+        deltsCmd.dialogToken = 0;
+
+        deltsCmd.ieeeReasonCode = deltsIoctl.ieeeReasonCode;
+
+        /* Calculate the length of the TSPEC and any other IEs */
+        deltsCmd.tspecDataLen = (wrq->u.data.length
+                                 - sizeof(deltsCmd.commandResult)
+                                 - sizeof(deltsCmd.ieeeReasonCode));
+        memcpy(deltsCmd.tspecData,
+               deltsIoctl.tspecData, deltsCmd.tspecDataLen);
+
+        /* Send the DELTS request to firmware, wait for a response */
+        retcode = wlan_prepare_cmd(priv,
+                                   HostCmd_CMD_WMM_DELTS_REQ, 0,
+                                   HostCmd_OPTION_WAITFORRSP, 0, &deltsCmd);
+
+        /* Return the firmware command result back to the application layer */
+        deltsIoctl.commandResult = deltsCmd.commandResult;
+
+        if (copy_to_user(wrq->u.data.pointer,
+                         &deltsCmd,
+                         MIN(wrq->u.data.length, sizeof(deltsIoctl)))) {
+            PRINTM(INFO, "Copy to user failed\n");
+            return -EFAULT;
+        }
+
+        if (retcode) {
+            retcode = -EFAULT;
+        }
+    }
+
+    return retcode;
+}
+
+/**
+ *  @brief Process the ADDTS_REQ command response from firmware
+ *
+ *  Return the ADDTS firmware response to the calling thread that sent
+ *    the command.  The result is then relayed back the app layer.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer including the
+ *                 command result and any returned ADDTS response TSPEC
+ *                 elements
+ *
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_addts_req_ioctl
+ */
+int
+wlan_cmdresp_wmm_addts_req(wlan_private * priv,
+                           const HostCmd_DS_COMMAND * resp)
+{
+    wlan_cmd_wmm_addts_req_t *pAddTsCmd;
+    const HostCmd_DS_WMM_ADDTS_REQ *pCmdResp;
+
+    /* Cast the NULL pointer of the buffer the IOCTL sent in the command req */
+    pAddTsCmd = (wlan_cmd_wmm_addts_req_t *) priv->adapter->CurCmd->pdata_buf;
+
+    /* Convenience variable for the ADDTS response from the firmware */
+    pCmdResp = &resp->params.addTsReq;
+
+    /* Assign return data */
+    pAddTsCmd->commandResult = pCmdResp->commandResult;
+    pAddTsCmd->dialogToken = pCmdResp->dialogToken;
+    pAddTsCmd->ieeeStatusCode = pCmdResp->ieeeStatusCode;
+
+    if (pCmdResp->commandResult == TSPEC_RESULT_SUCCESS) {
+        /* The tspecData field is potentially variable in size due to extra IEs
+         *   that may have been in the ADDTS response action frame.  Calculate
+         *   the data length from the firmware command response.
+         */
+        pAddTsCmd->tspecDataLen = (resp->Size
+                                   - sizeof(pCmdResp->commandResult)
+                                   - sizeof(pCmdResp->timeout_ms)
+                                   - sizeof(pCmdResp->dialogToken)
+                                   - sizeof(pCmdResp->ieeeStatusCode)
+                                   - S_DS_GEN);
+
+        /* Copy the TSPEC data include any extra IEs after the TSPEC */
+        memcpy(pAddTsCmd->tspecData,
+               pCmdResp->tspecData,
+               MIN(pAddTsCmd->tspecDataLen, sizeof(pAddTsCmd->tspecData)
+                   + sizeof(pAddTsCmd->addtsExtraIEBuf)));
+    } else {
+        pAddTsCmd->tspecDataLen = 0;
+    }
+
+    PRINTM(INFO, "TSPEC: ADDTS ret = %d,%d sz=%d\n",
+           pAddTsCmd->commandResult, pAddTsCmd->ieeeStatusCode,
+           pAddTsCmd->tspecDataLen);
+
+    HEXDUMP("TSPEC: ADDTS data",
+            pAddTsCmd->tspecData, pAddTsCmd->tspecDataLen);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process the DELTS_REQ command response from firmware
+ *
+ *  Return the DELTS firmware response to the calling thread that sent
+ *    the command.  The result is then relayed back the app layer.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer with the command
+ *                 result.  No other response information is passed back
+ *                 to the driver.
+ *
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_delts_req_ioctl
+ */
+int
+wlan_cmdresp_wmm_delts_req(wlan_private * priv,
+                           const HostCmd_DS_COMMAND * resp)
+{
+    wlan_cmd_wmm_delts_req_t *pDelTsCmd;
+
+    /* Cast the NULL pointer of the buffer the IOCTL sent in the command req */
+    pDelTsCmd = (wlan_cmd_wmm_delts_req_t *) priv->adapter->CurCmd->pdata_buf;
+
+    pDelTsCmd->commandResult
+        = wlan_le16_to_cpu(resp->params.delTsReq.commandResult);
+
+    PRINTM(INFO, "TSPEC: DELTS result = %d\n", pDelTsCmd->commandResult);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Implement cmd HostCmd_DS_WMM_ADDTS_REQ
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param cmd     Pointer to CMD buffer
+ *  @param InfoBuf Pointer to cmd data
+ *
+ *  @return        WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_addts_req_ioctl
+ */
+int
+wlan_cmd_wmm_addts_req(wlan_private * priv,
+                       HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    wlan_cmd_wmm_addts_req_t *pAddTsCmd;
+    int tspecCopySize;
+
+    pAddTsCmd = (wlan_cmd_wmm_addts_req_t *) InfoBuf;
+
+    cmd->params.addTsReq.timeout_ms = pAddTsCmd->timeout_ms;
+    cmd->params.addTsReq.dialogToken = pAddTsCmd->dialogToken;
+
+    tspecCopySize = MIN(pAddTsCmd->tspecDataLen,
+                        sizeof(cmd->params.addTsReq.tspecData));
+    memcpy(&cmd->params.addTsReq.tspecData,
+           pAddTsCmd->tspecData, tspecCopySize);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_ADDTS_REQ);
+    cmd->Size = wlan_cpu_to_le16(sizeof(cmd->params.addTsReq.dialogToken)
+                                 + sizeof(cmd->params.addTsReq.timeout_ms)
+                                 + sizeof(cmd->params.addTsReq.commandResult)
+                                 + sizeof(cmd->params.addTsReq.ieeeStatusCode)
+                                 + tspecCopySize + S_DS_GEN);
+
+    cmd->params.addTsReq.timeout_ms
+        = wlan_cpu_to_le32(cmd->params.addTsReq.timeout_ms);
+
+    PRINTM(INFO, "WMM: ADDTS Cmd: Data Len = %d\n", pAddTsCmd->tspecDataLen);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Implement cmd HostCmd_DS_WMM_DELTS_REQ
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      Pointer to CMD buffer
+ *  @param InfoBuf  Void pointer cast of a wlan_cmd_wmm_delts_req_t struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_delts_req_ioctl
+ */
+int
+wlan_cmd_wmm_delts_req(wlan_private * priv,
+                       HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    wlan_cmd_wmm_delts_req_t *pDelTsCmd;
+    int tspecCopySize;
+
+    pDelTsCmd = (wlan_cmd_wmm_delts_req_t *) InfoBuf;
+
+    cmd->params.delTsReq.dialogToken = pDelTsCmd->dialogToken;
+    cmd->params.delTsReq.ieeeReasonCode = pDelTsCmd->ieeeReasonCode;
+
+    tspecCopySize = MIN(pDelTsCmd->tspecDataLen,
+                        sizeof(cmd->params.delTsReq.tspecData));
+    memcpy(&cmd->params.delTsReq.tspecData,
+           pDelTsCmd->tspecData, tspecCopySize);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_DELTS_REQ);
+    cmd->Size = wlan_cpu_to_le16(sizeof(cmd->params.delTsReq.dialogToken)
+                                 + sizeof(cmd->params.delTsReq.commandResult)
+                                 + sizeof(cmd->params.delTsReq.ieeeReasonCode)
+                                 + tspecCopySize + S_DS_GEN);
+
+    PRINTM(INFO, "WMM: DELTS Cmd prepared\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Prepare the firmware command buffer for the WMM_QUEUE_CONFIG command
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      Pointer to CMD buffer
+ *  @param InfoBuf  Void pointer cast of a wlan_cmd_wmm_queue_config_t struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmd_wmm_queue_config(wlan_private * priv,
+                          HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    wlan_cmd_wmm_queue_config_t *pQConfigCmd;
+    int tlvCopySize;
+
+    pQConfigCmd = (wlan_cmd_wmm_queue_config_t *) InfoBuf;
+
+    cmd->params.queueConfig.action = pQConfigCmd->action;
+    cmd->params.queueConfig.accessCategory = pQConfigCmd->accessCategory;
+    cmd->params.queueConfig.msduLifetimeExpiry
+        = wlan_cpu_to_le16(pQConfigCmd->msduLifetimeExpiry);
+
+    tlvCopySize = MIN(pQConfigCmd->tlvBufLen,
+                      sizeof(cmd->params.queueConfig.tlvBuffer));
+    memcpy(&cmd->params.queueConfig.tlvBuffer,
+           pQConfigCmd->tlvBuffer, tlvCopySize);
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_QUEUE_CONFIG);
+    cmd->Size = wlan_cpu_to_le16(sizeof(cmd->params.queueConfig.action)
+                                 +
+                                 sizeof(cmd->params.queueConfig.
+                                        accessCategory)
+                                 +
+                                 sizeof(cmd->params.queueConfig.
+                                        msduLifetimeExpiry)
+                                 + tlvCopySize + S_DS_GEN);
+
+    PRINTM(INFO, "WMM: QUEUE CONFIG Cmd prepared\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process the WMM_QUEUE_CONFIG command response from firmware
+ *
+ *  Return the firmware command response to the blocked IOCTL caller function.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer with:
+ *                      - action code
+ *                      - access category
+ *                      - collected statistics if requested
+ *
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_queue_config_ioctl
+ */
+int
+wlan_cmdresp_wmm_queue_config(wlan_private * priv,
+                              const HostCmd_DS_COMMAND * resp)
+{
+    wlan_cmd_wmm_queue_config_t *pQConfigCmd;
+    const HostCmd_DS_WMM_QUEUE_CONFIG *pCmdResp;
+
+    pQConfigCmd =
+        (wlan_cmd_wmm_queue_config_t *) (priv->adapter->CurCmd->pdata_buf);
+    pCmdResp = &resp->params.queueConfig;
+
+    pQConfigCmd->action = pCmdResp->action;
+    pQConfigCmd->accessCategory = pCmdResp->accessCategory;
+    pQConfigCmd->msduLifetimeExpiry
+        = wlan_le16_to_cpu(pCmdResp->msduLifetimeExpiry);
+
+    pQConfigCmd->tlvBufLen = (resp->Size - sizeof(pCmdResp->action)
+                              - sizeof(pCmdResp->accessCategory)
+                              - sizeof(pCmdResp->msduLifetimeExpiry)
+                              - S_DS_GEN);
+
+    memcpy(pQConfigCmd->tlvBuffer,
+           pCmdResp->tlvBuffer, pQConfigCmd->tlvBufLen);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Private IOCTL entry to get/set a specified AC Queue's parameters
+ *
+ *  Receive a AC Queue configuration command which is used to get, set, or
+ *    default the parameters associated with a specific WMM AC Queue.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_queue_config_t struct
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_queue_config_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_wmm_queue_config_t queueConfigIoctl;
+    wlan_cmd_wmm_queue_config_t queueConfigCmd;
+    int retcode;
+
+    PRINTM(INFO, "WMM: Queue Config IOCTL Enter\n");
+
+    if (copy_from_user(&queueConfigIoctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length,
+                           sizeof(queueConfigIoctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "WMM: Queue Config: copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        memset(&queueConfigCmd, 0x00, sizeof(queueConfigCmd));
+
+        queueConfigCmd.action = queueConfigIoctl.action;
+        queueConfigCmd.accessCategory = queueConfigIoctl.accessCategory;
+        queueConfigCmd.msduLifetimeExpiry
+            = queueConfigIoctl.msduLifetimeExpiry;
+
+        /* Create a rates TLV from the supportedRates[] ioctl field */
+        queueConfigCmd.tlvBufLen = 0;
+
+        retcode = wlan_prepare_cmd(priv,
+                                   HostCmd_CMD_WMM_QUEUE_CONFIG, 0,
+                                   HostCmd_OPTION_WAITFORRSP, 0,
+                                   &queueConfigCmd);
+        if (retcode) {
+            retcode = -EFAULT;
+        } else {
+            memset(&queueConfigIoctl, 0x00, sizeof(queueConfigIoctl));
+
+            queueConfigIoctl.action = queueConfigCmd.action;
+            queueConfigIoctl.accessCategory = queueConfigCmd.accessCategory;
+            queueConfigIoctl.msduLifetimeExpiry
+                = queueConfigCmd.msduLifetimeExpiry;
+
+            wrq->u.data.length = sizeof(queueConfigIoctl);
+
+            if (copy_to_user(wrq->u.data.pointer,
+                             &queueConfigIoctl, sizeof(queueConfigIoctl))) {
+                PRINTM(INFO, "Copy to user failed\n");
+                retcode = -EFAULT;
+            }
+        }
+    }
+
+    return retcode;
+}
+
+/**
+ *  @brief Prepare the firmware command buffer for the WMM_QUEUE_STATS command
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      pointer to CMD buffer
+ *  @param InfoBuf  void pointer cast of a HostCmd_CMD_WMM_QUEUE_STATS struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmd_wmm_queue_stats(wlan_private * priv,
+                         HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    memcpy(&cmd->params.queueStats, InfoBuf, sizeof(cmd->params.queueStats));
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_QUEUE_STATS);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_WMM_QUEUE_STATS)
+                                 + S_DS_GEN);
+
+    PRINTM(INFO, "WMM: QUEUE STATS Cmd prepared\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process the WMM_QUEUE_STATS command response from firmware
+ *
+ *  Return the firmware command response to the blocked IOCTL caller function.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer with:
+ *                      - action code
+ *                      - access category
+ *                      - collected statistics if requested
+ *
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_queue_stats_ioctl
+ */
+int
+wlan_cmdresp_wmm_queue_stats(wlan_private * priv,
+                             const HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_WMM_QUEUE_STATS *pQueueStats =
+        (HostCmd_DS_WMM_QUEUE_STATS *) priv->adapter->CurCmd->pdata_buf;
+
+    memcpy(pQueueStats, &resp->params.queueStats, (resp->Size - S_DS_GEN));
+
+    pQueueStats->pktCount = wlan_le16_to_cpu(pQueueStats->pktCount);
+    pQueueStats->pktLoss = wlan_le16_to_cpu(pQueueStats->pktLoss);
+    pQueueStats->avgQueueDelay = wlan_le32_to_cpu(pQueueStats->avgQueueDelay);
+    pQueueStats->avgTxDelay = wlan_le32_to_cpu(pQueueStats->avgTxDelay);
+    pQueueStats->usedTime = wlan_le16_to_cpu(pQueueStats->usedTime);
+    pQueueStats->policedTime = wlan_le16_to_cpu(pQueueStats->policedTime);
+
+    PRINTM(INFO, "WMM: Queue Stats response: %d\n", resp->Size - S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Private IOCTL entry to get and start/stop queue stats on a WMM AC
+ *
+ *  Receive a AC Queue statistics command from the application for a specific
+ *    WMM AC.  The command can:
+ *         - Turn stats on
+ *         - Turn stats off
+ *         - Collect and clear the stats
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param wrq     A pointer to iwreq structure containing the
+ *                 wlan_ioctl_wmm_queue_stats_t struct
+ *
+ *  @return        0 if successful; IOCTL error code otherwise
+ */
+int
+wlan_wmm_queue_stats_ioctl(wlan_private * priv, struct iwreq *wrq)
+{
+    wlan_ioctl_wmm_queue_stats_t queueStatsIoctl;
+    HostCmd_DS_WMM_QUEUE_STATS queueStatsCmd;
+    int retcode;
+
+    if (copy_from_user(&queueStatsIoctl,
+                       wrq->u.data.pointer,
+                       MIN(wrq->u.data.length,
+                           sizeof(queueStatsIoctl))) != 0) {
+        /* copy_from_user failed  */
+        PRINTM(INFO, "WMM: Queue Stats: copy from user failed\n");
+        retcode = -EFAULT;
+
+    } else {
+        memcpy(&queueStatsCmd, &queueStatsIoctl, sizeof(queueStatsCmd));
+
+        PRINTM(INFO, "WMM: QUEUE STATS Ioctl: %d, %d\n",
+               queueStatsCmd.action, queueStatsCmd.accessCategory);
+
+        retcode = wlan_prepare_cmd(priv,
+                                   HostCmd_CMD_WMM_QUEUE_STATS, 0,
+                                   HostCmd_OPTION_WAITFORRSP, 0,
+                                   &queueStatsCmd);
+        if (retcode) {
+            retcode = -EFAULT;
+        } else {
+            if (copy_to_user(wrq->u.data.pointer,
+                             &queueStatsCmd,
+                             MIN(wrq->u.data.length,
+                                 sizeof(queueStatsCmd)))) {
+                PRINTM(INFO, "Copy to user failed\n");
+                retcode = -EFAULT;
+            }
+        }
+    }
+
+    if (retcode != WLAN_STATUS_SUCCESS) {
+        PRINTM(INFO, "WMM: QUEUE STATS Ioctl FAILED: %d, %d\n",
+               queueStatsIoctl.action, queueStatsIoctl.accessCategory);
+    }
+
+    return retcode;
+}
+
+/**
+ *  @brief Prepare the firmware command buffer for the WMM_TS_STATUS command
+ *
+ *  @param priv     Pointer to the wlan_private driver data struct
+ *  @param cmd      pointer to CMD buffer
+ *  @param InfoBuf  void pointer cast of a HostCmd_CMD_TS_STATUS struct
+ *
+ *  @return         WLAN_STATUS_SUCCESS
+ */
+int
+wlan_cmd_wmm_ts_status(wlan_private * priv,
+                       HostCmd_DS_COMMAND * cmd, void *InfoBuf)
+{
+    memcpy(&cmd->params.tsStatus, InfoBuf, sizeof(cmd->params.tsStatus));
+
+    cmd->Command = wlan_cpu_to_le16(HostCmd_CMD_WMM_TS_STATUS);
+    cmd->Size = wlan_cpu_to_le16(sizeof(HostCmd_DS_WMM_TS_STATUS) + S_DS_GEN);
+
+    PRINTM(INFO, "WMM: TS STATUS Cmd prepared\n");
+
+    return WLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process the WMM_TS_STATUS command response from firmware
+ *
+ *  Return the firmware command response to the blocked IOCTL caller function.
+ *
+ *  @param priv    Pointer to the wlan_private driver data struct
+ *  @param resp    Pointer to the command response buffer
+ *
+ *  @return WLAN_STATUS_SUCCESS
+ *
+ *  @sa wlan_wmm_queue_stats_ioctl
+ */
+int
+wlan_cmdresp_wmm_ts_status(wlan_private * priv,
+                           const HostCmd_DS_COMMAND * resp)
+{
+    HostCmd_DS_WMM_TS_STATUS *pTsStatus =
+        (HostCmd_DS_WMM_TS_STATUS *) priv->adapter->CurCmd->pdata_buf;
+
+    memcpy(pTsStatus, &resp->params.tsStatus, (resp->Size - S_DS_GEN));
+
+    pTsStatus->mediumTime = wlan_le16_to_cpu(pTsStatus->mediumTime);
+
+    PRINTM(INFO, "WMM: TS Status response: %d\n", resp->Size - S_DS_GEN);
+
+    return WLAN_STATUS_SUCCESS;
+}
diff --git a/drivers/net/wireless/8688_wlan/wlan/wlan_wmm.h b/drivers/net/wireless/8688_wlan/wlan/wlan_wmm.h
new file mode 100755
index 0000000..33b5e60
--- /dev/null
+++ b/drivers/net/wireless/8688_wlan/wlan/wlan_wmm.h
@@ -0,0 +1,136 @@
+/** @file wlan_wmm.h
+ * @brief This file contains related macros, enum, and struct
+ * of wmm functionalities
+ *
+ * (c) Copyright © 2003-2006, Marvell International Ltd. 
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+/****************************************************
+Change log:
+    09/26/05: add Doxygen format comments 
+    04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
+****************************************************/
+
+#ifndef __WLAN_WMM_H
+#define __WLAN_WMM_H
+
+/** Custom indiciation message sent to the application layer for WMM changes */
+#define WMM_CONFIG_CHANGE_INDICATION  "WMM_CONFIG_CHANGE.indication"
+
+/** Highest priority setting for a packet (uses voice AC) */
+#define WMM_HIGHEST_PRIORITY  7
+
+#ifdef __KERNEL__
+
+/** struct of WMM DESC */
+typedef struct
+{
+    u8 required;
+    u8 enabled;
+    u8 packetsQueued;
+    u8 queueStopped;
+    u32 packetsOut[MAX_AC_QUEUES];
+    u32 userPriPktTxCtrl[WMM_HIGHEST_PRIORITY + 1];     /* UP: 0 to 7 */
+
+    struct sk_buff txSkbQ[MAX_AC_QUEUES];
+    WmmAcStatus_t acStatus[MAX_AC_QUEUES];
+    wlan_wmm_ac_e acDowngradedVals[MAX_AC_QUEUES];
+
+    /** max driver packet delay sent to the firmware for expiry eval */
+    int drvPktDelayMax;
+
+    /** wmm queue priority table*/
+    u8 queuePriority[MAX_AC_QUEUES];
+
+    u8 qosinfo;
+} __ATTRIB_PACK__ WMM_DESC;
+
+extern void wmm_map_and_add_skb(wlan_private * priv, struct sk_buff *);
+extern u8 wmm_compute_driver_packet_delay(wlan_private * priv,
+                                          const struct sk_buff *skb);
+#endif
+
+extern int wlan_cmd_wmm_status_change(wlan_private * priv);
+extern int wmm_lists_empty(wlan_private * priv);
+extern void wmm_cleanup_queues(wlan_private * priv);
+extern void wmm_process_tx(wlan_private * priv);
+
+extern void wmm_init(wlan_private * priv);
+extern void wmm_setup_queues(wlan_private * priv);
+extern void wmm_start_queue(wlan_private * priv);
+extern void wmm_stop_queue(wlan_private * priv);
+extern int wmm_is_queue_stopped(wlan_private * priv);
+
+extern void wmm_process_fw_iface_tx_xfer_start(wlan_private * priv);
+extern void wmm_process_fw_iface_tx_xfer_end(wlan_private * priv);
+extern void wmm_process_app_iface_tx(wlan_private * priv);
+extern wlan_wmm_ac_e wmm_convert_tos_to_ac(int tos);
+extern wlan_wmm_ac_e wmm_downgrade_ac(wlan_private * priv,
+                                      wlan_wmm_ac_e acVal);
+
+extern u32 wlan_wmm_process_association_req(wlan_private * priv,
+                                            u8 ** ppAssocBuf,
+                                            IEEEtypes_WmmParameter_t *
+                                            pWmmIE);
+
+/* 
+ *  Functions used in the cmd handling routine
+ */
+extern int wlan_cmd_wmm_get_status(wlan_private * priv,
+                                   HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_addts_req(wlan_private * priv,
+                                  HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_delts_req(wlan_private * priv,
+                                  HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_queue_config(wlan_private * priv,
+                                     HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_queue_stats(wlan_private * priv,
+                                    HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+extern int wlan_cmd_wmm_ts_status(wlan_private * priv,
+                                  HostCmd_DS_COMMAND * cmd, void *InfoBuf);
+
+/* 
+ *  Functions used in the cmdresp handling routine
+ */
+extern int wlan_cmdresp_wmm_get_status(wlan_private * priv,
+                                       const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_addts_req(wlan_private * priv,
+                                      const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_delts_req(wlan_private * priv,
+                                      const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_queue_config(wlan_private * priv,
+                                         const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_queue_stats(wlan_private * priv,
+                                        const HostCmd_DS_COMMAND * resp);
+extern int wlan_cmdresp_wmm_ts_status(wlan_private * priv,
+                                      const HostCmd_DS_COMMAND * resp);
+
+/* 
+ * IOCTLs 
+ */
+extern int wlan_wmm_enable_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_wmm_drv_delay_max_ioctl(wlan_private * priv,
+                                        struct iwreq *wrq);
+extern int wlan_wmm_queue_status_ioctl(wlan_private * priv,
+                                       struct iwreq *wrq);
+extern int wlan_wmm_ts_status_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_wmm_addts_req_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_wmm_delts_req_ioctl(wlan_private * priv, struct iwreq *wrq);
+extern int wlan_wmm_queue_config_ioctl(wlan_private * priv,
+                                       struct iwreq *wrq);
+extern int wlan_wmm_queue_stats_ioctl(wlan_private * priv, struct iwreq *wrq);
+
+#endif /* __WLAN_WMM_H */
diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index 2b733c5..8461d8b 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -604,4 +604,20 @@ source "drivers/net/wireless/b43legacy/Kconfig"
 source "drivers/net/wireless/zd1211rw/Kconfig"
 source "drivers/net/wireless/rt2x00/Kconfig"
 
+comment "Marvell 8686/8688 SDIO device support"
+	depends on WLAN_80211 && PCI
+
+config MMC_SD8686
+        tristate "Marvell 8686 SDIO-WLAN support"
+        depends on PCI && WLAN_80211 && MMC && MMC_SDHCI
+	default y
+        help
+          WLAN is for Marvell SD8686 WLAN based on Pierr Ossman's
+	  mainline SDIO stack.
+
+config MMC_SD8688
+        tristate "Marvell 8688 SDIO-WLAN/BT support"
+        depends on PCI && WLAN_80211 && MMC && MMC_SDHCI && BT 
+	default y
+
 endmenu
diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
index 6f32b53..44da24e 100644
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -33,6 +33,9 @@ obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o
 obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
 
 obj-$(CONFIG_PRISM54)		+= prism54/
+obj-$(CONFIG_MMC_SD8686)	+= 8686_wlan/
+obj-$(CONFIG_MMC_SD8688)	+= 8688_wlan/
+obj-$(CONFIG_MMC_SD8688)	+= 8688_bt/
 
 obj-$(CONFIG_HOSTAP)		+= hostap/
 obj-$(CONFIG_BCM43XX)		+= bcm43xx/
