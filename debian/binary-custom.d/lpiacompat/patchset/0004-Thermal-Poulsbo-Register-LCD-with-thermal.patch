From d16d0dd90891aee036f4d2afafc8f9f085d04629 Mon Sep 17 00:00:00 2001
From: Sujith Thomas <sujith.thomas@intel.com>
Date: Tue, 14 Aug 2007 16:23:56 +0800
Subject: [PATCH] Poulsbo: Register LCD with thermal

-Register/Unregister with ACPI thermal driver
-Exports the callbacks for switching LCD brightness

Signed-off-by: Sujith Thomas <sujith.thomas@intel.com>
---
 drivers/acpi/Kconfig |    2 +-
 drivers/acpi/video.c |  128 ++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 129 insertions(+), 1 deletions(-)

diff --git a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
index 07ae366..ad9f836 100644
--- a/drivers/acpi/Kconfig
+++ b/drivers/acpi/Kconfig
@@ -155,7 +155,7 @@ config ACPI_THERMAL
 
 config ACPI_VIDEO
 	tristate "Video"
-	depends on X86 && BACKLIGHT_CLASS_DEVICE
+	depends on X86 && BACKLIGHT_CLASS_DEVICE && ACPI_THERMAL
 	default n
 	help
 	  This driver implement the ACPI Extensions For Display Adapters
diff --git a/drivers/acpi/video.c b/drivers/acpi/video.c
index 00d25b3..bdb67b8 100644
--- a/drivers/acpi/video.c
+++ b/drivers/acpi/video.c
@@ -38,6 +38,8 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#include <linux/thermal.h>
+
 #define ACPI_VIDEO_COMPONENT		0x08000000
 #define ACPI_VIDEO_CLASS		"video"
 #define ACPI_VIDEO_BUS_NAME		"Video Bus"
@@ -162,6 +164,7 @@ struct acpi_video_device_brightness {
 
 struct acpi_video_device {
 	unsigned long device_id;
+	acpi_bus_id name;
 	struct acpi_video_device_flags flags;
 	struct acpi_video_device_cap cap;
 	struct list_head entry;
@@ -169,6 +172,7 @@ struct acpi_video_device {
 	struct acpi_device *dev;
 	struct acpi_video_device_brightness *brightness;
 	struct backlight_device *backlight;
+	struct thermal_device *td;
 };
 
 /* bus */
@@ -1356,6 +1360,10 @@ acpi_video_bus_get_one_device(struct acpi_device *device,
 				break;
 			case ACPI_VIDEO_DISPLAY_LCD:
 				data->flags.lcd = 1;
+				data->td =
+				    thermal_register_device(device->pnp.bus_id,
+							    THERMAL_LCD_CLASS,
+							    data);
 				break;
 			default:
 				data->flags.unknown = 1;
@@ -1665,6 +1673,9 @@ static int acpi_video_bus_put_one_device(struct acpi_video_device *device)
 	up(&video->sem);
 	acpi_video_device_remove_fs(device->dev);
 
+	if (device->flags.lcd)
+		thermal_unregister_device(device->td);
+
 	status = acpi_remove_notify_handler(device->dev->handle,
 					    ACPI_DEVICE_NOTIFY,
 					    acpi_video_device_notify);
@@ -1870,6 +1881,119 @@ static int acpi_video_bus_remove(struct acpi_device *device, int type)
 	return 0;
 }
 
+/* --------------------------------------------------------------------------
+				Thermal management callbacks
+   -------------------------------------------------------------------------- */
+
+/*
+ * lcd_device_get_throttle_limit
+ * -----------------------------
+ * call back function for getting the device's current throttle limit
+ * data : acpi_video_device
+ * buf : sysfs buffer that needs to be filled back
+ */
+static int lcd_device_get_throttle_limit(void *data, char *buf)
+{
+	struct acpi_video_device *vd;
+	char *s = buf;
+
+	if (NULL == data || NULL == buf)
+		return -EINVAL;
+
+	vd = (struct acpi_video_device *)data;
+	s += sprintf(buf, "%d\n", vd->brightness->curr);
+
+	return (s - buf);
+}
+
+/*
+ * lcd_device_set_throttle_limit
+ * -----------------------------
+ * call back function for setting the device's new throttle limit
+ * data : acpi_video_device
+ * buf : sysfs buffer that needs to be filled back
+ */
+static int lcd_device_set_throttle_limit(enum throttle_set_type type,
+					 void *data, const char *buf)
+{
+	int new_state;
+	struct acpi_video_device *vd;
+
+	if (NULL == data || NULL == buf)
+		return -EINVAL;
+
+	/*Only absolute value throttling is supported for time being*/
+	if (THROTTLE_ABS != type)
+		return -EINVAL;
+
+	vd = (struct acpi_video_device *)data;
+	new_state = simple_strtol(buf, NULL, 0);
+	if (new_state == vd->brightness->curr
+	    || new_state > vd->brightness->count || new_state < 0)
+		return 0;
+
+	if (ACPI_SUCCESS
+	    (acpi_video_device_lcd_set_level
+	     (vd, vd->brightness->levels[new_state])))
+		vd->brightness->curr = new_state;
+
+	return 0;
+}
+
+/*
+ * lcd_device_get_maxthrottle_limit
+ * -----------------------------
+ * call back function for getting the device's maximum throttle limit
+ * data : acpi_video_device
+ * buf : sysfs buffer that needs to be filled back
+ */
+static int lcd_device_get_maxthrottle_limit(void *data, char *buf)
+{
+	struct acpi_video_device *vd;
+	char *s = buf;
+
+	if (NULL == data || NULL == buf)
+		return -EINVAL;
+
+	vd = (struct acpi_video_device *)data;
+	s += sprintf(buf, "%d\n", vd->brightness->count);
+
+	return (s - buf);
+}
+
+/*
+ * lcd_device_get_caps
+ * -----------------------------
+ * call back function for getting the device's capabilities
+ * data : acpi_video_device
+ * buf : sysfs buffer that needs to be filled back
+ */
+static int lcd_device_get_caps(void *data, char *buf)
+{
+	char *s = buf;
+	unsigned int caps = 0;
+
+	if (NULL == data || NULL == buf)
+		return -EINVAL;
+
+	caps |= DEVICE_CAPS_SW_PGM_THERMAL_EVENTS;
+	s += sprintf(buf, "%d\n", caps);
+
+	return (s - buf);
+}
+
+static struct thermal_device_ops lcd_thermal_ops = {
+	.getthrottlelimit = lcd_device_get_throttle_limit,
+	.setthrottlelimit = lcd_device_set_throttle_limit,
+	.getmaxthrottlelimit = lcd_device_get_maxthrottle_limit,
+	.getcaps = lcd_device_get_caps,
+};
+
+static struct thermal_device_driver lcd_thermal_driver = {
+	.class = THERMAL_LCD_CLASS,
+	.ops = &lcd_thermal_ops
+};
+
 static int __init acpi_video_init(void)
 {
 	int result = 0;
@@ -1885,6 +2009,8 @@ static int __init acpi_video_init(void)
 		return -ENODEV;
 	acpi_video_dir->owner = THIS_MODULE;
 
+	thermal_register_device_driver(&lcd_thermal_driver);
+
 	result = acpi_bus_register_driver(&acpi_video_bus);
 	if (result < 0) {
 		remove_proc_entry(ACPI_VIDEO_CLASS, acpi_root_dir);
@@ -1899,6 +2025,8 @@ static void __exit acpi_video_exit(void)
 
 	acpi_bus_unregister_driver(&acpi_video_bus);
 
+	thermal_unregister_device_driver(&lcd_thermal_driver);
+
 	remove_proc_entry(ACPI_VIDEO_CLASS, acpi_root_dir);
 
 	return;
-- 
1.5.2.4

