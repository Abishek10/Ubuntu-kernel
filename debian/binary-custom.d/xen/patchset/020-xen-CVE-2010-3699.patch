diff --git a/drivers/xen/blkback/xenbus.c b/drivers/xen/blkback/xenbus.c
index f9feb43..1611d7a 100644
--- a/drivers/xen/blkback/xenbus.c
+++ b/drivers/xen/blkback/xenbus.c
@@ -362,6 +362,11 @@ static void frontend_changed(struct xenbus_device *dev,
 		if (dev->state == XenbusStateConnected)
 			break;
 
+		/* Enforce precondition before potential leak point.
+		 * blkif_disconnect() is idempotent.
+		 */
+		blkif_disconnect(be->blkif);
+
 		err = connect_ring(be);
 		if (err)
 			break;
@@ -379,6 +384,7 @@ static void frontend_changed(struct xenbus_device *dev,
 			break;
 		/* fall through if not online */
 	case XenbusStateUnknown:
+		/* implies blkif_disconnect() via blkback_remove() */
 		device_unregister(&dev->dev);
 		break;
 
diff --git a/drivers/xen/blktap/xenbus.c b/drivers/xen/blktap/xenbus.c
index f9e3159..7114610 100644
--- a/drivers/xen/blktap/xenbus.c
+++ b/drivers/xen/blktap/xenbus.c
@@ -326,6 +326,21 @@ static void tap_backend_changed(struct xenbus_watch *watch,
 	tap_update_blkif_status(be->blkif);
 }
 
+
+static void tap_blkif_disconnect(blkif_t *blkif)
+{
+	if (blkif->xenblkd) {
+		kthread_stop(blkif->xenblkd);
+		blkif->xenblkd = NULL;
+	}
+
+        atomic_dec(&blkif->refcnt);
+        wait_event(blkif->waiting_to_free, atomic_read(&blkif->refcnt) == 0);
+        atomic_inc(&blkif->refcnt);
+        
+        tap_blkif_unmap(blkif);
+}
+
 /**
  * Callback received when the frontend's state changes.
  */
@@ -354,6 +369,11 @@ static void tap_frontend_changed(struct xenbus_device *dev,
 		if (dev->state == XenbusStateConnected)
 			break;
 
+		/* Enforce precondition before potential leak point.
+		 * tap_blkif_disconnect() is idempotent.
+		 */
+		tap_blkif_disconnect(be->blkif);
+
 		err = connect_ring(be);
 		if (err)
 			break;
@@ -361,10 +381,7 @@ static void tap_frontend_changed(struct xenbus_device *dev,
 		break;
 
 	case XenbusStateClosing:
-		if (be->blkif->xenblkd) {
-			kthread_stop(be->blkif->xenblkd);
-			be->blkif->xenblkd = NULL;
-		}
+		tap_blkif_disconnect(be->blkif);
 		xenbus_switch_state(dev, XenbusStateClosing);
 		break;
 
@@ -374,6 +391,9 @@ static void tap_frontend_changed(struct xenbus_device *dev,
 			break;
 		/* fall through if not online */
 	case XenbusStateUnknown:
+		/* Implies the effects of tap_blkif_disconnect() via
+		 * blktap_remove().
+		 */
 		device_unregister(&dev->dev);
 		break;
 
diff --git a/drivers/xen/netback/xenbus.c b/drivers/xen/netback/xenbus.c
index b55005c..a9af461 100644
--- a/drivers/xen/netback/xenbus.c
+++ b/drivers/xen/netback/xenbus.c
@@ -32,6 +32,7 @@
 static int connect_rings(struct backend_info *);
 static void connect(struct backend_info *);
 static void backend_create_netif(struct backend_info *be);
+static void netback_disconnect(struct device *);
 
 static int netback_remove(struct xenbus_device *dev)
 {
@@ -39,15 +40,22 @@ static int netback_remove(struct xenbus_device *dev)
 
 	netback_remove_accelerators(be, dev);
 
-	if (be->netif) {
-		netif_disconnect(be->netif);
-		be->netif = NULL;
-	}
+	netback_disconnect(&dev->dev);
 	kfree(be);
 	dev->dev.driver_data = NULL;
 	return 0;
 }
 
+static void netback_disconnect(struct device *xbdev_dev)
+{
+        struct backend_info *be = xbdev_dev->driver_data;
+ 
+        if (be && be->netif) {
+                kobject_uevent(&xbdev_dev->kobj, KOBJ_OFFLINE);
+                netif_disconnect(be->netif);
+                be->netif = NULL;
+        }
+}
 
 /**
  * Entry point to this code when a new device is created.  Allocate the basic
@@ -225,16 +233,17 @@ static void frontend_changed(struct xenbus_device *dev,
 		break;
 
 	case XenbusStateConnected:
+		if (dev->state == XenbusStateConnected)
+			break;
+
+		/* backend_create_netif() is idempotent */
 		backend_create_netif(be);
 		if (be->netif)
 			connect(be);
 		break;
 
 	case XenbusStateClosing:
-		if (be->netif) {
-			netif_disconnect(be->netif);
-			be->netif = NULL;
-		}
+		netback_disconnect(&dev->dev);
 		xenbus_switch_state(dev, XenbusStateClosing);
 		break;
 
@@ -244,8 +253,7 @@ static void frontend_changed(struct xenbus_device *dev,
 			break;
 		/* fall through if not online */
 	case XenbusStateUnknown:
-		if (be->netif != NULL)
-			kobject_uevent(&dev->dev.kobj, KOBJ_OFFLINE);
+		/* implies netback_disconnect() via netback_remove() */
 		device_unregister(&dev->dev);
 		break;
 
