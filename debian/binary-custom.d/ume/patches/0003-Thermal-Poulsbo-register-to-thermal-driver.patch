From fa3683edfad62dee199990e10b4f3a1eac52f462 Mon Sep 17 00:00:00 2001
From: Sujith Thomas <sujith.thomas@intel.com>
Date: Tue, 14 Aug 2007 16:23:56 +0800
Subject: [PATCH] Poulsbo: register to thermal driver

-Register/Unregister with ACPI thermal driver
-Exports the callbacks for switching P and T states
-Support for absolute and relative switching of P and T states

Signed-off-by: Sujith Thomas <sujith.thomas@intel.com>
---
 drivers/acpi/Kconfig          |    2 +-
 drivers/acpi/processor_core.c |  334 +++++++++++++++++++++++++++++++++++++++++
 include/acpi/processor.h      |    1 +
 3 files changed, 336 insertions(+), 1 deletions(-)

diff --git a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
index 3c74305..07ae366 100644
--- a/drivers/acpi/Kconfig
+++ b/drivers/acpi/Kconfig
@@ -168,6 +168,7 @@ config ACPI_VIDEO
 
 config ACPI_PROCESSOR
 	tristate "Processor"
+	depends on  ACPI_THERMAL
 	default y
 	help
 	  This driver installs ACPI as the idle handler for Linux, and uses
@@ -181,7 +182,6 @@ config ACPI_HOTPLUG_CPU
 	select ACPI_CONTAINER
 	default y
 
-
 config ACPI_NUMA
 	bool "NUMA support"
 	depends on NUMA
diff --git a/drivers/acpi/processor_core.c b/drivers/acpi/processor_core.c
index f7de02a..b493641 100644
--- a/drivers/acpi/processor_core.c
+++ b/drivers/acpi/processor_core.c
@@ -58,6 +58,7 @@
 #include <acpi/acpi_drivers.h>
 #include <acpi/processor.h>
 
+#include<linux/thermal.h>
 #define ACPI_PROCESSOR_COMPONENT	0x01000000
 #define ACPI_PROCESSOR_CLASS		"processor"
 #define ACPI_PROCESSOR_DEVICE_NAME	"Processor"
@@ -724,6 +725,12 @@ static int acpi_processor_add(struct acpi_device *device)
 	strcpy(acpi_device_name(device), ACPI_PROCESSOR_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_PROCESSOR_CLASS);
 	acpi_driver_data(device) = pr;
+	/* registering with tz driver */
+	pr->td =
+	    thermal_register_device(device->pnp.bus_id, THERMAL_CPU_CLASS, pr);
+	if (!pr->td)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+		" Failed to register with thermal zonefrom ACPI CPU driver "));
 
 	return 0;
 }
@@ -748,6 +755,8 @@ static int acpi_processor_remove(struct acpi_device *device, int type)
 		if (acpi_processor_handle_eject(pr))
 			return -EINVAL;
 	}
+	/*Unregister with the thermal zone driver*/
+	thermal_unregister_device(pr->td);
 
 	acpi_processor_power_exit(pr, device);
 
@@ -991,6 +1000,327 @@ void acpi_processor_uninstall_hotplug_notify(void)
  * ACPI, but needs symbols from this driver
  */
 
+/* --------------------------------------------------------------------------
+			Thermal management APIs
+   -------------------------------------------------------------------------- */
+struct acpi_processor_states {
+	u16 pstate;
+	u16 tstate;
+};
+
+#define MAXFREQ_STATE 0
+#define THROTTLE_STATE 1
+
+#define PSTATE_NOT_SUPPORTED 0
+#define TSTATE_NOT_SUPPORTED 0
+
+/*
+ * cpu_get_max_state
+ * -----------------------------
+ * Fills back the maximum permissible P-states and T-States
+ * pr : acpi_processor (processor context)
+ * states : OUT param with Max P & T states
+ */
+
+static int cpu_get_max_state(struct acpi_processor *pr,
+			     struct acpi_processor_states *states)
+{
+	if (!pr || !states)
+		return -EINVAL;
+
+	if ((!pr->performance) && (!(pr->throttling.state_count > 0))) {
+		states->tstate = TSTATE_NOT_SUPPORTED;
+		states->pstate = PSTATE_NOT_SUPPORTED;
+	}
+
+	else if (!pr->performance) {
+		states->tstate = pr->throttling.state_count;
+		states->pstate = PSTATE_NOT_SUPPORTED;
+	}
+
+	else if (!(pr->throttling.state_count > 0)) {
+		states->tstate = TSTATE_NOT_SUPPORTED;
+		states->pstate = pr->performance->state_count;
+	}
+
+	else {
+		states->tstate = pr->throttling.state_count;
+		states->pstate = pr->performance->state_count;
+	}
+
+	return 0;
+}
+
+/*
+ * cpu_get_current_state
+ * -----------------------------
+ * Fills back the current P-states and T-States
+ * pr : acpi_processor (processor context)
+ * states : OUT param with current P & T states
+ */
+static int cpu_get_current_state(struct acpi_processor *pr,
+				 struct acpi_processor_states *states)
+{
+	if (!pr || !states)
+		return -EINVAL;
+
+	if ((!pr->performance) && (!(pr->throttling.state_count > 0))) {
+		states->pstate = PSTATE_NOT_SUPPORTED;
+		states->tstate = TSTATE_NOT_SUPPORTED;
+	}
+
+	else if (!pr->performance) {
+		states->tstate = pr->throttling.state;
+		states->pstate = PSTATE_NOT_SUPPORTED;
+	}
+
+	else if (!(pr->throttling.state_count > 0)) {
+		states->tstate = TSTATE_NOT_SUPPORTED;
+		states->pstate = pr->performance->state;
+	}
+
+	else {
+		states->tstate = pr->throttling.state;
+		states->pstate = pr->performance->state;
+	}
+
+	return 0;
+}
+
+/*
+ * cpu_get_next_state
+ * -----------------------------
+ * Fills back the next possible combination of P-states and T-States
+ * Always P-states are exhausted and then the T-states
+ * pr : acpi_processor (processor context)
+ * states : OUT param with next possible P & T states
+ */
+
+/*We need to get the next state as below*/
+/*
+0   1   2   3   4   5   6   7   8   9   10
+=========================================
+P0  P1  P2
+	T0  T1  T2  T3  T4  T5  T6  T7
+*/
+static int cpu_get_next_state(int step, struct acpi_processor *pr,
+			      struct acpi_processor_states *states)
+{
+	int result;
+	int new_pstate;
+	struct acpi_processor_states cur_states, max_states;
+
+	if (!pr || !states)
+		return -EINVAL;
+
+	cpu_get_max_state(pr, &max_states);
+	cpu_get_current_state(pr, &cur_states);
+
+	/*Initialize to current*/
+	memcpy(states, &cur_states, sizeof(struct acpi_processor_states));
+
+	/*If the value goes beyond lower limit set states to high performance*/
+	if (cur_states.pstate + cur_states.tstate + step <= 0) {
+		states->pstate = 0;
+		states->tstate = 0;
+		result = MAXFREQ_STATE;
+	}
+	/*If the value goes beyond upper limit set states to low performance*/
+	else if (cur_states.tstate + step > max_states.tstate) {
+		states->pstate = max_states.pstate;
+		states->tstate = max_states.tstate;
+		result = THROTTLE_STATE;
+	}
+	/*If the 'step' partiailly inclues P-state
+	  and partially includes T-state*/
+	else if (cur_states.pstate + (cur_states.tstate + 1) + step >=
+		 max_states.pstate) {
+		new_pstate =
+		    max_states.pstate - 1 >= 0 ? max_states.pstate - 1 : 0;
+		states->pstate = new_pstate;
+		states->tstate += cur_states.pstate + step - new_pstate;
+		result = THROTTLE_STATE;
+	}
+	/*If step is in a valid P-state range*/
+	else {
+		states->pstate += step;
+		result = THROTTLE_STATE;
+	}
+
+	return result;
+}
+
+/* --------------------------------------------------------------------------
+			Thermal management sysfs callbacks
+   -------------------------------------------------------------------------- */
+
+/*
+ * cpu_device_set_throttle_limit
+ * -----------------------------
+ * call back function for setting the device's new throttle limit
+ * data : acpi_processor
+ * buf : sysfs buffer that contains the data
+ */
+int cpu_device_set_throttle_limit(enum throttle_set_type type,
+				  void *data, const char *buf)
+{
+	struct acpi_processor *pr = (struct acpi_processor *)data;
+	struct acpi_processor_performance *perf;
+	struct cpufreq_policy policy;
+	struct acpi_processor_states states;
+
+	int new_state;
+	int step;
+	unsigned int pstate;
+	unsigned int tstate;
+
+	int result = 0;
+
+	perf = pr->performance;
+
+	if (!buf)
+		return -EFAULT;
+
+	/*Absolute throttle*/
+	if (THROTTLE_ABS == type) {
+		new_state = simple_strtol(buf, NULL, 0);
+		if (new_state < 0)
+			return -EINVAL;
+
+		memcpy(&states, &new_state, sizeof(unsigned int));
+
+	}
+	/*Relative thorttle*/
+	else {
+		step = simple_strtol(buf, NULL, 0);
+		cpu_get_next_state(step, pr, &states);
+	}
+
+	pstate = states.pstate;
+	tstate = states.tstate;
+
+	if (perf && pstate < perf->state_count && pstate != perf->state) {
+		cpufreq_get_policy(&policy, pr->id);
+		policy.max = perf->states[pstate].core_frequency * 1000;
+		result = cpufreq_set_policy(&policy);
+
+		if (result)
+			return result;
+
+		pr->performance->state = pstate;
+	}
+
+	result = 0;
+
+	if (tstate < pr->throttling.state_count
+	    && tstate != pr->throttling.state)
+		result = acpi_processor_set_throttling(pr, tstate);
+
+	return result;
+}
+
+/*
+ * cpu_device_get_throttle_limit
+ * -----------------------------
+ * call back function for getting the device's current throttle limit
+ * data : acpi_processor
+ * buf : sysfs buffer that needs to be filled back
+ */
+int cpu_device_get_throttle_limit(void *data, char *buf)
+{
+	struct acpi_processor *pr = (struct acpi_processor *)data;
+	int throttlestate;
+	struct acpi_processor_states states;
+
+	char *s = buf;
+
+	if (!pr)
+		return -EINVAL;
+
+	cpu_get_current_state(pr, &states);
+
+	memcpy(&throttlestate, &states, sizeof(unsigned int));
+	s += sprintf(s, "%d\n", throttlestate);
+
+	return 0;
+}
+
+/*
+ * cpu_device_get_maxthrottle_limit
+ * -----------------------------
+ * call back function for getting the device's maximum throttle limit
+ * data : acpi_processor
+ * buf : sysfs buffer that needs to be filled back
+ */
+int cpu_device_get_maxthrottle_limit(void *data, char *buf)
+{
+	int maxthrottlestate = 0;
+	char *s = buf;
+	struct acpi_processor_states states;
+	struct acpi_processor *pr = (struct acpi_processor *)data;
+
+	if (!pr)
+		return -EINVAL;
+
+	if ((!pr->performance) && (!(pr->throttling.state_count > 0))) {
+		states.tstate = TSTATE_NOT_SUPPORTED;
+		states.pstate = PSTATE_NOT_SUPPORTED;
+	}
+
+	else if (!pr->performance) {
+		states.tstate = pr->throttling.state_count;
+		states.pstate = PSTATE_NOT_SUPPORTED;
+	}
+
+	else if (!(pr->throttling.state_count > 0)) {
+		states.tstate = TSTATE_NOT_SUPPORTED;
+		states.pstate = pr->performance->state_count;
+	}
+
+	else {
+		states.tstate = pr->throttling.state_count;
+		states.pstate = pr->performance->state_count;
+	}
+
+	memcpy(&maxthrottlestate, &states, sizeof(unsigned int));
+	s += sprintf(s, "%d\n", maxthrottlestate);
+
+	return 0;
+}
+
+/*
+ * cpu_device_get_caps
+ * -----------------------------
+ * call back function for getting the device's capabilities
+ * data : acpi_processor
+ * buf : sysfs buffer that needs to be filled back
+ */
+static int cpu_device_get_caps(void *data, char *buf)
+{
+	char *s = buf;
+	unsigned int caps = 0;
+
+	if (NULL == data || NULL == buf)
+		return -EINVAL;
+
+	caps |= DEVICE_CAPS_SW_PGM_THERMAL_EVENTS;
+	s += sprintf(buf, "%d\n", caps);
+
+	return (s - buf);
+}
+
+static struct thermal_device_ops cpu_thermal_ops = {
+	.getthrottlelimit = cpu_device_get_throttle_limit,
+	.setthrottlelimit = cpu_device_set_throttle_limit,
+	.getmaxthrottlelimit = cpu_device_get_maxthrottle_limit,
+	.getcaps = cpu_device_get_caps,
+};
+
+static struct thermal_device_driver cpu_thermal_driver = {
+	.class = THERMAL_CPU_CLASS,
+	.ops = &cpu_thermal_ops
+};
+
 static int __init acpi_processor_init(void)
 {
 	int result = 0;
@@ -1010,6 +1340,8 @@ static int __init acpi_processor_init(void)
 		return -ENOMEM;
 	acpi_processor_dir->owner = THIS_MODULE;
 
+	thermal_register_device_driver(&cpu_thermal_driver);
+
 	result = acpi_bus_register_driver(&acpi_processor_driver);
 	if (result < 0) {
 		remove_proc_entry(ACPI_PROCESSOR_CLASS, acpi_root_dir);
@@ -1036,6 +1368,8 @@ static void __exit acpi_processor_exit(void)
 
 	acpi_bus_unregister_driver(&acpi_processor_driver);
 
+	thermal_unregister_device_driver(&cpu_thermal_driver);
+
 	remove_proc_entry(ACPI_PROCESSOR_CLASS, acpi_root_dir);
 
 	return;
diff --git a/include/acpi/processor.h b/include/acpi/processor.h
index b4b0ffd..2e5d221 100644
--- a/include/acpi/processor.h
+++ b/include/acpi/processor.h
@@ -177,6 +177,7 @@ struct acpi_processor {
 
 	/* the _PDC objects for this processor, if any */
 	struct acpi_object_list *pdc;
+	struct thermal_device *td;
 };
 
 struct acpi_processor_errata {
-- 
1.5.2.4

