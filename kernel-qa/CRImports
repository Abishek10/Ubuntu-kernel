#!/usr/bin/env python
#
# Checkbox Results Import

import os
import sys
import re
import json
from CRDoc import *
from couchdbkit import *

# ThisAppConfig
#
# How to get the application configuration parameters. In this implementation
# I am using a json syntax for the configuration parameters so it's actually
# easy to load the configuration. It come in as a dictionary.
#
class ThisAppConfig:
    def __init__(self):
        return

    def load(self, configFilePath):
        if (not os.path.exists(configFilePath)):
            print("\n   *** Error: The indicated configuration file (%s) does not exist.\n" % configFilePath)
            raise

        with open(configFilePath, 'r') as f:
            self.cfg = json.load(f)

        return self.cfg

    def dump(self, cfg):
        print(json.dumps(cfg, indent=2))
        return

# ThisApp
#
# The directory that contains the test results and the log files has a
# guid as a directory name. The directory structure looks like:
#
#    0066ddb5-6527-4837-812e-a4e1d5c9dd0c
#      |
#      +-qa-log
#      |   |
#      |   +-testresult
#      |
#      +-ubuntu-log
#          |
#          +-*.log
#
class ThisApp:
    def __init__(self):
        self.log = open('_mylog_.txt', 'w')
        envHome = os.environ.get('HOME')
        if envHome is None:
            self.log.write("\n   *** Error: The environment variable HOME is not set but is required.\n")
            raise

        #self.cfg = ThisAppConfig().load("%s/.Canonical.cfg" % envHome)
        #self.cfg = ThisAppConfig().load("Canonical.cfg")
        self.cfg = ThisAppConfig().load(sys.argv[1])

        return

    def run(self):
        
        # We require a single commaand line parameter, the root directory
        # of the checkbox results tree. Under this directory is the checkbox-log
        # and ubuntu-log folders.
        #
        if (len(sys.argv) != 3):
            self.log.write("\n")
            self.log.write("   *** Error: This application requires two, and only two, command line arguments.\n")
            self.log.write("              That one argument is the root of the checkbox results tree.\n")
            raise

        root = sys.argv[2].rstrip('/') # Remove the trailing '/' if it exists
        if (not os.path.exists(root)):
            self.log.write("\n   *** Error: The specified root directory (%s) does not exist.\n" % root)
            raise

        results     = {}
        testResults = {}
        testResultsRoot     = "%s/qa-log" % root
        checkboxResultsFile = "%s/testresult"  % testResultsRoot
        ubuntuRoot          = "%s/ubuntu-log"   % root
        resultsId = self.determineResultsId(root)
        if (not os.path.exists(testResultsRoot)):
            self.log.write("\n")
            self.log.write("   *** Warning: There is no checkbox-log file in the specified root directory\n")
            self.log.write("                (%s).\n" % root)
        else:
            if (not os.path.exists(checkboxResultsFile)):
                self.log.write("\n")
                self.log.write("   *** Warning: There is no results file (%s).\n" % checkboxResultsFile)
                self.log.write("\n")
            else:
                testResults = self.processTestResults(checkboxResultsFile)
                
        results['id'] = resultsId
        results['tests'] = testResults
        self.updateDatabase(results, ubuntuRoot)
        self.log.close()
        return

    # processTestResults
    #
    # The significant file to be processed, which contains the test results
    # is "subunit.log" in the checkbox-log directory.
    #
    def processTestResults(self, resultsFile):
        retval = {}
        rslts = open(resultsFile, "r").readlines() # Read the entire log file into a single list
        #self.log.write("log:\n")
        #self.log.write(rslts)
        #self.log.write("\n")
        for line in rslts:
            m = re.search('(.*):(.*):(.*)', line)
            if (m != None):
                retval["%s:%s" % (m.group(1), m.group(2))] = m.group(3)

        return retval

    # determineResultsId
    #
    # We need a unique id for when we add our results to the central database.
    # The root directory name is a unique uuid. Use that as the unique id for
    # the database.
    #
    def determineResultsId(self, root):
        (head, sep, tail) = root.rpartition('/')
        #self.log.write("head: '%s'; sep: '%s'; tail: '%s'" % (head, sep, tail))
        return tail

    def attachLogs(self, root, db, doc):
        if (os.path.exists(root)):
            for f in os.listdir(root):
                fn = os.path.join(root, f)
                if (os.path.isfile(fn)):
                    fileContents = open(fn, 'r').read()
                    db.put_attachment(doc, fileContents, f, "text/plain")
        else:
            self.log.write("*** Path: '%s' doesn't exist.\n" % (root))
        return

    def updateDatabase(self, results, ubuntuRoot):
        server = Server(self.cfg['server'])
        db = server.get_or_create_db('kernel_test_data')
        
        CRDocument.set_db(db)
        
        doc = CRDocument()
        doc._id = results['id']
        doc.event = self.cfg['event']
        doc.testResults = results
        
        doc.save()

        self.attachLogs(ubuntuRoot, db, doc)
        return

if __name__ == '__main__':
    try:
        app = ThisApp()
        app.run()
    except:
	#raise
        pass


# vi:set ts=4 sw=4 expandtab:
