#!/usr/bin/env python
#
# shank is the "stable bot" or "stab-bot".
#

from sys                                import argv
from os                                 import path
from getopt                             import getopt, GetoptError
from ktl.utils                          import stdo, date_to_string
from ktl.ubuntu                         import Ubuntu
from ktl.std_app                        import StdApp
from ktl.workflow                       import Workflow, Properties
from ktl.tracking_bug                   import TrackingBug
from lpltk.LaunchpadService             import LaunchpadService
from datetime                           import datetime
from urllib                             import quote
from urllib2                            import HTTPError
from ktl.messaging                      import Email, Status
import re

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>]                         \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --verbose        Give some feedback of what is happening while the script is         \n")
        stdo("                         running.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --bugs=<bug list>  Only process the included bugs                                    \n")
        stdo("                                                                                             \n")
        stdo("        --dry-run         Don't actually change any bugs, just print info.                   \n")
        stdo("                                                                                             \n")
        stdo("        --config=<cfg file>                                                                  \n")
        stdo("                         The full path to the configuration file to use instead of           \n")
        stdo("                         the default location.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("        --staging                                                                            \n")
        stdo("                         Use the staging LP service instead of the production one.           \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'config=', 'debug=', 'staging', 'dry-run', 'bugs=']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif (opt == '--dry-run'):
                    self.cfg['dryrun'] = True

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in '--bugs':
                    buglist = []
                    for bugnum in val.split(','):
                        buglist.append(bugnum)
                    self.cfg['buglist'] = buglist

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

                elif (opt == '--staging'):
                    self.cfg['staging'] = True

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        return

# Shank
#
class Shank(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

        self.state_map = {
            # Task, Current State, Action
            'prepare-package'         : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.prep_package_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'upload-to-ppa'           : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.upload_to_ppa_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.upload_to_ppa_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-lbm'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_lbm_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-lrm'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_lrm_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-lum'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_lum_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-meta'    : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_meta_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-ports-meta':{'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_ports_meta_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-proposed'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.promote_to_proposed_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'verification-testing'    : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.verification_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'certification-testing'   : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':self.certification_testing_invalid},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.certification_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'regression-testing'      : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.regression_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-updates'      : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.check_for_final_close},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-security'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.check_for_final_close},
                                         'Unknown' : {'action':None},
                                         },
            'security-signoff'        : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':self.security_signoff_finished},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.security_signoff_finished},
                                         'Unknown' : {'action':None},
                                         },
        } 

    # initialize
    #
    def initialize(self):
        if 'staging' in self.cfg:
            self.defaults['launchpad_services_root'] = 'qastaging'
        self.lp = LaunchpadService(self.defaults)
        self.ubuntu = Ubuntu()
        self.wf = Workflow()

        # The service.distributions property is a collection of distributions. We
        # pretty much only care about one, 'ubuntu'.
        #
        self.distro = self.lp.distributions['ubuntu']

        self.projectname = 'kernel-sru-workflow'

        self.project = self.lp.projects[self.projectname]

        # Get set up for email and status messages
        if 'mail_notify' in self.cfg:
            mcfg = self.cfg['mail_notify']
            self.email = Email(mcfg['smtp_server'].encode('UTF-8'), mcfg['smtp_user'].encode('UTF-8'), mcfg['smtp_pass'].encode('UTF-8'))

        scfg = self.cfg['status_net']
        self.status = Status(scfg['url'], scfg['user'], scfg['pass'])

        # Get the text for spamming bugs
        spamtextpath =  path.join(path.dirname(__file__), self.cfg['bug_spam']['text_filename'])
        self.verbose('Bug spam text is from file %s\n' % spamtextpath)
        self.spamtext = open(spamtextpath, 'r').read()

        self.taskbyname = {}

        self.printlink = "(No link)"

        return

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            # set our config file, which can be overridden on the command line
            self.defaults['configuration_file'] = path.dirname(__file__) + '/sru-workflow.cfg'
            #print('config file = %s' % self.defaults['configuration_file'])

            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            project = self.lp.projects[self.projectname]

            # Searching for bug tasks, the search can be quite complicated and made up
            # of several components. The following can be combined in many ways to get
            # the search you want. The search happens on the server and returns a
            # collection of bug tasks that match the search criteria.
            #
            # tasks = pkg.search_tasks(tags=search_tags, tags_combinator=search_tags_combinator,
            #                          status=self.cfg['task_search_status'], modified_since=search_since)
            #
            search_tags            = [   # A list of the tags we care about
                    'kernel-release-tracking-bug'
                ]
            search_tags_combinator = "All"
            search_status          = ["New","In Progress","Invalid", "Incomplete", "Fix Committed"] # A list of the bug statuses that we care about
            search_since           = datetime(year=2011, month=1, day=1)
            tasks = project.search_tasks(status=search_status, tags=search_tags, tags_combinator=search_tags_combinator, modified_since=search_since)

            for task in tasks:
                bug = task.bug
                if 'buglist' in self.cfg:
                    if str(bug.id) not in self.cfg['buglist']:
                        continue
                if 'staging' in self.cfg:
                    self.cfg['lpserver'] = 'bugs.qastaging.launchpad.net'
                else:
                    self.cfg['lpserver'] = 'bugs.launchpad.net'

                self.printlink =  '%s : (%s)\n' % (bug.id, self.bug_url(bug.id)),
                self.verbose('Processing: %s' % self.printlink)

                # initialize any per-bug variables that we use for the release test
                self.bugtags = []
                for atag in bug.tags:
                    self.bugtags.append(atag)
                performReleaseTest = False
                self.certification_testing_complete = False
                self.regression_testing_complete = False
                self.security_signoff_complete = False
                self.security_publishing_required = False

                # Initialize the properties object
                self.props = Properties(bug)
                #
                # list any Properties from bug description
                props = bug.properties
                for prop in props:
                    self.verbose('    Bug has Property:  %s:%s' % (prop, props[prop]))

                # We iterate through tasks on a bug but we need access to the other tasks, so first build a list up from of all tasks on this bug
                # TODO This is a bit sloppy and I should probably build one list and walk it twice.
                try:
                    # TODO revisit this, but hardcode for now
                    #mtstring = self.project.display_name
                    mtstring = self.projectname

                    self.taskbyname = {}
                    for t in bug.tasks:
                        task_name       = t.bug_target_name

                        if task_name == mtstring:
                            # we save a pointer to the master task and check to make sure we should process this bug
                            self.taskbyname[mtstring] = t
                            if t.status == 'In Progress':
                                continue
                            else:
                                self.verbose('    Not processing this bug because master task state is set to %s\n' % (t.status))
                                raise RuntimeError

                        if not task_name.startswith(mtstring):
                            # Ignore the tasks assigned to the actual package, we care about workflow only
                            self.verbose('Skipping non-workflow task <%s>:<%s>\n' % (mtstring, task_name))
                            continue

                        # add one to account for the trailing /
                        therest = task_name[len(mtstring)+1:].strip()
                        self.taskbyname[therest] = t

                except RuntimeError:
                    # end processing for this bug
                    self.verbose('    Quitting this bug\n')
                    continue

                # now walk them one at a time
                for t in bug.tasks:
                    task_name = t.bug_target_name.strip()
                    # bug_target_name includes both the main and sub task in the string
                    # so for example it could be "Kernel SRU Workflow prepare-package"
                    # so we have to strip off the right hand part
                    # The task can also be just the single parent task
                    #

                    if task_name == mtstring:
                        self.verbose('Skipping empty master workflow task \n')
                        continue

                    if not task_name.startswith(mtstring):
                        # Ignore the tasks assigned to the actual package, we care about workflow only
                        self.verbose('Skipping non-workflow task %s\n' % (task_name))
                        continue

                    therest = task_name[len(mtstring)+1:].strip()
                    task_name = therest

                    state      = t.status
                    importance = t.importance
                    assignee    = t.assignee
                    if assignee is None:
                        assignee = '*Unassigned'
                    else:
                        assignee = assignee.display_name

                    self.verbose("TASK: %25s  %15s  %10s  %s\n" % (task_name, state, importance, assignee))

                    if task_name not in self.state_map:
                        print self.printlink,
                        print("I don't know how to handle the task <%s>, skipping" % (task_name))
                        continue

                    if 'action' not in self.state_map[task_name][state]:
                        print self.printlink,
                        print("ERROR: No action found for state <%s> and task <%s>" % (state, task_name))
                        raise ValueError

                    action = self.state_map[task_name][state]['action']

                    if  action is None:
                        self.verbose('ACTION: No action for task %s in state %s\n' % (task_name, state))
                    else:
                        if action(t):
                            performReleaseTest = True

                # Now process any tests which require information from multiple tasks
                # will require info stored in class variables during task processing
                if performReleaseTest:
                    self.perform_release_test()

                # Now flush any property changes to the bug description
                self.props.flush()
                self.verbose('--\n')


        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

    # end of main

    def bug_url(self, bug_id):
        retval = 'https://%s/bugs/%s' % (self.cfg['lpserver'], bug_id)
        return retval

    def send_comment(self, task, subject, body):
        """
        Add comment to tracking bug
        """
        if 'dryrun' in self.cfg:
            self.verbose('Dryrun - Adding comment to tracking bug\n')
        else:
            self.verbose('Adding comment to tracking bug\n')
            task.bug.add_comment(body, subject)

    def send_email(self, task, subject, body):
        """
        Send email to the configured list or recipient
        """
        if 'dryrun' in self.cfg:
            self.verbose('Dryrun - Sending email\n')
            return

        self.verbose('Sending email\n')

        if not 'mail_notify' in self.cfg:
            self.verbose('No mail_notify config found, can\'t send email\n')
            return

        mcfg = self.cfg['mail_notify']
        body_top = 'The following message is regarding the following Kernel SRU Tracking bug:\n%s\n' % self.bug_url(task.bug.id)
        body_top = body_top + ('%s\n\n' % task.bug.title)
        msg = body_top + body
        subj =  '[ShankBot] ' + subject
        self.email.send(mcfg['from_address'], mcfg['to_address'], subj, msg)
        return

    def send_status_update(self, task, message):
        """
        Send a status update to twitter, status.net, identi.ca, etc
        """
        if 'dryrun' in self.cfg:
            self.verbose('Dryrun - Sending Status\n')
            return

        self.verbose('Sending Status\n')

        bugurl = quote(self.bug_url(task.bug.id))

        btitle = task.bug.title
        packagename = btitle.split(':')[0]
        version = btitle.split(':')[1].split()[0]
        kinfo = self.ubuntu.lookup(version.split('-')[0])
        series_name = kinfo['name']
        pkgid = '%s package %s %s ' % (series_name, packagename, version)

        self.status.update(bugurl + ' : ' + pkgid + ' ' + message)
        return

    def set_task_to_state(self, taskname, state):
        """
        Set a task with a given name to the desired state
        returns True if we changed the state and False if it was already at the desired state
        """
        if 'dryrun' in self.cfg:
            self.verbose('Dryrun - Set task %s to state %s\n' % (taskname, state))
            return

        # TODO could add error handling and retries here if needed
        if self.taskbyname[taskname].status != state:
            print self.printlink,
            print 'Setting Task <%s> to State <%s>' % (taskname, state)
            self.taskbyname[taskname].status = state
            return True
        else:
            self.verbose('Task <%s> was already in state <%s>\n' % (taskname, state))
            return False

    # set_tagged_timestamp
    #
    """
    Add the supplied key with a timestamp. We do not replace existing keys
    """
    def set_tagged_timestamp(self, taskobj, keyvalue):
        bug = taskobj.bug
        if keyvalue in  bug.properties:
            self.verbose('tagged timestamp <%s> already in the tracking bug, not replacing\n' % keyvalue)
            return
        if 'dryrun' in self.cfg:
            self.verbose('Dryrun - Adding tagged timestamp <%s> to tracking bug\n' % keyvalue)
            return
        else:
            self.verbose('Adding tagged timestamp <%s> to tracking bug\n' % keyvalue)

            now = datetime.utcnow()
            now.replace(tzinfo=None)
            tstamp = date_to_string(now)
            props = {keyvalue:tstamp}
            self.props.set(props)

    # set_stable_phase
    #
    """
    Add the phase we're entering as a 'property',
    along with a time stamp
    """
    def set_stable_phase(self, taskobj, phasetext):
        # We have to check here to see whether the same status is already set,
        # or we will overwrite the timestamp needlessly
        if 'kernel-stable-phase' in taskobj.bug.properties:
            if taskobj.bug.properties['kernel-stable-phase'] == phasetext:
                # we already have this one
                self.verbose('Not overwriting identical phase property\n')
                return
        # Handle dryrun mode
        if 'dryrun' in self.cfg:
            self.verbose('Dryrun - Changing stable phase to <%s>\n' % phasetext)
            return
        else:
            self.verbose('Changing stable phase to <%s>\n' % phasetext)
        # Add phase and time stamp
        now = datetime.utcnow()
        now.replace(tzinfo=None)
        tstamp = date_to_string(now)
        props = {'kernel-stable-phase':phasetext, 'kernel-stable-phase-changed':tstamp}
        self.props.set(props)

    def is_prep_pkg_closed(self, taskname):
        if taskname in self.taskbyname:
            if (self.taskbyname[taskname].status != "Fix Released" and
                self.taskbyname[taskname].status != "Invalid"):
                return False
        return True

    def is_prep_pkg_released(self, taskname):
        if taskname in self.taskbyname:
            if self.taskbyname[taskname].status != "Fix Released":
                return False
        return True

    def check_dep_pkg_built(self, taskobj, deptype):
        title = taskobj.bug.title
        pkg_name = re.findall('linux[^:]*', title)[0]
        pkg_ver = re.findall('([0-9]+\.[^ ]+)', title)[0]
        series = self.wf.expected_series_name(self.ubuntu.db, pkg_name, pkg_ver)
        if not series:
            print("ERROR: Can't find series for %s-%s to check %s dependency\n" %
                  (pkg_name, pkg_ver, deptype))
            return False
        kinfo = self.ubuntu.lookup(series)
        dep_name = ''
        if 'dependent-packages' in kinfo:
            if pkg_name in kinfo['dependent-packages']:
                if deptype in kinfo['dependent-packages'][pkg_name]:
                    dep_name = kinfo['dependent-packages'][pkg_name][deptype]
        if not dep_name:
            print("ERROR: can't find %s package name for %s-%s\n" %
                  (deptype, pkg_name, pkg_ver))
            return False
        pkg_abi = re.findall('-[0-9]+[^.]+', pkg_ver)[0]
        pkg_kernel = re.findall('-[0-9]+[^ ]+', pkg_ver)[0]
        pkg_kernel = pkg_ver.replace(pkg_kernel, '', 1)
        pkg_abi = pkg_abi.lstrip('-')
        dep_ver1 = '%s-%s' % (pkg_kernel, pkg_abi)
        dep_ver2 = '%s.%s' % (pkg_kernel, pkg_abi)
        ckt = self.lp.launchpad.people['canonical-kernel-team']
        ppa = ckt.getPPAByName(name='ppa')
        dep_matches = [ p for p in ppa.getPublishedSources(source_name=dep_name)
                          if p.status.lower() == 'published' and
                             (p.source_package_version.startswith(dep_ver1) or
                              p.source_package_version.startswith(dep_ver2)) ]
        if not dep_matches:
            self.verbose('Can\'t find <%s> (<%s> or <%s>) build on c-k-t ppa\n' %
                         (dep_name, dep_ver1, dep_ver2))
        for dep_pkg in dep_matches:
            src_id = str(dep_pkg.self).rsplit('/', 1)[1]
            build_summaries = ppa.getBuildSummariesForSourceIds(source_ids=[src_id])[src_id]
            task_name = taskobj.bug_target_name
            workflow_task = task_name[len(self.projectname)+1:].strip()
            if build_summaries['status'] == 'FULLYBUILT':
                self.verbose('<%s> <%s> built, %s is Fix Released\n'
                             % (dep_name, dep_pkg.source_package_version, workflow_task))
                self.set_task_to_state(workflow_task, 'Fix Released')
            else:
                self.verbose('<%s> <%s> not fully built yet, %s still In Progress\n'
                             % (dep_name, dep_pkg.source_package_version, workflow_task))
        return False

    #
    # Begin action methods for state transitions
    #

    def prep_lbm_package_in_progress(self, taskobj):
        """
        when we have a prepare-package-lbm task and it's set to In
        Progress, the package have a dependent linux-backports-modules
        package to be built; update the task if package is built
        """
        self.check_dep_pkg_built(taskobj, 'lbm')
        return False

    def prep_lrm_package_in_progress(self, taskobj):
        """
        when we have a prepare-package-lrm task and it's set to In
        Progress, the package have a dependent linux-restricted-modules
        package to be built; update the task if package is built
        """
        self.check_dep_pkg_built(taskobj, 'lrm')
        return False

    def prep_lum_package_in_progress(self, taskobj):
        """
        when we have a prepare-package-lum task and it's set to In
        Progress, the package have a dependent linux-ubuntu-modules
        package to be built; update the task if package is built
        """
        self.check_dep_pkg_built(taskobj, 'lum')
        return False

    def prep_meta_package_in_progress(self, taskobj):
        """
        when we have a prepare-package-meta task and it's set to In
        Progress, the package have a dependent meta package to be built;
        update the task if package is built
        """
        self.check_dep_pkg_built(taskobj, 'meta')
        return False

    def prep_ports_meta_package_in_progress(self, taskobj):
        """
        when we have a prepare-package-ports-meta task and it's set to
        In Progress, the package have a dependent ports-meta package to
        be built; update the task if package is built
        """
        self.check_dep_pkg_built(taskobj, 'ports-meta')
        return False

    def prep_package_in_progress(self, taskobj):
        """
        when the prep-package task is set to In Progress and no
        upload-to-ppa task is present, kernel team builds the packages;
        check the build status and update tasks
        """
        task_name = taskobj.bug_target_name
        workflow_task = task_name[len(self.projectname)+1:].strip()
        if ('upload-to-ppa' in self.taskbyname and workflow_task == 'prepare-package'):
            return False
        if (not (self.is_prep_pkg_closed('prepare-package-lbm') and
                 self.is_prep_pkg_closed('prepare-package-lrm') and
                 self.is_prep_pkg_closed('prepare-package-lum') and
                 self.is_prep_pkg_closed('prepare-package-meta') and
                 self.is_prep_pkg_closed('prepare-package-ports-meta'))):
            return False
        title = taskobj.bug.title
        pkg_name = re.findall('linux[^:]*', title)[0]
        pkg_ver = re.findall('([0-9]+\.[^ ]+)', title)[0]
        ckt = self.lp.launchpad.people['canonical-kernel-team']
        ppa = ckt.getPPAByName(name='ppa')
        matches = [ p for p in ppa.getPublishedSources(source_name=pkg_name)
                            if p.status.lower() == 'published' and
                               p.source_package_version == pkg_ver ]
        if not matches:
            self.verbose('Can\'t find <%s> <%s> build on c-k-t ppa\n' % (pkg_name, pkg_ver))
        for pkg in matches:
            src_id = str(pkg.self).rsplit('/', 1)[1]
            build_summaries = ppa.getBuildSummariesForSourceIds(source_ids=[src_id])[src_id]
            if build_summaries['status'] == 'FULLYBUILT':
                self.verbose('<%s> <%s> built, prep-package is Fix Released\n'
                             % (pkg_name, pkg_ver))
                if not 'upload-to-ppa' in self.taskbyname:
                    self.set_task_to_state('prepare-package', 'Fix Released')
                else:
                    self.set_task_to_state('upload-to-ppa', 'Fix Released')
            else:
                self.verbose('<%s> <%s> not fully built yet, skipping\n'
                             % (pkg_name, pkg_ver))
        return False

    def prep_package_fix_released(self, taskobj):
        """
        when the prep-package task is set to Fix Released and there is
        no upload-to-ppa task, we create new tracking bugs for
        derivative packages, and set the promote-to-proposed task to
        Confirmed. Otherwise, if upload-to-ppa task is present, just set
        it to Confirmed if necessary
        """
        task_name = taskobj.bug_target_name
        workflow_task = task_name[len(self.projectname)+1:].strip()
        if ('upload-to-ppa' in self.taskbyname and workflow_task == 'prepare-package'):
            if self.taskbyname['upload-to-ppa'].status == 'New':
                self.set_task_to_state('upload-to-ppa', 'Confirmed')
            return False

        if self.taskbyname['promote-to-proposed'].status == 'New':
            # open new tracking bugs for derivative packages if needed
            title = taskobj.bug.title
            pkg_name = re.findall('linux[^:]*', title)[0]
            pkg_ver = re.findall('([0-9]+\.[^ ]+)', title)[0]
            series = self.wf.expected_series_name(self.ubuntu.db, pkg_name, pkg_ver)
            if not series:
                print("ERROR: Can't find series for %s-%s to get derivatives\n"
                      % (pkg_name, pkg_ver))
                return False
            der_list = []
            found = self.ubuntu.lookup(series)
            if 'derivative-packages' in found:
                if pkg_name in found['derivative-packages']:
                    der_list = found['derivative-packages'][pkg_name]
            bp_list = []
            for entry in self.ubuntu.db.itervalues():
                if 'backport-packages' in entry:
                    bp_entries = entry['backport-packages']
                    for bp_entry in iter(bp_entries):
                        if (bp_entries[bp_entry][0] == pkg_name and
                            bp_entries[bp_entry][1] == found['series_version']):
                            bp_list.append([bp_entry, entry['name']])
            der_bug_list = []
            bp_bug_list = []
            tb = TrackingBug(self.lp, 'staging' in self.cfg)
            for der_pkg in der_list:
                if 'dryrun' in self.cfg:
                    self.verbose('Dryrun - Would open tracking bug for derivative package %s\n'
                                 % (der_pkg))
                    continue
                bug = tb.open(der_pkg, '<version to be filled>', True, series)
                print 'Opened tracking bug %s for derivative package %s\n' % (bug.id, der_pkg)
                der_bug_list.append([der_pkg, bug.id])
            for bp_pkg in bp_list:
                if 'dryrun' in self.cfg:
                    self.verbose('Dryrun - Would open tracking bug for backport package %s\n'
                                 % (bp_pkg[0]))
                    continue
                # Verify abi change, assume all prepare-package-* tasks are Fix Released
                new_abi = (self.is_prep_pkg_released('prepare-package-lbm') and
                           self.is_prep_pkg_released('prepare-package-lrm') and
                           self.is_prep_pkg_released('prepare-package-lum') and
                           self.is_prep_pkg_released('prepare-package-meta') and
                           self.is_prep_pkg_released('prepare-package-ports-meta'))
                bug = tb.open(bp_pkg[0], '%s~%s1' % (pkg_ver, bp_pkg[1]), new_abi)
                print('Opened tracking bug %s for backport package %s (%s)\n'
                      % (bug.id, bp_pkg[0], bp_pkg[1]))
                bp_bug_list.append([bp_pkg[0], bp_pkg[1], bug.id])

            # comment about publishing and possible new tracking bugs opened
            msgbody  = 'All builds are complete, packages in this bug can be'
            msgbody += ' copied to -proposed.'
            if der_bug_list:
                msgbody += '\n\nDerivative packages from packages here can be worked on,'
                msgbody += ' the following tracking bugs were opened for them:'
                for pkg_bug in der_bug_list:
                    msgbody += '\n%s - bug %s' % (pkg_bug[0], pkg_bug[1])
            if bp_bug_list:
                msgbody += '\n\nBackport packages from packages here can be worked on,'
                msgbody += ' the following tracking bugs were opened for them:'
                for pkg_bug in bp_bug_list:
                    msgbody += '\n%s (%s) - bug %s' % (pkg_bug[0], pkg_bug[1], pkg_bug[2])
            task = self.taskbyname[self.projectname]
            self.send_comment(task, 'Packages are ready for -proposed', msgbody)

            # Set promote-to-proposed
            self.set_task_to_state('promote-to-proposed', 'Confirmed')
            # Add time stamp and status
            self.set_tagged_timestamp(taskobj, 'kernel-stable-prepare-end')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-copy-to-proposed-start')
            self.set_stable_phase(taskobj, 'CopyToProposed')
        return False

    def upload_to_ppa_in_progress(self, taskobj):
        """
        When the upload-to-ppa task is set to In Progress, kernel team
        builds the packages; check the build status and update tasks
        """
        return self.prep_package_in_progress(taskobj)

    def upload_to_ppa_fix_released(self, taskobj):
        """
        When the upload-to-ppa task is set to Fix Released we create new
        tracking bugs for derivative packages, and set the
        promote-to-proposed task to Confirmed.
        """
        return self.prep_package_fix_released(taskobj)

    def promote_to_proposed_fix_released(self, taskobj):
        """
        When promote-to-proposed is set to Fix Released, we begin verification testing by setting
        verification-testing to In Progress, add tags to the bugs, and spam with text
        """
        # Add time stamp and status
        self.set_tagged_timestamp(taskobj, 'kernel-stable-copy-to-proposed-end')
        task = self.taskbyname['verification-testing']
        if task.status == 'New':
            if self.set_task_to_state('verification-testing', 'In Progress'):
                # we did change the state, weren't already in it
                self.set_tagged_timestamp(taskobj, 'kernel-stable-verification-start')
                self.set_stable_phase(taskobj, 'Verification')
                # Now tag all bugs verification-needed and spam with a comment
                # Automate this in the future but for now send an email
                print self.printlink,
                print 'Here is where we would tag and spam the verification bugs'
                # FIXME: not sending emails anymore, we can remove later the 3 lines below
                #msgbody = 'The stable kernel team should now add bug comments and tags\nas required. This is a manual step for now.'
                #self.send_email(taskobj, 'Bug spamming required', msgbody)
                #self.send_status_update(task, 'available in -proposed.')
        return False

    def verification_testing_fix_released(self, taskobj):
        """
        When verification-testing is set to Fix Released, we set three tasks to Confirmed.
        These are certification-testing, regression-testing, and security-signoff
        """
        # Add time stamp and status
        if ((self.taskbyname['certification-testing'].status != 'Fix Released' and
             self.taskbyname['certification-testing'].status != 'Invalid') or
            (self.taskbyname['security-signoff'].status != 'Fix Released' and
             self.taskbyname['security-signoff'].status != 'Invalid') or
            self.taskbyname['regression-testing'].status != 'Fix Released'):
            self.set_tagged_timestamp(taskobj, 'kernel-stable-verification-end')
            self.set_stable_phase(taskobj, 'Testing')

        if self.taskbyname['certification-testing'].status == 'New':
            self.set_task_to_state('certification-testing', 'Confirmed')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-certification-start')
        if self.taskbyname['regression-testing'].status == 'New':
            self.set_task_to_state('regression-testing', 'Confirmed')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-qa-start')
        if self.taskbyname['security-signoff'].status == 'New':
            self.set_task_to_state('security-signoff', 'Confirmed')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-security-signoff-start')
        return False

    def certification_testing_fix_released(self, taskobj):
        """
        When certification-testing is set to Fix Released, we check the tags
        If tagged certification-testing-failed then we alert people
        If certification-testing-passed then we save the tag and state and trigger
        running of the test to see if we're ready for publishing
        """
        if 'certification-testing-failed' in self.bugtags:
            self.verbose('Certification tagged as FAIL\n')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-certification-end')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The bug was tagged as certification-testing-failed\n'
            self.send_comment(taskobj, 'Certification FAILURE', msgbody)
            # stop further processing by this bot
            self.set_task_to_state(self.projectname, 'Incomplete')
            self.set_stable_phase(taskobj, 'TestFail')
            return False
        elif 'certification-testing-passed' in self.bugtags:
            self.verbose('Certification tagged as PASSED\n')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-certification-end')
            # TODO send a status.net update?
            self.certification_testing_complete = True
            return True
        else:
            self.verbose('certification-testing task set to Fix Released but no status tag!\n')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The certification-testing task was set to Fix Released but neither the certification-testing-passed or certification-testing-failed tag was applied\n'
            self.send_comment(taskobj, 'Certification completed but no status tags applied', msgbody)
            # reset task state so Certification team fixes it
            self.set_task_to_state('certification-testing', 'Incomplete')
            return False

    def certification_testing_invalid(self, taskobj):
        """
        When certification-testing is set to Invalid, this indicates
        that certification testing will not be performed on this release.
        We consider the task to be 'done' in that we trigger a release test,
        but we don't check any tags
        """
        self.certification_testing_complete = True
        self.set_tagged_timestamp(taskobj, 'kernel-stable-certification-end')
        return True

    def regression_testing_fix_released(self, taskobj):
        """
        When regression-testing is set to Fix Released, we check the tags
        If tagged qa-testing-failed then we alert people
        If qa-testing-passed then we save the tag and state and trigger
        running of the test to see if we're ready for publishing
        """
        if 'qa-testing-failed' in self.bugtags:
            self.verbose('Regression Testing tagged as FAIL\n')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-qa-end')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The bug was tagged as qa-testing-failed\n'
            self.send_comment(taskobj, 'Regression Testing FAILURE', msgbody)
            # stop further processing by this bot
            self.set_task_to_state(self.projectname, 'Incomplete')
            self.set_stable_phase(taskobj, 'TestFail')
            return False
        elif 'qa-testing-passed' in self.bugtags:
            self.verbose('Regression Testing tagged as PASSED\n')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-qa-end')
            # TODO send a status.net update?
            self.regression_testing_complete = True
            return True
        else:
            self.verbose('regression-testing task set to Fix Released but no status tag!\n')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The regression-testing task was set to Fix Released but neither the qa-testing-passed or qa-testing-failed tag was applied\n'
            self.send_comment(taskobj, 'Regression Testing completed but no status tags applied', msgbody)
            # reset task so QA team can fix it
            self.set_task_to_state('regression-testing', 'Incomplete')
            # stop further processing by this bot
            self.set_task_to_state(self.projectname, 'Incomplete')
            self.set_stable_phase(taskobj, 'OnHold')
            return False

    def security_signoff_finished(self, taskobj):
        """
        When security-signoff is set to either Invalid or Fix Released, it is done.
        If set to Fix Released, we set a flag to indicate that the package must
        be copied to the -security pocket.
        """
        self.security_signoff_complete = True
        self.set_tagged_timestamp(taskobj, 'kernel-stable-security-signoff-end')
        # Trigger the release test
        return True

    def release_test_state_check(self, taskname, desired_state_list):
        taskobj = self.taskbyname[taskname]
        if taskobj.status not in desired_state_list:
            self.verbose('ERROR: %s task set to Unexpected state!\n' % taskname)
            # Send email and possibly a status update
            msgbody = 'The %s task was not set to one of the following states during the release test:\n' % taskname
            for statename in desired_state_list:
                msgbody = msgbody + statename + ', '
            msgbody = msgbody + '\n'
            msgbody = msgbody + '%s task was set to state %s\n' % (taskname, taskobj.status)
            msgbody = msgbody + 'Further processing of this bug by Workflow Manager is halted.\n'
            self.send_comment(taskobj, '%s task not set to correct state during release test' % taskname, msgbody)
            # stop further processing by this bot
            self.set_task_to_state(self.projectname, 'Incomplete')

    #
    # This is not performed during processing for a specific task but only if several tasks are
    # in the correct state
    #
    # perform_release_test
    #
    def perform_release_test(self):
        """
        Check results from multiple tasks to see whether release
        to -updates and -security are required
        """
        self.verbose('*** Performing release test\n')

        # No need to do anything until these three are all complete
        if (self.certification_testing_complete and self.regression_testing_complete and self.security_signoff_complete):
            self.verbose('Cert and regression testing and security signoff all complete\n')

            # Some general sanity checks before we pull the lever to publish
            self.release_test_state_check('prepare-package', ['Fix Released'])
            self.release_test_state_check('promote-to-proposed', ['Fix Released'])
            self.release_test_state_check('verification-testing', ['Fix Released'])
            self.release_test_state_check('certification-testing', ['Invalid', 'Fix Released'])
            self.release_test_state_check('regression-testing', ['Fix Released'])
            self.release_test_state_check('security-signoff', ['Invalid', 'Fix Released'])
            # confirmed is in the next two in case we rerun the release test after
            # a dumb failure like email send fail or something
            self.release_test_state_check('promote-to-security', ['New', 'Confirmed', 'Invalid', 'Fix Released'])
            self.release_test_state_check('promote-to-updates', ['New', 'Confirmed', 'Fix Released'])

            # If we found any problems, we've halted processing and set this
            if self.taskbyname[self.projectname].status != 'In Progress':
                self.verbose('*** Exiting release test without triggering any publishing\n')
                return

            if ((self.taskbyname['promote-to-security'].status == 'Confirmed' or
                 self.taskbyname['promote-to-security'].status == 'Invalid') and
                self.taskbyname['promote-to-updates'].status == 'Confirmed'):
                self.verbose('*** Exiting release test, all set\n')
                return

            if self.taskbyname['security-signoff'].status == 'Fix Released':
                # publishing to security is required
                self.security_publishing_required = True

            # one last check for test results
            if 'qa-testing-passed' in self.bugtags and \
                    ('certification-testing-passed' in self.bugtags or self.taskbyname['certification-testing'].status == 'Invalid'):
                task = self.taskbyname[self.projectname]
                # we're all good
                if self.security_publishing_required:
                    self.verbose('Requires publishing to the -security pocket\n')
                    if self.taskbyname['promote-to-security'].status == 'New':
                        self.set_task_to_state('promote-to-security', 'Confirmed')
                else:
                    if self.taskbyname['promote-to-security'].status == 'New':
                        self.set_task_to_state('promote-to-security', 'Invalid')

                if self.taskbyname['promote-to-updates'].status == 'New':
                    self.set_task_to_state('promote-to-updates', 'Confirmed')
                    self.set_tagged_timestamp(task, 'kernel-stable-copy-to-updates-start')
                    self.set_stable_phase(task, 'CopyToUpdates')
                # Now send a happy email 
                msgbody = 'All tests are complete and the publishing tasks have been set to Confirmed\n'
                #self.send_email(task, 'Package is ready for publication', msgbody)
                #self.send_status_update(task, 'available for publication.')
                
            else:
                # don't have required testing signoffs
                self.verbose('ERROR: test completion tags not found during release test!\n')
                # Send email and possibly a status update
                msgbody = 'During the release test either the certification-testing-passed or the qa-testing-passed tag was not found\n'
                msgbody = msgbody + 'Tags on this bug are:\n'
                for ftag in self.bugtags:
                    msgbody = msgbody + '    ' + ftag + '\n'
                msgbody = msgbody + '\n'
                msgbody = msgbody + 'Further processing of this bug by Workflow Manager is halted.\n'
                self.send_comment(self.taskbyname[self.projectname], 'Test completion tags not found during release test', msgbody)
                # stop further processing by this bot
                self.set_task_to_state(self.projectname, 'Incomplete')
                self.set_stable_phase(task, 'OnHold')
        # this method is not associated with a task state transition so no status returned
        return 

    def check_for_final_close(self, taskobj):
        """
        If either of the publishing tasks is set to complete (Fix Released) we
        make a check to see whether we can set the entire tracking bug to Fix Released (done)
        """
        self.verbose('*** Performing check for final close test\n')

        if (( self.taskbyname['promote-to-updates'].status == 'Fix Released') and
            (self.taskbyname['promote-to-security'].status == 'Invalid' or
            self.taskbyname['promote-to-security'].status == 'Fix Released')):

            print self.printlink,
            print ' Everything is done, setting bug to Fix Released'
            self.set_task_to_state(self.projectname, 'Fix Released')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-copy-to-updates-end')
            self.set_stable_phase(taskobj, 'Released')

            # Send email and possibly a status update -spc- TODO
            msgbody = 'The package has been published and the bug is being set to Fix Released\n'
            self.send_comment(taskobj, 'Package Released!', msgbody)

            task = self.taskbyname['promote-to-updates']
            self.send_status_update(task, 'has been published.')

        # We should never trigger a release test from this, since it should have lready been done
        return False

if __name__ == '__main__':
    app = Shank()
    try:
        app.main()
    except HTTPError, err:
        if err.code == 503:
            print 'Launchpad server is down (503)'
        else:
            print 'Launchpad returned error %d' % err.code
            raise

# vi:set ts=4 sw=4 expandtab:

