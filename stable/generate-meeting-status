#!/usr/bin/env python
#

from sys                                import argv
from os                                 import path
from getopt                             import getopt, GetoptError
import json
from ktl.utils                          import stdo
from ktl.std_app                        import StdApp

from columns                            import align, FormatTable, LEFT, RIGHT, CENTER

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>] <srus.json>             \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --verbose        Give some feedback of what is happening while the script is         \n")
        stdo("                         running.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --config=<cfg file>                                                                  \n")
        stdo("                         The full path to the configuration file to use instead of           \n")
        stdo("                         the default location.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'config=', 'debug=']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

            if result: # No errors yet

                # At lease one source package must be specified.
                #
                if len(args) > 0:
                    self.cfg['sru'] = args[0]

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        if 'sru' not in self.cfg:
            raise CmdlineError('A json file containing the sru information is required. This is generated by the sru-report script.')
        return

# GenerateMeetingStatus
#
class GenerateMeetingStatus(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

    # initialize
    #
    def initialize(self):
        self.dbg('core', "initialize: enter\n")
        self.dbg('core', "initialize: leave\n")
        return

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            if path.exists(self.cfg['sru']):
                with open(self.cfg['sru'], 'r') as f:
                    sru = json.load(f)

            print '||'
            print '|| Current Kernel versions are always available here: http://people.canonical.com/~kernel/reports/versions.html'
            print '||'

            tformat = ((42, LEFT), (20, LEFT), (20, LEFT), (4, RIGHT), (8, RIGHT), (8, RIGHT))
            rows = []
            # Headers
            rows.append(('Package', 'Upd/Sec', 'Proposed', 'TiP', 'Verified', 'Reverted'))
            rows.append((' ', ' ', ' ', ' ', ' ', ' '))
            for rls in sorted(sru['releases'].keys()):
                rdict = sru['releases'][rls]
                self.dbg("core", "release: '%s'\n" % (rls))
                if (len(rdict) == 0):
                    continue
                rlsname = rls
                for pkg in rdict.keys():
                    rowt = []
                    try:
                        release = rdict[pkg]['Release']
                    except KeyError:
                        release = ' '
                    total_bugs = 0
                    verified_bugs = 0
                    reverted_bugs = 0
                    self.dbg("core", "    package: '%s'\n" % (pkg))
                    rlstext =  '%s %s' % (align(rlsname, 8), pkg)
                    # after first one for a release, change the formatting
                    rlsname = "---"
                    # first column - release
                    rowt.append(rlstext)
                    try:
                        proposed = rdict[pkg]['Proposed']
                    except KeyError:
                        proposed = ' '
                    update = rdict[pkg]['Updates']
                    rowt.append(update)
                    rowt.append(proposed)
                    if 'bugs' in rdict[pkg]:
                        for bug in rdict[pkg]['bugs'].keys():
                            self.dbg("core", "        bug: '%s'\n" % (bug))
                            state = rdict[pkg]['bugs'][bug]['state']
                            if state == 'needed':
                                total_bugs = total_bugs + 1
                            elif state == 'verified':
                                total_bugs = total_bugs + 1
                                verified_bugs = verified_bugs + 1
                            elif state == 'reverted':
                                total_bugs = total_bugs + 1
                                reverted_bugs = reverted_bugs + 1
                        rowt.append(str(total_bugs))
                        rowt.append(str(verified_bugs))
                        rowt.append(str(reverted_bugs))
                    else:
                        rowt.append(' ')
                        rowt.append(' ')
                        rowt.append(' ')
                    rows.append(rowt)
                #rows.append((' ', ' ', ' ', ' ', ' ', ' '))

            print FormatTable(tformat, rows, retain_newlines=True)
            print '||'

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

if __name__ == '__main__':
    app = GenerateMeetingStatus()
    app.main()

# vi:set ts=4 sw=4 expandtab:

