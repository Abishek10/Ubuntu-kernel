#!/usr/bin/env python
#

from sys                                import argv
#from getopt                             import getopt, GetoptError
from ktl.utils                          import stdo, error, run_command, eout
#from ktl.std_app                        import StdApp
from ktl.git                            import Git, GitError
#from re                                 import compile, IGNORECASE, MULTILINE
#from commands                           import getstatusoutput
#from ktl.kernel                         import Kernel
from os                                 import path #, mkdir, remove, rename, getenv
#from shutil                             import move
#from tempfile                           import NamedTemporaryFile

if len(argv) < 3:
    print "Usage:\n"
    print "%s <last upstream tag> <list of patch files>\n" % argv[0]
    print "will compare the patch files with the git repository you are currently in,"
    print "back to the tag specified, and attempt to list those already applied\n"

last_tag = argv[1]
file_list = argv[3:]

Git = Git

# Make sure we're in a git repo
if not Git.is_repo():
    eout("\nThis only works if you're in a git repo")

gitcmd = "git log --pretty=format:%%f %s.." % (last_tag)
status, commitlist = run_command(gitcmd, dbg=False)
if status:
    eout("error while running git command:\n%s\n" % gitcmd)

hits = []
for fn in file_list:
    patch_name = path.basename(fn).split(".")[0][5:]
    for commit in commitlist:
        if commit.startswith(patch_name):
            hits.append(fn)

if len(hits) > 0:
    print "The following commits may already be in your tree:\n"
    for fn in hits:
        print fn

#
# take a path to a directory full of patches
#

#
# For each patch in that directory
#
#    See whether it's already applied to the current tree
#
#
#
#
#
#


#
# 
#

#
# 
#

#
# 
#

#
# 
#

#
# 
#

#
# 
#

#
# 
#
