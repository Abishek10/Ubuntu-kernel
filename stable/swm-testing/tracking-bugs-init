#!/usr/bin/env python
#
# release tracking bug testing
#
# init
#
# Using the packages that are currently in the kernel team ppa, create tracking
# bugs for each of those packages in the staging LP server.
#

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, INFO, DEBUG
import json

from lpltk.LaunchpadService             import LaunchpadService

from ktl.tracking_bug                   import TrackingBug
from ktl.workflow                       import Workflow
from ktl.kernel_bug                     import KernelBug
from ktl.bugs                           import Bugs
from ktl.ubuntu                         import Ubuntu

from sb.log                             import cinfo, cwarn, cdebug

def results(label, result):
    cinfo('%40s: %s' % (label, result))

# TrackingBugsTester
#
class TrackingBugsTester():
    # __init__
    #
    def __init__(s, args):
        s.defaults = {}
        s.defaults['launchpad_client_name'] = 'kernel-team-smoker'
        s.production = LaunchpadService(s.defaults)  # Some things are only available on the production

        s.defaults['launchpad_services_root'] = 'qastaging'  # All testing is done using the qastaging LP service
        s.staging = LaunchpadService(s.defaults)
        s.args = args
        s.wf = Workflow()
        s.tracker = TrackingBug(s.staging, True, True)
        s.__kernel_test_versions = None

    @property
    def kernel_versions(s):
        if s.__kernel_test_versions is None:
            lp = s.production.launchpad
            person = lp.people['canonical-kernel-team']
            ppa = person.getPPAByName(name='ppa')

            s.__kernel_test_versions = []
            for astatus in ['Pending', 'Published']:
                psrc = ppa.getPublishedSources(status=astatus)
                for p in  psrc:
                    if p.source_package_name == 'linux':
                        if '3.8.0' in p.source_package_version:
                            s.__kernel_test_versions.append(p.source_package_version)
                            continue

        return s.__kernel_test_versions

    # Test
    #
    def Test(s):
        # The testing as all sru-workflow work is centered around release tracking bugs. The
        # first thing we need to do is create release tracking bugs for each of the series.
        #
        # Using the packages that currently exist in the canonical-kernel-team/ppa create
        # new tracking bugs for those packages. By using the existing packages and creating
        # new tracking bugs we should be able to go through the entire kernel SRU cycle with
        # mostly-real data.
        #
        s.tracking_by_bugid = {}
        s.tracking_by_kernel_version = {}
        s.ref = {}

        project = 'linux'

        # Create the tracking bugs
        #
        cinfo('Creating the tracking bugs:')
        for version in s.kernel_versions:
            cinfo('    ' + version)
            series = Ubuntu().series_name(project, version)
            if series not in s.ref:
                s.ref[series] = {}

            bug = s.tracker.open(project, version, True, None, None)
            cinfo('        https://qastaging.launchpad.net/ubuntu/+source/linux/+bug/%s' % bug.id)

            kbug = KernelBug(bug)
            kbug_info = Bugs.bug_info(kbug, None)
            kbug_info['id'] = bug.id

            s.tracking_by_bugid[bug.id] = kbug_info
            s.tracking_by_kernel_version[version] = kbug_info

            if project in s.ref[series]:
                cwarn('        Already have a bug for this series/project (%s/%s)' % (series, project))
            s.ref[series][project] = kbug_info

            ## If this version/package has any derivative packages, create tracking
            ## bugs for them as well.
            ##
            #rec = Ubuntu().index_by_series_name[series]
            #try:
            #    for package in rec['derivative-packages'][project]:
            #        cdebug('       package: \'%s\'' % package)
            #        derivative = s.tracker.open(project, "[unknown at this time]", True, bug.id, series)
            #        kbug = KernelBug(derivative)
            #        kbug_info = Bugs.bug_info(kbug, None)
            #        kbug_info['id'] = derivative.id

            #        s.tracking_by_bugid[derivative.id] = kbug_info
            #        s.tracking_by_kernel_version[version] = kbug_info

            #        if package in s.ref[series]:
            #            cwarn('        Already have a bug for this series/package (%s/%s)' % (series, package))
            #        s.ref[series][package] = kbug_info
            #except KeyError:
            #    pass

class Smokem():

    # __init__
    #
    def __init__(s, args):
        s.args = args

    def main(s):
        TrackingBugsTester(args).Test()

# RTBT_Init
#
class RTBT_Init():
    '''
    This class is just the engine that makes everything go.
    '''

    # __init__
    #
    def __init__(s, args):
        '''
        '''
        s.args = args

    # main
    #
    def main(s):
        '''
        '''
        retval = 1

        try:
            Smokem(s.args).main()
            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            cwarn("Aborting ...")

        return retval

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
    '''
    app_epilog = '''
examples:
    rtbt-init --help
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug',        action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.debug:
        basicConfig(level=DEBUG, format=log_format)
    else:
        basicConfig(level=INFO, format=log_format)

    app = RTBT_Init(args)
    exit(app.main())


# vi:set ts=4 sw=4 expandtab:

