#!/usr/bin/env python
#
# Collect Bug Data (CBD)
#

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, INFO, DEBUG

from ktl.utils                          import error
from ktl.bugs                           import Bugs
from ktl.kernel_bug                     import KernelBug
from ktl.utils                          import date_to_string
from ktl.workflow                       import Properties
from lpltk.LaunchpadService             import LaunchpadService
from datetime                           import datetime, timedelta
import json
import re
from sb.log                             import cinfo, cwarn, cdebug

# NoMatch
#
class NoMatch(Exception):
    '''
    '''
    def __init__(s, emsg):
        s.__message = emsg

    @property
    def message(s):
        '''
        '''
        return s.__message

# TheApp
#
class TheApp():
    # __init__
    #
    def __init__(s, args):
        '''
        '''
        s.args = args
        s.defaults = {}
        s.cfg = {}
        s.cfg['verbose'] = True

        #                              .- package name (group(1))
        #                             /           .- kernel version (group(2))
        #                            /           /          .- version/abi separator (group(3))
        #                           /           /          /
        s.ver_rc   = re.compile("(\S+): (\d+\.\d+\.\d+)([-\.])(\d+)\.(\d+)([~a-z\d]*)")
        #                                                       /      /       /
        #                                                      /      /       .- backport extra (m.group(6))
        #                                                     /      .- upload number (m.group(5))
        #                                                    .- abi (group(4))

        s.alt_rc   = re.compile("(\S+): <version to be filled>*")

    # __initialize
    #
    # A separate initialize that we can control when it gets called (not
    # when the object is instantiated).
    #
    def __initialize(s):
        s.cfg = {}
        s.cfg['launchpad_client_name'] = 'tracking-bugs-modify'
        s.cfg['launchpad_services_root'] = 'qastaging'
        cdebug(" . Connecting to Launchpad")
        s.lp = LaunchpadService(s.cfg)

        # The service.distributions property is a collection of distributions. We
        # pretty much only care about one, 'ubuntu'.
        #
        s.distro = s.lp.distributions['ubuntu']
        return

    # __get_relevant_task
    #
    def __get_relevant_task(s, bug, pkg):
        retval = None
        for t in bug.tasks:
            task       = t.bug_target_name
            p = task.replace(' (Ubuntu)', '')
            if pkg == p:
                retval = t
                break
        return retval

    # __verbose_bug_info
    #
    def __verbose_bug_info(s, bug):
        print(" ")
        print("    %s: %s" % (bug.id, bug.title))
        print(" ")

        tags = ""
        for t in bug.tags:
            tags += t
            tags += " "
        print("        Tags:")
        print("            %s" % (tags))

        tasks = bug.tasks
        print("        Tasks:")
        for task in tasks:
            print("            %45s %20s %20s" % (task.bug_target_name, task.status, task.importance))

    # date_to_string
    #
    def date_to_string(s, date):
        return date.strftime("%A, %d. %B %Y %H:%M UTC")

    # string_to_date
    #
    def string_to_date(s, date):
        return datetime.strptime(date, '%A, %d. %B %Y %H:%M UTC')

    # bug_needs_attention
    #
    def bug_needs_attention(s, bug, package, db):
        retval = False

        if bug.id in db['bug-collections'][package]['bugs']:
            retval = True
        else:
            retval = False

        return retval

    def find_match(s, ref, data):
        bug = None
        for bid in data:
            if data[bid]['series name'] == ref['series name']:
                ref_package = s.package(ref)
                comp_package = s.package(data[bid])
                cdebug('ref: %s; data: %s' % (ref_package, comp_package))
                if ref_package == comp_package:
                    bug = data[bid]
                    break

        if bug is None:
            raise NoMatch(ref['title'])

        return bid, bug

    def package(s, bug):
        package = None
        m = s.ver_rc.search(bug['title'])
        if m:
            package = m.group(1)
        else:
            m = s.alt_rc.search(bug['title'])
            package = m.group(1)
        return package

    # main
    #
    def main(s):
        using_search_since = False
        try:
            # The dictionary of changes to be made to workflow bugs.
            #
            with open(s.args.changes, 'r') as f:
                changes = json.load(f)

            #-------------------------------------------------------------------------------------------
            # Get the information about all the workflow bugs. This information compared to
            # the 'poke' data will allow us to find the bug id for the bugs we want to
            # 'poke'/modify.
            #
            s.__initialize()
            now = datetime.utcnow()

            bugs = {}

            projects_of_interest   = [ "kernel-sru-workflow", "kernel-development-workflow" ]
            search_status          = ["New","Incomplete","Confirmed","Triaged","In Progress"] # A list of the bug statuses that we care about
            search_tags_combinator = "Any"

            for project in projects_of_interest:
                try:
                    lp_project = s.lp.projects[project]
                except KeyError:
                    error("The project (%s) does not exist." % project)
                    raise

                cdebug('%s (%s)' % (project, lp_project.name))

                try:
                    tasks = lp_project.search_tasks(status=search_status)

                    this_package_bugs = None
                    for task in tasks:
                        bug = KernelBug(task.bug)
                        primary_task = s.__get_relevant_task(bug, lp_project.name)
                        #s.__verbose_bug_info(bug)

                        bugs[bug.id] = Bugs.bug_info(bug, now, primary_task)

                except:
                    error("Exception caught processing the tasks, building the bugs database.\n")
                    raise

            #-------------------------------------------------------------------------------------------
            # Find the bug ids of the bugs that are to be modified and make the
            # changes.
            #
            for change in changes:
                bid, data = s.find_match(change, bugs)
                cinfo('https://%s.launchpad.net/ubuntu/+source/linux/+bug/%s - %s' % (s.lp.config['launchpad_services_root'], bid, data['title']))
                bug = KernelBug(s.lp.get_bug(bid))

                if 'tasks' in change:
                    for ctask in change['tasks']:
                        ct_name = ctask['target-name']

                        for btask in bug.tasks:
                            if ct_name == btask.bug_target_name:
                                # Found the task we want to modify
                                #
                                if 'status' in ctask:
                                    btask.status = ctask['status']

                if 'ops' in change:
                    for op in change['ops']:
                        if op == 'p2p_advance_timestamp':
                            # Retreat the promote-to-proposed-end property by 1 hour
                            #
                            tstamp_prop = 'kernel-stable-Promote-to-proposed-end'
                            date_str = bug.properties[tstamp_prop]
                            timestamp = datetime.strptime(date_str, '%A, %d. %B %Y %H:%M UTC')
                            ts = timestamp + timedelta(0, ((1 * 60 * 60) + (5 * 60)) * -1)
                            properties = Properties(bug)
                            properties.set({tstamp_prop:date_to_string(ts)})
                            properties.flush()

                if 'tags' in change:
                    for tag in change['tags']:
                        bug.tags.append(str(tag))

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            print("Keyboard interrupt")
            pass

        return

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
    '''
    app_epilog = '''
examples:
    rtb-snapshot snap1.json
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug',        action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('changes',   metavar='changes',   type=str, help='The file name of bug information that is to be modified.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.debug:
        basicConfig(level=DEBUG, format=log_format)
    else:
        basicConfig(level=INFO, format=log_format)

    app = TheApp(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab:
