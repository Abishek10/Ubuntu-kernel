#!/usr/bin/env python
#
# Executes a set of tests to verify that certain scripts and
# libraries are still working properly.
#

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, INFO, DEBUG
import json
import re
from os                                 import getenv

from lpltk.LaunchpadService             import LaunchpadService

from ktl.tracking_bug                   import TrackingBug
from ktl.workflow                       import Workflow
from ktl.ubuntu                         import Ubuntu

from sb.log                             import cinfo, cwarn, cdebug, cerror

def results(label, *args):
    if args[0]:
        cdebug('%40s: %s' % (label, args[0]))
    else:
        cerror('%40s: %s  [expected: %s, found: %s]' % (label, args[0], args[1], args[2]))

# NoMatch
#
class NoMatch(Exception):
    '''
    '''
    def __init__(s, emsg):
        s.__message = emsg

    @property
    def message(s):
        '''
        '''
        return s.__message

# TBCompare
#
class TBCompare():
    # __init__
    #
    def __init__(s, args):
        s.cfg = {}
        s.cfg['launchpad_client_name'] = 'kernel-team-smoker'
        s.production = LaunchpadService(s.cfg)  # Some things are only available on the production

        s.cfg['launchpad_services_root'] = getenv('LP_SERVICE', 'qastaging')
        s.staging = LaunchpadService(s.cfg)
        s.args = args
        s.wf = Workflow()
        s.tracker = TrackingBug(s.staging, True, True)
        s.__kernel_test_versions = None
        s.errors = 0

        #                              .- package name (group(1))
        #                             /           .- kernel version (group(2))
        #                            /           /          .- version/abi separator (group(3))
        #                           /           /          /
        s.ver_rc   = re.compile("(\S+): (\d+\.\d+\.\d+)([-\.])(\d+)\.(\d+)([~a-z\d]*)")
        #                                                       /      /       /
        #                                                      /      /       .- backport extra (m.group(6))
        #                                                     /      .- upload number (m.group(5))
        #                                                    .- abi (group(4))

        s.alt_rc   = re.compile("(\S+): <version to be filled>*")


    # workflow_project
    #
    def workflow_project(s, series):
        '''
        Given the series, return either 'Kernel SRU Workflow' or 'Kernel Development Workflow'.
        '''
        if Ubuntu().is_development_series(series):
            workflow_task = 'Kernel Development Workflow'
            workflow_project = 'kernel-development-workflow'
        else:
            workflow_task = 'Kernel SRU Workflow'
            workflow_project = 'kernel-sru-workflow'

        return workflow_project

    # verify_task
    #
    def verify_task(s, bug_info, expected_task, expected_status, expected_assignee, series):
        verified = False
        task_found = False
        expected = None
        actual = None
        for task in bug_info['tasks']:
            actual = task['target-name'].replace('%s/' % s.workflow_project(series), '')
            if actual == '':
                actual = task['target-name']

            if expected_task == actual:
                task_found = True
                if expected_status == task['status']:
                    if expected_assignee == task['assignee-name']:
                        verified = True
                    else:
                        expected = expected_assignee
                        actual = task['assignee-name']
                else:
                    expected = expected_status
                    actual = task['status']
                break

        if not task_found:
            expected = expected_task

        if not verified:
            s.errors += 1

        return verified, expected, actual

    # verify_workflow_task
    #
    def verify_workflow_task(s, bug_info, series):
        '''
        We support two kinds of SRU Workflow bugs, one for SRU kernels and one
        for development kernels. Based on the series, verify that this bug
        has the correct workflow task.
        '''
        results('Verify correct workflow task', *s.verify_task(bug_info, s.workflow_project(series), 'In Progress', 'unassigned', series))

    # verify_package_task
    #
    def verify_package_task(s, bug_info, package, series):
        '''
        In addition to the kernel workflow project, each tracking bug also has
        a task for the package and a nomination for the series.
        '''
        if package == 'linux':
            expected_status = 'Invalid'
        else:
            expected_status = 'New'
        results('Verify correct package task', *s.verify_task(bug_info, '%s (Ubuntu)' % package, expected_status, 'unassigned', series))
        results('Verify nomination for package task', *s.verify_task(bug_info, '%s (Ubuntu %s)' % (package, series.title()), 'New', 'unassigned', series))

    # verify_sru_tasks
    #
    def verify_sru_tasks(s, reference, bug_info, package, series):
        '''
        '''
        cdebug('verify_sru_tasks enter')

        cdebug('    tasks:')
        for t in reference['tasks']:
            task = t['target-name'].replace('%s/' % s.workflow_project(series), '')
            expected_status = t['status'] 
            expected_assignee = t['assignee-name']
            if expected_assignee is None:
                expected_assignee = 'unassigned'
                expected_status = 'Invalid'
            results('Verify %s task' % task, *s.verify_task(bug_info, task, expected_status, expected_assignee, series))

        cdebug('verify_sru_tasks leave')

    @property
    def kernel_versions(s):
        if s.__kernel_test_versions is None:
            lp = s.staging.launchpad
            person = lp.people['canonical-kernel-team']
            ppa = person.getPPAByName(name='ppa')

            s.__kernel_test_versions = []
            for astatus in ['Pending', 'Published']:
                psrc = ppa.getPublishedSources(status=astatus)
                for p in  psrc:
                    if p.source_package_name == 'linux':
                        s.__kernel_test_versions.append(p.source_package_version)
                        continue

        return s.__kernel_test_versions

    def find_match(s, ref, data):
        bug = None
        for bid in data:
            if data[bid]['series name'] == ref['series name']:
                ref_package = s.package(ref)
                comp_package = s.package(data[bid])
                cdebug('ref: %s; data: %s' % (ref_package, comp_package))
                if ref_package == comp_package:
                    bug = data[bid]
                    break

        if bug is None:
            raise NoMatch(ref['title'])

        return bid, bug

    def package(s, bug):
        package = None
        m = s.ver_rc.search(bug['title'])
        if m:
            package = m.group(1)
        else:
            m = s.alt_rc.search(bug['title'])
            package = m.group(1)
        return package

    # main
    #
    def main(s):
        # Reference data
        #
        with open(s.args.ref, 'r') as f:
            reference = json.load(f)

        # Comparison data
        #
        with open(s.args.comp, 'r') as f:
            comparison = json.load(f)

        for x in reference:
            package = None
            series = None
            data = None
            bid = None

            try:
                package = s.package(reference[x])
                bid, data = s.find_match(reference[x], comparison)
                series = data['series name']

                cdebug('https://%s.launchpad.net/ubuntu/+source/linux/+bug/%s - %s' % (s.cfg['launchpad_services_root'], bid, comparison[bid]['title']))
                cdebug('    %s' % series)
                s.verify_workflow_task(data, series)
                s.verify_package_task(data, package, series)
                s.verify_sru_tasks(reference[x], data, package, series)

            except KeyError:
                cerror('The comparison data does not contain information about bug #%s' % x)

            except NoMatch as e:
                cerror('Did not find a matching bug for: %s' % e.message)

        return s.errors

# TheApp
#
class TheApp():
    '''
    This class is just the engine that makes everything go.
    '''

    # __init__
    #
    def __init__(s, args):
        '''
        '''
        s.args = args

    # main
    #
    def main(s):
        '''
        '''
        retval = 1

        try:
            retval = TBCompare(s.args).main()

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            cwarn("Aborting ...")

        return retval

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I'm a application skeleton, your job is to make me into something useful.
    '''
    app_epilog = '''
examples:
    Smokem --help
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug',        action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('ref',   metavar='ref',   type=str, help='The file name of the reference data.')
    parser.add_argument('comp',  metavar='comp',  type=str, help='The file name of the data to be compared against the reference data.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.debug:
        basicConfig(level=DEBUG, format=log_format)
    else:
        basicConfig(level=INFO, format=log_format)

    app = TheApp(args)
    exit(app.main())


# vi:set ts=4 sw=4 expandtab:

