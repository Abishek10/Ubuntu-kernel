#!/usr/bin/env python
#
# Collect Bug Data (CBD)
#

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, INFO, DEBUG

from ktl.utils                          import error
from ktl.bugs                           import Bugs
from ktl.kernel_bug                     import KernelBug
from lpltk.LaunchpadService             import LaunchpadService
from datetime                           import datetime
from ktl.ubuntu                         import Ubuntu
import json
from sb.log                             import cinfo, cwarn, cdebug

# TheApp
#
class TheApp():
    # __init__
    #
    def __init__(s, args):
        '''
        '''
        s.args = args
        s.defaults = {}
        s.cfg = {}
        s.cfg['verbose'] = True

    # __initialize
    #
    # A separate initialize that we can control when it gets called (not
    # when the object is instantiated).
    #
    def __initialize(s):
        s.cfg = {}
        s.cfg['read_only'] = True
        s.cfg['launchpad_client_name'] = 'kernel-team-bjf-collect-bug-data'
        s.cfg['launchpad_services_root'] = 'qastaging'
        cdebug(" . Connecting to Launchpad")
        s.lp = LaunchpadService(s.cfg)

        # The service.distributions property is a collection of distributions. We
        # pretty much only care about one, 'ubuntu'.
        #
        s.distro = s.lp.distributions['ubuntu']
        return

    # __get_relevant_task
    #
    def __get_relevant_task(s, bug, pkg):
        retval = None
        for t in bug.tasks:
            task       = t.bug_target_name
            p = task.replace(' (Ubuntu)', '')
            if pkg == p:
                retval = t
                break
        return retval

    # __verbose_bug_info
    #
    def __verbose_bug_info(s, bug):
        print(" ")
        print("    %s: %s" % (bug.id, bug.title))
        print(" ")

        tags = ""
        for t in bug.tags:
            tags += t
            tags += " "
        print("        Tags:")
        print("            %s" % (tags))

        tasks = bug.tasks
        print("        Tasks:")
        for task in tasks:
            print("            %45s %20s %20s" % (task.bug_target_name, task.status, task.importance))

    # date_to_string
    #
    def date_to_string(s, date):
        return date.strftime("%A, %d. %B %Y %H:%M UTC")

    # string_to_date
    #
    def string_to_date(s, date):
        return datetime.strptime(date, '%A, %d. %B %Y %H:%M UTC')

    # bug_needs_attention
    #
    def bug_needs_attention(s, bug, package, db):
        retval = False

        if bug.id in db['bug-collections'][package]['bugs']:
            retval = True
        else:
            retval = False

        return retval

    # main
    #
    def main(s):
        using_search_since = False
        try:
            s.__initialize()
            now = datetime.utcnow()

            bugs = {}

            #-------------------------------------------------------------------------------------------
            #
            projects_of_interest   = [ "kernel-sru-workflow", "kernel-development-workflow" ]
            search_status          = ["New","Incomplete","Confirmed","Triaged","In Progress"] # A list of the bug statuses that we care about
            search_tags_combinator = "Any"

            for project in projects_of_interest:
                try:
                    lp_project = s.lp.projects[project]
                except KeyError:
                    error("The project (%s) does not exist." % project)
                    raise

                cdebug('%s (%s)' % (project, lp_project.name))

                try:
                    tasks = lp_project.search_tasks(status=search_status)

                    this_package_bugs = None
                    for task in tasks:
                        bug = KernelBug(task.bug)
                        if s.args.list:
                            cinfo('        https://qastaging.launchpad.net/ubuntu/+source/linux/+bug/%s' % bug.id)
                        else:
                            primary_task = s.__get_relevant_task(bug, lp_project.name)
                            #s.__verbose_bug_info(bug)

                            bugs[bug.id] = Bugs.bug_info(bug, now, primary_task)

                except:
                    error("Exception caught processing the tasks, building the bugs database.\n")
                    raise

            if not s.args.list:
                with open(s.args.out, 'w') as f:
                    f.write(json.dumps(bugs, sort_keys=True, indent=4))

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            print("Keyboard interrupt")
            pass

        return

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
    '''
    app_epilog = '''
examples:
    rtb-snapshot snap1.json
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug',        action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--list',         action='store_true', default=False, help='Just produce a list of the tracking bugs.')
    parser.add_argument('out',   metavar='out',   type=str, nargs='?', help='The file name of the collected data.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.debug:
        basicConfig(level=DEBUG, format=log_format)
    else:
        basicConfig(level=INFO, format=log_format)

    app = TheApp(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab:
