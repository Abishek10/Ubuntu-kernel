#!/usr/bin/env python
#

from sys                                import argv
from getopt                             import getopt, GetoptError
from ktl.utils                          import stdo, error
from ktl.std_app                        import StdApp
from lpltk.LaunchpadService             import LaunchpadService
from ktl.ubuntu                         import Ubuntu
import sys, os, re
common_lib = os.path.dirname(os.path.abspath(sys.argv[0]))
common_lib = os.path.dirname(common_lib)
common_lib = os.path.join(common_lib, "lib")
sys.path.insert(0, common_lib)
from buildenv_lib                       import GetUploadVersion

# This script check for component mismatches using the launchpad api

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
class Cmdline:
    """
    Handle all the command line processing for the application.
    """
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        """
        Simple helper which prints out an error message and then prints out the usage.
        """
        if e != '': error(e)
        self.usage(defaults)

    # usage
    #
    def usage(self, defaults):
        """
        Prints out the help text which explains the command line options.
        """
        stdo("    Usage:                                                                                   \n")
        stdo("        %s <series> <source package>                                                         \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --staging                                                                            \n")
        stdo("                         Use the staging LP service instead of the production one.           \n")
        stdo("                                                                                             \n")
        stdo("        --pocket=<pocket>                                                                    \n")
        stdo("                         Use the specified pocket instead of the default (proposed)          \n")
        stdo("                                                                                             \n")
        stdo("        --package_version=<version>                                                          \n")
        stdo("                         Don't use the latest version from the archive, use the specified    \n")
        stdo("                         package version                                                     \n")
        stdo("                                                                                             \n")
        stdo("        --list                                                                               \n")
        stdo("                         Just list the component where the packages are in, don't do any     \n")
        stdo("                         mismatch check                                                      \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s oneiric linux                                                                     \n" % self.cfg['app_name'])

    # process
    #
    def process(self, argv, defaults):
        """
        This method is responsible for calling the getopt function to process the command
        line. All parameters are processed into class variables for use by other methods.
        """
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'staging', 'pocket=', 'package_version=',
                         'list']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--staging'):
                    self.cfg['staging'] = True

                elif opt in '--pocket':
                    self.cfg['pocket'] = val

                elif opt in '--package_version':
                    self.cfg['package_version'] = val

                elif opt in '--list':
                    self.cfg['list'] = True

            if len(args) < 2:
                raise CmdlineError('Missing series and/or package arguments')
            self.cfg['series'] = args[0]
            self.cfg['package'] = args[1]

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        """
        Used to verify that all required parameters are present and correct.
        """
        return


# CheckComponent
#
class CheckComponent(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

    # initialize
    #
    def initialize(self):
        """
        A separate initialize that we can control when it gets called (not
        when the object is instantiated).
        """
        self.defaults['launchpad_client_name'] = 'kernel-team-check-component'
        if 'staging' in self.cfg:
            self.defaults['launchpad_services_root'] = 'qastaging'
        self.defaults['pocket'] = 'proposed'
        self.lp = LaunchpadService(self.defaults)
        self.ubuntu = Ubuntu()
        self.override_db = { 'hardy': {
                               'linux-meta' : {
                                 'linux-restricted-modules-server' : 'restricted'
                               }
                             }
                           }
        self.release_db = {}
        self.abi_db = {}
        return

    def load_release_components(self, series, package):
        ubuntu = self.lp.launchpad.distributions["ubuntu"]
        archive = ubuntu.main_archive
        lp_series = ubuntu.getSeries(name_or_version=series)
        rel_ver = GetUploadVersion(series, package, pocket="release")
        if rel_ver:
            pkg_rel = archive.getPublishedSources(exact_match=True,
                        source_name=package,
                        distro_series=lp_series,
                        pocket='Release',
                        version=rel_ver)
            if pkg_rel:
                src_pkg = pkg_rel[0]
                self.release_db[package] = {}
                self.release_db[package][None] = src_pkg.component_name
                for bin_pkg in src_pkg.getPublishedBinaries():
                    bname = bin_pkg.binary_package_name
                    bcomponent = bin_pkg.component_name
                    self.release_db[package][bname] = bcomponent
        return

    def default_component(self, dcomponent, series, package, bin_pkg):
        if not self.release_db:
            self.load_release_components(series, package)
        if package in self.release_db:
            if bin_pkg in self.release_db[package]:
                return self.release_db[package][bin_pkg]
        return dcomponent

    def override_component(self, dcomponent, series, package, bin_pkg):
        if series in self.override_db:
            if package in self.override_db[series]:
                if bin_pkg in self.override_db[series][package]:
                    return self.override_db[series][package][bin_pkg]
        if series != 'hardy' and package == 'linux-meta':
            if (bin_pkg and bin_pkg.startswith('linux-backports-modules-') and
                (not bin_pkg.endswith('-preempt'))):
                return 'main'
        if package.startswith('linux-backports-modules-'):
            dcomponent = 'main'
        return self.default_component(dcomponent, series, package, bin_pkg)

    def main_component(self, dcomponent, series, package, bin_pkg):
        return 'main'

    def name_abi_transform(self, name):
        if not name:
            return name
        abi = re.findall('([0-9]+\.[^ ]+)', name)
        if abi:
            abi = abi[0]
            abi = abi.split('-')
            if len(abi) >= 2:
                abi = abi[1]
            else:
                abi = None
            if abi:
                version = re.findall('([0-9]+\.[^-]+)', name)
                if version:
                    version = version[0]
                    name = name.replace('%s-%s' % (version, abi),
                                        '%s-ABI' % version)
        return name

    def linux_abi_component(self, dcomponent, series, package, bpkg):
        if package in self.abi_db:
            mpkg = self.name_abi_transform(bpkg)
            if mpkg in self.abi_db[package]:
                return self.abi_db[package][mpkg]
            else:
                return 'universe'

        ubuntu = self.lp.launchpad.distributions["ubuntu"]
        archive = ubuntu.main_archive
        lp_series = ubuntu.getSeries(name_or_version=series)
        rel_ver = GetUploadVersion(series, package, pocket="release")
        if rel_ver:
            pkg_rel = archive.getPublishedSources(exact_match=True,
                        source_name=package,
                        distro_series=lp_series,
                        pocket='Release',
                        version=rel_ver)
            if pkg_rel:
                src_pkg = pkg_rel[0]
                self.abi_db[package] = {}
                self.abi_db[package][None] = src_pkg.component_name
                for bin_pkg in src_pkg.getPublishedBinaries():
                    bname = self.name_abi_transform(bin_pkg.binary_package_name)
                    self.abi_db[package][bname] = bin_pkg.component_name
            else:
                self.abi_db[package] = {}
        else:
            self.abi_db[package] = {}
        return self.linux_abi_component(dcomponent, series, package, bpkg)

    def component_function(self, series, package):
        if (package == 'linux'):
            if series in [ 'hardy', 'lucid' ]:
                return self.linux_abi_component
            return self.main_component
        if (package == 'linux-meta'):
            return self.override_component
        if package.startswith('linux-lts-backport-'):
            return self.main_component
        if package.startswith('linux-backports-modules-'):
            return self.override_component
        if package.startswith('linux-restricted-modules-'):
            return self.linux_abi_component
        return self.default_component

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.initialize()
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            series = self.cfg['series']
            package = self.cfg['package']
            pocket = self.cfg['pocket']
            ubuntu = self.lp.launchpad.distributions["ubuntu"]
            archive = ubuntu.main_archive
            lp_series = ubuntu.getSeries(name_or_version=series)

            # Get the components where the packages were officially
            # released, if we're checking components
            get_component = self.component_function(series, package)

            if not 'package_version' in self.cfg:
                pkg_ver = GetUploadVersion(series, package, pocket=pocket)
                if pkg_ver == None:
                    error("No upload of %s for %s is currently available in"
                          " the %s pocket" % (package, series, pocket))
                    sys.exit(1)
            else:
                pkg_ver = self.cfg['package_version']
            ps = archive.getPublishedSources(exact_match=True,
                                             source_name=package,
                                             distro_series=lp_series,
                                             pocket=pocket.title(),
                                             version=pkg_ver)
            if ps:
                src_pkg = ps[0]
                if not 'list' in self.cfg:
                    component = 'universe'
                    component = get_component('universe', series, package, None)
                    if src_pkg.component_name != component:
                        print("%s %s - is in %s instead of %s" % 
                              (src_pkg.source_package_name,
                               src_pkg.source_package_version,
                               src_pkg.component_name, component))
                    for bin_pkg in src_pkg.getPublishedBinaries():
                        component = 'universe'
                        pkg_name = bin_pkg.binary_package_name
                        component = get_component('universe', series, package,
                                                  pkg_name)
                        if bin_pkg.component_name != component:
                            print("%s %s - is in %s instead of %s" % 
                                  (bin_pkg.binary_package_name,
                                   bin_pkg.binary_package_version,
                                   bin_pkg.component_name, component))
                else:
                    print("%s %s - in %s" % (src_pkg.source_package_name,
                          src_pkg.source_package_version,
                          src_pkg.component_name))
                    for bin_pkg in src_pkg.getPublishedBinaries():
                        print("%s %s - in %s" % (bin_pkg.binary_package_name,
                              bin_pkg.binary_package_version,
                              bin_pkg.component_name))
            else:
                error("No results returned by getPublishedSources")
                sys.exit(1)

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

if __name__ == '__main__':
    app = CheckComponent()
    app.main()

# vi:set ts=4 sw=4 expandtab:

