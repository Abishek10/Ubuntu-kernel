#!/usr/bin/env python
#

from sys                                import argv
from getopt                             import getopt, GetoptError
from ktl.utils                          import stdo, dump, eout
from ktl.std_app                        import StdApp
from ktl.archive                        import Archive
from re                                 import compile

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>]                         \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --verbose        Give some feedback of what is happening while the script is         \n")
        stdo("                         running.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --config=<cfg file>                                                                  \n")
        stdo("                         The full path to the configuration file to use instead of           \n")
        stdo("                         the default location.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'config=', 'debug=']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        return

# AbiCheckError
#
class AbiCheckError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error


# AbiCheck
#
class AbiCheck(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}
        self.defaults['verbose'] = False
        self.version_rc      = compile("^([0-9]+\.[0-9]+\.[0-9]+[\.0-9]*)[-\.]([0-9]+)\.([0-9]+)([~\S]*)$")

        self.abi_deps = [
                #----------------------------------------------------------
                # Dapper
                {
                    'series'   : 'dapper',
                    'packages' :
                    [
                        'linux-source-2.6.15',
                        'linux-restricted-modules-2.6.15',
                        'linux-backports-modules-2.6.15'
                    ]
                },
                #----------------------------------------------------------
                # Hardy
                {
                    'series'   : 'hardy',
                    'packages' :
                    [
                        'linux',
                        'linux-restricted-modules-2.6.24',
                        'linux-backports-modules-2.6.24',
                        'linux-ubuntu-modules-2.6.24',
                        'linux-meta'
                    ]
                },
                #----------------------------------------------------------
                # Karmic
                {
                    'series'   : 'karmic',
                    'packages' :
                    [
                        'linux',
                        'linux-backports-modules-2.6.31',
                        'linux-meta',
                        'linux-ports-meta'
                    ]
                },
                {
                    'series'   : 'karmic',
                    'packages' :
                    [
                        'linux-ec2',
                        'linux-meta-ec2'
                    ]
                },
                {
                    'series'   : 'karmic',
                    'packages' :
                    [
                        'linux-fsl-imx51',
                        'linux-meta-fsl-imx51'
                    ]
                },
                {
                    'series'   : 'karmic',
                    'packages' :
                    [
                        'linux-mvl-dove',
                        'linux-meta-mvl-dove'
                    ]
                },
                #----------------------------------------------------------
                # Lucid
                {
                    'series'   : 'lucid',
                    'packages' :
                    [
                        'linux',
                        'linux-backports-modules-2.6.32',
                        'linux-meta',
                        'linux-ports-meta'
                    ]
                },
                {
                    'series'   : 'lucid',
                    'packages' :
                    [
                        'linux-ec2',
                        'linux-meta-ec2'
                    ]
                },
                {
                    'series'   : 'lucid',
                    'packages' :
                    [
                        'linux-fsl-imx51',
                        'linux-meta-fsl-imx51'
                    ]
                },
                {
                    'series'   : 'lucid',
                    'packages' :
                    [
                        'linux-mvl-dove',
                        'linux-meta-mvl-dove'
                    ]
                },
                {
                    'series'   : 'lucid',
                    'packages' :
                    [
                        'linux-lts-backport-maverick',
                        'linux-meta-lts-backport-maverick'
                    ]
                },
                #----------------------------------------------------------
                # Maverick
                {
                    'series'   : 'maverick',
                    'packages' :
                    [
                        'linux',
                        'linux-backports-modules-2.6.35',
                        'linux-meta',
                        'linux-ports-meta'
                    ]
                },
                {
                    'series'   : 'maverick',
                    'packages' :
                    [
                        'linux-ti-omap4',
                        'linux-meta-ti-omap4'
                    ]
                },
                {
                    'series'   : 'maverick',
                    'packages' :
                    [
                        'linux-mvl-dove',
                        'linux-meta-mvl-dove'
                    ]
                },
            ]

    # initialize
    #
    # A separate initialize that we can control when it gets called (not
    # when the object is instantiated).
    #
    def initialize(self):
        self.verbose(" . Fetching version data from the archive.")
        ar             = Archive()
        ar.archive_cache_lifetime = 60 * 60 * 4 # FIXME bjf - This is for development. 4 hours
        self.ppa       = ar.ppa_versions()
        self.dversions = ar.distro_versions()

        self.spam = {}   # Series Package Map
        for package in self.dversions:
            p = self.dversions[package]
            if p['series'] not in self.spam:
                self.spam[p['series']] = {}

            if p['source_package_name'] not in self.spam[p['series']]:
                self.spam[p['series']][p['source_package_name']] = {}

            self.spam[p['series']][p['source_package_name']][p['pocket']] = p['source_package_version']

        return

    def verbose(self, msg, newln=True):
        if 'verbose' in self.cfg and self.cfg['verbose']:
            stdo(msg)
            if newln:
                stdo('\n')

    # abi
    #
    # Given a version string, return the abi number.
    #
    def abi(self, version):
        retval = None
        m = self.version_rc.match(version)
        if m != None:
            retval = m.group(2)
        else:
            raise AbiCheckError("The version (%s) does not match the regular expression." % version)
        return retval

    # main
    #
    def main(self):
        cmdline = Cmdline()
        series = ""
        pkg    = ""
        failures = False
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            self.verbose(" . Checking ABIs for all packages in all series.")
            for index in self.abi_deps:
                series = index['series']
                self.verbose("     Series: %s" % series)
                v1 = None
                for pkg in index['packages']:

                    self.verbose("        %-34s" % pkg, False)
                    # If the package is in -proposed, grab the abi. All the packages must have the
                    # same abi. If the other packages are not in -proposed, there could be a version
                    # in -updates with the correct abi.
                    #
                    if v1 == None:
                        if 'Proposed' in self.spam[series][pkg]:
                            where = 'Proposed'
                            v1_version = self.spam[series][pkg][where]
                            v1 = self.abi(v1_version)
                        else:
                            where = 'Updates'
                            v1_version = self.spam[series][pkg][where]
                            v1 = self.abi(v1_version)
                        self.verbose(" %s, %s (%s)" % (where, v1_version, v1))

                    else:
                        if 'Proposed' in self.spam[series][pkg]:
                            where = 'Proposed'
                            v2_version = self.spam[series][pkg][where]
                            v2 = self.abi(v2_version)
                        else:
                            where = 'Updates'
                            v2_version = self.spam[series][pkg][where]
                            v2 = self.abi(v2_version)
                        self.verbose(" %s, %s (%s)" % (where, v2_version, v2))

                        if v1 != v2:
                            failures = True
                            print("    Abi mismatch: %s %s; %s != %s" % (series, pkg, v1, v2))
                            print("          v1 version: %s" % v1_version)
                            print("              v1 abi: %s" % v1)
                            print("          v2 version: %s" % v2_version)
                            print("              v2 abi: %s" % v2)

            if not failures:
                print("All package ABIs appear to be in sync at this time.\n")
            print("That's all Folks!")

        except AbiCheckError as e:
            eout(e.msg)

        except KeyError:
            print("KeyError Exception")
            print("    %s : %s" % (series, pkg))
            dump(self.spam[series][pkg])
            raise

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

if __name__ == '__main__':
    app = AbiCheck()
    app.main()

# vi:set ts=4 sw=4 expandtab:

