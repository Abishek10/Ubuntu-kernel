#!/usr/bin/env python
#
# Sometimes when you are debugging a script that talks to LP, you want a way
# to dump out information about a bug and compare that with what you are
# getting yourself. This script can help in that way. It can also give you
# some ideas on how to use the lpltk library to talk to LP.
#

from sys                                import argv
from getopt                             import getopt, GetoptError
from ktl.utils                          import stdo, date_to_string
from ktl.std_app                        import StdApp
from ktl.kernel_bug                     import KernelBug
from lpltk.LaunchpadService             import LaunchpadService, LaunchpadServiceError
from re                                 import match
from datetime                           import datetime

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>]                         \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --verbose        Give some feedback of what is happening while the script is         \n")
        stdo("                         running.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --config=<cfg file>                                                                  \n")
        stdo("                         The full path to the configuration file to use instead of           \n")
        stdo("                         the default location.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'config=', 'debug=', 'staging']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

                elif (opt == '--staging'):
                    self.cfg['staging'] = True

            if result: # No errors yet

                # At lease one source package must be specified.
                #
                if len(args) > 0:
                    self.cfg['bugs'] = args

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        return


# BugInfo
#
class BugInfo(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

    # initialize
    #
    def initialize(self):
        if 'staging' in self.cfg:
            self.defaults['launchpad_services_root'] = 'qastaging'
        try:
            self.lp = LaunchpadService(self.defaults)
        except LaunchpadServiceError, e:
            print(e.msg)
            raise

        # The service.distributions property is a collection of distributions. We
        # pretty much only care about one, 'ubuntu'.
        #
        self.distro = self.lp.distributions['ubuntu']

    # __verbose_bug_info
    #
    def __print_bug_info(self, bug):
        print(" ")
        print("    %s: %s" % (bug.id, bug.title))
        print(" ")

        print("                 Owner: %s" % ("None" if bug.owner is None else bug.owner.display_name))

        print("               Created: %s" % (date_to_string(bug.date_created)))
        print("          Last Message: %s" % (date_to_string(bug.date_last_message)))
        print("          Last Updated: %s" % (date_to_string(bug.date_last_updated)))
        print("               Private: %s" % bug.private)
        print("              Security: %s" % bug.security_related)
        print("             Duplicate: %s" % bug.duplicate_of)
        print("                  Heat: %s" % bug.heat)
        print("          Latest Patch: %s" % (date_to_string(bug.date_latest_patch_uploaded)))
        print("          Is Expirable: %s" % bug.is_expirable())
        print("           Series Name: %s" % (bug.series[0]))
        print("        Series Version: %s" % (bug.series[1]))

        tags = ""
        for t in bug.tags:
            tags += t
            tags += " "
        print(" ")
        print("        Tags:")
        print("        -----------------------------------------------------------------------------------")
        print("            %s" % (tags))

        print(" ")
        print("        Nominations:")
        print("        -----------------------------------------------------------------------------------")
        nominations = bug.nominations
        print("                       Number: %d" % len(nominations))
        print(" ")
        for nomination in nominations:
            print("                       Target: %s" % (nomination.target.name))
            print("                       Status: %s" % (nomination.status))

            ds = nomination.distro_series
            if ds is None:
                print("                Distro Series: None")
            else:
                print("                Distro Series: %s" % (ds.name))
                print("                       Active: %s" % (ds.active))
                print("                    Supported: %s" % (ds.supported))
            print("               Product Series: %s" % ("None" if nomination.product_series is None else nomination.product_series.name))
            print("                      Created: %s" % (date_to_string(nomination.date_created)))
            print("                      Decided: %s" % (date_to_string(nomination.date_decided)))
            print(" ")

        tasks = bug.tasks
        print(" ")
        print("        Tasks:")
        print("        -----------------------------------------------------------------------------------")
        #print("                                           Task  Status                Importance            Assignee")
        #print("          -------------------------------------  --------------------  --------------------  -----------------------")
        #for task in tasks:
        #    assignee = task.assignee
        #    if assignee is None:
        #        assignee = "Unknown"
        #    else:
        #        assignee = assignee.display_name
        #    print("  %45s  %-20s  %-20s  %-s" % (task.bug_target_name, task.status, task.importance, assignee))
        for task in tasks:
            assignee = task.assignee
            if assignee is None:
                assignee = "Unknown"
            else:
                assignee = assignee.display_name
            print("            %s (%s)" % (task.bug_target_name, task.bug_target_display_name))
            print("                       Status: %-20s  Importance: %-20s  Assignee: %-s" % (task.status, task.importance, assignee))
            print("                      Created: %s" % (date_to_string(task.date_created)))
            print("                    Confirmed: %s" % (date_to_string(task.date_confirmed)))
            print("                     Assigned: %s" % (date_to_string(task.date_assigned)))
            print("                       Closed: %s" % (date_to_string(task.date_closed)))
            print("                Fix Committed: %s" % (date_to_string(task.date_fix_committed)))
            print("                 Fix Released: %s" % (date_to_string(task.date_fix_released)))
            print("                  In Progress: %s" % (date_to_string(task.date_in_progress)))
            print("                   Incomplete: %s" % (date_to_string(task.date_incomplete)))
            print("                  Left Closed: %s" % (date_to_string(task.date_left_closed)))
            print("                     Left New: %s" % (date_to_string(task.date_left_new)))
            print("                      Triaged: %s" % (date_to_string(task.date_triaged)))
            print("                  Is Complete: %s" % (task.is_complete))
            print("                        Owner: %s" % (task.owner.display_name))
            print("                        Title: %s" % (task.title))
            print("                       Target: %s" % (task.target))
            print("                   Watch Link: %s" % (task.bug_watch))

            milestone = task.milestone
            if milestone is not None:
                print("                    Milestone: %s" % (milestone.name))
            else:
                print("                    Milestone: None")

            print(" ")
            print("                Related Tasks:")
            print("                ---------------------------------------------------------------------------")
            if len(task.related_tasks) > 0:
                for related_task in task.related_tasks:
                    print("                    %s (%s)" % (related_task.bug_target_name, related_task.bug_target_display_name))
            else:
                print("                    None")

            #print("                        resource type: %s" % (task.resource_type))
            #print("                        web: %s" % (task.web))


            print(" ")

        print("        Attachments:")
        print("        -----------------------------------------------------------------------------------")
        for attachment in bug.attachments:
            print("            %-40s  %s" % (attachment.title, "None" if attachment.owner is None else attachment.owner.display_name))


        print(" ")
        # print("        -----------------------------------------------------------------------------------")
        # print("        -----------------------------------------------------------------------------------")
        # print(" ")
        # now = datetime.utcnow()
        # now.replace(tzinfo=None)
        # bi = Bugs.bug_info(bug, now)
        # target_task = "linux (Ubuntu Natty)"
        # #task_nominations = {}
        # #for task in tasks:
        # #    if '(' in task.bug_target_name:
        # #        m = match('(^\S+)\s+\(Ubuntu\s(\S+)\)$', task.bug_target_name)
        # #        if m is not None:
        # #            if m.group(1) not in task_nominations:
        # #                task_nominations[m.group(1)] = {}
        # #            task_nominations[m.group(1)][m.group(2)] = task.bug_target_name
        # #    else:
        # #        if task.bug_target_name not in task_nominations:
        # #            task_nominations[task.bug_target_name] = {}
        # #        task_nominations[task.bug_target_name]['!'] = task.bug_target_name

        # #for task in task_nominations:
        # #    for nom in sorted(task_nominations[task].keys()):
        # #        index = task_nominations[task][nom]

        # #        if nom == '!':
        # #            print(task)
        # #            if len(task_nominations[task]) == 1:
        # #                print("      just one")
        # #            else:
        # #                print("      none")
        # #        else:
        # #            print(nom)

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            # Go through all the bug-ids that the user specified on the command line.
            #
            for id in self.cfg['bugs']:

                # Get an instance of a bug object based on a bug-id. If the bug
                # id does not exist or if it is not visibile to you with the LP
                # credentials you are using, an exception will be thrown.
                #
                try:
                    bug = self.lp.get_bug(id)
                except:
                    print("Either the bug id specified (%s) does not exist in the LP server database or you are not authrorized to view it." % (id))

                else:
                    self.__print_bug_info(KernelBug(bug))

                    print(" ") # A line break between bug info

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

if __name__ == '__main__':
    app = BugInfo()
    app.main()

# vi:set ts=4 sw=4 expandtab:

