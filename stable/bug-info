#!/usr/bin/env python
#
# Sometimes when you are debugging a script that talks to LP, you want a way
# to dump out information about a bug and compare that with what you are
# getting yourself. This script can help in that way. It can also give you
# some ideas on how to use the lpltk library to talk to LP.
#

from sys                                import argv
from os                                 import unlink
from getopt                             import getopt, GetoptError
from ktl.utils                          import stdo, date_to_string, cout
from ktl.std_app                        import StdApp
from lpltk.service                      import LaunchpadService, LaunchpadServiceError
from ktl.kernel_bug                     import KernelBug
from tempfile                           import NamedTemporaryFile
from subprocess                         import Popen, PIPE

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("    Usage:                                                                                   \n")
        stdo("        %s <options> <bug-id> [<bug-id> ]+                                                   \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Where <options>:                                                                         \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --staging        Use the staging service to lookup the bug rather than the production\n")
        stdo("                         service.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --acpi           If the bug has an AcpiTables.txt file attached to it, run that      \n")
        stdo("                         through fwts for processing and show the results.                   \n")
        stdo("                                                                                             \n")
        stdo("        --fwts=<fwts-tests>                                                                  \n")
        stdo("                         The specific list of tests that want fwts to run.                   \n")
        stdo("                                                                                             \n")
        stdo("        --tasks                                                                              \n")
        stdo("                         Dump the bugs individual task information.                          \n")
        stdo("                                                                                             \n")
        stdo("        --nominations                                                                        \n")
        stdo("                         Dump the bugs individual nomination information.                    \n")
        stdo("                                                                                             \n")
        stdo("        --attachments                                                                        \n")
        stdo("                         Dump a list of all the attachments for a bug.                       \n")
        stdo("                                                                                             \n")
        stdo("        --tags                                                                               \n")
        stdo("                         Dump a list of all the tags on a bug.                               \n")
        stdo("                                                                                             \n")
        stdo("    Where <bug-id> is the Launchpad bug number that is to be dumped.                         \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s 781441                                                                            \n" % self.cfg['app_name'])
        stdo("        %s --staging 781441                                                                  \n" % self.cfg['app_name'])
        stdo("        %s --acpi 781441                                                                     \n" % self.cfg['app_name'])
        stdo('        %s --fwts="acpidump acpitables syntaxcheck" 781441                                   \n' % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        self.cfg['request'] = []
        self.cfg['needs acpitables attachment'] = False
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'staging', 'acpi', 'fwts=', 'tasks', 'nominations', 'attachments', 'tags']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--staging'):
                    self.cfg['staging'] = True

                elif (opt == '--acpi'):
                    self.cfg['show acpi'] = True
                    self.cfg['request'].append('acpi')
                    self.cfg['needs acpitables attachment'] = True

                elif (opt == '--fwts'):
                    self.cfg['fwts'] = val
                    self.cfg['request'].append('fwts')
                    self.cfg['needs acpitables attachment'] = True

                elif (opt == '--tasks'):
                    self.cfg['request'].append('tasks')

                elif (opt == '--nominations'):
                    self.cfg['request'].append('nominations')

                elif (opt == '--attachments'):
                    self.cfg['request'].append('attachments')

                elif (opt == '--tags'):
                    self.cfg['request'].append('tags')

            if result: # No errors yet

                # At lease one source package must be specified.
                #
                if len(args) > 0:
                    self.cfg['bugs'] = args

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        return


# BugInfo
#
class BugInfo(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

    # initialize
    #
    def initialize(self):
        if 'staging' in self.cfg:
            self.defaults['launchpad_services_root'] = 'qastaging'
        try:
            self.lp = LaunchpadService(self.defaults)
        except LaunchpadServiceError, e:
            print(e.msg)
            raise

        # The service.distributions property is a collection of distributions. We
        # pretty much only care about one, 'ubuntu'.
        #
        self.distro = self.lp.distributions['ubuntu']

    # __verbose_bug_info
    #
    def __print_bug_info(self, bug):
        stdo("\n")
        stdo("    %s: %s\n" % (bug.id, bug.title))
        stdo("\n")

        stdo("                 Owner: %s\n" % ("None" if bug.owner is None else bug.owner.display_name))

        stdo("               Created: %s\n" % (date_to_string(bug.date_created)))
        stdo("          Last Message: %s\n" % (date_to_string(bug.date_last_message)))
        stdo("          Last Updated: %s\n" % (date_to_string(bug.date_last_updated)))
        stdo("               Private: %s\n" % bug.private)
        stdo("              Security: %s\n" % bug.security_related)
        stdo("             Duplicate: %s\n" % bug.duplicate_of)
        stdo("                  Heat: %s\n" % bug.heat)
        stdo("          Latest Patch: %s\n" % (date_to_string(bug.date_latest_patch_uploaded)))
        stdo("          Is Expirable: %s\n" % bug.is_expirable())
        stdo("\n")

        if 'tags' in self.cfg['request']:
            tags = ""
            for t in bug.tags:
                tags += t
                tags += " "
            stdo("        Tags:\n")
            stdo("        -----------------------------------------------------------------------------------\n")
            stdo("            %s\n" % (tags))
            stdo("\n")

        if 'nominations' in self.cfg['request']:
            stdo("\n")
            stdo("        Nominations:\n")
            stdo("        -----------------------------------------------------------------------------------\n")
            nominations = bug.nominations
            stdo("                 Number: %d\n" % len(nominations))
            stdo("\n")
            for nomination in nominations:
                stdo("                 Target: %-15s" % (nomination.target.name))
                stdo("Status: %-15s\n" % (nomination.status))

                ds = nomination.distro_series
                if ds is None:
                    stdo("          Distro Series: None\n")
                else:
                    stdo("          Distro Series: %-15s" % (ds.name))
                    stdo("Active: %-15s" % (ds.active))
                    stdo("  Supported: %s\n" % (ds.supported))
                stdo("         Product Series: %s\n" % ("None" if nomination.product_series is None else nomination.product_series.name))
                stdo("                Created: %-35s" % (date_to_string(nomination.date_created)))
                stdo("       Decided: %s\n" % (date_to_string(nomination.date_decided)))
                stdo("\n")

        if 'tasks' in self.cfg['request']:
            tasks = bug.tasks
            stdo("\n")
            stdo("        Tasks:\n")
            stdo("        -----------------------------------------------------------------------------------\n")
            for task in tasks:
                assignee = task.assignee
                if assignee is None:
                    assignee = "Unknown"
                else:
                    assignee = assignee.display_name
                stdo("        %s (%s)\n" % (task.bug_target_name, task.bug_target_display_name))
                stdo("\n")

                stdo("                  Title: %s\n" % (task.title))
                stdo("                 Status: %-20s\n             Importance: %-20s\n               Assignee: %-s\n" % (task.status, task.importance, assignee))
                stdo("\n")
                stdo("                Created: %-35s" % (date_to_string(task.date_created)))
                stdo("       Confirmed: %-20s\n" % (date_to_string(task.date_confirmed)))
                stdo("               Assigned: %-35s" % (date_to_string(task.date_assigned)))
                stdo("          Closed: %-20s\n" % (date_to_string(task.date_closed)))
                stdo("          Fix Committed: %-35s" % (date_to_string(task.date_fix_committed)))
                stdo("    Fix Released: %-20s\n" % (date_to_string(task.date_fix_released)))
                stdo("            In Progress: %-35s" % (date_to_string(task.date_in_progress)))
                stdo("      Incomplete: %-20s\n" % (date_to_string(task.date_incomplete)))
                stdo("            Left Closed: %-35s" % (date_to_string(task.date_left_closed)))
                stdo("        Left New: %s\n" % (date_to_string(task.date_left_new)))
                stdo("                Triaged: %s\n" % (date_to_string(task.date_triaged)))
                stdo("            Is Complete: %s\n" % (task.is_complete))
                stdo("                  Owner: %s\n" % (task.owner.display_name))
                stdo("             Watch Link: %s\n" % (task.bug_watch))
                stdo("                 Target: %s\n" % (task.target))

                milestone = task.milestone
                if milestone is not None:
                    stdo("              Milestone: %s\n" % (milestone.name))
                else:
                    stdo("              Milestone: None\n")

                stdo("\n")
                stdo("          Related Tasks:\n")
                stdo("          ---------------------------------------------------------------------------\n")
                if len(task.related_tasks) > 0:
                    for related_task in task.related_tasks:
                        stdo("          %s (%s)\n" % (related_task.bug_target_name, related_task.bug_target_display_name))
                else:
                    stdo("          None\n")

                stdo("\n")

        if 'attachments' in self.cfg['request']:
            stdo("        Attachments:\n")
            stdo("        -----------------------------------------------------------------------------------\n")
            for attachment in bug.attachments:
                stdo("            %-40s  %s\n" % (attachment.title, "None" if attachment.owner is None else attachment.owner.display_name))
            stdo("\n")


        # Acpi Tables
        #
        acpi_fidname = ''
        if self.cfg['needs acpitables attachment']:
            content = bug.find_attachment('AcpiTables.txt')
            if content is not None:
                with NamedTemporaryFile(dir='./', delete=False) as acpi_fid:
                    acpi_fid.write(content)
                acpi_fidname = acpi_fid.name

        if 'acpi' in self.cfg['request']:
            stdo("        Acpi Tables:")
            stdo("        -----------------------------------------------------------------------------------\n")
            if acpi_fidname != '':
                for line in self.run_fwts(acpi_fid.name).split('\n'):
                    stdo(line + '\n')

        # fwts
        #
        if 'fwts' in self.cfg['request']:
            stdo("        Framework Test Suite:\n")
            stdo("        -----------------------------------------------------------------------------------\n")
            if acpi_fidname != '':
                for line in self.run_fwts(acpi_fid.name).split('\n'):
                    stdo(line + '\n')

        if acpi_fidname != '':
            unlink(acpi_fidname)

    # run_fwts
    #
    def run_fwts(self, fid):
        retval = ''

        if 'fwts' in self.cfg:
            cmd = "fwts --dumpfile=%s %s -" % (fid, self.cfg['fwts'])
        else:
            cmd = "fwts --dumpfile=%s  syntaxcheck acpitables acpidump -" % (fid)
        tags = []
        try:
            for line in Popen(cmd, shell=True, stdout=PIPE).stdout:
                retval += line
        except:
            stdo("        An exception was caught running the fwts. Make sure you have it installed.")

        return retval

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            # Go through all the bug-ids that the user specified on the command line.
            #
            for id in self.cfg['bugs']:

                # Get an instance of a bug object based on a bug-id. If the bug
                # id does not exist or if it is not visibile to you with the LP
                # credentials you are using, an exception will be thrown.
                #
                try:
                    bug = KernelBug(self.lp.get_bug(id))
                except:
                    stdo("Either the bug id specified (%s) does not exist in the LP server database or you are not authrorized to view it." % (id))

                else:
                    self.__print_bug_info(bug)

                    stdo(" ") # A line break between bug info

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

if __name__ == '__main__':
    app = BugInfo()
    app.main()

# vi:set ts=4 sw=4 expandtab:
