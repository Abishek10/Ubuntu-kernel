#!/usr/bin/env python
#
# Sometimes when you are debugging a script that talks to LP, you want a way
# to dump out information about a bug and compare that with what you are
# getting yourself. This script can help in that way. It can also give you
# some ideas on how to use the lpltk library to talk to LP.
#

from sys                                import argv
from os                                 import unlink
from getopt                             import getopt, GetoptError
from ktl.utils                          import stdo, date_to_string
from ktl.std_app                        import StdApp
from lpltk.service                      import LaunchpadService, LaunchpadServiceError
from ktl.kernel_bug                     import KernelBug
from tempfile                           import NamedTemporaryFile
from subprocess                         import Popen, PIPE

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("    Usage:                                                                                   \n")
        stdo("        %s <options> <bug-id> [<bug-id> ]+                                                   \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Where <options>:                                                                         \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --staging        Use the staging service to lookup the bug rather than the production\n")
        stdo("                         service.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --acpi           If the bug has an AcpiTables.txt file attached to it, run that      \n")
        stdo("                         through fwts for processing and show the results.                   \n")
        stdo("                                                                                             \n")
        stdo("        --fwts=<fwts-tests>                                                                  \n")
        stdo("                         The specific list of tests that want fwts to run.                   \n")
        stdo("                                                                                             \n")
        stdo("    Where <bug-id> is the Launchpad bug number that is to be dumped.                         \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s 781441                                                                            \n" % self.cfg['app_name'])
        stdo("        %s --staging 781441                                                                  \n" % self.cfg['app_name'])
        stdo("        %s --acpi 781441                                                                     \n" % self.cfg['app_name'])
        stdo('        %s --fwts="acpidump acpitables syntaxcheck" 781441                                   \n' % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'staging', 'acpi', 'fwts=']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--staging'):
                    self.cfg['staging'] = True

                elif (opt == '--acpi'):
                    self.cfg['show acpi'] = True

                elif (opt == '--fwts'):
                    self.cfg['fwts'] = val

            if result: # No errors yet

                # At lease one source package must be specified.
                #
                if len(args) > 0:
                    self.cfg['bugs'] = args

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        return


# BugInfo
#
class BugInfo(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

    # initialize
    #
    def initialize(self):
        if 'staging' in self.cfg:
            self.defaults['launchpad_services_root'] = 'qastaging'
        try:
            self.lp = LaunchpadService(self.defaults)
        except LaunchpadServiceError, e:
            print(e.msg)
            raise

        # The service.distributions property is a collection of distributions. We
        # pretty much only care about one, 'ubuntu'.
        #
        self.distro = self.lp.distributions['ubuntu']

    # __verbose_bug_info
    #
    def __print_bug_info(self, bug):
        print(" ")
        print("    %s: %s" % (bug.id, bug.title))
        print(" ")

        print("                 Owner: %s" % ("None" if bug.owner is None else bug.owner.display_name))

        print("               Created: %s" % (date_to_string(bug.date_created)))
        print("          Last Message: %s" % (date_to_string(bug.date_last_message)))
        print("          Last Updated: %s" % (date_to_string(bug.date_last_updated)))
        print("               Private: %s" % bug.private)
        print("              Security: %s" % bug.security_related)
        print("             Duplicate: %s" % bug.duplicate_of)
        print("                  Heat: %s" % bug.heat)
        print("          Latest Patch: %s" % (date_to_string(bug.date_latest_patch_uploaded)))
        print("          Is Expirable: %s" % bug.is_expirable())

        tags = ""
        for t in bug.tags:
            tags += t
            tags += " "
        print(" ")
        print("        Tags:")
        print("        -----------------------------------------------------------------------------------")
        print("            %s" % (tags))

        print(" ")
        print("        Nominations:")
        print("        -----------------------------------------------------------------------------------")
        nominations = bug.nominations
        print("                       Number: %d" % len(nominations))
        print(" ")
        for nomination in nominations:
            print("                       Target: %s" % (nomination.target.name))
            print("                       Status: %s" % (nomination.status))

            ds = nomination.distro_series
            if ds is None:
                print("                Distro Series: None")
            else:
                print("                Distro Series: %s" % (ds.name))
                print("                       Active: %s" % (ds.active))
                print("                    Supported: %s" % (ds.supported))
            print("               Product Series: %s" % ("None" if nomination.product_series is None else nomination.product_series.name))
            print("                      Created: %s" % (date_to_string(nomination.date_created)))
            print("                      Decided: %s" % (date_to_string(nomination.date_decided)))
            print(" ")

        tasks = bug.tasks
        print(" ")
        print("        Tasks:")
        print("        -----------------------------------------------------------------------------------")
        for task in tasks:
            assignee = task.assignee
            if assignee is None:
                assignee = "Unknown"
            else:
                assignee = assignee.display_name
            print("            %s (%s)" % (task.bug_target_name, task.bug_target_display_name))
            print("                       Status: %-20s  Importance: %-20s  Assignee: %-s" % (task.status, task.importance, assignee))
            print("                      Created: %s" % (date_to_string(task.date_created)))
            print("                    Confirmed: %s" % (date_to_string(task.date_confirmed)))
            print("                     Assigned: %s" % (date_to_string(task.date_assigned)))
            print("                       Closed: %s" % (date_to_string(task.date_closed)))
            print("                Fix Committed: %s" % (date_to_string(task.date_fix_committed)))
            print("                 Fix Released: %s" % (date_to_string(task.date_fix_released)))
            print("                  In Progress: %s" % (date_to_string(task.date_in_progress)))
            print("                   Incomplete: %s" % (date_to_string(task.date_incomplete)))
            print("                  Left Closed: %s" % (date_to_string(task.date_left_closed)))
            print("                     Left New: %s" % (date_to_string(task.date_left_new)))
            print("                      Triaged: %s" % (date_to_string(task.date_triaged)))
            print("                  Is Complete: %s" % (task.is_complete))
            print("                        Owner: %s" % (task.owner.display_name))
            print("                        Title: %s" % (task.title))
            print("                       Target: %s" % (task.target))
            print("                   Watch Link: %s" % (task.bug_watch))

            milestone = task.milestone
            if milestone is not None:
                print("                    Milestone: %s" % (milestone.name))
            else:
                print("                    Milestone: None")

            print(" ")
            print("                Related Tasks:")
            print("                ---------------------------------------------------------------------------")
            if len(task.related_tasks) > 0:
                for related_task in task.related_tasks:
                    print("                    %s (%s)" % (related_task.bug_target_name, related_task.bug_target_display_name))
            else:
                print("                    None")

            print(" ")

        print("        Attachments:")
        print("        -----------------------------------------------------------------------------------")
        for attachment in bug.attachments:
            print("            %-40s  %s" % (attachment.title, "None" if attachment.owner is None else attachment.owner.display_name))


        print(" ")


        # Acpi Tables
        #
        if 'show acpi' in self.cfg:
            print("        Acpi Tables:")
            print("        -----------------------------------------------------------------------------------")
            content = bug.find_attachment('AcpiTables.txt')
            if content is not None:
                with NamedTemporaryFile(dir='./', delete=False) as acpi_fid:
                    acpi_fid.write(content)

                for line in self.run_fwts(acpi_fid.name).split('\n'):
                    print line

                unlink(acpi_fid.name)

        # fwts
        #
        if 'fwts' in self.cfg:
            print("        Framework Test Suite:")
            print("        -----------------------------------------------------------------------------------")
            content = bug.find_attachment('AcpiTables.txt')
            if content is not None:
                with NamedTemporaryFile(dir='./', delete=False) as acpi_fid:
                    acpi_fid.write(content)

                for line in self.run_fwts(acpi_fid.name).split('\n'):
                    print line

                unlink(acpi_fid.name)

    # run_fwts
    #
    def run_fwts(self, fid):
        retval = ''

        if 'fwts' in self.cfg:
            cmd = "fwts --dumpfile=%s %s -" % (fid, self.cfg['fwts'])
        else:
            cmd = "fwts --dumpfile=%s  syntaxcheck acpitables acpidump -" % (fid)
        tags = []
        try:
            for line in Popen(cmd, shell=True, stdout=PIPE).stdout:
                retval += line
        except:
            print("        An exception was caught running the fwts. Make sure you have it installed.")

        return retval

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            # Go through all the bug-ids that the user specified on the command line.
            #
            for id in self.cfg['bugs']:

                # Get an instance of a bug object based on a bug-id. If the bug
                # id does not exist or if it is not visibile to you with the LP
                # credentials you are using, an exception will be thrown.
                #
                try:
                    bug = KernelBug(self.lp.get_bug(id))
                except:
                    print("Either the bug id specified (%s) does not exist in the LP server database or you are not authrorized to view it." % (id))

                else:
                    self.__print_bug_info(bug)

                    print(" ") # A line break between bug info

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

if __name__ == '__main__':
    app = BugInfo()
    app.main()

# vi:set ts=4 sw=4 expandtab:
