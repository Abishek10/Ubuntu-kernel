#!/usr/bin/env python
#

from sys                                import argv
from os                                 import path
from getopt                             import getopt, GetoptError
from ilib.utils                         import stdo
from ilib.std_app                       import StdApp
from threading                          import Lock, Thread
from time                               import sleep, time
from datetime                           import datetime
from instrument                         import Instrument

import socket

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
class Cmdline:
    """
    Handle all the command line processing for the application.
    """
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        """
        Simple helper which prints out an error message and then prints out the usage.
        """
        if e != '': error(e)
        self.usage(defaults)

    # usage
    #
    def usage(self, defaults):
        """
        Prints out the help text which explains the command line options.
        """
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>]                         \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --verbose        Give some feedback of what is happening while the script is         \n")
        stdo("                         running.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --config=<cfg file>                                                                  \n")
        stdo("                         The full path to the configuration file to use instead of           \n")
        stdo("                         the default location.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --measure=[v|c|hc]                                                                   \n")
        stdo("                         Measurement type:                                                   \n")
        stdo("                         v = voltage                                                         \n")
        stdo("                         c = current (400 mA max)                                            \n")
        stdo("                         hc = high current (10A max)                                         \n")
        stdo("                                                                                             \n")
        stdo("        --acdc=[ac|dc]                                                                       \n")
        stdo("                         Select AC or DC measurement                                         \n")
        stdo("                                                                                             \n")
        stdo("        --samples=<number>                                                                   \n")
        stdo("                         The number of measurements to make.                                 \n")
        stdo("                         A value of zero runs forever until killed.                          \n")
        stdo("                                                                                             \n")
        stdo("        --interval=<time delay(float)>                                                       \n")
        stdo("                         The time delay between samples. The measurement intervals           \n")
        stdo("                         may not match this precisely. If measurements take longer than       \n")
        stdo("                         the specified interval, they will be taken at the fastest rate      \n")
        stdo("                         possible. A value of zero reads at the fastest possible rate.       \n")
        stdo("                                                                                             \n")
        stdo("        --addr=<ip address>                                                                  \n")
        stdo("                         The IP address of the instrument                                    \n")
        stdo("                                                                                             \n")
        stdo("        --port=<port number>                                                                 \n")
        stdo("                         The IP port number of the instrument                                \n")
        stdo("                         Defaults to port 3490                                               \n")
        stdo("                                                                                             \n")
        stdo("        --out=<filename>                                                                     \n")
        stdo("                         The filename to write the output to.                                \n")
        stdo("                         Defaults to stdout.                                                 \n")
        stdo("                                                                                             \n")
        stdo("        --tagport=<socket number>                                                          \n")
        stdo("                         Listens for additional log information on                           \n")
        stdo("                         The specified socket.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])

    # process
    #
    def process(self, argv, defaults):
        """
        This method is responsible for calling the getopt function to process the command
        line. All parameters are processed into class variables for use by other methods.
        """
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'config=', 'measure=', 'debug=', 'samples=', 'interval=',
                         'addr=', 'port=', 'out=', 'tagport=', 'acdc=']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in ('--measure'):
                    self.cfg['measure'] = val

                elif opt in ('--acdc'):
                    self.cfg['acdc'] = val

                elif opt in ('--samples'):
                    self.cfg['samples'] = val

                elif opt in ('--interval'):
                    self.cfg['interval'] = val

                elif opt in ('--addr'):
                    self.cfg['addr'] = val

                elif opt in ('--port'):
                    self.cfg['port'] = val

                elif opt in ('--out'):
                    self.cfg['out'] = val

                elif opt in ('--tagport'):
                    self.cfg['tagport'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        """
        Used to verify that all required parameters are present and correct.
        """
        if 'samples' in cfg:
            if cfg['samples'] < 0:
                raise ValueError('you must supply a positive or zero value for number for --samples')
        else:
            stdo("Number of samples (--samples=) not specified, defaulting to 1\n")
            cfg['samples'] = 1

        if  cfg['samples'] != 1:
            if 'interval' in cfg:
                if cfg['interval'] < 0:
                    raise ValueError('you must supply a positive or zero value for number for --interval')
            else:
                stdo("Sample interval (--interval=) not specified, defaulting to fastest possible\n")
                cfg['interval'] = 0

        if 'measure' not in cfg:
            stdo("You must specify a measurement type to make (--measure)\n")
            raise ValueError
        else:
            if cfg['measure'].upper() not in ['V', 'C', 'HC']:
                raise ValueError('Invalid measurement type specified')

        if 'acdc' not in cfg:
            stdo("You must specify AC or DC measurement (--acdc)\n")
            raise ValueError
        else:
            if cfg['acdc'].upper() not in ['AC', 'DC']:
                raise ValueError('Invalid value for AC or DC')

        if 'addr' not in cfg:
            stdo("You must specify an IP address for the meter\n")
            raise ValueError
        else:
            try:
                socket.inet_aton(cfg['addr'])
            except socket.error:
                raise ValueError('Invalid IP address specified')

        if 'port' not in cfg:
            cfg['port'] = '3490'

        if 'tagport' in cfg:
            try:
                int(cfg['tagport'])
            except ValueError:
                raise ValueError('You must pass an integer value for --tagport')

        return

# MetaData
#
class MetaData():
    """
    This class exists only to provide the class variables containing the lock
    used for output, and the output method, So that the thread listening for
    tag data and the thread making measurements can both output without
    interleaving output within a line.
    """
    outputLock = None
    meterOutHandler = None

# LogMeter
#
class LogMeter(StdApp, MetaData):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {} # default configs
        self.logfile = None
        self.udpserver = None
        self.meter = None
        self.outputLock = Lock()

    # __del__
    #
    def __del__(self):
        if self.logfile is not None:
            self.logfile.close()
        if self.udpserver is not None:
            self.udpserver.shutdown()

    # initialize
    #
    def initialize(self):
        """
        A separate initialize that we can control when it gets called (not
        when the object is instantiated).
        """
        return

    def UDPhandler(self, port):
	#
	#  Using IP 0.0.0.0 rather than localhost means we
	#  can listen for all incoming hosts, ideal for remote
	#  client on test and a host logger.
	#
        UDP_IP="0.0.0.0"
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.bind( (UDP_IP, port) )

        while True:
            data, addr = sock.recvfrom(1500)
	    data = "TAG: " + data
            MetaData.meterOutHandler(data)
            print data.strip("\n")

    # openlog
    #
    def openLog(self, logpath):
        if path.exists(logpath):
            stdo("Existing file <%s> found, appending new information\n" % logpath)
            # maybe in the future rename or rotate logs
            self.logfile = open(logpath, 'a', 0)
        else:
            self.logfile = open(logpath, 'w', 0)
        return

    # writeOutput
    #
    def writeOutput(self, output):
        dt = datetime.utcnow().isoformat()
        self.outputLock.acquire()
        out = dt + ' ' + output.rstrip() + '\n'
        self.logfile.write(out)
        self.outputLock.release()
        return

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            if self.meter is not None:
                self.meter.device.setLocalMode()
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        # Open output file if requested
        #
        if 'out' in self.cfg:
            self.openLog(self.cfg['out'])

        self.meter = Instrument('fluke', '8846A')
        self.meter.initNet(self.cfg['addr'], self.cfg['port'])

        self.writeOutput('START: *****************************************')
        self.writeOutput('START: **            New Log Start            **')
        self.writeOutput('START: *****************************************')

        mid = self.meter.getIdent()
        self.writeOutput('INFO: id = %s' % mid)
        md = self.meter.device
        md.setRemoteMode()

        cd = md.getCalDate()
        self.writeOutput('INFO: Calibration Date = %s' % cd)
        md.clearStatus()

        d = md.getDate()
        self.writeOutput('INFO: meter date = %s' % d)

        t = md.getTime()
        self.writeOutput('INFO: meter time = %s' % t)

        #
        # For reasons that I cannot fathom when doing
        # repeated current measurements and breaking
        # before doing a reading can mess up the
        # multimeter readigs.  Forcing a measureVoltage()
        # seems to workaround this.  It is a major ugly
        # hack. 
        #
        md.measureVoltage('DC', 'Max')

        MetaData.meterOutHandler = self.writeOutput

        if 'tagport' in self.cfg:
            portno = int(self.cfg['tagport'])
            server_thread = Thread(target=self.UDPhandler, args=(portno,))
            # Exit the server thread when the main thread terminates
            server_thread.daemon = True
            server_thread.start()
            self.writeOutput('INFO: listening for tags on UDP port %d' % portno)

        if 'interval' in self.cfg:
            print 'Requested %f interval' % float(self.cfg['interval'])

        if 'debug' in self.cfg and 'dump' in self.cfg['debug']:
            md.dump = True
        # Set up for the requested measurement type
        mtype = self.cfg['measure'].upper()
        print 'measure type = ', mtype
        acdc = self.cfg['acdc'].upper()

        if mtype == 'V':
            md.setVoltage(acdc, 'Max')
        elif mtype == 'C':
            md.setCurrent(acdc, 'Def')
        elif mtype == 'HC':
            md.setCurrent(acdc, 'Max')
        else:
            raise RuntimeError('Unexpected value for measurement type')

        print 'Requested %d samples' % int(self.cfg['samples'])
        num = int(self.cfg['samples'])
        idelay = float(self.cfg['interval'])
	start_time = time()
	wake_time = start_time

        while num:
            wake_time = wake_time + idelay
            st = md.read()
            if st == '':
                ss = md.checkStatus()
                for ln in ss:
                    stdo('%s\n' % ln)
            dt = 'datetime'
            print 'Sample:', datetime.utcnow().isoformat(), st.strip()
            self.writeOutput('SAMPLE: %s' % st)
            num = num - 1
            if idelay and (num > 1):
                sleep_delay = wake_time - time()
		if sleep_delay > 0:
                	sleep(sleep_delay)

        md.setLocalMode()
        self.meter = None
        return

if __name__ == '__main__':
    app = LogMeter()
    app.main()

# vi:set ts=4 sw=4 expandtab:
