#!/usr/bin/env python
#

from sys                                import argv
from getopt                             import getopt, GetoptError
from ilib.utils                          import stdo
from ilib.std_app                        import StdApp

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
class Cmdline:
    """
    Handle all the command line processing for the application.
    """
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        """
        Simple helper which prints out an error message and then prints out the usage.
        """
        if e != '': error(e)
        self.usage(defaults)

    # usage
    #
    def usage(self, defaults):
        """
        Prints out the help text which explains the command line options.
        """
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>]                         \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --verbose        Give some feedback of what is happening while the script is         \n")
        stdo("                         running.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --config=<cfg file>                                                                  \n")
        stdo("                         The full path to the configuration file to use instead of           \n")
        stdo("                         the default location.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --samples=<number>                                                                   \n")
        stdo("                         The number of measurements to make.                                 \n")
        stdo("                         A value of zero runs forever until killed.                          \n")
        stdo("                                                                                             \n")
        stdo("        --interval=<time delay(float)>                                                       \n")
        stdo("                         The time delay between samples. The measurement intervals           \n")
        stdo("                         may not mach this precisely. If measurements take longer than       \n")
        stdo("                         the specified interval, they will be taken at the fastest rate      \n")
        stdo("                         possible. A value of zero reads at the fastest possible rate.       \n")
        stdo("                                                                                             \n")
        stdo("        --out=<filename>                                                                     \n")
        stdo("                         The filename to write the output to.                                \n")
        stdo("                         Defaults to stdout.                                                 \n")
        stdo("                                                                                             \n")
        stdo("        --tagsocket=<socket number>                                                          \n")
        stdo("                         Listens for additional log information on                           \n")
        stdo("                         The specified socket.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])

    # process
    #
    def process(self, argv, defaults):
        """
        This method is responsible for calling the getopt function to process the command
        line. All parameters are processed into class variables for use by other methods.
        """
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'config=', 'debug=', 'samples=', 'interval=']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in ('--samples'):
                    self.cfg['samples'] = val

                elif opt in ('--interval'):
                    self.cfg['interval'] = val

                elif opt in ('--out'):
                    self.cfg['out'] = val

                elif opt in ('--tagsocket'):
                    self.cfg['tagsocket'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        """
        Used to verify that all required parameters are present and correct.
        """
        if 'samples' in cfg:
            if cfg['samples'] < 0:
                raise ValueError('you must supply a positive or zero value for number for --samples')
        else:
            stdo("Number of samples (--samples=) not specified, defaulting to 1\n")
            cfg['samples'] = 1

        if  cfg['samples'] != 1:
            if 'interval' in cfg:
                if cfg['interval'] < 0:
                    raise ValueError('you must supply a positive or zero value for number for --interval')
            else:
                stdo("Sample interval (--interval=) not specified, defaulting to fastest possible\n")
                cfg['interval'] = 0

        if 'tagsocket' in cfg:
            try:
                int(cfg['tagsocket'])
            except ValueError:
                raise ValueError('You must pass an integer value for --tagsocket')

        return


# LogMeter
#
class LogMeter(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {} # default configs

    # initialize
    #
    def initialize(self):
        """
        A separate initialize that we can control when it gets called (not
        when the object is instantiated).
        """
        return

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        if 'out' in self.cfg:
            print 'Need to write output to', self.cfg['out']

        print 'Requested %d samples' % int(self.cfg['samples'])
        if 'interval' in self.cfg:
            print 'Requested %f interval' % float(self.cfg['interval'])
        if 'tagsocket' in self.cfg:
            print 'Requested tagsocket %d' % int(self.cfg['tagsocket'])

        return

if __name__ == '__main__':
    app = LogMeter()
    app.main()

# vi:set ts=4 sw=4 expandtab:

