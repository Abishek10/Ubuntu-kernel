#!/usr/bin/python
#==============================================================================
# Author: Stefan Bader <stefan.bader@canonical.com>
# Copyright (C) 2010
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#==============================================================================
import sys, os, optparse
from cvescripts_lib import *
from buildenv_lib import *

parser = optparse.OptionParser("Usage: %prog [options]")
dsc  = "Start preparing a security release"
parser.set_description(dsc)
parser.add_option("-f", "--force", action="store_true", dest="force",
	default=False, help="Throw away exising work and start over!")
parser.add_option("--no-pull", dest="trkpull", action="store_false",
	default=True, help="Skip pulling in tracker updates.")
(opts, args) = parser.parse_args()

#------------------------------------------------------------------------------
# Helper function to verify a package has the pending updates pulled.
#------------------------------------------------------------------------------
def CheckPatchesReady(workitem, pkg, series, pull=True):
	patchdir = GetPatchDir(workitem.get_candidate(), create=False)
	patchdir = os.path.join(patchdir, series, pkg)

	valid = True
	#----------------------------------------------------------------------
	# Does the patch directory exist?
	#----------------------------------------------------------------------
	if not os.path.isdir(patchdir):
		valid = False
	#----------------------------------------------------------------------
	# If the directory exists are there files in it (assuming that are the
	# patches)?
	#----------------------------------------------------------------------
	elif not os.listdir(patchdir):
		valid = False

	name = workitem.get_candidate()
	assignee = workitem.get_assignee()
	if not valid:
		if assignee != my_ircnick and pull:
			# FIXME: This needs cleanup
			if os.system("cve-item-pull " + name):
				valid = CheckPatchesReady(workitem, pkg, series,
						pull=False)
		elif assignee != my_ircnick and not pull:
			print "EE:", name, "needs pulling from", assignee
		else:
			print "EE:", name, "seems unsaved"

	return valid

#------------------------------------------------------------------------------
# Helper to re-order workitems when there is a dependency detected later.
#------------------------------------------------------------------------------
def WorkItemMoveAfter(itemlist, item1, name):
	for item2 in itemlist:
		if item2.get_candidate() == name:
			break
	else:
		return False

	if itemlist.index(item2) > itemlist.index(item1):
		print "II: Moving", item1.get_candidate(), "after", \
			item2.get_candidate()
		itemlist.remove(item1)
		itemlist.insert(itemlist.index(item2)+1, item1)
		return True

	return False

#------------------------------------------------------------------------------
# Update the tracker and check for workitems that have only pending package
# status for kernel related packages (there should be no packages that require
# triaging work).
#------------------------------------------------------------------------------
if opts.trkpull:
	TrackerPull()
workitems = ListWorkItemsToDo(waiting=False)

areas = []
for wi in workitems:
	nr_pending = 0
	nr_waiting = 0
	for (pkg, series) in ListLinuxPackagesAndSeries():
		pkgname = PkgList[series][pkg]

		if wi.is_pkg_pending(pkgname, series):
			#------------------------------------------------------
			# Security updates are released as normal updates, not
			# as security releases. But we need to make sure that
			# the issues are propagated to the right people.
			#------------------------------------------------------
			if series == cve_lib.devel_release:
				print "WW: " + wi.get_candidate() + " has " + \
					"pending work for development release."
			else:
				if not CheckPatchesReady(wi, pkg, series):
					print "EE: Aborting"
					sys.exit(1)
				if not [pkg, series] in areas:
					areas.append([pkg, series])
				nr_pending += 1
		if wi.is_pkg_waiting(pkgname, series):
			nr_waiting += 1
			break
	#----------------------------------------------------------------------
	# If there is any package waiting for work to be done, then the whole
	# workitem is not ready for release.
	#----------------------------------------------------------------------
	if nr_waiting:
		print "WW: " + wi.get_candidate() + " has uncompleted work." \
			+ " Removing from list."
		workitems.remove(wi)
	#----------------------------------------------------------------------
	# Should there be no updates pending, then this workitem can be safely
	# ignored on the further process.
	#----------------------------------------------------------------------
	elif not nr_pending:
		print "II: " + wi.get_candidate() + " has no pending items " \
			+ "in maintenance. Removing from list"
		workitems.remove(wi)

#------------------------------------------------------------------------------
# Attempting to resolve dependencies between patches by evaluating a
# file named "depends" in the save directory.
#------------------------------------------------------------------------------
repeat = True
while repeat:
	repeat = False
	for wi in workitems:
		depfile = GetSaveDir(wi.get_candidate())
		depfile = os.path.join(depfile, "depends")
		try:
			fp = open(depfile, "r")
		except:
			pass
		else:
			for line in fp.readlines():
				line = line.rstrip()
				if WorkItemMoveAfter(workitems, wi, line):
					repeat = True
			fp.close()
		if repeat:
			break

for wi in workitems:
	print wi.get_candidate()


print "II: Checking all workareas to be clean..."
if not IsWorkareaClean():
	print "EE: Refusing to start a new task while workarea is unclean"
	sys.exit(1)

#------------------------------------------------------------------------------
# Generate a list of packages that are touched by the workitems left.
#------------------------------------------------------------------------------
owd = os.getcwd()
for (pkg, series) in areas:
	area = os.path.join(series, pkg)

	print "II: Entering", area
	try:
		os.chdir(area)
		print "II: Updating repository..."
		os.system("git remote update ubuntu >/dev/null 2>&1")
	except:
		raise

	try:
		CreateBranch(series, pkg, "security", force=True)
	except:
		print "EE: CreateBranch() failed!"
		raise

	if os.system("maint-startnewrelease"):
		print "EE: Failed to start a new release!"
		raise

	for wi in workitems:
		if wi.is_pkg_pending(PkgList[series][pkg], series):
			print "II: Applying patches for", wi.get_candidate()
			patchdir = GetPatchDir(wi.get_candidate())
			patchdir = os.path.join(patchdir, series, pkg)

			for patch in sorted(os.listdir(patchdir)):
				patchfile = os.path.join(patchdir, patch)
				for line in open(patchfile, "r").readlines():
					if wi.get_candidate() in line:
						break
				else:
					continue
				os.system("rm -rf .git/rebase-apply")
				if os.system("git am -q " + patchfile):
					sys.exit(1)
	os.chdir(owd)
			

