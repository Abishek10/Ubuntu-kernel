#!/usr/bin/python
#==============================================================================
# Author: Stefan Bader <stefan.bader@canonical.com>
# Copyright (C) 2010
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#==============================================================================
import sys, os
from subprocess import *

#------------------------------------------------------------------------------
# This script is not meant to be run manually, but as part of the cve-setup
# task. It will be pushed to the central host and will create a git repo
# there.
#------------------------------------------------------------------------------
if len(sys.argv) < 5:
	print
	print "EE: This script should not be run manually. It will be run by",
	print " other scripts."
	print
	sys.exit(1)

groupname = sys.argv[1]
series    = sys.argv[2]
package   = sys.argv[3]
srcrepo   = sys.argv[4]
if len(sys.argv) > 5:
	refrepo = sys.argv[5]

#------------------------------------------------------------------------------
# Is there a better way to get the numeric group id?
#------------------------------------------------------------------------------
def GetGroupID(name):
	result = ""
	cmd = "getent group %s 2>/dev/null" % name
	stdout = Popen(cmd, shell=True, stdout=PIPE).stdout
	for line in stdout:
		result = result + line
	stdout.close()

	return int(result.split(":")[2])

#------------------------------------------------------------------------------
# All repositories for review should be located in ~/security which must
# belong to one group (kernel_team) and be only accessible for the user and
# that group.
#------------------------------------------------------------------------------
path = os.path.join(os.path.expanduser("~"), "security")
if not os.path.isdir(path):
	try:
		print "RR: Creating new " + path
		os.mkdir(path)
	except:
		print "EE: Cannot create " + path
		sys.exit(1)
	else:
		pass
os.chown(path, os.getuid(), GetGroupID(groupname))
os.chmod(path, 00750)

#------------------------------------------------------------------------------
# All package repos for one series are stored in one common directory under
# security. These need to belong to the same group and be readable by its
# members. Make files created automatically belong to that group.
#------------------------------------------------------------------------------
path = os.path.join(path, series)
if not os.path.isdir(path):
	try:
		print "RR: Creating new " + path
		os.mkdir(path)
	except:
		print "EE: Cannot create " + path
		sys.exit(1)
	else:
		pass
os.chown(path, os.getuid(), GetGroupID(groupname))
os.chmod(path, 02750)

#------------------------------------------------------------------------------
# Finally the repository gets cloned. To have the right accessmode, use
# an umask. And if there is a reference, use that as well.
# The repository itself will be named like the package and the files will
# not be checked out.
#------------------------------------------------------------------------------
old_umask = os.umask(0022)
path = os.path.join(path, package)
if os.path.isdir(os.path.join(path, ".git")):
	os.chdir(path)
	print "RR: Updating " + path
	os.system("git fetch -q")
else:
	cmd = "git clone -l -s -n -q"
	if refrepo != "":
		cmd += " --reference " + refrepo
	cmd += " " + srcrepo + " " + path
	try:
		print "RR: Creating new " + path
		os.system(cmd)
	except:
		print "EE: Failed to clone " + srcrepo
		os.umask(old_umask)
		sys.exit(1)
	else:
		pass
os.umask(old_umask)

