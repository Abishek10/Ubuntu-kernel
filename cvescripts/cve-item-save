#!/usr/bin/python
#==============================================================================
# Author: Stefan Bader <stefan.bader@canonical.com>
# Copyright (C) 2010
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#==============================================================================
import sys, os
import optparse
from cvescripts_lib import *
from buildenv_lib import *
import cve_lib

parser = optparse.OptionParser()
dsc = "Save current work in progress (extracts patches, updates tracker)"
parser.set_description(dsc)
(opt, args) = parser.parse_args()

#------------------------------------------------------------------------------
# First make sure there is a link named "current-item" which points to the
# cve-tracker data.
#------------------------------------------------------------------------------
workdir = os.getcwd()
workfile = os.path.join(workdir, "current-item")
if not os.path.islink(workfile):
	print "EE: Link {0} not found or not a symbolic link".format(workfile)
	sys.exit(1)
if not os.path.isfile(workfile):
	print "EE: Link {0} does not point to a file".format(workfile)
	sys.exit(1)

#------------------------------------------------------------------------------
# Load workitem data.
#------------------------------------------------------------------------------
wi = WorkItem(workfile)

#------------------------------------------------------------------------------
# Get the save directory (will be created)
#------------------------------------------------------------------------------
savedir = GetSaveDir(workdir, wi.get_candidate())

#------------------------------------------------------------------------------
# Verify that the work repositories are clean.
#------------------------------------------------------------------------------
print "II: Verifying whether all workareas are clean..."
if not IsWorkareaClean(branch=wi.get_candidate()):
	print "EE: Will not save until workarea has been cleaned"
	sys.exit(1)

#------------------------------------------------------------------------------
# Now walk through all workareas and extract the patches
#------------------------------------------------------------------------------
print "II: Extracting patches..."
for area in ListWorkareas():
	patchdir = os.path.join(savedir, "patches", area)
	AssertDir(patchdir)
	#----------------------------------------------------------------------
	# Remove the files currently in patchdir (not to gather dead entries).
	#----------------------------------------------------------------------
	for file in os.listdir(patchdir):
		if file.split(".")[-1] == "patch":
			os.unlink(os.path.join(patchdir, file))
	#----------------------------------------------------------------------
	# Export all patches since the branch was split off.
	#----------------------------------------------------------------------
	os.chdir(os.path.join(workdir, area))
	mergebase = GitMergeBase("ubuntu/master", wi.get_candidate())
	if not mergebase:
		print "EE: Failed to find a mergebase for", area
		sys.exit(1)
	cmd = "git format-patch -o {0} {1}".format(patchdir, mergebase)
	os.system(cmd)
	os.chdir(workdir)

#------------------------------------------------------------------------------
for pkg in wi.list_packages():
	if wi.packages[pkg].has_key("Patches"):
		wi.packages[pkg]["Patches"] = []
for area in ListWorkareas():
	series, pkgshort = area.split(os.path.sep, 1)
	pkg = PkgList[series][pkgshort]
	patchdir = os.path.join(savedir, "patches", area)
	patches = sorted(os.listdir(patchdir))

	if patches:
		if not pkg in wi.list_packages():
			print "WW: New package created", pkg
			wi.packages[pkg] = dict()
			wi.packages[pkg]["status"] = dict()
			wi.packages[pkg]["status"][series] = "needed"

		st = wi.get_status(pkg, series)
		if st in ["not-affected", "needs-triage", "needed"]:
			wi.set_status(pkg, series, "applied")
		for patch in patches:
			value = series + ": " + GetHttpLink()
			value += os.path.join(wi.get_candidate(), area, patch)
			if not wi.packages[pkg].has_key("Patches"):
				wi.packages[pkg].setdefault("Patches", [])
			wi.packages[pkg]["Patches"].append(value)
	else:
		st = wi.get_status(pkg, series)
		if st == "applied":
			wi.set_status(pkg, series, "needed")
		if st == "needs-triage":
			wi.set_status(pkg, series, "not-affected")

#------------------------------------------------------------------------------
# Being optimistic, we create a backup of the
#------------------------------------------------------------------------------
ifile = open(workfile, "r")
ofile = open(os.path.realpath(workfile) + ".bak", "w")
for line in ifile.readlines():
	ofile.write(line)
ofile.close()
ifile.close()

wi.save(workfile)

