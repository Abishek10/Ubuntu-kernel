#!/usr/bin/python
#==============================================================================
# Author: Stefan Bader <stefan.bader@canonical.com>
# Copyright (C) 2010
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#==============================================================================
import sys, os
import optparse
from cvescripts_lib import *
from buildenv_lib import *

parser = optparse.OptionParser()
dsc = "Save current work in progress (extracts patches, updates tracker)"
parser.set_description(dsc)
parser.add_option("--no-tracker-push", action="store_false",
		  dest="trackerpush", default=True,
		  help="Do not push changes to CVE tracker after committing.")
(opt, args) = parser.parse_args()

#------------------------------------------------------------------------------
# First make sure there is a link named "current-item" which points to the
# cve-tracker data.
#------------------------------------------------------------------------------
workdir = os.getcwd()
workfile = os.path.join(workdir, "current-item")
if not os.path.islink(workfile):
	print "EE: Link {0} not found or not a symbolic link".format(workfile)
	sys.exit(1)
if not os.path.isfile(workfile):
	print "EE: Link {0} does not point to a file".format(workfile)
	sys.exit(1)

#------------------------------------------------------------------------------
# Load workitem data.
#------------------------------------------------------------------------------
wi = WorkItem(workfile)
winame = wi.get_candidate()

#------------------------------------------------------------------------------
# Get the save directory (will be created)
#------------------------------------------------------------------------------
savedir = GetSaveDir(winame)

#------------------------------------------------------------------------------
# Verify that the work repositories are clean.
#------------------------------------------------------------------------------
print "II: Verifying whether all workareas are clean..."
if not IsWorkareaClean(branch=winame):
	print "EE: Will not save until workarea has been cleaned"
	sys.exit(1)

#------------------------------------------------------------------------------
# Now walk through all workareas and extract the patches
#------------------------------------------------------------------------------
SavePatches(winame, push=True)

#------------------------------------------------------------------------------
# Now update the workitem with the patches and current status.
#------------------------------------------------------------------------------
for area in ListWorkareas():
	series, pkgshort = area.split(os.path.sep, 1)
	pkg = PkgList[series][pkgshort]
	patchdir = os.path.join(GetPatchDir(winame), area)

	#----------------------------------------------------------------------
	# Remove all patches currently defined for this series/package. Those
	# will be re-added (or replaced by new ones) later.
	#----------------------------------------------------------------------
	if pkg in wi.list_packages() and wi.packages[pkg].has_key("Patches"):
		patches = []
		for patch in wi.packages[pkg]["Patches"]:
			if not patch.startswith(series + ":"):
				patches.append(patch)
		wi.packages[pkg]["Patches"] = patches

	#----------------------------------------------------------------------
	# Usually with the new model, all patches in the branch of a workitem
	# should be required to fix it. Just now I saw one case were a second
	# CVE is required to fix something introduced by another CVE which is
	# on the worklist, too. So the other patch is needed but should not be
	# part of the patches shown. Long story, short solution: only include
	# patches that have the right reference in them.
	#----------------------------------------------------------------------
	patches = []
	for patch in sorted(os.listdir(patchdir)):
		patchfile = os.path.join(patchdir, patch)
		for line in open(patchfile, "r").readlines():
			if winame.startswith("BUG-"):
				bugnr = winame.split("-")[1]
				if "BugLink:" in line and bugnr in line:
					patches.append(patch)
					break
			if winame in line:
				patches.append(patch)
				break

	#----------------------------------------------------------------------
	# Take any patches left and update the workitem with those.
	#----------------------------------------------------------------------
	if patches:
		if not pkg in wi.list_packages():
			print "WW: New package created", pkg
			wi.packages[pkg] = dict()
			wi.packages[pkg]["status"] = dict()
			wi.packages[pkg]["status"][series] = "needed"

		st = wi.get_status(pkg, series)
		if st in ["not-affected", "needs-triage", "needed"]:
			wi.set_status(pkg, series, "pending")
		for patch in patches:
			value = series + ": " + GetHttpLink(winame)
			value = os.path.join(value, "patches", area, patch)
			if not wi.packages[pkg].has_key("Patches"):
				wi.packages[pkg].setdefault("Patches", [])
			wi.packages[pkg]["Patches"].append(value)
	else:
		#--------------------------------------------------------------
		# This assumes that, when saving, any series without patches
		# is not affected.
		#--------------------------------------------------------------
		st = wi.get_status(pkg, series)
		if st == "pending":
			wi.set_status(pkg, series, "needed")
		if st == "needs-triage":
			wi.set_status(pkg, series, "not-affected")

#------------------------------------------------------------------------------
# This sends the patches to the public_html directory
#------------------------------------------------------------------------------
Publish(savedir)

#------------------------------------------------------------------------------
# Being optimistic, we create a backup of the
#------------------------------------------------------------------------------
ifile = open(workfile, "r")
ofile = open(os.path.basename(os.path.realpath(workfile)) + ".bak", "w")
for line in ifile.readlines():
	ofile.write(line)
ofile.close()
ifile.close()

#------------------------------------------------------------------------------
# Finally save the workitem and update the tracker. This will only cause a
# commit if there are really changes.
#------------------------------------------------------------------------------
TrackerPull()
if not wi.save(workfile):
	print wi.msg
TrackerCommit(winame + " updated with current work status",
	      push=opt.trackerpush)

