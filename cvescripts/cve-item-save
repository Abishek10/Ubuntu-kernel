#!/usr/bin/python
#==============================================================================
# Author: Stefan Bader <stefan.bader@canonical.com>
# Copyright (C) 2010
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#==============================================================================
import sys, os
import optparse
from cvescripts_lib import *
from buildenv_lib import *

parser = optparse.OptionParser()
dsc = "Save current work in progress (extracts patches, updates tracker)"
parser.set_description(dsc)
(opt, args) = parser.parse_args()

#------------------------------------------------------------------------------
# First make sure there is a link named "current-item" which points to the
# cve-tracker data.
#------------------------------------------------------------------------------
workdir = os.getcwd()
workfile = os.path.join(workdir, "current-item")
if not os.path.islink(workfile):
	print "EE: Link {0} not found or not a symbolic link".format(workfile)
	sys.exit(1)
if not os.path.isfile(workfile):
	print "EE: Link {0} does not point to a file".format(workfile)
	sys.exit(1)

#------------------------------------------------------------------------------
# Load workitem data.
#------------------------------------------------------------------------------
wi = WorkItem(workfile)

#------------------------------------------------------------------------------
# Get the save directory (will be created)
#------------------------------------------------------------------------------
savedir = GetSaveDir(workdir, wi.get_candidate())

#------------------------------------------------------------------------------
# Verify that the work repositories are clean.
#------------------------------------------------------------------------------
print "II: Verifying whether all workareas are clean..."
if not IsWorkareaClean(branch=wi.get_candidate()):
	print "EE: Will not save until workarea has been cleaned"
	sys.exit(1)

#------------------------------------------------------------------------------
# Now walk through all workareas and extract the patches
#------------------------------------------------------------------------------
print "II: Extracting patches..."
for area in ListWorkareas():
	patchdir = os.path.join(savedir, "patches", area)
	AssertDir(patchdir)
	#----------------------------------------------------------------------
	# Remove the files currently in patchdir (not to gather dead entries).
	#----------------------------------------------------------------------
	for file in os.listdir(patchdir):
		if file.split(".")[-1] == "patch":
			os.unlink(os.path.join(patchdir, file))
	#----------------------------------------------------------------------
	# Export all patches since the branch was split off.
	#----------------------------------------------------------------------
	os.chdir(os.path.join(workdir, area))
	mergebase = GitMergeBase("ubuntu/master", wi.get_candidate())
	if not mergebase:
		print "EE: Failed to find a mergebase for", area
		sys.exit(1)
	cmd  = "git format-patch--suffix=.txt -o " + patchdir
	cmd += " " + mergebase + " 2>/dev/null"
	os.system(cmd)
	os.chdir(workdir)

#------------------------------------------------------------------------------
# Now update the workitem with the patches and current status.
#------------------------------------------------------------------------------
for area in ListWorkareas():
	series, pkgshort = area.split(os.path.sep, 1)
	pkg = PkgList[series][pkgshort]
	patchdir = os.path.join(savedir, "patches", area)

	#----------------------------------------------------------------------
	# Remove all patches currently defined for this series/package. Those
	# will be re-added (or replaced by new ones) later.
	#----------------------------------------------------------------------
	if pkg in wi.list_packages() and wi.packages[pkg].has_key("Patches"):
		for patch in wi.packages[pkg]["Patches"]:
			if patch.startswith(series + ":"):
				wi.packages[pkg]["Patches"].remove(patch)

	#----------------------------------------------------------------------
	# Usually with the new model, all patches in the branch of a workitem
	# should be required to fix it. Just now I saw one case were a second
	# CVE is required to fix something introduced by another CVE which is
	# on the worklist, too. So the other patch is needed but should not be
	# part of the patches shown. Long story, short solution: only include
	# patches that have the right reference in them.
	#----------------------------------------------------------------------
	patches = sorted(os.listdir(patchdir))
	for patch in patches:
		found = 0
		patchfile = os.path.join(patchdir, patch)
		for line in open(patchfile, "r").readlines():
			if wi.get_candidate() in line:
				found = 1
				break
		if not found:
			patches.remove(patch)

	#----------------------------------------------------------------------
	# Take any patches left and update the workitem with those.
	#----------------------------------------------------------------------
	if patches:
		if not pkg in wi.list_packages():
			print "WW: New package created", pkg
			wi.packages[pkg] = dict()
			wi.packages[pkg]["status"] = dict()
			wi.packages[pkg]["status"][series] = "needed"

		st = wi.get_status(pkg, series)
		if st in ["not-affected", "needs-triage", "needed"]:
			wi.set_status(pkg, series, "applied")
		for patch in patches:
			value = series + ": " + GetHttpLink(wi.get_candidate())
			value = os.path.join(value, "patches", area, patch)
			if not wi.packages[pkg].has_key("Patches"):
				wi.packages[pkg].setdefault("Patches", [])
			wi.packages[pkg]["Patches"].append(value)
	else:
		#--------------------------------------------------------------
		# This assumes that, when saving, any series without patches
		# is not affected.
		#--------------------------------------------------------------
		st = wi.get_status(pkg, series)
		if st == "applied":
			wi.set_status(pkg, series, "needed")
		if st == "needs-triage":
			wi.set_status(pkg, series, "not-affected")

#------------------------------------------------------------------------------
# This sends the patches to the public_html directory
#------------------------------------------------------------------------------
Publish(savedir)

#------------------------------------------------------------------------------
# Being optimistic, we create a backup of the
#------------------------------------------------------------------------------
ifile = open(workfile, "r")
ofile = open(os.path.basename(os.path.realpath(workfile)) + ".bak", "w")
for line in ifile.readlines():
	ofile.write(line)
ofile.close()
ifile.close()

#------------------------------------------------------------------------------
# Finally save the workitem and update the tracker. This will only cause a
# commit if there are really changes.
#------------------------------------------------------------------------------
wi.save(workfile)
TrackerCommit(wi.get_candidate() + " updated with current work status")

