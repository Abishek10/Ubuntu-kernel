#!/usr/bin/env python
#
# Called by one of the jenkins matix jobs for every cell of
# the matix. This job creates the correct provision-job,
# testing-job combination based on the environment variables
# of the matrix job.
#

from sys                                import stdout, argv, exit
from os                                 import getenv, path
from argparse                           import ArgumentParser
from logging                            import debug, info, basicConfig, DEBUG, INFO
from mako.template                      import Template
from mako.exceptions                    import RichTraceback
from lib.jenkins                        import Jenkins, JenkinsException, LAUNCHER_SSH, LAUNCHER_COMMAND, LAUNCHER_WINDOWS_SERVICE

from lib.ubuntu                         import Ubuntu

# Exit
#
class Exit():
    """
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    """
    pass

# InvalidException
#
class InvalidException(Exception):
    def __init__(self, v):
        self.value = v
    def __str__(self):
        return self.value

# InvalidSystemType
#
class InvalidSystemType(InvalidException):
    def __init__(self, v):
        InvalidException.__init__(self, v)

# InvalidKernelArch
#
class InvalidKernelArch(InvalidException):
    def __init__(self, v):
        InvalidException.__init__(self, v)

# InvalidKernelType
#
class InvalidKernelType(InvalidException):
    def __init__(self, v):
        InvalidException.__init__(self, v)

# InvalidSeries
#
class InvalidSeries(InvalidException):
    def __init__(self, v):
        InvalidException.__init__(self, v)

# KernelMatrixJob
#
class KernelMatrixJob():

    # __init__
    #
    def __init__(self, args):
        self.cfg = args
        server_url = 'http://kernel-jenkins:8080'
        self.jenkins = Jenkins(server_url)

    # load_template
    #
    def load_template(self, file_name):
        """
        Load the indicated mako template file. Return a mako Template()
        instance.
        """
        retval = None
        with open(file_name, 'r') as f:
            retval = Template(f.read())

        return retval

    def jenkins_create_job(self, job_name, data):
        template = self.load_template('job-template.mako')
        job_xml = template.render(data=data)

        self.jenkins.create_job(job_name, job_xml)
        print(job_xml)
        info('created jenkins job: %s' % job_name)

    # create_test_job
    #
    def create_job(self, job_name, template_name, cfg):
        template = self.load_template(path.join(path.dirname(argv[0]), template_name))
        job_xml = template.render(data=cfg)

        try:
            self.jenkins.delete_job(job_name)
        except:
            pass
        self.jenkins.create_job(job_name, job_xml)
        info('created jenkins job: %s' % job_name)

    # create_hw_testing_jobs
    #
    def create_hw_testing_jobs(self, cfg):
        job_name = 'hw-provisioning-%s-%s' % (cfg.target_series, cfg.kernel_arch)
        self.create_job(job_name, 'hw-provisioning-job.mako', cfg)

        job_name = '%s-%s-%s-test' % (cfg.test_host, cfg.target_series, cfg.kernel_arch)
        self.create_job(job_name, 'testing-job.mako', cfg)

    # create_vm_testing_jobs
    #
    def create_vm_testing_jobs(self, cfg):
        print("\n   *** Error: create_vm_testing_jobs is not implemented yet.\n")

    # main
    #
    def main(self):
        retval = 1
        try:
            valid = {
                'kernel-arch' : ['amd64', 'i386'],
                'kernel-type' : ['regular', 'lts-hwe'],
                'system-type' : ['real', 'virtual'],
            }

            setattr(self.cfg, 'kernel_arch', getenv('KERNEL_ARCH')) # amd64 / i386
            setattr(self.cfg, 'kernel_type', getenv('KERNEL_TYPE')) # regular / lts_hwe
            setattr(self.cfg, 'system_type', getenv('SYSTEM_TYPE')) # real / virtual

            debug('Kernel arch: %s' % self.cfg.kernel_arch)
            debug('Kernel type: %s' % self.cfg.kernel_type)
            debug('System type: %s' % self.cfg.system_type)

            if self.cfg.target_series:
                debug('Target series: %s' % self.cfg.target_series)

            if self.cfg.kernel_series:
                debug('Kernel series: %s' % self.cfg.kernel_series)

            if self.cfg.test_host:
                debug('Test host: %s' % self.cfg.test_host)

            # Validate that we can handle what we've been given and that we've been given
            # all that we need.
            #
            if self.cfg.kernel_arch not in valid['kernel-arch']:
                raise InvalidKernelArch(self.cfg.kernel_arch)

            if self.cfg.kernel_type not in valid['kernel-type']:
                raise InvalidKernelType(self.cfg.kernel_type)

            if self.cfg.system_type not in valid['system-type']:
                raise InvalidSystemType(self.cfg.system_type)

            if self.cfg.target_series not in Ubuntu.index_by_series_name:
                raise InvalidSeries(self.cfg.target_series)

            if self.cfg.kernel_series not in Ubuntu.index_by_series_name:
                raise InvalidSeries(self.cfg.kernel_series)

            # Now, actually do something.
            #
            try:
                if self.cfg.system_type == 'real':
                    self.create_hw_testing_jobs(self.cfg)
                else:
                    self.create_vm_testing_jobs(self.cfg)
            except:
                traceback = RichTraceback()
                for (filename, lineno, function, line) in traceback.traceback:
                    print("File %s, line %s, in %s" % (filename, lineno, function))
                    for s in line:
                        stdout.write(s)
                print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        except InvalidSystemType as e:
            print("\n   *** Error: The SYSTEM_TYPE specified (%s) is not valid.\n" % e.value)

        except InvalidKernelType as e:
            print("\n   *** Error: The KERNEL_ARCH specified (%s) is not valid.\n" % e.value)

        except InvalidKernelArch as e:
            print("\n   *** Error: The KERNEL_ARCH specified (%s) is not valid.\n" % e.value)

        except InvalidSeries as e:
            print("\n   *** Error: The series specified (%s) is not valid.\n" % e.value)

        except Exit:
            pass

        return retval

if __name__ == '__main__':

    if getenv('DEBUG'):
        LOGLEVEL = DEBUG
    else:
        LOGLEVEL = INFO
    basicConfig(level=LOGLEVEL, format="%(asctime)-15s-%(levelname)s - %(message)s")
    info('Started')

    parser = ArgumentParser()
    parser.add_argument('-d', '--dry-run',  action='store_true', help='Don\'t actually perform the operations.')
    parser.add_argument('-s', '--target-series', required=True, help='The series the test system will be installed with.')
    parser.add_argument('-k', '--kernel-series', required=True, help='The series of the kernel that is to be tested.')
    parser.add_argument('-t', '--test-host',     required=True, help='The name of the test system that will be re-provisioned.')
    args = parser.parse_args()

    app = KernelMatrixJob(args)
    result = app.main()
    info('That\'s All Folks!')
    exit(result)

# vi:set ts=4 sw=4 expandtab:

