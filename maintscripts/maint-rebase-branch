#!/usr/bin/python
#==============================================================================
# Author: Stefan Bader <stefan.bader@canonical.com>
# Copyright (C) 2010
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#==============================================================================
import sys, os, optparse
from ktl.utils                        import debug, error, run_command

#------------------------------------------------------------------------------
# Libraries shared by all kteam-tools will be found here (../lib)
#------------------------------------------------------------------------------
cvescripts_common_lib = os.path.dirname(os.path.abspath(sys.argv[0]))
cvescripts_common_lib = os.path.dirname(cvescripts_common_lib)
cvescripts_common_lib = os.path.join(cvescripts_common_lib, "lib")
sys.path.insert(0, cvescripts_common_lib)

from buildenv_lib import *
from git_lib import *

usage = "Usage: %prog [<options>] <branch> <target>"
parser = optparse.OptionParser(usage)
dsc = """
Rebase a given branch onto the master branch at a specific commit.

<branch> is the branch which should get rebased
<target> is the location on the master branch the specified branch is to rebased to
"""
parser.set_description(dsc)
parser.add_option("--continue", action="store_true", default=False,
    dest="continue_rebase", help="continue a disrupted rebase")
parser.add_option("--debug", action="store_true", default=False,
    dest="debug", help="print loads of verbose messages that might give a clue as to what's going on")

(opts, args) = parser.parse_args()

if opts.debug:
    debug("Debug flag has been set!")

#------------------------------------------------------------------------------
# First argument is the branch which should get rebased.
#------------------------------------------------------------------------------
try:
    branch = args[0]
except:
    error("The name of the branch to be rebased is required but missing.\n")
    parser.print_usage()
    sys.exit(1)

#------------------------------------------------------------------------------
# Is that branch valid?
#------------------------------------------------------------------------------
if not branch in GitListBranches():
    error("The specified branch (%s) is not a recognized branch in this repository.\n")
    sys.exit(1)

#------------------------------------------------------------------------------
# Second argument is the target (a tag or a sha1).
#------------------------------------------------------------------------------
try:
    target = args[1]
except:
    error("A tag or sha1 as a rebase point must be specified but is not.\n")
    parser.print_usage()
    sys.exit(1)

#------------------------------------------------------------------------------
# Is the target a valid object?
#------------------------------------------------------------------------------
try:
    msg = GitLog(opts="-1 --pretty='%s' " + target)[0]
except:
    error("The target (%s) doesn't appear to be a valid object.\n" % (target))
    sys.exit(1)

if not msg.startswith("UBUNTU: Ubuntu-"):
    error("The target (%s) doesn't appear to point to a release.\n" % (target))
    sys.exit(1)

debug("branch : (%s) [exists]\n" % (branch), opts.debug)
debug("target : (%s) [exists]\n" % (target), opts.debug)

#------------------------------------------------------------------------------
# Remember what version (from the changelog) should be the target.
#------------------------------------------------------------------------------
info = GetPackageInfo(target)
if info == None:
    error("Failed to get the package information for the target (%s).\n" % (target))
    sys.exit(1)
TargetVersion = info[1]
TargetPocket  = info[2]
debug("target:  version: '%s'; pocket: '%s'\n" % (TargetVersion, TargetPocket), opts.debug)

#------------------------------------------------------------------------------
# As a branch might be based on a different base than origin, we need to
# collect all remote master branches.
#------------------------------------------------------------------------------
masters = []
for line in GitListBranches(remote=True):
    fields = line.rstrip().split(" ")[0].split("/")
    if fields[0] != "remotes":
        continue
    if  fields[-1] == "master":
        masters.append(fields[1] + "/" + fields[2])

if not masters:
    error("Unable to find a remote, master branch.\n")
    sys.exit(1)

#------------------------------------------------------------------------------
# FIXME: The library version only handles two branches
#------------------------------------------------------------------------------
cmd = "git merge-base " + branch
for line in masters:
    cmd += " " + line
debug("cmd: '%s'\n" % (cmd))
for line in Popen(cmd, shell=True, stdout=PIPE).stdout:
    MergeBase = line.strip()
    break
info = GetPackageInfo(sha1=MergeBase)
if info == None:
    error("Failed to get the package information for the mergebase (%s).\n" % (MergeBase))
    sys.exit(1)
BaseVersion = info[1]
debug("merge base:  version: '%s'\n" % (BaseVersion))

if BaseVersion == TargetVersion:
    error("This branch is already rebased to %s" % (TargetVersion))
    sys.exit(1)

#------------------------------------------------------------------------------
# FIXME: For the moment the branch must be UNRELEASED. Change this when there
#        is code to the automatic retrieval of the ABI files.
#------------------------------------------------------------------------------
if GetPackageInfo(branch)[2] != "UNRELEASED":
    print "E: The branch is not UNRELEASED!"
    sys.exit(1)

#------------------------------------------------------------------------------
# Working tree must be clean
#------------------------------------------------------------------------------
if opts.continue_rebase == False:
    print "Checking working tree ...",
    if GitListFiles(opts="--others --modified") != []:
        print "NOT CLEAN!"
        sys.exit(1)
    print "OK"


    #----------------------------------------------------------------------
    # First switch to the branch (to get of auto-tmp-rebase for sure).
    #----------------------------------------------------------------------
    print "Switching to", branch
    os.system("git checkout " + branch)

    #----------------------------------------------------------------------
    # Then create the temporary rebase branch (delete it if already present)
    #----------------------------------------------------------------------
    if "auto-tmp-rebase" in GitListBranches():
        os.system("git branch -D auto-tmp-rebase")
    print "Creating temporary auto-tmp-rebase"
    os.system("git checkout -b auto-tmp-rebase " + branch)

#------------------------------------------------------------------------------
# Get the sha1 of the last common commit with the master branch and remember
# the version number of it. Then rebase the temporary branch on top of the
# target release.
#------------------------------------------------------------------------------
if opts.continue_rebase == False:
    print "Rebasing from", BaseVersion, "to", TargetVersion
    cmd = "git rebase --onto Ubuntu-{0} {1}".format(TargetVersion, MergeBase)
else:
    cmd = "git rebase --continue"
p = Popen(cmd, shell=True)
status = os.waitpid(p.pid, 0)[1]
if status > 0:
    sys.exit(1)

#------------------------------------------------------------------------------
# Insert the changes of the master tree between the last base and the new
# one. If the ABI changed between those, bump the ABI for the branch, too.
#------------------------------------------------------------------------------
debdir = GetDebianDir()
changelog = os.path.join(debdir, "changelog")

#------------------------------------------------------------------------------
# COMPAT: Once the more current version of this script was in the abstracted
# directory. But it might be in the generic directory now.
#------------------------------------------------------------------------------
print "Inserting changes..."
cmd = "./{0}/scripts/misc/insert-ubuntu-changes".format(debdir)
if not os.path.isfile(cmd):
    cmd = "./debian/scripts/misc/insert-ubuntu-changes"
cmd += " {0} {1} ".format(changelog, BaseVersion.split("-")[1])
cmd += TargetVersion.split("-")[1]
os.system(cmd)

#------------------------------------------------------------------------------
# The ABI needs to be bumped only if this hasn't been done already and the
# rebase moves between ABI versions.
#------------------------------------------------------------------------------
if VersionGetABI(GetPackageInfo()[1]) == \
   VersionGetABI(GetPackageInfo(prev=True)[1]):
    if VersionGetABI(BaseVersion) != VersionGetABI(TargetVersion):
        BumpABI()

print "Committing changes..."
cmd = "git add {0}".format(changelog)
os.system(cmd)
cmd = "git commit -s -m \"UBUNTU: Rebased to {0}\"".format(TargetVersion)
os.system(cmd)

#------------------------------------------------------------------------------
# FIXME: Everything below can go into maint-close-release
#------------------------------------------------------------------------------
print "Inserting changes to close release..."
PkgVersion = GetPackageInfo()[1]
os.system("./debian/rules insertchanges")
ModifyChangelog(SetRelease=TargetPocket)
cmd = "git add {0}".format(changelog)
os.system(cmd)
tagname = "Ubuntu-{0}".format(PkgVersion)
print "Committing release..."
cmd = "git commit -s -m \"UBUNTU: {0}\"".format(tagname)
os.system(cmd)
print "Tagging release..."
os.system("git tag -s -f -m {0} {0}".format(tagname))
os.system("git clean -d -x -f")

# vi:set ts=4 sw=4 expandtab:
