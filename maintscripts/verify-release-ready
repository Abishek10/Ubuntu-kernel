#!/usr/bin/env python
#

from ktl.utils                          import stdo, eout, dump
from ktl.std_app                        import StdApp
from ktl.git                            import Git, GitError
from ktl.debian                         import Debian, DebianError
from ktl.kernel                         import Kernel, KernelError
from sys                                import argv
from getopt                             import getopt, GetoptError
import re

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("                                                                                             \n")
        stdo("                                                                                             \n")
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>]                         \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --config=<cfg file>                                                                  \n")
        stdo("                         The full path to the configuration file to use instead of           \n")
        stdo("                         the default location.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("                         debian - Enable debugging in the Debian class which determins       \n")
        stdo("                                  where the changelog is and parses it.                      \n")
        stdo("                                                                                             \n")
        stdo("        --verbose                                                                            \n")
        stdo("                         Give more detailed output for each of the checks being performed.   \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s                                                                                   \n" % self.cfg['app_name'])
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])
        stdo("        %s --debug=debian                                                                    \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'config=', 'debug=', 'verbose']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

                elif opt in ('--verbose'):
                    self.cfg['verbose'] = True

            if result: # No errors yet

                # At lease one source package must be specified.
                #
                if len(args) > 0:
                    self.cfg['source_pkgs'] = args

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        return

# AppError
#
# A general exception that can be raised when an error is encountered in the app.
#
class AppError(Exception):
    # __init__
    #
    def __init__(self, error=''):
        self.msg = error


# VerifyReleaseReady
#
class VerifyReleaseReady(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}
        self.defaults['verbose'] = False
        self.passed = 0
        self.failed = 0
        self.delimiter = 40

    # initialize
    #
    def initialize(self):
        validation_sequence = [
            (self.is_repo, True, 'is valid git repo'),
        ]

        if 'debug' in self.cfg:
            if 'debian' in self.cfg['debug']:
                Debian.debug = True

    # Are we currently in a git repository?
    #
    def is_repo(self):
        retval = True
        if not Git.is_repo():
            raise AppError('This script can only be run from within a git repository.')
        return retval

    def status(self, msg, flag):
        indent = self.delimiter - len(msg)
        if indent <= 0:
            indent = 0

        stdo('%s' % (' ' * indent) + msg + ':')
        if flag:
            self.passed += 1
            stdo(' pass\n')
        else:
            self.failed += 1
            stdo(' fail\n')

    def verbose(self, msg):
        if 'verbose' in self.cfg and self.cfg['verbose']:
            stdo(msg)
            stdo('\n')

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)
            self.initialize()

            # Check: Are we currently in a git repository?
            #
            if not Git.is_repo():
                raise AppError('This script can only be run from within a git repository.')
            self.status('is valid git repo', True)
            branch = Git.current_branch()

            changelog = Debian.changelog()

            # Check: Make sure the current version line in the changelog contains the correct pocket.
            #
            cl1 = changelog[0]
            if '-' not in cl1['version']:
                raise AppError("The version string is not well formed (missing '-').")

            # Verify the version information in the changelog
            #
            (cl1_version, abi_build) = cl1['version'].split('-')  # Current version line
            cl1_abi   = cl1['ABI']
            cl1_build = cl1['upload-number']

            cl2 = changelog[1]
            (cl2_version, abi_build) = cl2['version'].split('-')  # Previous version line
            cl2_abi   = cl2['ABI']
            cl2_build = cl2['upload-number']
            while True:
                # Version is correct
                #
                msg = 'kernel version (%s)' % (Kernel.version())
                if cl1_version != Kernel.version():
                    self.status(msg, False)
                    self.verbose("expected '%s' but got: '%s'" % (Kernel.version(), cl1_version))
                    break
                self.status(msg, True)

                # Check: Make sure the current version is correctly incremented from the previous one.
                #
                msg = 'build number (%d)' % (int(cl2_build) + 1)
                if int(cl1_build) != int(cl2_build) + 1:
                    self.status(msg, False)
                    self.verbose("expected %d but got: %d" % (int(cl2_build), int(cl1_build)))
                    break
                self.status(msg, True)

                # Check: Make sure that the abi directory has the previous version
                msg = 'previous abi present (%s)' % (cl2['version'])
                abi = Debian.abi()
                if  cl2['version'] not in abi:
                    self.status(msg, False)
                    break
                self.status(msg, True)

                # Check: That the release information is correct.
                #
                msg = 'release (%s)' % (Kernel.release())
                if cl1['release'] != Kernel.release():
                    self.status(msg, False)
                    self.verbose("expected '%s' but got: '%s'" % (Kernel.release(), cl1['release']))
                    break
                self.status(msg, True)

                # Check: That the pocket information is correct.
                #
                msg = 'pocket (-proposed)'
                if cl1['pocket'] != 'proposed':
                    self.status(msg, False)
                    self.verbose("expected '-proposed' but got: '%s'" % (cl1['pocket']))
                    break
                self.status(msg, True)

                break

            if cl1['package'] != 'linux':
                tag_prefix = 'Ubuntu-' + cl1['package'].replace('linux-', '')
            else:
                tag_prefix = 'Ubuntu'

            # Check: Make sure the commit of the version is the correct text.
            #
            log = Git.log(num=1) # Only interested in the last commit

            commit = []
            for line in log['commits'][0]['text']:
                line = line.strip()
                if line != '':
                    if 'Signed-off-by' not in line:
                        commit.append(line)

            # **NOTE: Because we are inconsistent with the exact text used in the last commit
            #         I'm loosing up the matching a bit but making sure that what is in the
            #         last commit matches the tag
            #
            closed = True
            m = re.match('^UBUNTU: (Ubuntu[-\S]*-%s-%s.%s)$' % (cl1['linux-version'], cl1['ABI'], cl1['upload-number']), commit[0])
            msg = 'closing release commit'
            if len(commit) != 1:        # There should only be a single line in the commit
                self.status(msg, False)
                self.verbose("too many lines of text")
                closed = False
            elif m == None:
                self.status(msg, False)
                expected = '^UBUNTU: (Ubuntu[-\S]*-%s-%s.%s)$' % (cl1['linux-version'], cl1['ABI'], cl1['upload-number'])
                self.verbose("expected '%s', got '%s'" % (expected, commit[0]))
            else:
                expected = m.group(1) # This should be the tag text
                self.status(msg, True)

            # Check: Make sure the commit corresponds to the tag.
            #        Only runs if we have the expected tag.
            #
            # **NOTE: There can be multiple tags associated with the specific commit.
            #
            if closed:
                tag_found = False
                msg = 'tag exists on final commit'
                tags = Git.tags(contains=log['commits'][0]['sha1'])
                for tag in tags:
                    if tag == expected:
                        self.status(msg, True)
                        tag_found = True
                        break
                if not tag_found:
                    self.status(msg, False) # the specified commit.
                    self.verbose("unable to find any tag that matched (%s) on the last commit " % (expected))

            # Look to see if a tracking bug has been added to the changelog
            #
            found_tracker = False
            for line in changelog[1]['content']:
                if 'Tracking Bug' in line:
                    found_tracker = True
            self.status('release tracking bug', found_tracker)

            # It's important that there be a single blank line at the beginning of
            # the content. (after the package/version/pocket line)
            #
            ei = 1
            et = []
            error_text = 'There should be one and only one blank line following the package/version/pocket line.'
            content_error = False
            test = changelog[1]['content'][0].strip()
            if test != '':                              # Should be a blank line
                self.status('content [%d]' % ei, False)
                ei += 1
                et.append(error_text)
                content_error = True

            test = changelog[1]['content'][1].strip()
            if not content_error and test == '':       # Should not be a blank line
                self.status('content [%d]' % ei, False)
                ei += 1
                et.append(error_text)
                content_error = True

            # The "Final" line in the version content should be a line that starts
            # with two dashes, has an email address and a date/time stamp.
            #
            cl = len(changelog[1]['content'])
            error_text = 'The final three lines of a new changelog block should be a blank line, a "signature" line, and a final blank line.'

            if changelog[1]['content'][cl - 3].strip() != '': # Should be a blank line
                self.status('content [%d]' % ei, False)
                et.append(error_text)
                content_error = True
            else:
                if changelog[1]['content'][cl - 1].strip() != '': # Should be a blank line
                    self.status('content [%d]' % ei, False)
                    et.append(error_text)
                    content_error = True
                else:
                    if changelog[1]['content'][cl - 2].strip() == '': # Should be the "signature" line
                        self.status('content [%d]' % ei, False)
                        et.append(error_text)
                        content_error = True
                    else:
                        m = re.match('^ -- (.*) <(.*)@(.*)> .*$', changelog[1]['content'][cl - 2])
                        if m != None:
                            if 'canonical.com' not in m.group(3):
                                error_text = "The email address on the signature line does not contail 'canonical.com'."
                                et.append(error_text)
                                self.status('content [%d]' % ei, False)
                                content_error = True
                        else:
                            error_text = "Failed to parse the signature line."
                            et.append(error_text)
                            self.status('content [%d]' % ei, False)
                            content_error = True

            if content_error:
                print(' ')
                ei = 1
                for e in et:
                    print(' [%d] %s' % (ei, e))
                    ei += 1
            else:
                self.status('content', True)

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        # Handle all application errors
        #
        except AppError as e:
            eout(e.msg)

        except DebianError as e:
            eout(e.msg)

        except GitError as e:
            eout(e.msg[0])

        except KernelError as e:
            eout(e.msg)

        return

if __name__ == '__main__':
    app = VerifyReleaseReady()
    app.main()

# vi:set ts=4 sw=4 expandtab:

