From 26c1abde043c8186b483fd29715d2a03e864ac4e Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Sat, 30 Jun 2007 08:42:00 +0800
Subject: [PATCH] mac80211: [HT] fix ieee80211_send_addba_resp interface

Fix ieee80211_send_addba_resp interface to support dialog_token,
policy, buffer size and timeout.

Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
Signed-off-by: Zhu Yi <yi.zhu@intel.com>
---
 net/mac80211/ieee80211_sta.c |   24 +++++++++++++-----------
 1 files changed, 13 insertions(+), 11 deletions(-)

diff --git a/net/mac80211/ieee80211_sta.c b/net/mac80211/ieee80211_sta.c
index a13d665..e84bbad 100644
--- a/net/mac80211/ieee80211_sta.c
+++ b/net/mac80211/ieee80211_sta.c
@@ -2503,16 +2503,16 @@ static void ieee80211_rx_mgmt_probe_req(struct net_device *dev,
 	ieee80211_sta_tx(dev, skb, 0);
 }
 
-static void ieee80211_send_addba_resp(struct net_device *dev,
-				      struct ieee80211_mgmt *mgmt_src,
-				      size_t len,
-				      u16 status)
+void ieee80211_send_addba_resp(struct net_device *dev, u8 *da, u16 tid,
+					u8 dialog_token, u16 status, u16 policy,
+					u16 buf_size,u16 timeout)
 {
 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
 	struct ieee80211_if_sta *ifsta = &sdata->u.sta;
 	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
 	struct sk_buff *skb;
 	struct ieee80211_mgmt *mgmt;
+	u16 capab=0;
 
 	skb = dev_alloc_skb(sizeof(*mgmt) + local->hw.extra_tx_headroom);
 	if (!skb) {
@@ -2524,7 +2524,7 @@ static void ieee80211_send_addba_resp(struct net_device *dev,
 	skb_reserve(skb, local->hw.extra_tx_headroom);
 	mgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);
 	memset(mgmt, 0, 24);
-	memcpy(mgmt->da, ifsta->bssid, ETH_ALEN);
+	memcpy(mgmt->da, da, ETH_ALEN);
 	memcpy(mgmt->sa, dev->dev_addr, ETH_ALEN);
 	memcpy(mgmt->bssid, ifsta->bssid, ETH_ALEN);
 	mgmt->frame_control = IEEE80211_FC(IEEE80211_FTYPE_MGMT,
@@ -2533,12 +2533,14 @@ static void ieee80211_send_addba_resp(struct net_device *dev,
 	skb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_resp));
 	mgmt->u.action.category = WLAN_CATEGORY_BACK;
 	mgmt->u.action.u.addba_resp.action_code = WLAN_ACTION_ADDBA_RESP;
-	mgmt->u.action.u.addba_resp.dialog_token =
-		mgmt_src->u.action.u.addba_req.dialog_token;
-	mgmt->u.action.u.addba_resp.capab =
-		mgmt_src->u.action.u.addba_req.capab;
-	mgmt->u.action.u.addba_resp.timeout =
-		mgmt_src->u.action.u.addba_req.timeout;
+	mgmt->u.action.u.addba_resp.dialog_token = dialog_token;
+
+	capab |= (u16)(policy << 1);		/* bit 1 aggregation policy (1 - immediate 0 - delayed )*/
+	capab |= (u16)(tid << 2); 			/* bit 5:2 TID number */
+	capab |= (u16)(buf_size << 6);		/* bit 15:6 max size of aggergation */
+
+	mgmt->u.action.u.addba_resp.capab = cpu_to_le16(capab);
+	mgmt->u.action.u.addba_resp.timeout = cpu_to_le16(timeout);
 	mgmt->u.action.u.addba_resp.status = cpu_to_le16(status);
 
 	ieee80211_sta_tx(dev, skb, 0);
-- 
1.5.2

